import { GLTFLoader as GLTFLoader$1 } from '/js/jsm/loaders/GLTFLoader.js';

/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
 const REVISION$1 = '130';
 const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
 const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
 const CullFaceNone$1 = 0;
 const CullFaceBack$1 = 1;
 const CullFaceFront$1 = 2;
 const PCFShadowMap$1 = 1;
 const PCFSoftShadowMap$1 = 2;
 const VSMShadowMap$1 = 3;
 const FrontSide$1 = 0;
 const BackSide$1 = 1;
 const DoubleSide$1 = 2;
 const FlatShading$1 = 1;
 const NoBlending$1 = 0;
 const NormalBlending$1 = 1;
 const AdditiveBlending$1 = 2;
 const SubtractiveBlending$1 = 3;
 const MultiplyBlending$1 = 4;
 const CustomBlending$1 = 5;
 const AddEquation$1 = 100;
 const SubtractEquation$1 = 101;
 const ReverseSubtractEquation$1 = 102;
 const MinEquation$1 = 103;
 const MaxEquation$1 = 104;
 const ZeroFactor$1 = 200;
 const OneFactor$1 = 201;
 const SrcColorFactor$1 = 202;
 const OneMinusSrcColorFactor$1 = 203;
 const SrcAlphaFactor$1 = 204;
 const OneMinusSrcAlphaFactor$1 = 205;
 const DstAlphaFactor$1 = 206;
 const OneMinusDstAlphaFactor$1 = 207;
 const DstColorFactor$1 = 208;
 const OneMinusDstColorFactor$1 = 209;
 const SrcAlphaSaturateFactor$1 = 210;
 const NeverDepth$1 = 0;
 const AlwaysDepth$1 = 1;
 const LessDepth$1 = 2;
 const LessEqualDepth$1 = 3;
 const EqualDepth$1 = 4;
 const GreaterEqualDepth$1 = 5;
 const GreaterDepth$1 = 6;
 const NotEqualDepth$1 = 7;
 const MultiplyOperation$1 = 0;
 const MixOperation$1 = 1;
 const AddOperation$1 = 2;
 const NoToneMapping$1 = 0;
 const LinearToneMapping$1 = 1;
 const ReinhardToneMapping$1 = 2;
 const CineonToneMapping$1 = 3;
 const ACESFilmicToneMapping$1 = 4;
 const CustomToneMapping$1 = 5;

 const UVMapping$1 = 300;
 const CubeReflectionMapping$1 = 301;
 const CubeRefractionMapping$1 = 302;
 const EquirectangularReflectionMapping$1 = 303;
 const EquirectangularRefractionMapping$1 = 304;
 const CubeUVReflectionMapping$1 = 306;
 const CubeUVRefractionMapping$1 = 307;
 const RepeatWrapping$1 = 1000;
 const ClampToEdgeWrapping$1 = 1001;
 const MirroredRepeatWrapping$1 = 1002;
 const NearestFilter$1 = 1003;
 const NearestMipmapNearestFilter$1 = 1004;
 const NearestMipmapLinearFilter$1 = 1005;
 const LinearFilter$1 = 1006;
 const LinearMipmapNearestFilter$1 = 1007;
 const LinearMipmapLinearFilter$1 = 1008;
 const UnsignedByteType$1 = 1009;
 const ByteType$1 = 1010;
 const ShortType$1 = 1011;
 const UnsignedShortType$1 = 1012;
 const IntType$1 = 1013;
 const UnsignedIntType$1 = 1014;
 const FloatType$1 = 1015;
 const HalfFloatType$1 = 1016;
 const UnsignedShort4444Type$1 = 1017;
 const UnsignedShort5551Type$1 = 1018;
 const UnsignedShort565Type$1 = 1019;
 const UnsignedInt248Type$1 = 1020;
 const AlphaFormat$1 = 1021;
 const RGBFormat$1 = 1022;
 const RGBAFormat$1 = 1023;
 const LuminanceFormat$1 = 1024;
 const LuminanceAlphaFormat$1 = 1025;
 const DepthFormat$1 = 1026;
 const DepthStencilFormat$1 = 1027;
 const RedFormat$1 = 1028;
 const RedIntegerFormat$1 = 1029;
 const RGFormat$1 = 1030;
 const RGIntegerFormat$1 = 1031;
 const RGBIntegerFormat$1 = 1032;
 const RGBAIntegerFormat$1 = 1033;

 const RGB_S3TC_DXT1_Format$1 = 33776;
 const RGBA_S3TC_DXT1_Format$1 = 33777;
 const RGBA_S3TC_DXT3_Format$1 = 33778;
 const RGBA_S3TC_DXT5_Format$1 = 33779;
 const RGB_PVRTC_4BPPV1_Format$1 = 35840;
 const RGB_PVRTC_2BPPV1_Format$1 = 35841;
 const RGBA_PVRTC_4BPPV1_Format$1 = 35842;
 const RGBA_PVRTC_2BPPV1_Format$1 = 35843;
 const RGB_ETC1_Format$1 = 36196;
 const RGB_ETC2_Format$1 = 37492;
 const RGBA_ETC2_EAC_Format$1 = 37496;
 const RGBA_ASTC_4x4_Format$1 = 37808;
 const RGBA_ASTC_5x4_Format$1 = 37809;
 const RGBA_ASTC_5x5_Format$1 = 37810;
 const RGBA_ASTC_6x5_Format$1 = 37811;
 const RGBA_ASTC_6x6_Format$1 = 37812;
 const RGBA_ASTC_8x5_Format$1 = 37813;
 const RGBA_ASTC_8x6_Format$1 = 37814;
 const RGBA_ASTC_8x8_Format$1 = 37815;
 const RGBA_ASTC_10x5_Format$1 = 37816;
 const RGBA_ASTC_10x6_Format$1 = 37817;
 const RGBA_ASTC_10x8_Format$1 = 37818;
 const RGBA_ASTC_10x10_Format$1 = 37819;
 const RGBA_ASTC_12x10_Format$1 = 37820;
 const RGBA_ASTC_12x12_Format$1 = 37821;
 const RGBA_BPTC_Format$1 = 36492;
 const SRGB8_ALPHA8_ASTC_4x4_Format$1 = 37840;
 const SRGB8_ALPHA8_ASTC_5x4_Format$1 = 37841;
 const SRGB8_ALPHA8_ASTC_5x5_Format$1 = 37842;
 const SRGB8_ALPHA8_ASTC_6x5_Format$1 = 37843;
 const SRGB8_ALPHA8_ASTC_6x6_Format$1 = 37844;
 const SRGB8_ALPHA8_ASTC_8x5_Format$1 = 37845;
 const SRGB8_ALPHA8_ASTC_8x6_Format$1 = 37846;
 const SRGB8_ALPHA8_ASTC_8x8_Format$1 = 37847;
 const SRGB8_ALPHA8_ASTC_10x5_Format$1 = 37848;
 const SRGB8_ALPHA8_ASTC_10x6_Format$1 = 37849;
 const SRGB8_ALPHA8_ASTC_10x8_Format$1 = 37850;
 const SRGB8_ALPHA8_ASTC_10x10_Format$1 = 37851;
 const SRGB8_ALPHA8_ASTC_12x10_Format$1 = 37852;
 const SRGB8_ALPHA8_ASTC_12x12_Format$1 = 37853;
 const LoopOnce$1 = 2200;
 const LoopRepeat$1 = 2201;
 const LoopPingPong$1 = 2202;
 const InterpolateDiscrete$1 = 2300;
 const InterpolateLinear$1 = 2301;
 const InterpolateSmooth$1 = 2302;
 const ZeroCurvatureEnding$1 = 2400;
 const ZeroSlopeEnding$1 = 2401;
 const WrapAroundEnding$1 = 2402;
 const NormalAnimationBlendMode$1 = 2500;
 const AdditiveAnimationBlendMode$1 = 2501;
 const TrianglesDrawMode$1 = 0;
 const TriangleStripDrawMode = 1;
 const TriangleFanDrawMode = 2;
 const LinearEncoding$1 = 3000;
 const sRGBEncoding$1 = 3001;
 const GammaEncoding$1 = 3007;
 const RGBEEncoding$1 = 3002;
 const LogLuvEncoding$1 = 3003;
 const RGBM7Encoding$1 = 3004;
 const RGBM16Encoding$1 = 3005;
 const RGBDEncoding$1 = 3006;
 const BasicDepthPacking$1 = 3200;
 const RGBADepthPacking$1 = 3201;
 const TangentSpaceNormalMap$1 = 0;
 const ObjectSpaceNormalMap$1 = 1;
 const KeepStencilOp$1 = 7680;
 const AlwaysStencilFunc$1 = 519;

 const StaticDrawUsage$1 = 35044;
 const DynamicDrawUsage$1 = 35048;
 const GLSL3$1 = '300 es';

 /**
	* https://github.com/mrdoob/eventdispatcher.js/
	*/

 class EventDispatcher$1 {

	 addEventListener( type, listener ) {

		 if ( this._listeners === undefined ) this._listeners = {};

		 const listeners = this._listeners;

		 if ( listeners[ type ] === undefined ) {

			 listeners[ type ] = [];

		 }

		 if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			 listeners[ type ].push( listener );

		 }

	 }

	 hasEventListener( type, listener ) {

		 if ( this._listeners === undefined ) return false;

		 const listeners = this._listeners;

		 return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	 }

	 removeEventListener( type, listener ) {

		 if ( this._listeners === undefined ) return;

		 const listeners = this._listeners;
		 const listenerArray = listeners[ type ];

		 if ( listenerArray !== undefined ) {

			 const index = listenerArray.indexOf( listener );

			 if ( index !== - 1 ) {

				 listenerArray.splice( index, 1 );

			 }

		 }

	 }

	 dispatchEvent( event ) {

		 if ( this._listeners === undefined ) return;

		 const listeners = this._listeners;
		 const listenerArray = listeners[ event.type ];

		 if ( listenerArray !== undefined ) {

			 event.target = this;

			 // Make a copy, in case listeners are removed while iterating.
			 const array = listenerArray.slice( 0 );

			 for ( let i = 0, l = array.length; i < l; i ++ ) {

				 array[ i ].call( this, event );

			 }

			 event.target = null;

		 }

	 }

 }

 const _lut$1 = [];

 for ( let i = 0; i < 256; i ++ ) {

	 _lut$1[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

 }

 let _seed = 1234567;


 const DEG2RAD$1 = Math.PI / 180;
 const RAD2DEG$1 = 180 / Math.PI;

 // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
 function generateUUID$1() {

	 const d0 = Math.random() * 0xffffffff | 0;
	 const d1 = Math.random() * 0xffffffff | 0;
	 const d2 = Math.random() * 0xffffffff | 0;
	 const d3 = Math.random() * 0xffffffff | 0;
	 const uuid = _lut$1[ d0 & 0xff ] + _lut$1[ d0 >> 8 & 0xff ] + _lut$1[ d0 >> 16 & 0xff ] + _lut$1[ d0 >> 24 & 0xff ] + '-' +
			 _lut$1[ d1 & 0xff ] + _lut$1[ d1 >> 8 & 0xff ] + '-' + _lut$1[ d1 >> 16 & 0x0f | 0x40 ] + _lut$1[ d1 >> 24 & 0xff ] + '-' +
			 _lut$1[ d2 & 0x3f | 0x80 ] + _lut$1[ d2 >> 8 & 0xff ] + '-' + _lut$1[ d2 >> 16 & 0xff ] + _lut$1[ d2 >> 24 & 0xff ] +
			 _lut$1[ d3 & 0xff ] + _lut$1[ d3 >> 8 & 0xff ] + _lut$1[ d3 >> 16 & 0xff ] + _lut$1[ d3 >> 24 & 0xff ];

	 // .toUpperCase() here flattens concatenated strings to save heap memory space.
	 return uuid.toUpperCase();

 }

 function clamp$1( value, min, max ) {

	 return Math.max( min, Math.min( max, value ) );

 }

 // compute euclidian modulo of m % n
 // https://en.wikipedia.org/wiki/Modulo_operation
 function euclideanModulo$1( n, m ) {

	 return ( ( n % m ) + m ) % m;

 }

 // Linear mapping from range <a1, a2> to range <b1, b2>
 function mapLinear( x, a1, a2, b1, b2 ) {

	 return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

 }

 // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
 function inverseLerp( x, y, value ) {

	 if ( x !== y ) {

		 return ( value - x ) / ( y - x );

			} else {

		 return 0;

			}

 }

 // https://en.wikipedia.org/wiki/Linear_interpolation
 function lerp$1( x, y, t ) {

	 return ( 1 - t ) * x + t * y;

 }

 // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
 function damp( x, y, lambda, dt ) {

	 return lerp$1( x, y, 1 - Math.exp( - lambda * dt ) );

 }

 // https://www.desmos.com/calculator/vcsjnyz7x4
 function pingpong( x, length = 1 ) {

	 return length - Math.abs( euclideanModulo$1( x, length * 2 ) - length );

 }

 // http://en.wikipedia.org/wiki/Smoothstep
 function smoothstep( x, min, max ) {

	 if ( x <= min ) return 0;
	 if ( x >= max ) return 1;

	 x = ( x - min ) / ( max - min );

	 return x * x * ( 3 - 2 * x );

 }

 function smootherstep( x, min, max ) {

	 if ( x <= min ) return 0;
	 if ( x >= max ) return 1;

	 x = ( x - min ) / ( max - min );

	 return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

 }

 // Random integer from <low, high> interval
 function randInt( low, high ) {

	 return low + Math.floor( Math.random() * ( high - low + 1 ) );

 }

 // Random float from <low, high> interval
 function randFloat( low, high ) {

	 return low + Math.random() * ( high - low );

 }

 // Random float from <-range/2, range/2> interval
 function randFloatSpread( range ) {

	 return range * ( 0.5 - Math.random() );

 }

 // Deterministic pseudo-random float in the interval [ 0, 1 ]
 function seededRandom( s ) {

	 if ( s !== undefined ) _seed = s % 2147483647;

	 // Park-Miller algorithm

	 _seed = _seed * 16807 % 2147483647;

	 return ( _seed - 1 ) / 2147483646;

 }

 function degToRad( degrees ) {

	 return degrees * DEG2RAD$1;

 }

 function radToDeg( radians ) {

	 return radians * RAD2DEG$1;

 }

 function isPowerOfTwo$1( value ) {

	 return ( value & ( value - 1 ) ) === 0 && value !== 0;

 }

 function ceilPowerOfTwo( value ) {

	 return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

 }

 function floorPowerOfTwo$1( value ) {

	 return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

 }

 function setQuaternionFromProperEuler( q, a, b, c, order ) {

	 // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	 // rotations are applied to the axes in the order specified by 'order'
	 // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	 // angles are in radians

	 const cos = Math.cos;
	 const sin = Math.sin;

	 const c2 = cos( b / 2 );
	 const s2 = sin( b / 2 );

	 const c13 = cos( ( a + c ) / 2 );
	 const s13 = sin( ( a + c ) / 2 );

	 const c1_3 = cos( ( a - c ) / 2 );
	 const s1_3 = sin( ( a - c ) / 2 );

	 const c3_1 = cos( ( c - a ) / 2 );
	 const s3_1 = sin( ( c - a ) / 2 );

	 switch ( order ) {

		 case 'XYX':
			 q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			 break;

		 case 'YZY':
			 q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			 break;

		 case 'ZXZ':
			 q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			 break;

		 case 'XZX':
			 q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			 break;

		 case 'YXY':
			 q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			 break;

		 case 'ZYZ':
			 q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			 break;

		 default:
			 console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	 }

 }

 var MathUtils = /*#__PURE__*/Object.freeze({
	 __proto__: null,
	 DEG2RAD: DEG2RAD$1,
	 RAD2DEG: RAD2DEG$1,
	 generateUUID: generateUUID$1,
	 clamp: clamp$1,
	 euclideanModulo: euclideanModulo$1,
	 mapLinear: mapLinear,
	 inverseLerp: inverseLerp,
	 lerp: lerp$1,
	 damp: damp,
	 pingpong: pingpong,
	 smoothstep: smoothstep,
	 smootherstep: smootherstep,
	 randInt: randInt,
	 randFloat: randFloat,
	 randFloatSpread: randFloatSpread,
	 seededRandom: seededRandom,
	 degToRad: degToRad,
	 radToDeg: radToDeg,
	 isPowerOfTwo: isPowerOfTwo$1,
	 ceilPowerOfTwo: ceilPowerOfTwo,
	 floorPowerOfTwo: floorPowerOfTwo$1,
	 setQuaternionFromProperEuler: setQuaternionFromProperEuler
 });

 class Vector2$1 {

	 constructor( x = 0, y = 0 ) {

		 this.x = x;
		 this.y = y;

	 }

	 get width() {

		 return this.x;

	 }

	 set width( value ) {

		 this.x = value;

	 }

	 get height() {

		 return this.y;

	 }

	 set height( value ) {

		 this.y = value;

	 }

	 set( x, y ) {

		 this.x = x;
		 this.y = y;

		 return this;

	 }

	 setScalar( scalar ) {

		 this.x = scalar;
		 this.y = scalar;

		 return this;

	 }

	 setX( x ) {

		 this.x = x;

		 return this;

	 }

	 setY( y ) {

		 this.y = y;

		 return this;

	 }

	 setComponent( index, value ) {

		 switch ( index ) {

			 case 0: this.x = value; break;
			 case 1: this.y = value; break;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

		 return this;

	 }

	 getComponent( index ) {

		 switch ( index ) {

			 case 0: return this.x;
			 case 1: return this.y;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

	 }

	 clone() {

		 return new this.constructor( this.x, this.y );

	 }

	 copy( v ) {

		 this.x = v.x;
		 this.y = v.y;

		 return this;

	 }

	 add( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			 return this.addVectors( v, w );

		 }

		 this.x += v.x;
		 this.y += v.y;

		 return this;

	 }

	 addScalar( s ) {

		 this.x += s;
		 this.y += s;

		 return this;

	 }

	 addVectors( a, b ) {

		 this.x = a.x + b.x;
		 this.y = a.y + b.y;

		 return this;

	 }

	 addScaledVector( v, s ) {

		 this.x += v.x * s;
		 this.y += v.y * s;

		 return this;

	 }

	 sub( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			 return this.subVectors( v, w );

		 }

		 this.x -= v.x;
		 this.y -= v.y;

		 return this;

	 }

	 subScalar( s ) {

		 this.x -= s;
		 this.y -= s;

		 return this;

	 }

	 subVectors( a, b ) {

		 this.x = a.x - b.x;
		 this.y = a.y - b.y;

		 return this;

	 }

	 multiply( v ) {

		 this.x *= v.x;
		 this.y *= v.y;

		 return this;

	 }

	 multiplyScalar( scalar ) {

		 this.x *= scalar;
		 this.y *= scalar;

		 return this;

	 }

	 divide( v ) {

		 this.x /= v.x;
		 this.y /= v.y;

		 return this;

	 }

	 divideScalar( scalar ) {

		 return this.multiplyScalar( 1 / scalar );

	 }

	 applyMatrix3( m ) {

		 const x = this.x, y = this.y;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		 this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		 return this;

	 }

	 min( v ) {

		 this.x = Math.min( this.x, v.x );
		 this.y = Math.min( this.y, v.y );

		 return this;

	 }

	 max( v ) {

		 this.x = Math.max( this.x, v.x );
		 this.y = Math.max( this.y, v.y );

		 return this;

	 }

	 clamp( min, max ) {

		 // assumes min < max, componentwise

		 this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		 this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		 return this;

	 }

	 clampScalar( minVal, maxVal ) {

		 this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		 this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		 return this;

	 }

	 clampLength( min, max ) {

		 const length = this.length();

		 return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	 }

	 floor() {

		 this.x = Math.floor( this.x );
		 this.y = Math.floor( this.y );

		 return this;

	 }

	 ceil() {

		 this.x = Math.ceil( this.x );
		 this.y = Math.ceil( this.y );

		 return this;

	 }

	 round() {

		 this.x = Math.round( this.x );
		 this.y = Math.round( this.y );

		 return this;

	 }

	 roundToZero() {

		 this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		 this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		 return this;

	 }

	 negate() {

		 this.x = - this.x;
		 this.y = - this.y;

		 return this;

	 }

	 dot( v ) {

		 return this.x * v.x + this.y * v.y;

	 }

	 cross( v ) {

		 return this.x * v.y - this.y * v.x;

	 }

	 lengthSq() {

		 return this.x * this.x + this.y * this.y;

	 }

	 length() {

		 return Math.sqrt( this.x * this.x + this.y * this.y );

	 }

	 manhattanLength() {

		 return Math.abs( this.x ) + Math.abs( this.y );

	 }

	 normalize() {

		 return this.divideScalar( this.length() || 1 );

	 }

	 angle() {

		 // computes the angle in radians with respect to the positive x-axis

		 const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		 return angle;

	 }

	 distanceTo( v ) {

		 return Math.sqrt( this.distanceToSquared( v ) );

	 }

	 distanceToSquared( v ) {

		 const dx = this.x - v.x, dy = this.y - v.y;
		 return dx * dx + dy * dy;

	 }

	 manhattanDistanceTo( v ) {

		 return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	 }

	 setLength( length ) {

		 return this.normalize().multiplyScalar( length );

	 }

	 lerp( v, alpha ) {

		 this.x += ( v.x - this.x ) * alpha;
		 this.y += ( v.y - this.y ) * alpha;

		 return this;

	 }

	 lerpVectors( v1, v2, alpha ) {

		 this.x = v1.x + ( v2.x - v1.x ) * alpha;
		 this.y = v1.y + ( v2.y - v1.y ) * alpha;

		 return this;

	 }

	 equals( v ) {

		 return ( ( v.x === this.x ) && ( v.y === this.y ) );

	 }

	 fromArray( array, offset = 0 ) {

		 this.x = array[ offset ];
		 this.y = array[ offset + 1 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.x;
		 array[ offset + 1 ] = this.y;

		 return array;

	 }

	 fromBufferAttribute( attribute, index, offset ) {

		 if ( offset !== undefined ) {

			 console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		 }

		 this.x = attribute.getX( index );
		 this.y = attribute.getY( index );

		 return this;

	 }

	 rotateAround( center, angle ) {

		 const c = Math.cos( angle ), s = Math.sin( angle );

		 const x = this.x - center.x;
		 const y = this.y - center.y;

		 this.x = x * c - y * s + center.x;
		 this.y = x * s + y * c + center.y;

		 return this;

	 }

	 random() {

		 this.x = Math.random();
		 this.y = Math.random();

		 return this;

	 }

 }

 Vector2$1.prototype.isVector2 = true;

 class Matrix3$1 {

	 constructor() {

		 this.elements = [

			 1, 0, 0,
			 0, 1, 0,
			 0, 0, 1

		 ];

		 if ( arguments.length > 0 ) {

			 console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		 }

	 }

	 set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		 const te = this.elements;

		 te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		 te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		 te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		 return this;

	 }

	 identity() {

		 this.set(

			 1, 0, 0,
			 0, 1, 0,
			 0, 0, 1

		 );

		 return this;

	 }

	 copy( m ) {

		 const te = this.elements;
		 const me = m.elements;

		 te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		 te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		 te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		 return this;

	 }

	 extractBasis( xAxis, yAxis, zAxis ) {

		 xAxis.setFromMatrix3Column( this, 0 );
		 yAxis.setFromMatrix3Column( this, 1 );
		 zAxis.setFromMatrix3Column( this, 2 );

		 return this;

	 }

	 setFromMatrix4( m ) {

		 const me = m.elements;

		 this.set(

			 me[ 0 ], me[ 4 ], me[ 8 ],
			 me[ 1 ], me[ 5 ], me[ 9 ],
			 me[ 2 ], me[ 6 ], me[ 10 ]

		 );

		 return this;

	 }

	 multiply( m ) {

		 return this.multiplyMatrices( this, m );

	 }

	 premultiply( m ) {

		 return this.multiplyMatrices( m, this );

	 }

	 multiplyMatrices( a, b ) {

		 const ae = a.elements;
		 const be = b.elements;
		 const te = this.elements;

		 const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		 const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		 const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		 const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		 const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		 const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		 te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		 te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		 te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		 te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		 te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		 te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		 te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		 te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		 te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		 return this;

	 }

	 multiplyScalar( s ) {

		 const te = this.elements;

		 te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		 te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		 te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		 return this;

	 }

	 determinant() {

		 const te = this.elements;

		 const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			 d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			 g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		 return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	 }

	 invert() {

		 const te = this.elements,

			 n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			 n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			 n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			 t11 = n33 * n22 - n32 * n23,
			 t12 = n32 * n13 - n33 * n12,
			 t13 = n23 * n12 - n22 * n13,

			 det = n11 * t11 + n21 * t12 + n31 * t13;

		 if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		 const detInv = 1 / det;

		 te[ 0 ] = t11 * detInv;
		 te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		 te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		 te[ 3 ] = t12 * detInv;
		 te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		 te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		 te[ 6 ] = t13 * detInv;
		 te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		 te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		 return this;

	 }

	 transpose() {

		 let tmp;
		 const m = this.elements;

		 tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		 tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		 tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		 return this;

	 }

	 getNormalMatrix( matrix4 ) {

		 return this.setFromMatrix4( matrix4 ).invert().transpose();

	 }

	 transposeIntoArray( r ) {

		 const m = this.elements;

		 r[ 0 ] = m[ 0 ];
		 r[ 1 ] = m[ 3 ];
		 r[ 2 ] = m[ 6 ];
		 r[ 3 ] = m[ 1 ];
		 r[ 4 ] = m[ 4 ];
		 r[ 5 ] = m[ 7 ];
		 r[ 6 ] = m[ 2 ];
		 r[ 7 ] = m[ 5 ];
		 r[ 8 ] = m[ 8 ];

		 return this;

	 }

	 setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		 const c = Math.cos( rotation );
		 const s = Math.sin( rotation );

		 this.set(
			 sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			 - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			 0, 0, 1
		 );

		 return this;

	 }

	 scale( sx, sy ) {

		 const te = this.elements;

		 te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		 te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		 return this;

	 }

	 rotate( theta ) {

		 const c = Math.cos( theta );
		 const s = Math.sin( theta );

		 const te = this.elements;

		 const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		 const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		 te[ 0 ] = c * a11 + s * a21;
		 te[ 3 ] = c * a12 + s * a22;
		 te[ 6 ] = c * a13 + s * a23;

		 te[ 1 ] = - s * a11 + c * a21;
		 te[ 4 ] = - s * a12 + c * a22;
		 te[ 7 ] = - s * a13 + c * a23;

		 return this;

	 }

	 translate( tx, ty ) {

		 const te = this.elements;

		 te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		 te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		 return this;

	 }

	 equals( matrix ) {

		 const te = this.elements;
		 const me = matrix.elements;

		 for ( let i = 0; i < 9; i ++ ) {

			 if ( te[ i ] !== me[ i ] ) return false;

		 }

		 return true;

	 }

	 fromArray( array, offset = 0 ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.elements[ i ] = array[ i + offset ];

		 }

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 const te = this.elements;

		 array[ offset ] = te[ 0 ];
		 array[ offset + 1 ] = te[ 1 ];
		 array[ offset + 2 ] = te[ 2 ];

		 array[ offset + 3 ] = te[ 3 ];
		 array[ offset + 4 ] = te[ 4 ];
		 array[ offset + 5 ] = te[ 5 ];

		 array[ offset + 6 ] = te[ 6 ];
		 array[ offset + 7 ] = te[ 7 ];
		 array[ offset + 8 ] = te[ 8 ];

		 return array;

	 }

	 clone() {

		 return new this.constructor().fromArray( this.elements );

	 }

 }

 Matrix3$1.prototype.isMatrix3 = true;

 let _canvas$1;

 class ImageUtils$1 {

	 static getDataURL( image ) {

		 if ( /^data:/i.test( image.src ) ) {

			 return image.src;

		 }

		 if ( typeof HTMLCanvasElement == 'undefined' ) {

			 return image.src;

		 }

		 let canvas;

		 if ( image instanceof HTMLCanvasElement ) {

			 canvas = image;

		 } else {

			 if ( _canvas$1 === undefined ) _canvas$1 = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			 _canvas$1.width = image.width;
			 _canvas$1.height = image.height;

			 const context = _canvas$1.getContext( '2d' );

			 if ( image instanceof ImageData ) {

				 context.putImageData( image, 0, 0 );

			 } else {

				 context.drawImage( image, 0, 0, image.width, image.height );

			 }

			 canvas = _canvas$1;

		 }

		 if ( canvas.width > 2048 || canvas.height > 2048 ) {

			 console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			 return canvas.toDataURL( 'image/jpeg', 0.6 );

		 } else {

			 return canvas.toDataURL( 'image/png' );

		 }

	 }

 }

 let textureId$1 = 0;

 class Texture$1 extends EventDispatcher$1 {

	 constructor( image = Texture$1.DEFAULT_IMAGE, mapping = Texture$1.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping$1, wrapT = ClampToEdgeWrapping$1, magFilter = LinearFilter$1, minFilter = LinearMipmapLinearFilter$1, format = RGBAFormat$1, type = UnsignedByteType$1, anisotropy = 1, encoding = LinearEncoding$1 ) {

		 super();

		 Object.defineProperty( this, 'id', { value: textureId$1 ++ } );

		 this.uuid = generateUUID$1();

		 this.name = '';

		 this.image = image;
		 this.mipmaps = [];

		 this.mapping = mapping;

		 this.wrapS = wrapS;
		 this.wrapT = wrapT;

		 this.magFilter = magFilter;
		 this.minFilter = minFilter;

		 this.anisotropy = anisotropy;

		 this.format = format;
		 this.internalFormat = null;
		 this.type = type;

		 this.offset = new Vector2$1( 0, 0 );
		 this.repeat = new Vector2$1( 1, 1 );
		 this.center = new Vector2$1( 0, 0 );
		 this.rotation = 0;

		 this.matrixAutoUpdate = true;
		 this.matrix = new Matrix3$1();

		 this.generateMipmaps = true;
		 this.premultiplyAlpha = false;
		 this.flipY = true;
		 this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		 // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		 //
		 // Also changing the encoding after already used by a Material will not automatically make the Material
		 // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		 this.encoding = encoding;

		 this.version = 0;
		 this.onUpdate = null;

	 }

	 updateMatrix() {

		 this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.name = source.name;

		 this.image = source.image;
		 this.mipmaps = source.mipmaps.slice( 0 );

		 this.mapping = source.mapping;

		 this.wrapS = source.wrapS;
		 this.wrapT = source.wrapT;

		 this.magFilter = source.magFilter;
		 this.minFilter = source.minFilter;

		 this.anisotropy = source.anisotropy;

		 this.format = source.format;
		 this.internalFormat = source.internalFormat;
		 this.type = source.type;

		 this.offset.copy( source.offset );
		 this.repeat.copy( source.repeat );
		 this.center.copy( source.center );
		 this.rotation = source.rotation;

		 this.matrixAutoUpdate = source.matrixAutoUpdate;
		 this.matrix.copy( source.matrix );

		 this.generateMipmaps = source.generateMipmaps;
		 this.premultiplyAlpha = source.premultiplyAlpha;
		 this.flipY = source.flipY;
		 this.unpackAlignment = source.unpackAlignment;
		 this.encoding = source.encoding;

		 return this;

	 }

	 toJSON( meta ) {

		 const isRootObject = ( meta === undefined || typeof meta === 'string' );

		 if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			 return meta.textures[ this.uuid ];

		 }

		 const output = {

			 metadata: {
				 version: 4.5,
				 type: 'Texture',
				 generator: 'Texture.toJSON'
			 },

			 uuid: this.uuid,
			 name: this.name,

			 mapping: this.mapping,

			 repeat: [ this.repeat.x, this.repeat.y ],
			 offset: [ this.offset.x, this.offset.y ],
			 center: [ this.center.x, this.center.y ],
			 rotation: this.rotation,

			 wrap: [ this.wrapS, this.wrapT ],

			 format: this.format,
			 type: this.type,
			 encoding: this.encoding,

			 minFilter: this.minFilter,
			 magFilter: this.magFilter,
			 anisotropy: this.anisotropy,

			 flipY: this.flipY,

			 premultiplyAlpha: this.premultiplyAlpha,
			 unpackAlignment: this.unpackAlignment

		 };

		 if ( this.image !== undefined ) {

			 // TODO: Move to THREE.Image

			 const image = this.image;

			 if ( image.uuid === undefined ) {

				 image.uuid = generateUUID$1(); // UGH

			 }

			 if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				 let url;

				 if ( Array.isArray( image ) ) {

					 // process array of images e.g. CubeTexture

					 url = [];

					 for ( let i = 0, l = image.length; i < l; i ++ ) {

						 // check cube texture with data textures

						 if ( image[ i ].isDataTexture ) {

							 url.push( serializeImage$1( image[ i ].image ) );

						 } else {

							 url.push( serializeImage$1( image[ i ] ) );

						 }

					 }

				 } else {

					 // process single image

					 url = serializeImage$1( image );

				 }

				 meta.images[ image.uuid ] = {
					 uuid: image.uuid,
					 url: url
				 };

			 }

			 output.image = image.uuid;

		 }

		 if ( ! isRootObject ) {

			 meta.textures[ this.uuid ] = output;

		 }

		 return output;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

	 transformUv( uv ) {

		 if ( this.mapping !== UVMapping$1 ) return uv;

		 uv.applyMatrix3( this.matrix );

		 if ( uv.x < 0 || uv.x > 1 ) {

			 switch ( this.wrapS ) {

				 case RepeatWrapping$1:

					 uv.x = uv.x - Math.floor( uv.x );
					 break;

				 case ClampToEdgeWrapping$1:

					 uv.x = uv.x < 0 ? 0 : 1;
					 break;

				 case MirroredRepeatWrapping$1:

					 if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						 uv.x = Math.ceil( uv.x ) - uv.x;

					 } else {

						 uv.x = uv.x - Math.floor( uv.x );

					 }

					 break;

			 }

		 }

		 if ( uv.y < 0 || uv.y > 1 ) {

			 switch ( this.wrapT ) {

				 case RepeatWrapping$1:

					 uv.y = uv.y - Math.floor( uv.y );
					 break;

				 case ClampToEdgeWrapping$1:

					 uv.y = uv.y < 0 ? 0 : 1;
					 break;

				 case MirroredRepeatWrapping$1:

					 if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						 uv.y = Math.ceil( uv.y ) - uv.y;

					 } else {

						 uv.y = uv.y - Math.floor( uv.y );

					 }

					 break;

			 }

		 }

		 if ( this.flipY ) {

			 uv.y = 1 - uv.y;

		 }

		 return uv;

	 }

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

 }

 Texture$1.DEFAULT_IMAGE = undefined;
 Texture$1.DEFAULT_MAPPING = UVMapping$1;

 Texture$1.prototype.isTexture = true;

 function serializeImage$1( image ) {

	 if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		 ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		 ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		 // default images

		 return ImageUtils$1.getDataURL( image );

	 } else {

		 if ( image.data ) {

			 // images of DataTexture

			 return {
				 data: Array.prototype.slice.call( image.data ),
				 width: image.width,
				 height: image.height,
				 type: image.data.constructor.name
			 };

		 } else {

			 console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			 return {};

		 }

	 }

 }

 class Vector4$1 {

	 constructor( x = 0, y = 0, z = 0, w = 1 ) {

		 this.x = x;
		 this.y = y;
		 this.z = z;
		 this.w = w;

	 }

	 get width() {

		 return this.z;

	 }

	 set width( value ) {

		 this.z = value;

	 }

	 get height() {

		 return this.w;

	 }

	 set height( value ) {

		 this.w = value;

	 }

	 set( x, y, z, w ) {

		 this.x = x;
		 this.y = y;
		 this.z = z;
		 this.w = w;

		 return this;

	 }

	 setScalar( scalar ) {

		 this.x = scalar;
		 this.y = scalar;
		 this.z = scalar;
		 this.w = scalar;

		 return this;

	 }

	 setX( x ) {

		 this.x = x;

		 return this;

	 }

	 setY( y ) {

		 this.y = y;

		 return this;

	 }

	 setZ( z ) {

		 this.z = z;

		 return this;

	 }

	 setW( w ) {

		 this.w = w;

		 return this;

	 }

	 setComponent( index, value ) {

		 switch ( index ) {

			 case 0: this.x = value; break;
			 case 1: this.y = value; break;
			 case 2: this.z = value; break;
			 case 3: this.w = value; break;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

		 return this;

	 }

	 getComponent( index ) {

		 switch ( index ) {

			 case 0: return this.x;
			 case 1: return this.y;
			 case 2: return this.z;
			 case 3: return this.w;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

	 }

	 clone() {

		 return new this.constructor( this.x, this.y, this.z, this.w );

	 }

	 copy( v ) {

		 this.x = v.x;
		 this.y = v.y;
		 this.z = v.z;
		 this.w = ( v.w !== undefined ) ? v.w : 1;

		 return this;

	 }

	 add( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			 return this.addVectors( v, w );

		 }

		 this.x += v.x;
		 this.y += v.y;
		 this.z += v.z;
		 this.w += v.w;

		 return this;

	 }

	 addScalar( s ) {

		 this.x += s;
		 this.y += s;
		 this.z += s;
		 this.w += s;

		 return this;

	 }

	 addVectors( a, b ) {

		 this.x = a.x + b.x;
		 this.y = a.y + b.y;
		 this.z = a.z + b.z;
		 this.w = a.w + b.w;

		 return this;

	 }

	 addScaledVector( v, s ) {

		 this.x += v.x * s;
		 this.y += v.y * s;
		 this.z += v.z * s;
		 this.w += v.w * s;

		 return this;

	 }

	 sub( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			 return this.subVectors( v, w );

		 }

		 this.x -= v.x;
		 this.y -= v.y;
		 this.z -= v.z;
		 this.w -= v.w;

		 return this;

	 }

	 subScalar( s ) {

		 this.x -= s;
		 this.y -= s;
		 this.z -= s;
		 this.w -= s;

		 return this;

	 }

	 subVectors( a, b ) {

		 this.x = a.x - b.x;
		 this.y = a.y - b.y;
		 this.z = a.z - b.z;
		 this.w = a.w - b.w;

		 return this;

	 }

	 multiply( v ) {

		 this.x *= v.x;
		 this.y *= v.y;
		 this.z *= v.z;
		 this.w *= v.w;

		 return this;

	 }

	 multiplyScalar( scalar ) {

		 this.x *= scalar;
		 this.y *= scalar;
		 this.z *= scalar;
		 this.w *= scalar;

		 return this;

	 }

	 applyMatrix4( m ) {

		 const x = this.x, y = this.y, z = this.z, w = this.w;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		 this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		 this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		 this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		 return this;

	 }

	 divideScalar( scalar ) {

		 return this.multiplyScalar( 1 / scalar );

	 }

	 setAxisAngleFromQuaternion( q ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		 // q is assumed to be normalized

		 this.w = 2 * Math.acos( q.w );

		 const s = Math.sqrt( 1 - q.w * q.w );

		 if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		 } else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		 }

		 return this;

	 }

	 setAxisAngleFromRotationMatrix( m ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 let angle, x, y, z; // variables for result
		 const epsilon = 0.01,		// margin to allow for rounding errors
			 epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			 te = m.elements,

			 m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			 m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			 m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		 if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
					( Math.abs( m13 - m31 ) < epsilon ) &&
					( Math.abs( m23 - m32 ) < epsilon ) ) {

			 // singularity found
			 // first check for identity matrix which must have +1 for all terms
			 // in leading diagonal and zero in other terms

			 if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
						( Math.abs( m13 + m31 ) < epsilon2 ) &&
						( Math.abs( m23 + m32 ) < epsilon2 ) &&
						( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				 // this singularity is identity matrix so angle = 0

				 this.set( 1, 0, 0, 0 );

				 return this; // zero angle, arbitrary axis

			 }

			 // otherwise this singularity is angle = 180

			 angle = Math.PI;

			 const xx = ( m11 + 1 ) / 2;
			 const yy = ( m22 + 1 ) / 2;
			 const zz = ( m33 + 1 ) / 2;
			 const xy = ( m12 + m21 ) / 4;
			 const xz = ( m13 + m31 ) / 4;
			 const yz = ( m23 + m32 ) / 4;

			 if ( ( xx > yy ) && ( xx > zz ) ) {

				 // m11 is the largest diagonal term

				 if ( xx < epsilon ) {

					 x = 0;
					 y = 0.707106781;
					 z = 0.707106781;

				 } else {

					 x = Math.sqrt( xx );
					 y = xy / x;
					 z = xz / x;

				 }

			 } else if ( yy > zz ) {

				 // m22 is the largest diagonal term

				 if ( yy < epsilon ) {

					 x = 0.707106781;
					 y = 0;
					 z = 0.707106781;

				 } else {

					 y = Math.sqrt( yy );
					 x = xy / y;
					 z = yz / y;

				 }

			 } else {

				 // m33 is the largest diagonal term so base result on this

				 if ( zz < epsilon ) {

					 x = 0.707106781;
					 y = 0.707106781;
					 z = 0;

				 } else {

					 z = Math.sqrt( zz );
					 x = xz / z;
					 y = yz / z;

				 }

			 }

			 this.set( x, y, z, angle );

			 return this; // return 180 deg rotation

		 }

		 // as we have reached here there are no singularities so we can handle normally

		 let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			 ( m13 - m31 ) * ( m13 - m31 ) +
			 ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		 if ( Math.abs( s ) < 0.001 ) s = 1;

		 // prevent divide by zero, should not happen if matrix is orthogonal and should be
		 // caught by singularity test above, but I've left it in just in case

		 this.x = ( m32 - m23 ) / s;
		 this.y = ( m13 - m31 ) / s;
		 this.z = ( m21 - m12 ) / s;
		 this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		 return this;

	 }

	 min( v ) {

		 this.x = Math.min( this.x, v.x );
		 this.y = Math.min( this.y, v.y );
		 this.z = Math.min( this.z, v.z );
		 this.w = Math.min( this.w, v.w );

		 return this;

	 }

	 max( v ) {

		 this.x = Math.max( this.x, v.x );
		 this.y = Math.max( this.y, v.y );
		 this.z = Math.max( this.z, v.z );
		 this.w = Math.max( this.w, v.w );

		 return this;

	 }

	 clamp( min, max ) {

		 // assumes min < max, componentwise

		 this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		 this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		 this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		 this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		 return this;

	 }

	 clampScalar( minVal, maxVal ) {

		 this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		 this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		 this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		 this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		 return this;

	 }

	 clampLength( min, max ) {

		 const length = this.length();

		 return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	 }

	 floor() {

		 this.x = Math.floor( this.x );
		 this.y = Math.floor( this.y );
		 this.z = Math.floor( this.z );
		 this.w = Math.floor( this.w );

		 return this;

	 }

	 ceil() {

		 this.x = Math.ceil( this.x );
		 this.y = Math.ceil( this.y );
		 this.z = Math.ceil( this.z );
		 this.w = Math.ceil( this.w );

		 return this;

	 }

	 round() {

		 this.x = Math.round( this.x );
		 this.y = Math.round( this.y );
		 this.z = Math.round( this.z );
		 this.w = Math.round( this.w );

		 return this;

	 }

	 roundToZero() {

		 this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		 this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		 this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		 this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		 return this;

	 }

	 negate() {

		 this.x = - this.x;
		 this.y = - this.y;
		 this.z = - this.z;
		 this.w = - this.w;

		 return this;

	 }

	 dot( v ) {

		 return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	 }

	 lengthSq() {

		 return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	 }

	 length() {

		 return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	 }

	 manhattanLength() {

		 return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	 }

	 normalize() {

		 return this.divideScalar( this.length() || 1 );

	 }

	 setLength( length ) {

		 return this.normalize().multiplyScalar( length );

	 }

	 lerp( v, alpha ) {

		 this.x += ( v.x - this.x ) * alpha;
		 this.y += ( v.y - this.y ) * alpha;
		 this.z += ( v.z - this.z ) * alpha;
		 this.w += ( v.w - this.w ) * alpha;

		 return this;

	 }

	 lerpVectors( v1, v2, alpha ) {

		 this.x = v1.x + ( v2.x - v1.x ) * alpha;
		 this.y = v1.y + ( v2.y - v1.y ) * alpha;
		 this.z = v1.z + ( v2.z - v1.z ) * alpha;
		 this.w = v1.w + ( v2.w - v1.w ) * alpha;

		 return this;

	 }

	 equals( v ) {

		 return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	 }

	 fromArray( array, offset = 0 ) {

		 this.x = array[ offset ];
		 this.y = array[ offset + 1 ];
		 this.z = array[ offset + 2 ];
		 this.w = array[ offset + 3 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.x;
		 array[ offset + 1 ] = this.y;
		 array[ offset + 2 ] = this.z;
		 array[ offset + 3 ] = this.w;

		 return array;

	 }

	 fromBufferAttribute( attribute, index, offset ) {

		 if ( offset !== undefined ) {

			 console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		 }

		 this.x = attribute.getX( index );
		 this.y = attribute.getY( index );
		 this.z = attribute.getZ( index );
		 this.w = attribute.getW( index );

		 return this;

	 }

	 random() {

		 this.x = Math.random();
		 this.y = Math.random();
		 this.z = Math.random();
		 this.w = Math.random();

		 return this;

	 }

 }

 Vector4$1.prototype.isVector4 = true;

 /*
	In options, we can specify:
	* Texture parameters for an auto-generated target texture
	* depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
 */
 class WebGLRenderTarget$1 extends EventDispatcher$1 {

	 constructor( width, height, options = {} ) {

		 super();

		 this.width = width;
		 this.height = height;
		 this.depth = 1;

		 this.scissor = new Vector4$1( 0, 0, width, height );
		 this.scissorTest = false;

		 this.viewport = new Vector4$1( 0, 0, width, height );

		 this.texture = new Texture$1( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		 this.texture.image = { width: width, height: height, depth: 1 };

		 this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		 this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter$1;

		 this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		 this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		 this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	 }

	 setTexture( texture ) {

		 texture.image = {
			 width: this.width,
			 height: this.height,
			 depth: this.depth
		 };

		 this.texture = texture;

	 }

	 setSize( width, height, depth = 1 ) {

		 if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			 this.width = width;
			 this.height = height;
			 this.depth = depth;

			 this.texture.image.width = width;
			 this.texture.image.height = height;
			 this.texture.image.depth = depth;

			 this.dispose();

		 }

		 this.viewport.set( 0, 0, width, height );
		 this.scissor.set( 0, 0, width, height );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.width = source.width;
		 this.height = source.height;
		 this.depth = source.depth;

		 this.viewport.copy( source.viewport );

		 this.texture = source.texture.clone();
		 this.texture.image = { ...this.texture.image }; // See #20328.

		 this.depthBuffer = source.depthBuffer;
		 this.stencilBuffer = source.stencilBuffer;
		 this.depthTexture = source.depthTexture;

		 return this;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

 }

 WebGLRenderTarget$1.prototype.isWebGLRenderTarget = true;

 class WebGLMultipleRenderTargets$1 extends WebGLRenderTarget$1 {

	 constructor( width, height, count ) {

		 super( width, height );

		 const texture = this.texture;

		 this.texture = [];

		 for ( let i = 0; i < count; i ++ ) {

			 this.texture[ i ] = texture.clone();

		 }

	 }

	 setSize( width, height, depth = 1 ) {

		 if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			 this.width = width;
			 this.height = height;
			 this.depth = depth;

			 for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

				 this.texture[ i ].image.width = width;
				 this.texture[ i ].image.height = height;
				 this.texture[ i ].image.depth = depth;

			 }

			 this.dispose();

		 }

		 this.viewport.set( 0, 0, width, height );
		 this.scissor.set( 0, 0, width, height );

		 return this;

	 }

	 copy( source ) {

		 this.dispose();

		 this.width = source.width;
		 this.height = source.height;
		 this.depth = source.depth;

		 this.viewport.set( 0, 0, this.width, this.height );
		 this.scissor.set( 0, 0, this.width, this.height );

		 this.depthBuffer = source.depthBuffer;
		 this.stencilBuffer = source.stencilBuffer;
		 this.depthTexture = source.depthTexture;

		 this.texture.length = 0;

		 for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

			 this.texture[ i ] = source.texture[ i ].clone();

		 }

		 return this;

	 }

 }

 WebGLMultipleRenderTargets$1.prototype.isWebGLMultipleRenderTargets = true;

 class WebGLMultisampleRenderTarget$1 extends WebGLRenderTarget$1 {

	 constructor( width, height, options ) {

		 super( width, height, options );

		 this.samples = 4;

	 }

	 copy( source ) {

		 super.copy.call( this, source );

		 this.samples = source.samples;

		 return this;

	 }

 }

 WebGLMultisampleRenderTarget$1.prototype.isWebGLMultisampleRenderTarget = true;

 class Quaternion$1 {

	 constructor( x = 0, y = 0, z = 0, w = 1 ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._w = w;

	 }

	 static slerp( qa, qb, qm, t ) {

		 console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		 return qm.slerpQuaternions( qa, qb, t );

	 }

	 static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		 // fuzz-free, array-based Quaternion SLERP operation

		 let x0 = src0[ srcOffset0 + 0 ],
			 y0 = src0[ srcOffset0 + 1 ],
			 z0 = src0[ srcOffset0 + 2 ],
			 w0 = src0[ srcOffset0 + 3 ];

		 const x1 = src1[ srcOffset1 + 0 ],
			 y1 = src1[ srcOffset1 + 1 ],
			 z1 = src1[ srcOffset1 + 2 ],
			 w1 = src1[ srcOffset1 + 3 ];

		 if ( t === 0 ) {

			 dst[ dstOffset + 0 ] = x0;
			 dst[ dstOffset + 1 ] = y0;
			 dst[ dstOffset + 2 ] = z0;
			 dst[ dstOffset + 3 ] = w0;
			 return;

		 }

		 if ( t === 1 ) {

			 dst[ dstOffset + 0 ] = x1;
			 dst[ dstOffset + 1 ] = y1;
			 dst[ dstOffset + 2 ] = z1;
			 dst[ dstOffset + 3 ] = w1;
			 return;

		 }

		 if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			 let s = 1 - t;
			 const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				 dir = ( cos >= 0 ? 1 : - 1 ),
				 sqrSin = 1 - cos * cos;

			 // Skip the Slerp for tiny steps to avoid numeric problems:
			 if ( sqrSin > Number.EPSILON ) {

				 const sin = Math.sqrt( sqrSin ),
					 len = Math.atan2( sin, cos * dir );

				 s = Math.sin( s * len ) / sin;
				 t = Math.sin( t * len ) / sin;

			 }

			 const tDir = t * dir;

			 x0 = x0 * s + x1 * tDir;
			 y0 = y0 * s + y1 * tDir;
			 z0 = z0 * s + z1 * tDir;
			 w0 = w0 * s + w1 * tDir;

			 // Normalize in case we just did a lerp:
			 if ( s === 1 - t ) {

				 const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				 x0 *= f;
				 y0 *= f;
				 z0 *= f;
				 w0 *= f;

			 }

		 }

		 dst[ dstOffset ] = x0;
		 dst[ dstOffset + 1 ] = y0;
		 dst[ dstOffset + 2 ] = z0;
		 dst[ dstOffset + 3 ] = w0;

	 }

	 static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		 const x0 = src0[ srcOffset0 ];
		 const y0 = src0[ srcOffset0 + 1 ];
		 const z0 = src0[ srcOffset0 + 2 ];
		 const w0 = src0[ srcOffset0 + 3 ];

		 const x1 = src1[ srcOffset1 ];
		 const y1 = src1[ srcOffset1 + 1 ];
		 const z1 = src1[ srcOffset1 + 2 ];
		 const w1 = src1[ srcOffset1 + 3 ];

		 dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		 dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		 dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		 dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		 return dst;

	 }

	 get x() {

		 return this._x;

	 }

	 set x( value ) {

		 this._x = value;
		 this._onChangeCallback();

	 }

	 get y() {

		 return this._y;

	 }

	 set y( value ) {

		 this._y = value;
		 this._onChangeCallback();

	 }

	 get z() {

		 return this._z;

	 }

	 set z( value ) {

		 this._z = value;
		 this._onChangeCallback();

	 }

	 get w() {

		 return this._w;

	 }

	 set w( value ) {

		 this._w = value;
		 this._onChangeCallback();

	 }

	 set( x, y, z, w ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._w = w;

		 this._onChangeCallback();

		 return this;

	 }

	 clone() {

		 return new this.constructor( this._x, this._y, this._z, this._w );

	 }

	 copy( quaternion ) {

		 this._x = quaternion.x;
		 this._y = quaternion.y;
		 this._z = quaternion.z;
		 this._w = quaternion.w;

		 this._onChangeCallback();

		 return this;

	 }

	 setFromEuler( euler, update ) {

		 if ( ! ( euler && euler.isEuler ) ) {

			 throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		 }

		 const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		 // http://www.mathworks.com/matlabcentral/fileexchange/
		 // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		 //	content/SpinCalc.m

		 const cos = Math.cos;
		 const sin = Math.sin;

		 const c1 = cos( x / 2 );
		 const c2 = cos( y / 2 );
		 const c3 = cos( z / 2 );

		 const s1 = sin( x / 2 );
		 const s2 = sin( y / 2 );
		 const s3 = sin( z / 2 );

		 switch ( order ) {

			 case 'XYZ':
				 this._x = s1 * c2 * c3 + c1 * s2 * s3;
				 this._y = c1 * s2 * c3 - s1 * c2 * s3;
				 this._z = c1 * c2 * s3 + s1 * s2 * c3;
				 this._w = c1 * c2 * c3 - s1 * s2 * s3;
				 break;

			 case 'YXZ':
				 this._x = s1 * c2 * c3 + c1 * s2 * s3;
				 this._y = c1 * s2 * c3 - s1 * c2 * s3;
				 this._z = c1 * c2 * s3 - s1 * s2 * c3;
				 this._w = c1 * c2 * c3 + s1 * s2 * s3;
				 break;

			 case 'ZXY':
				 this._x = s1 * c2 * c3 - c1 * s2 * s3;
				 this._y = c1 * s2 * c3 + s1 * c2 * s3;
				 this._z = c1 * c2 * s3 + s1 * s2 * c3;
				 this._w = c1 * c2 * c3 - s1 * s2 * s3;
				 break;

			 case 'ZYX':
				 this._x = s1 * c2 * c3 - c1 * s2 * s3;
				 this._y = c1 * s2 * c3 + s1 * c2 * s3;
				 this._z = c1 * c2 * s3 - s1 * s2 * c3;
				 this._w = c1 * c2 * c3 + s1 * s2 * s3;
				 break;

			 case 'YZX':
				 this._x = s1 * c2 * c3 + c1 * s2 * s3;
				 this._y = c1 * s2 * c3 + s1 * c2 * s3;
				 this._z = c1 * c2 * s3 - s1 * s2 * c3;
				 this._w = c1 * c2 * c3 - s1 * s2 * s3;
				 break;

			 case 'XZY':
				 this._x = s1 * c2 * c3 - c1 * s2 * s3;
				 this._y = c1 * s2 * c3 - s1 * c2 * s3;
				 this._z = c1 * c2 * s3 + s1 * s2 * c3;
				 this._w = c1 * c2 * c3 + s1 * s2 * s3;
				 break;

			 default:
				 console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		 }

		 if ( update !== false ) this._onChangeCallback();

		 return this;

	 }

	 setFromAxisAngle( axis, angle ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		 // assumes axis is normalized

		 const halfAngle = angle / 2, s = Math.sin( halfAngle );

		 this._x = axis.x * s;
		 this._y = axis.y * s;
		 this._z = axis.z * s;
		 this._w = Math.cos( halfAngle );

		 this._onChangeCallback();

		 return this;

	 }

	 setFromRotationMatrix( m ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 const te = m.elements,

			 m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			 m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			 m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			 trace = m11 + m22 + m33;

		 if ( trace > 0 ) {

			 const s = 0.5 / Math.sqrt( trace + 1.0 );

			 this._w = 0.25 / s;
			 this._x = ( m32 - m23 ) * s;
			 this._y = ( m13 - m31 ) * s;
			 this._z = ( m21 - m12 ) * s;

		 } else if ( m11 > m22 && m11 > m33 ) {

			 const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			 this._w = ( m32 - m23 ) / s;
			 this._x = 0.25 * s;
			 this._y = ( m12 + m21 ) / s;
			 this._z = ( m13 + m31 ) / s;

		 } else if ( m22 > m33 ) {

			 const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			 this._w = ( m13 - m31 ) / s;
			 this._x = ( m12 + m21 ) / s;
			 this._y = 0.25 * s;
			 this._z = ( m23 + m32 ) / s;

		 } else {

			 const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			 this._w = ( m21 - m12 ) / s;
			 this._x = ( m13 + m31 ) / s;
			 this._y = ( m23 + m32 ) / s;
			 this._z = 0.25 * s;

		 }

		 this._onChangeCallback();

		 return this;

	 }

	 setFromUnitVectors( vFrom, vTo ) {

		 // assumes direction vectors vFrom and vTo are normalized

		 let r = vFrom.dot( vTo ) + 1;

		 if ( r < Number.EPSILON ) {

			 // vFrom and vTo point in opposite directions

			 r = 0;

			 if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				 this._x = - vFrom.y;
				 this._y = vFrom.x;
				 this._z = 0;
				 this._w = r;

			 } else {

				 this._x = 0;
				 this._y = - vFrom.z;
				 this._z = vFrom.y;
				 this._w = r;

			 }

		 } else {

			 // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			 this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			 this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			 this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			 this._w = r;

		 }

		 return this.normalize();

	 }

	 angleTo( q ) {

		 return 2 * Math.acos( Math.abs( clamp$1( this.dot( q ), - 1, 1 ) ) );

	 }

	 rotateTowards( q, step ) {

		 const angle = this.angleTo( q );

		 if ( angle === 0 ) return this;

		 const t = Math.min( 1, step / angle );

		 this.slerp( q, t );

		 return this;

	 }

	 identity() {

		 return this.set( 0, 0, 0, 1 );

	 }

	 invert() {

		 // quaternion is assumed to have unit length

		 return this.conjugate();

	 }

	 conjugate() {

		 this._x *= - 1;
		 this._y *= - 1;
		 this._z *= - 1;

		 this._onChangeCallback();

		 return this;

	 }

	 dot( v ) {

		 return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	 }

	 lengthSq() {

		 return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	 }

	 length() {

		 return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	 }

	 normalize() {

		 let l = this.length();

		 if ( l === 0 ) {

			 this._x = 0;
			 this._y = 0;
			 this._z = 0;
			 this._w = 1;

		 } else {

			 l = 1 / l;

			 this._x = this._x * l;
			 this._y = this._y * l;
			 this._z = this._z * l;
			 this._w = this._w * l;

		 }

		 this._onChangeCallback();

		 return this;

	 }

	 multiply( q, p ) {

		 if ( p !== undefined ) {

			 console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			 return this.multiplyQuaternions( q, p );

		 }

		 return this.multiplyQuaternions( this, q );

	 }

	 premultiply( q ) {

		 return this.multiplyQuaternions( q, this );

	 }

	 multiplyQuaternions( a, b ) {

		 // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		 const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		 const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		 this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		 this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		 this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		 this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		 this._onChangeCallback();

		 return this;

	 }

	 slerp( qb, t ) {

		 if ( t === 0 ) return this;
		 if ( t === 1 ) return this.copy( qb );

		 const x = this._x, y = this._y, z = this._z, w = this._w;

		 // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		 let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		 if ( cosHalfTheta < 0 ) {

			 this._w = - qb._w;
			 this._x = - qb._x;
			 this._y = - qb._y;
			 this._z = - qb._z;

			 cosHalfTheta = - cosHalfTheta;

		 } else {

			 this.copy( qb );

		 }

		 if ( cosHalfTheta >= 1.0 ) {

			 this._w = w;
			 this._x = x;
			 this._y = y;
			 this._z = z;

			 return this;

		 }

		 const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		 if ( sqrSinHalfTheta <= Number.EPSILON ) {

			 const s = 1 - t;
			 this._w = s * w + t * this._w;
			 this._x = s * x + t * this._x;
			 this._y = s * y + t * this._y;
			 this._z = s * z + t * this._z;

			 this.normalize();
			 this._onChangeCallback();

			 return this;

		 }

		 const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		 const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		 const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			 ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		 this._w = ( w * ratioA + this._w * ratioB );
		 this._x = ( x * ratioA + this._x * ratioB );
		 this._y = ( y * ratioA + this._y * ratioB );
		 this._z = ( z * ratioA + this._z * ratioB );

		 this._onChangeCallback();

		 return this;

	 }

	 slerpQuaternions( qa, qb, t ) {

		 this.copy( qa ).slerp( qb, t );

	 }

	 equals( quaternion ) {

		 return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	 }

	 fromArray( array, offset = 0 ) {

		 this._x = array[ offset ];
		 this._y = array[ offset + 1 ];
		 this._z = array[ offset + 2 ];
		 this._w = array[ offset + 3 ];

		 this._onChangeCallback();

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this._x;
		 array[ offset + 1 ] = this._y;
		 array[ offset + 2 ] = this._z;
		 array[ offset + 3 ] = this._w;

		 return array;

	 }

	 fromBufferAttribute( attribute, index ) {

		 this._x = attribute.getX( index );
		 this._y = attribute.getY( index );
		 this._z = attribute.getZ( index );
		 this._w = attribute.getW( index );

		 return this;

	 }

	 _onChange( callback ) {

		 this._onChangeCallback = callback;

		 return this;

	 }

	 _onChangeCallback() {}

 }

 Quaternion$1.prototype.isQuaternion = true;

 class Vector3$1 {

	 constructor( x = 0, y = 0, z = 0 ) {

		 this.x = x;
		 this.y = y;
		 this.z = z;

	 }

	 set( x, y, z ) {

		 if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		 this.x = x;
		 this.y = y;
		 this.z = z;

		 return this;

	 }

	 setScalar( scalar ) {

		 this.x = scalar;
		 this.y = scalar;
		 this.z = scalar;

		 return this;

	 }

	 setX( x ) {

		 this.x = x;

		 return this;

	 }

	 setY( y ) {

		 this.y = y;

		 return this;

	 }

	 setZ( z ) {

		 this.z = z;

		 return this;

	 }

	 setComponent( index, value ) {

		 switch ( index ) {

			 case 0: this.x = value; break;
			 case 1: this.y = value; break;
			 case 2: this.z = value; break;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

		 return this;

	 }

	 getComponent( index ) {

		 switch ( index ) {

			 case 0: return this.x;
			 case 1: return this.y;
			 case 2: return this.z;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

	 }

	 clone() {

		 return new this.constructor( this.x, this.y, this.z );

	 }

	 copy( v ) {

		 this.x = v.x;
		 this.y = v.y;
		 this.z = v.z;

		 return this;

	 }

	 add( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			 return this.addVectors( v, w );

		 }

		 this.x += v.x;
		 this.y += v.y;
		 this.z += v.z;

		 return this;

	 }

	 addScalar( s ) {

		 this.x += s;
		 this.y += s;
		 this.z += s;

		 return this;

	 }

	 addVectors( a, b ) {

		 this.x = a.x + b.x;
		 this.y = a.y + b.y;
		 this.z = a.z + b.z;

		 return this;

	 }

	 addScaledVector( v, s ) {

		 this.x += v.x * s;
		 this.y += v.y * s;
		 this.z += v.z * s;

		 return this;

	 }

	 sub( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			 return this.subVectors( v, w );

		 }

		 this.x -= v.x;
		 this.y -= v.y;
		 this.z -= v.z;

		 return this;

	 }

	 subScalar( s ) {

		 this.x -= s;
		 this.y -= s;
		 this.z -= s;

		 return this;

	 }

	 subVectors( a, b ) {

		 this.x = a.x - b.x;
		 this.y = a.y - b.y;
		 this.z = a.z - b.z;

		 return this;

	 }

	 multiply( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			 return this.multiplyVectors( v, w );

		 }

		 this.x *= v.x;
		 this.y *= v.y;
		 this.z *= v.z;

		 return this;

	 }

	 multiplyScalar( scalar ) {

		 this.x *= scalar;
		 this.y *= scalar;
		 this.z *= scalar;

		 return this;

	 }

	 multiplyVectors( a, b ) {

		 this.x = a.x * b.x;
		 this.y = a.y * b.y;
		 this.z = a.z * b.z;

		 return this;

	 }

	 applyEuler( euler ) {

		 if ( ! ( euler && euler.isEuler ) ) {

			 console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		 }

		 return this.applyQuaternion( _quaternion$4$1.setFromEuler( euler ) );

	 }

	 applyAxisAngle( axis, angle ) {

		 return this.applyQuaternion( _quaternion$4$1.setFromAxisAngle( axis, angle ) );

	 }

	 applyMatrix3( m ) {

		 const x = this.x, y = this.y, z = this.z;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		 this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		 this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		 return this;

	 }

	 applyNormalMatrix( m ) {

		 return this.applyMatrix3( m ).normalize();

	 }

	 applyMatrix4( m ) {

		 const x = this.x, y = this.y, z = this.z;
		 const e = m.elements;

		 const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		 this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		 this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		 this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		 return this;

	 }

	 applyQuaternion( q ) {

		 const x = this.x, y = this.y, z = this.z;
		 const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		 // calculate quat * vector

		 const ix = qw * x + qy * z - qz * y;
		 const iy = qw * y + qz * x - qx * z;
		 const iz = qw * z + qx * y - qy * x;
		 const iw = - qx * x - qy * y - qz * z;

		 // calculate result * inverse quat

		 this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		 this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		 this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		 return this;

	 }

	 project( camera ) {

		 return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	 }

	 unproject( camera ) {

		 return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	 }

	 transformDirection( m ) {

		 // input: THREE.Matrix4 affine matrix
		 // vector interpreted as a direction

		 const x = this.x, y = this.y, z = this.z;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		 this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		 this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		 return this.normalize();

	 }

	 divide( v ) {

		 this.x /= v.x;
		 this.y /= v.y;
		 this.z /= v.z;

		 return this;

	 }

	 divideScalar( scalar ) {

		 return this.multiplyScalar( 1 / scalar );

	 }

	 min( v ) {

		 this.x = Math.min( this.x, v.x );
		 this.y = Math.min( this.y, v.y );
		 this.z = Math.min( this.z, v.z );

		 return this;

	 }

	 max( v ) {

		 this.x = Math.max( this.x, v.x );
		 this.y = Math.max( this.y, v.y );
		 this.z = Math.max( this.z, v.z );

		 return this;

	 }

	 clamp( min, max ) {

		 // assumes min < max, componentwise

		 this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		 this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		 this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		 return this;

	 }

	 clampScalar( minVal, maxVal ) {

		 this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		 this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		 this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		 return this;

	 }

	 clampLength( min, max ) {

		 const length = this.length();

		 return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	 }

	 floor() {

		 this.x = Math.floor( this.x );
		 this.y = Math.floor( this.y );
		 this.z = Math.floor( this.z );

		 return this;

	 }

	 ceil() {

		 this.x = Math.ceil( this.x );
		 this.y = Math.ceil( this.y );
		 this.z = Math.ceil( this.z );

		 return this;

	 }

	 round() {

		 this.x = Math.round( this.x );
		 this.y = Math.round( this.y );
		 this.z = Math.round( this.z );

		 return this;

	 }

	 roundToZero() {

		 this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		 this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		 this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		 return this;

	 }

	 negate() {

		 this.x = - this.x;
		 this.y = - this.y;
		 this.z = - this.z;

		 return this;

	 }

	 dot( v ) {

		 return this.x * v.x + this.y * v.y + this.z * v.z;

	 }

	 // TODO lengthSquared?

	 lengthSq() {

		 return this.x * this.x + this.y * this.y + this.z * this.z;

	 }

	 length() {

		 return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	 }

	 manhattanLength() {

		 return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	 }

	 normalize() {

		 return this.divideScalar( this.length() || 1 );

	 }

	 setLength( length ) {

		 return this.normalize().multiplyScalar( length );

	 }

	 lerp( v, alpha ) {

		 this.x += ( v.x - this.x ) * alpha;
		 this.y += ( v.y - this.y ) * alpha;
		 this.z += ( v.z - this.z ) * alpha;

		 return this;

	 }

	 lerpVectors( v1, v2, alpha ) {

		 this.x = v1.x + ( v2.x - v1.x ) * alpha;
		 this.y = v1.y + ( v2.y - v1.y ) * alpha;
		 this.z = v1.z + ( v2.z - v1.z ) * alpha;

		 return this;

	 }

	 cross( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			 return this.crossVectors( v, w );

		 }

		 return this.crossVectors( this, v );

	 }

	 crossVectors( a, b ) {

		 const ax = a.x, ay = a.y, az = a.z;
		 const bx = b.x, by = b.y, bz = b.z;

		 this.x = ay * bz - az * by;
		 this.y = az * bx - ax * bz;
		 this.z = ax * by - ay * bx;

		 return this;

	 }

	 projectOnVector( v ) {

		 const denominator = v.lengthSq();

		 if ( denominator === 0 ) return this.set( 0, 0, 0 );

		 const scalar = v.dot( this ) / denominator;

		 return this.copy( v ).multiplyScalar( scalar );

	 }

	 projectOnPlane( planeNormal ) {

		 _vector$c$1.copy( this ).projectOnVector( planeNormal );

		 return this.sub( _vector$c$1 );

	 }

	 reflect( normal ) {

		 // reflect incident vector off plane orthogonal to normal
		 // normal is assumed to have unit length

		 return this.sub( _vector$c$1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	 }

	 angleTo( v ) {

		 const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		 if ( denominator === 0 ) return Math.PI / 2;

		 const theta = this.dot( v ) / denominator;

		 // clamp, to handle numerical problems

		 return Math.acos( clamp$1( theta, - 1, 1 ) );

	 }

	 distanceTo( v ) {

		 return Math.sqrt( this.distanceToSquared( v ) );

	 }

	 distanceToSquared( v ) {

		 const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		 return dx * dx + dy * dy + dz * dz;

	 }

	 manhattanDistanceTo( v ) {

		 return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	 }

	 setFromSpherical( s ) {

		 return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	 }

	 setFromSphericalCoords( radius, phi, theta ) {

		 const sinPhiRadius = Math.sin( phi ) * radius;

		 this.x = sinPhiRadius * Math.sin( theta );
		 this.y = Math.cos( phi ) * radius;
		 this.z = sinPhiRadius * Math.cos( theta );

		 return this;

	 }

	 setFromCylindrical( c ) {

		 return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	 }

	 setFromCylindricalCoords( radius, theta, y ) {

		 this.x = radius * Math.sin( theta );
		 this.y = y;
		 this.z = radius * Math.cos( theta );

		 return this;

	 }

	 setFromMatrixPosition( m ) {

		 const e = m.elements;

		 this.x = e[ 12 ];
		 this.y = e[ 13 ];
		 this.z = e[ 14 ];

		 return this;

	 }

	 setFromMatrixScale( m ) {

		 const sx = this.setFromMatrixColumn( m, 0 ).length();
		 const sy = this.setFromMatrixColumn( m, 1 ).length();
		 const sz = this.setFromMatrixColumn( m, 2 ).length();

		 this.x = sx;
		 this.y = sy;
		 this.z = sz;

		 return this;

	 }

	 setFromMatrixColumn( m, index ) {

		 return this.fromArray( m.elements, index * 4 );

	 }

	 setFromMatrix3Column( m, index ) {

		 return this.fromArray( m.elements, index * 3 );

	 }

	 equals( v ) {

		 return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	 }

	 fromArray( array, offset = 0 ) {

		 this.x = array[ offset ];
		 this.y = array[ offset + 1 ];
		 this.z = array[ offset + 2 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.x;
		 array[ offset + 1 ] = this.y;
		 array[ offset + 2 ] = this.z;

		 return array;

	 }

	 fromBufferAttribute( attribute, index, offset ) {

		 if ( offset !== undefined ) {

			 console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		 }

		 this.x = attribute.getX( index );
		 this.y = attribute.getY( index );
		 this.z = attribute.getZ( index );

		 return this;

	 }

	 random() {

		 this.x = Math.random();
		 this.y = Math.random();
		 this.z = Math.random();

		 return this;

	 }

 }

 Vector3$1.prototype.isVector3 = true;

 const _vector$c$1 = /*@__PURE__*/ new Vector3$1();
 const _quaternion$4$1 = /*@__PURE__*/ new Quaternion$1();

 class Box3$1 {

	 constructor( min = new Vector3$1( + Infinity, + Infinity, + Infinity ), max = new Vector3$1( - Infinity, - Infinity, - Infinity ) ) {

		 this.min = min;
		 this.max = max;

	 }

	 set( min, max ) {

		 this.min.copy( min );
		 this.max.copy( max );

		 return this;

	 }

	 setFromArray( array ) {

		 let minX = + Infinity;
		 let minY = + Infinity;
		 let minZ = + Infinity;

		 let maxX = - Infinity;
		 let maxY = - Infinity;
		 let maxZ = - Infinity;

		 for ( let i = 0, l = array.length; i < l; i += 3 ) {

			 const x = array[ i ];
			 const y = array[ i + 1 ];
			 const z = array[ i + 2 ];

			 if ( x < minX ) minX = x;
			 if ( y < minY ) minY = y;
			 if ( z < minZ ) minZ = z;

			 if ( x > maxX ) maxX = x;
			 if ( y > maxY ) maxY = y;
			 if ( z > maxZ ) maxZ = z;

		 }

		 this.min.set( minX, minY, minZ );
		 this.max.set( maxX, maxY, maxZ );

		 return this;

	 }

	 setFromBufferAttribute( attribute ) {

		 let minX = + Infinity;
		 let minY = + Infinity;
		 let minZ = + Infinity;

		 let maxX = - Infinity;
		 let maxY = - Infinity;
		 let maxZ = - Infinity;

		 for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			 const x = attribute.getX( i );
			 const y = attribute.getY( i );
			 const z = attribute.getZ( i );

			 if ( x < minX ) minX = x;
			 if ( y < minY ) minY = y;
			 if ( z < minZ ) minZ = z;

			 if ( x > maxX ) maxX = x;
			 if ( y > maxY ) maxY = y;
			 if ( z > maxZ ) maxZ = z;

		 }

		 this.min.set( minX, minY, minZ );
		 this.max.set( maxX, maxY, maxZ );

		 return this;

	 }

	 setFromPoints( points ) {

		 this.makeEmpty();

		 for ( let i = 0, il = points.length; i < il; i ++ ) {

			 this.expandByPoint( points[ i ] );

		 }

		 return this;

	 }

	 setFromCenterAndSize( center, size ) {

		 const halfSize = _vector$b$1.copy( size ).multiplyScalar( 0.5 );

		 this.min.copy( center ).sub( halfSize );
		 this.max.copy( center ).add( halfSize );

		 return this;

	 }

	 setFromObject( object ) {

		 this.makeEmpty();

		 return this.expandByObject( object );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( box ) {

		 this.min.copy( box.min );
		 this.max.copy( box.max );

		 return this;

	 }

	 makeEmpty() {

		 this.min.x = this.min.y = this.min.z = + Infinity;
		 this.max.x = this.max.y = this.max.z = - Infinity;

		 return this;

	 }

	 isEmpty() {

		 // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		 return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	 }

	 getCenter( target ) {

		 return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	 }

	 getSize( target ) {

		 return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	 }

	 expandByPoint( point ) {

		 this.min.min( point );
		 this.max.max( point );

		 return this;

	 }

	 expandByVector( vector ) {

		 this.min.sub( vector );
		 this.max.add( vector );

		 return this;

	 }

	 expandByScalar( scalar ) {

		 this.min.addScalar( - scalar );
		 this.max.addScalar( scalar );

		 return this;

	 }

	 expandByObject( object ) {

		 // Computes the world-axis-aligned bounding box of an object (including its children),
		 // accounting for both the object's, and children's, world transforms

		 object.updateWorldMatrix( false, false );

		 const geometry = object.geometry;

		 if ( geometry !== undefined ) {

			 if ( geometry.boundingBox === null ) {

				 geometry.computeBoundingBox();

			 }

			 _box$3$1.copy( geometry.boundingBox );
			 _box$3$1.applyMatrix4( object.matrixWorld );

			 this.union( _box$3$1 );

		 }

		 const children = object.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 this.expandByObject( children[ i ] );

		 }

		 return this;

	 }

	 containsPoint( point ) {

		 return point.x < this.min.x || point.x > this.max.x ||
			 point.y < this.min.y || point.y > this.max.y ||
			 point.z < this.min.z || point.z > this.max.z ? false : true;

	 }

	 containsBox( box ) {

		 return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			 this.min.y <= box.min.y && box.max.y <= this.max.y &&
			 this.min.z <= box.min.z && box.max.z <= this.max.z;

	 }

	 getParameter( point, target ) {

		 // This can potentially have a divide by zero if the box
		 // has a size dimension of 0.

		 return target.set(
			 ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			 ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			 ( point.z - this.min.z ) / ( this.max.z - this.min.z )
		 );

	 }

	 intersectsBox( box ) {

		 // using 6 splitting planes to rule out intersections.
		 return box.max.x < this.min.x || box.min.x > this.max.x ||
			 box.max.y < this.min.y || box.min.y > this.max.y ||
			 box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	 }

	 intersectsSphere( sphere ) {

		 // Find the point on the AABB closest to the sphere center.
		 this.clampPoint( sphere.center, _vector$b$1 );

		 // If that point is inside the sphere, the AABB and sphere intersect.
		 return _vector$b$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	 }

	 intersectsPlane( plane ) {

		 // We compute the minimum and maximum dot product values. If those values
		 // are on the same side (back or front) of the plane, then there is no intersection.

		 let min, max;

		 if ( plane.normal.x > 0 ) {

			 min = plane.normal.x * this.min.x;
			 max = plane.normal.x * this.max.x;

		 } else {

			 min = plane.normal.x * this.max.x;
			 max = plane.normal.x * this.min.x;

		 }

		 if ( plane.normal.y > 0 ) {

			 min += plane.normal.y * this.min.y;
			 max += plane.normal.y * this.max.y;

		 } else {

			 min += plane.normal.y * this.max.y;
			 max += plane.normal.y * this.min.y;

		 }

		 if ( plane.normal.z > 0 ) {

			 min += plane.normal.z * this.min.z;
			 max += plane.normal.z * this.max.z;

		 } else {

			 min += plane.normal.z * this.max.z;
			 max += plane.normal.z * this.min.z;

		 }

		 return ( min <= - plane.constant && max >= - plane.constant );

	 }

	 intersectsTriangle( triangle ) {

		 if ( this.isEmpty() ) {

			 return false;

		 }

		 // compute box center and extents
		 this.getCenter( _center$1 );
		 _extents$1.subVectors( this.max, _center$1 );

		 // translate triangle to aabb origin
		 _v0$2$1.subVectors( triangle.a, _center$1 );
		 _v1$7$1.subVectors( triangle.b, _center$1 );
		 _v2$3$1.subVectors( triangle.c, _center$1 );

		 // compute edge vectors for triangle
		 _f0$1.subVectors( _v1$7$1, _v0$2$1 );
		 _f1$1.subVectors( _v2$3$1, _v1$7$1 );
		 _f2$1.subVectors( _v0$2$1, _v2$3$1 );

		 // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		 // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		 // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		 let axes = [
			 0, - _f0$1.z, _f0$1.y, 0, - _f1$1.z, _f1$1.y, 0, - _f2$1.z, _f2$1.y,
			 _f0$1.z, 0, - _f0$1.x, _f1$1.z, 0, - _f1$1.x, _f2$1.z, 0, - _f2$1.x,
			 - _f0$1.y, _f0$1.x, 0, - _f1$1.y, _f1$1.x, 0, - _f2$1.y, _f2$1.x, 0
		 ];
		 if ( ! satForAxes$1( axes, _v0$2$1, _v1$7$1, _v2$3$1, _extents$1 ) ) {

			 return false;

		 }

		 // test 3 face normals from the aabb
		 axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		 if ( ! satForAxes$1( axes, _v0$2$1, _v1$7$1, _v2$3$1, _extents$1 ) ) {

			 return false;

		 }

		 // finally testing the face normal of the triangle
		 // use already existing triangle edge vectors here
		 _triangleNormal$1.crossVectors( _f0$1, _f1$1 );
		 axes = [ _triangleNormal$1.x, _triangleNormal$1.y, _triangleNormal$1.z ];

		 return satForAxes$1( axes, _v0$2$1, _v1$7$1, _v2$3$1, _extents$1 );

	 }

	 clampPoint( point, target ) {

		 return target.copy( point ).clamp( this.min, this.max );

	 }

	 distanceToPoint( point ) {

		 const clampedPoint = _vector$b$1.copy( point ).clamp( this.min, this.max );

		 return clampedPoint.sub( point ).length();

	 }

	 getBoundingSphere( target ) {

		 this.getCenter( target.center );

		 target.radius = this.getSize( _vector$b$1 ).length() * 0.5;

		 return target;

	 }

	 intersect( box ) {

		 this.min.max( box.min );
		 this.max.min( box.max );

		 // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		 if ( this.isEmpty() ) this.makeEmpty();

		 return this;

	 }

	 union( box ) {

		 this.min.min( box.min );
		 this.max.max( box.max );

		 return this;

	 }

	 applyMatrix4( matrix ) {

		 // transform of empty box is an empty box.
		 if ( this.isEmpty() ) return this;

		 // NOTE: I am using a binary pattern to specify all 2^3 combinations below
		 _points$1[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		 _points$1[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		 _points$1[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		 _points$1[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		 _points$1[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		 _points$1[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		 _points$1[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		 _points$1[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		 this.setFromPoints( _points$1 );

		 return this;

	 }

	 translate( offset ) {

		 this.min.add( offset );
		 this.max.add( offset );

		 return this;

	 }

	 equals( box ) {

		 return box.min.equals( this.min ) && box.max.equals( this.max );

	 }

 }

 Box3$1.prototype.isBox3 = true;

 const _points$1 = [
	 /*@__PURE__*/ new Vector3$1(),
	 /*@__PURE__*/ new Vector3$1(),
	 /*@__PURE__*/ new Vector3$1(),
	 /*@__PURE__*/ new Vector3$1(),
	 /*@__PURE__*/ new Vector3$1(),
	 /*@__PURE__*/ new Vector3$1(),
	 /*@__PURE__*/ new Vector3$1(),
	 /*@__PURE__*/ new Vector3$1()
 ];

 const _vector$b$1 = /*@__PURE__*/ new Vector3$1();

 const _box$3$1 = /*@__PURE__*/ new Box3$1();

 // triangle centered vertices

 const _v0$2$1 = /*@__PURE__*/ new Vector3$1();
 const _v1$7$1 = /*@__PURE__*/ new Vector3$1();
 const _v2$3$1 = /*@__PURE__*/ new Vector3$1();

 // triangle edge vectors

 const _f0$1 = /*@__PURE__*/ new Vector3$1();
 const _f1$1 = /*@__PURE__*/ new Vector3$1();
 const _f2$1 = /*@__PURE__*/ new Vector3$1();

 const _center$1 = /*@__PURE__*/ new Vector3$1();
 const _extents$1 = /*@__PURE__*/ new Vector3$1();
 const _triangleNormal$1 = /*@__PURE__*/ new Vector3$1();
 const _testAxis$1 = /*@__PURE__*/ new Vector3$1();

 function satForAxes$1( axes, v0, v1, v2, extents ) {

	 for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		 _testAxis$1.fromArray( axes, i );
		 // project the aabb onto the seperating axis
		 const r = extents.x * Math.abs( _testAxis$1.x ) + extents.y * Math.abs( _testAxis$1.y ) + extents.z * Math.abs( _testAxis$1.z );
		 // project all 3 vertices of the triangle onto the seperating axis
		 const p0 = v0.dot( _testAxis$1 );
		 const p1 = v1.dot( _testAxis$1 );
		 const p2 = v2.dot( _testAxis$1 );
		 // actual test, basically see if either of the most extreme of the triangle points intersects r
		 if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			 // points of the projected triangle are outside the projected half-length of the aabb
			 // the axis is seperating and we can exit
			 return false;

		 }

	 }

	 return true;

 }

 const _box$2$1 = /*@__PURE__*/ new Box3$1();
 const _v1$6$1 = /*@__PURE__*/ new Vector3$1();
 const _toFarthestPoint$1 = /*@__PURE__*/ new Vector3$1();
 const _toPoint$1 = /*@__PURE__*/ new Vector3$1();

 class Sphere$1 {

	 constructor( center = new Vector3$1(), radius = - 1 ) {

		 this.center = center;
		 this.radius = radius;

	 }

	 set( center, radius ) {

		 this.center.copy( center );
		 this.radius = radius;

		 return this;

	 }

	 setFromPoints( points, optionalCenter ) {

		 const center = this.center;

		 if ( optionalCenter !== undefined ) {

			 center.copy( optionalCenter );

		 } else {

			 _box$2$1.setFromPoints( points ).getCenter( center );

		 }

		 let maxRadiusSq = 0;

		 for ( let i = 0, il = points.length; i < il; i ++ ) {

			 maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		 }

		 this.radius = Math.sqrt( maxRadiusSq );

		 return this;

	 }

	 copy( sphere ) {

		 this.center.copy( sphere.center );
		 this.radius = sphere.radius;

		 return this;

	 }

	 isEmpty() {

		 return ( this.radius < 0 );

	 }

	 makeEmpty() {

		 this.center.set( 0, 0, 0 );
		 this.radius = - 1;

		 return this;

	 }

	 containsPoint( point ) {

		 return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	 }

	 distanceToPoint( point ) {

		 return ( point.distanceTo( this.center ) - this.radius );

	 }

	 intersectsSphere( sphere ) {

		 const radiusSum = this.radius + sphere.radius;

		 return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	 }

	 intersectsBox( box ) {

		 return box.intersectsSphere( this );

	 }

	 intersectsPlane( plane ) {

		 return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	 }

	 clampPoint( point, target ) {

		 const deltaLengthSq = this.center.distanceToSquared( point );

		 target.copy( point );

		 if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			 target.sub( this.center ).normalize();
			 target.multiplyScalar( this.radius ).add( this.center );

		 }

		 return target;

	 }

	 getBoundingBox( target ) {

		 if ( this.isEmpty() ) {

			 // Empty sphere produces empty bounding box
			 target.makeEmpty();
			 return target;

		 }

		 target.set( this.center, this.center );
		 target.expandByScalar( this.radius );

		 return target;

	 }

	 applyMatrix4( matrix ) {

		 this.center.applyMatrix4( matrix );
		 this.radius = this.radius * matrix.getMaxScaleOnAxis();

		 return this;

	 }

	 translate( offset ) {

		 this.center.add( offset );

		 return this;

	 }

	 expandByPoint( point ) {

		 // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		 _toPoint$1.subVectors( point, this.center );

		 const lengthSq = _toPoint$1.lengthSq();

		 if ( lengthSq > ( this.radius * this.radius ) ) {

			 const length = Math.sqrt( lengthSq );
			 const missingRadiusHalf = ( length - this.radius ) * 0.5;

			 // Nudge this sphere towards the target point. Add half the missing distance to radius,
			 // and the other half to position. This gives a tighter enclosure, instead of if
			 // the whole missing distance were just added to radius.

			 this.center.add( _toPoint$1.multiplyScalar( missingRadiusHalf / length ) );
			 this.radius += missingRadiusHalf;

		 }

		 return this;

	 }

	 union( sphere ) {

		 // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		 // To enclose another sphere into this sphere, we only need to enclose two points:
		 // 1) Enclose the farthest point on the other sphere into this sphere.
		 // 2) Enclose the opposite point of the farthest point into this sphere.

		 _toFarthestPoint$1.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		 this.expandByPoint( _v1$6$1.copy( sphere.center ).add( _toFarthestPoint$1 ) );
		 this.expandByPoint( _v1$6$1.copy( sphere.center ).sub( _toFarthestPoint$1 ) );

		 return this;

	 }

	 equals( sphere ) {

		 return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 const _vector$a$1 = /*@__PURE__*/ new Vector3$1();
 const _segCenter$1 = /*@__PURE__*/ new Vector3$1();
 const _segDir$1 = /*@__PURE__*/ new Vector3$1();
 const _diff$1 = /*@__PURE__*/ new Vector3$1();

 const _edge1$1 = /*@__PURE__*/ new Vector3$1();
 const _edge2$1 = /*@__PURE__*/ new Vector3$1();
 const _normal$1$1 = /*@__PURE__*/ new Vector3$1();

 class Ray$1 {

	 constructor( origin = new Vector3$1(), direction = new Vector3$1( 0, 0, - 1 ) ) {

		 this.origin = origin;
		 this.direction = direction;

	 }

	 set( origin, direction ) {

		 this.origin.copy( origin );
		 this.direction.copy( direction );

		 return this;

	 }

	 copy( ray ) {

		 this.origin.copy( ray.origin );
		 this.direction.copy( ray.direction );

		 return this;

	 }

	 at( t, target ) {

		 return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	 }

	 lookAt( v ) {

		 this.direction.copy( v ).sub( this.origin ).normalize();

		 return this;

	 }

	 recast( t ) {

		 this.origin.copy( this.at( t, _vector$a$1 ) );

		 return this;

	 }

	 closestPointToPoint( point, target ) {

		 target.subVectors( point, this.origin );

		 const directionDistance = target.dot( this.direction );

		 if ( directionDistance < 0 ) {

			 return target.copy( this.origin );

		 }

		 return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	 }

	 distanceToPoint( point ) {

		 return Math.sqrt( this.distanceSqToPoint( point ) );

	 }

	 distanceSqToPoint( point ) {

		 const directionDistance = _vector$a$1.subVectors( point, this.origin ).dot( this.direction );

		 // point behind the ray

		 if ( directionDistance < 0 ) {

			 return this.origin.distanceToSquared( point );

		 }

		 _vector$a$1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		 return _vector$a$1.distanceToSquared( point );

	 }

	 distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		 // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		 // It returns the min distance between the ray and the segment
		 // defined by v0 and v1
		 // It can also set two optional targets :
		 // - The closest point on the ray
		 // - The closest point on the segment

		 _segCenter$1.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		 _segDir$1.copy( v1 ).sub( v0 ).normalize();
		 _diff$1.copy( this.origin ).sub( _segCenter$1 );

		 const segExtent = v0.distanceTo( v1 ) * 0.5;
		 const a01 = - this.direction.dot( _segDir$1 );
		 const b0 = _diff$1.dot( this.direction );
		 const b1 = - _diff$1.dot( _segDir$1 );
		 const c = _diff$1.lengthSq();
		 const det = Math.abs( 1 - a01 * a01 );
		 let s0, s1, sqrDist, extDet;

		 if ( det > 0 ) {

			 // The ray and segment are not parallel.

			 s0 = a01 * b1 - b0;
			 s1 = a01 * b0 - b1;
			 extDet = segExtent * det;

			 if ( s0 >= 0 ) {

				 if ( s1 >= - extDet ) {

					 if ( s1 <= extDet ) {

						 // region 0
						 // Minimum at interior points of ray and segment.

						 const invDet = 1 / det;
						 s0 *= invDet;
						 s1 *= invDet;
						 sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					 } else {

						 // region 1

						 s1 = segExtent;
						 s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					 }

				 } else {

					 // region 5

					 s1 = - segExtent;
					 s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				 }

			 } else {

				 if ( s1 <= - extDet ) {

					 // region 4

					 s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					 s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				 } else if ( s1 <= extDet ) {

					 // region 3

					 s0 = 0;
					 s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					 sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				 } else {

					 // region 2

					 s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					 s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				 }

			 }

		 } else {

			 // Ray and segment are parallel.

			 s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			 s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		 }

		 if ( optionalPointOnRay ) {

			 optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		 }

		 if ( optionalPointOnSegment ) {

			 optionalPointOnSegment.copy( _segDir$1 ).multiplyScalar( s1 ).add( _segCenter$1 );

		 }

		 return sqrDist;

	 }

	 intersectSphere( sphere, target ) {

		 _vector$a$1.subVectors( sphere.center, this.origin );
		 const tca = _vector$a$1.dot( this.direction );
		 const d2 = _vector$a$1.dot( _vector$a$1 ) - tca * tca;
		 const radius2 = sphere.radius * sphere.radius;

		 if ( d2 > radius2 ) return null;

		 const thc = Math.sqrt( radius2 - d2 );

		 // t0 = first intersect point - entrance on front of sphere
		 const t0 = tca - thc;

		 // t1 = second intersect point - exit point on back of sphere
		 const t1 = tca + thc;

		 // test to see if both t0 and t1 are behind the ray - if so, return null
		 if ( t0 < 0 && t1 < 0 ) return null;

		 // test to see if t0 is behind the ray:
		 // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		 // in order to always return an intersect point that is in front of the ray.
		 if ( t0 < 0 ) return this.at( t1, target );

		 // else t0 is in front of the ray, so return the first collision point scaled by t0
		 return this.at( t0, target );

	 }

	 intersectsSphere( sphere ) {

		 return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	 }

	 distanceToPlane( plane ) {

		 const denominator = plane.normal.dot( this.direction );

		 if ( denominator === 0 ) {

			 // line is coplanar, return origin
			 if ( plane.distanceToPoint( this.origin ) === 0 ) {

				 return 0;

			 }

			 // Null is preferable to undefined since undefined means.... it is undefined

			 return null;

		 }

		 const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		 // Return if the ray never intersects the plane

		 return t >= 0 ? t : null;

	 }

	 intersectPlane( plane, target ) {

		 const t = this.distanceToPlane( plane );

		 if ( t === null ) {

			 return null;

		 }

		 return this.at( t, target );

	 }

	 intersectsPlane( plane ) {

		 // check if the ray lies on the plane first

		 const distToPoint = plane.distanceToPoint( this.origin );

		 if ( distToPoint === 0 ) {

			 return true;

		 }

		 const denominator = plane.normal.dot( this.direction );

		 if ( denominator * distToPoint < 0 ) {

			 return true;

		 }

		 // ray origin is behind the plane (and is pointing behind it)

		 return false;

	 }

	 intersectBox( box, target ) {

		 let tmin, tmax, tymin, tymax, tzmin, tzmax;

		 const invdirx = 1 / this.direction.x,
			 invdiry = 1 / this.direction.y,
			 invdirz = 1 / this.direction.z;

		 const origin = this.origin;

		 if ( invdirx >= 0 ) {

			 tmin = ( box.min.x - origin.x ) * invdirx;
			 tmax = ( box.max.x - origin.x ) * invdirx;

		 } else {

			 tmin = ( box.max.x - origin.x ) * invdirx;
			 tmax = ( box.min.x - origin.x ) * invdirx;

		 }

		 if ( invdiry >= 0 ) {

			 tymin = ( box.min.y - origin.y ) * invdiry;
			 tymax = ( box.max.y - origin.y ) * invdiry;

		 } else {

			 tymin = ( box.max.y - origin.y ) * invdiry;
			 tymax = ( box.min.y - origin.y ) * invdiry;

		 }

		 if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		 // These lines also handle the case where tmin or tmax is NaN
		 // (result of 0 * Infinity). x !== x returns true if x is NaN

		 if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		 if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		 if ( invdirz >= 0 ) {

			 tzmin = ( box.min.z - origin.z ) * invdirz;
			 tzmax = ( box.max.z - origin.z ) * invdirz;

		 } else {

			 tzmin = ( box.max.z - origin.z ) * invdirz;
			 tzmax = ( box.min.z - origin.z ) * invdirz;

		 }

		 if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		 if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		 if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		 //return point closest to the ray (positive side)

		 if ( tmax < 0 ) return null;

		 return this.at( tmin >= 0 ? tmin : tmax, target );

	 }

	 intersectsBox( box ) {

		 return this.intersectBox( box, _vector$a$1 ) !== null;

	 }

	 intersectTriangle( a, b, c, backfaceCulling, target ) {

		 // Compute the offset origin, edges, and normal.

		 // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		 _edge1$1.subVectors( b, a );
		 _edge2$1.subVectors( c, a );
		 _normal$1$1.crossVectors( _edge1$1, _edge2$1 );

		 // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		 // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		 //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		 //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		 //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		 let DdN = this.direction.dot( _normal$1$1 );
		 let sign;

		 if ( DdN > 0 ) {

			 if ( backfaceCulling ) return null;
			 sign = 1;

		 } else if ( DdN < 0 ) {

			 sign = - 1;
			 DdN = - DdN;

		 } else {

			 return null;

		 }

		 _diff$1.subVectors( this.origin, a );
		 const DdQxE2 = sign * this.direction.dot( _edge2$1.crossVectors( _diff$1, _edge2$1 ) );

		 // b1 < 0, no intersection
		 if ( DdQxE2 < 0 ) {

			 return null;

		 }

		 const DdE1xQ = sign * this.direction.dot( _edge1$1.cross( _diff$1 ) );

		 // b2 < 0, no intersection
		 if ( DdE1xQ < 0 ) {

			 return null;

		 }

		 // b1+b2 > 1, no intersection
		 if ( DdQxE2 + DdE1xQ > DdN ) {

			 return null;

		 }

		 // Line intersects triangle, check if ray does.
		 const QdN = - sign * _diff$1.dot( _normal$1$1 );

		 // t < 0, no intersection
		 if ( QdN < 0 ) {

			 return null;

		 }

		 // Ray intersects triangle.
		 return this.at( QdN / DdN, target );

	 }

	 applyMatrix4( matrix4 ) {

		 this.origin.applyMatrix4( matrix4 );
		 this.direction.transformDirection( matrix4 );

		 return this;

	 }

	 equals( ray ) {

		 return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 class Matrix4$1 {

	 constructor() {

		 this.elements = [

			 1, 0, 0, 0,
			 0, 1, 0, 0,
			 0, 0, 1, 0,
			 0, 0, 0, 1

		 ];

		 if ( arguments.length > 0 ) {

			 console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		 }

	 }

	 set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		 const te = this.elements;

		 te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		 te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		 te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		 te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		 return this;

	 }

	 identity() {

		 this.set(

			 1, 0, 0, 0,
			 0, 1, 0, 0,
			 0, 0, 1, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 clone() {

		 return new Matrix4$1().fromArray( this.elements );

	 }

	 copy( m ) {

		 const te = this.elements;
		 const me = m.elements;

		 te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		 te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		 te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		 te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		 return this;

	 }

	 copyPosition( m ) {

		 const te = this.elements, me = m.elements;

		 te[ 12 ] = me[ 12 ];
		 te[ 13 ] = me[ 13 ];
		 te[ 14 ] = me[ 14 ];

		 return this;

	 }

	 setFromMatrix3( m ) {

		 const me = m.elements;

		 this.set(

			 me[ 0 ], me[ 3 ], me[ 6 ], 0,
			 me[ 1 ], me[ 4 ], me[ 7 ], 0,
			 me[ 2 ], me[ 5 ], me[ 8 ], 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 extractBasis( xAxis, yAxis, zAxis ) {

		 xAxis.setFromMatrixColumn( this, 0 );
		 yAxis.setFromMatrixColumn( this, 1 );
		 zAxis.setFromMatrixColumn( this, 2 );

		 return this;

	 }

	 makeBasis( xAxis, yAxis, zAxis ) {

		 this.set(
			 xAxis.x, yAxis.x, zAxis.x, 0,
			 xAxis.y, yAxis.y, zAxis.y, 0,
			 xAxis.z, yAxis.z, zAxis.z, 0,
			 0, 0, 0, 1
		 );

		 return this;

	 }

	 extractRotation( m ) {

		 // this method does not support reflection matrices

		 const te = this.elements;
		 const me = m.elements;

		 const scaleX = 1 / _v1$5$1.setFromMatrixColumn( m, 0 ).length();
		 const scaleY = 1 / _v1$5$1.setFromMatrixColumn( m, 1 ).length();
		 const scaleZ = 1 / _v1$5$1.setFromMatrixColumn( m, 2 ).length();

		 te[ 0 ] = me[ 0 ] * scaleX;
		 te[ 1 ] = me[ 1 ] * scaleX;
		 te[ 2 ] = me[ 2 ] * scaleX;
		 te[ 3 ] = 0;

		 te[ 4 ] = me[ 4 ] * scaleY;
		 te[ 5 ] = me[ 5 ] * scaleY;
		 te[ 6 ] = me[ 6 ] * scaleY;
		 te[ 7 ] = 0;

		 te[ 8 ] = me[ 8 ] * scaleZ;
		 te[ 9 ] = me[ 9 ] * scaleZ;
		 te[ 10 ] = me[ 10 ] * scaleZ;
		 te[ 11 ] = 0;

		 te[ 12 ] = 0;
		 te[ 13 ] = 0;
		 te[ 14 ] = 0;
		 te[ 15 ] = 1;

		 return this;

	 }

	 makeRotationFromEuler( euler ) {

		 if ( ! ( euler && euler.isEuler ) ) {

			 console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		 }

		 const te = this.elements;

		 const x = euler.x, y = euler.y, z = euler.z;
		 const a = Math.cos( x ), b = Math.sin( x );
		 const c = Math.cos( y ), d = Math.sin( y );
		 const e = Math.cos( z ), f = Math.sin( z );

		 if ( euler.order === 'XYZ' ) {

			 const ae = a * e, af = a * f, be = b * e, bf = b * f;

			 te[ 0 ] = c * e;
			 te[ 4 ] = - c * f;
			 te[ 8 ] = d;

			 te[ 1 ] = af + be * d;
			 te[ 5 ] = ae - bf * d;
			 te[ 9 ] = - b * c;

			 te[ 2 ] = bf - ae * d;
			 te[ 6 ] = be + af * d;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'YXZ' ) {

			 const ce = c * e, cf = c * f, de = d * e, df = d * f;

			 te[ 0 ] = ce + df * b;
			 te[ 4 ] = de * b - cf;
			 te[ 8 ] = a * d;

			 te[ 1 ] = a * f;
			 te[ 5 ] = a * e;
			 te[ 9 ] = - b;

			 te[ 2 ] = cf * b - de;
			 te[ 6 ] = df + ce * b;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'ZXY' ) {

			 const ce = c * e, cf = c * f, de = d * e, df = d * f;

			 te[ 0 ] = ce - df * b;
			 te[ 4 ] = - a * f;
			 te[ 8 ] = de + cf * b;

			 te[ 1 ] = cf + de * b;
			 te[ 5 ] = a * e;
			 te[ 9 ] = df - ce * b;

			 te[ 2 ] = - a * d;
			 te[ 6 ] = b;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'ZYX' ) {

			 const ae = a * e, af = a * f, be = b * e, bf = b * f;

			 te[ 0 ] = c * e;
			 te[ 4 ] = be * d - af;
			 te[ 8 ] = ae * d + bf;

			 te[ 1 ] = c * f;
			 te[ 5 ] = bf * d + ae;
			 te[ 9 ] = af * d - be;

			 te[ 2 ] = - d;
			 te[ 6 ] = b * c;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'YZX' ) {

			 const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			 te[ 0 ] = c * e;
			 te[ 4 ] = bd - ac * f;
			 te[ 8 ] = bc * f + ad;

			 te[ 1 ] = f;
			 te[ 5 ] = a * e;
			 te[ 9 ] = - b * e;

			 te[ 2 ] = - d * e;
			 te[ 6 ] = ad * f + bc;
			 te[ 10 ] = ac - bd * f;

		 } else if ( euler.order === 'XZY' ) {

			 const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			 te[ 0 ] = c * e;
			 te[ 4 ] = - f;
			 te[ 8 ] = d * e;

			 te[ 1 ] = ac * f + bd;
			 te[ 5 ] = a * e;
			 te[ 9 ] = ad * f - bc;

			 te[ 2 ] = bc * f - ad;
			 te[ 6 ] = b * e;
			 te[ 10 ] = bd * f + ac;

		 }

		 // bottom row
		 te[ 3 ] = 0;
		 te[ 7 ] = 0;
		 te[ 11 ] = 0;

		 // last column
		 te[ 12 ] = 0;
		 te[ 13 ] = 0;
		 te[ 14 ] = 0;
		 te[ 15 ] = 1;

		 return this;

	 }

	 makeRotationFromQuaternion( q ) {

		 return this.compose( _zero$1, q, _one$1 );

	 }

	 lookAt( eye, target, up ) {

		 const te = this.elements;

		 _z$1.subVectors( eye, target );

		 if ( _z$1.lengthSq() === 0 ) {

			 // eye and target are in the same position

			 _z$1.z = 1;

		 }

		 _z$1.normalize();
		 _x$1.crossVectors( up, _z$1 );

		 if ( _x$1.lengthSq() === 0 ) {

			 // up and z are parallel

			 if ( Math.abs( up.z ) === 1 ) {

				 _z$1.x += 0.0001;

			 } else {

				 _z$1.z += 0.0001;

			 }

			 _z$1.normalize();
			 _x$1.crossVectors( up, _z$1 );

		 }

		 _x$1.normalize();
		 _y$1.crossVectors( _z$1, _x$1 );

		 te[ 0 ] = _x$1.x; te[ 4 ] = _y$1.x; te[ 8 ] = _z$1.x;
		 te[ 1 ] = _x$1.y; te[ 5 ] = _y$1.y; te[ 9 ] = _z$1.y;
		 te[ 2 ] = _x$1.z; te[ 6 ] = _y$1.z; te[ 10 ] = _z$1.z;

		 return this;

	 }

	 multiply( m, n ) {

		 if ( n !== undefined ) {

			 console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			 return this.multiplyMatrices( m, n );

		 }

		 return this.multiplyMatrices( this, m );

	 }

	 premultiply( m ) {

		 return this.multiplyMatrices( m, this );

	 }

	 multiplyMatrices( a, b ) {

		 const ae = a.elements;
		 const be = b.elements;
		 const te = this.elements;

		 const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		 const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		 const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		 const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		 const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		 const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		 const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		 const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		 te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		 te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		 te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		 te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		 te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		 te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		 te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		 te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		 te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		 te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		 te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		 te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		 te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		 te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		 te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		 te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		 return this;

	 }

	 multiplyScalar( s ) {

		 const te = this.elements;

		 te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		 te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		 te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		 te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		 return this;

	 }

	 determinant() {

		 const te = this.elements;

		 const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		 const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		 const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		 const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		 //TODO: make this more efficient
		 //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		 return (
			 n41 * (
				 + n14 * n23 * n32
					- n13 * n24 * n32
					- n14 * n22 * n33
					+ n12 * n24 * n33
					+ n13 * n22 * n34
					- n12 * n23 * n34
			 ) +
			 n42 * (
				 + n11 * n23 * n34
					- n11 * n24 * n33
					+ n14 * n21 * n33
					- n13 * n21 * n34
					+ n13 * n24 * n31
					- n14 * n23 * n31
			 ) +
			 n43 * (
				 + n11 * n24 * n32
					- n11 * n22 * n34
					- n14 * n21 * n32
					+ n12 * n21 * n34
					+ n14 * n22 * n31
					- n12 * n24 * n31
			 ) +
			 n44 * (
				 - n13 * n22 * n31
					- n11 * n23 * n32
					+ n11 * n22 * n33
					+ n13 * n21 * n32
					- n12 * n21 * n33
					+ n12 * n23 * n31
			 )

		 );

	 }

	 transpose() {

		 const te = this.elements;
		 let tmp;

		 tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		 tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		 tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		 tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		 tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		 tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		 return this;

	 }

	 setPosition( x, y, z ) {

		 const te = this.elements;

		 if ( x.isVector3 ) {

			 te[ 12 ] = x.x;
			 te[ 13 ] = x.y;
			 te[ 14 ] = x.z;

		 } else {

			 te[ 12 ] = x;
			 te[ 13 ] = y;
			 te[ 14 ] = z;

		 }

		 return this;

	 }

	 invert() {

		 // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		 const te = this.elements,

			 n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			 n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			 n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			 n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			 t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			 t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			 t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			 t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		 const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		 if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		 const detInv = 1 / det;

		 te[ 0 ] = t11 * detInv;
		 te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		 te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		 te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		 te[ 4 ] = t12 * detInv;
		 te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		 te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		 te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		 te[ 8 ] = t13 * detInv;
		 te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		 te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		 te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		 te[ 12 ] = t14 * detInv;
		 te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		 te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		 te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		 return this;

	 }

	 scale( v ) {

		 const te = this.elements;
		 const x = v.x, y = v.y, z = v.z;

		 te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		 te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		 te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		 te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		 return this;

	 }

	 getMaxScaleOnAxis() {

		 const te = this.elements;

		 const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		 const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		 const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		 return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	 }

	 makeTranslation( x, y, z ) {

		 this.set(

			 1, 0, 0, x,
			 0, 1, 0, y,
			 0, 0, 1, z,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationX( theta ) {

		 const c = Math.cos( theta ), s = Math.sin( theta );

		 this.set(

			 1, 0, 0, 0,
			 0, c, - s, 0,
			 0, s, c, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationY( theta ) {

		 const c = Math.cos( theta ), s = Math.sin( theta );

		 this.set(

				c, 0, s, 0,
				0, 1, 0, 0,
			 - s, 0, c, 0,
				0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationZ( theta ) {

		 const c = Math.cos( theta ), s = Math.sin( theta );

		 this.set(

			 c, - s, 0, 0,
			 s, c, 0, 0,
			 0, 0, 1, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationAxis( axis, angle ) {

		 // Based on http://www.gamedev.net/reference/articles/article1199.asp

		 const c = Math.cos( angle );
		 const s = Math.sin( angle );
		 const t = 1 - c;
		 const x = axis.x, y = axis.y, z = axis.z;
		 const tx = t * x, ty = t * y;

		 this.set(

			 tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			 tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			 tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeScale( x, y, z ) {

		 this.set(

			 x, 0, 0, 0,
			 0, y, 0, 0,
			 0, 0, z, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeShear( xy, xz, yx, yz, zx, zy ) {

		 this.set(

			 1, yx, zx, 0,
			 xy, 1, zy, 0,
			 xz, yz, 1, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 compose( position, quaternion, scale ) {

		 const te = this.elements;

		 const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		 const x2 = x + x,	y2 = y + y, z2 = z + z;
		 const xx = x * x2, xy = x * y2, xz = x * z2;
		 const yy = y * y2, yz = y * z2, zz = z * z2;
		 const wx = w * x2, wy = w * y2, wz = w * z2;

		 const sx = scale.x, sy = scale.y, sz = scale.z;

		 te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		 te[ 1 ] = ( xy + wz ) * sx;
		 te[ 2 ] = ( xz - wy ) * sx;
		 te[ 3 ] = 0;

		 te[ 4 ] = ( xy - wz ) * sy;
		 te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		 te[ 6 ] = ( yz + wx ) * sy;
		 te[ 7 ] = 0;

		 te[ 8 ] = ( xz + wy ) * sz;
		 te[ 9 ] = ( yz - wx ) * sz;
		 te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		 te[ 11 ] = 0;

		 te[ 12 ] = position.x;
		 te[ 13 ] = position.y;
		 te[ 14 ] = position.z;
		 te[ 15 ] = 1;

		 return this;

	 }

	 decompose( position, quaternion, scale ) {

		 const te = this.elements;

		 let sx = _v1$5$1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		 const sy = _v1$5$1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		 const sz = _v1$5$1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		 // if determine is negative, we need to invert one scale
		 const det = this.determinant();
		 if ( det < 0 ) sx = - sx;

		 position.x = te[ 12 ];
		 position.y = te[ 13 ];
		 position.z = te[ 14 ];

		 // scale the rotation part
		 _m1$2$1.copy( this );

		 const invSX = 1 / sx;
		 const invSY = 1 / sy;
		 const invSZ = 1 / sz;

		 _m1$2$1.elements[ 0 ] *= invSX;
		 _m1$2$1.elements[ 1 ] *= invSX;
		 _m1$2$1.elements[ 2 ] *= invSX;

		 _m1$2$1.elements[ 4 ] *= invSY;
		 _m1$2$1.elements[ 5 ] *= invSY;
		 _m1$2$1.elements[ 6 ] *= invSY;

		 _m1$2$1.elements[ 8 ] *= invSZ;
		 _m1$2$1.elements[ 9 ] *= invSZ;
		 _m1$2$1.elements[ 10 ] *= invSZ;

		 quaternion.setFromRotationMatrix( _m1$2$1 );

		 scale.x = sx;
		 scale.y = sy;
		 scale.z = sz;

		 return this;

	 }

	 makePerspective( left, right, top, bottom, near, far ) {

		 if ( far === undefined ) {

			 console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		 }

		 const te = this.elements;
		 const x = 2 * near / ( right - left );
		 const y = 2 * near / ( top - bottom );

		 const a = ( right + left ) / ( right - left );
		 const b = ( top + bottom ) / ( top - bottom );
		 const c = - ( far + near ) / ( far - near );
		 const d = - 2 * far * near / ( far - near );

		 te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		 te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		 te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		 te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		 return this;

	 }

	 makeOrthographic( left, right, top, bottom, near, far ) {

		 const te = this.elements;
		 const w = 1.0 / ( right - left );
		 const h = 1.0 / ( top - bottom );
		 const p = 1.0 / ( far - near );

		 const x = ( right + left ) * w;
		 const y = ( top + bottom ) * h;
		 const z = ( far + near ) * p;

		 te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		 te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		 te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		 te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		 return this;

	 }

	 equals( matrix ) {

		 const te = this.elements;
		 const me = matrix.elements;

		 for ( let i = 0; i < 16; i ++ ) {

			 if ( te[ i ] !== me[ i ] ) return false;

		 }

		 return true;

	 }

	 fromArray( array, offset = 0 ) {

		 for ( let i = 0; i < 16; i ++ ) {

			 this.elements[ i ] = array[ i + offset ];

		 }

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 const te = this.elements;

		 array[ offset ] = te[ 0 ];
		 array[ offset + 1 ] = te[ 1 ];
		 array[ offset + 2 ] = te[ 2 ];
		 array[ offset + 3 ] = te[ 3 ];

		 array[ offset + 4 ] = te[ 4 ];
		 array[ offset + 5 ] = te[ 5 ];
		 array[ offset + 6 ] = te[ 6 ];
		 array[ offset + 7 ] = te[ 7 ];

		 array[ offset + 8 ] = te[ 8 ];
		 array[ offset + 9 ] = te[ 9 ];
		 array[ offset + 10 ] = te[ 10 ];
		 array[ offset + 11 ] = te[ 11 ];

		 array[ offset + 12 ] = te[ 12 ];
		 array[ offset + 13 ] = te[ 13 ];
		 array[ offset + 14 ] = te[ 14 ];
		 array[ offset + 15 ] = te[ 15 ];

		 return array;

	 }

 }

 Matrix4$1.prototype.isMatrix4 = true;

 const _v1$5$1 = /*@__PURE__*/ new Vector3$1();
 const _m1$2$1 = /*@__PURE__*/ new Matrix4$1();
 const _zero$1 = /*@__PURE__*/ new Vector3$1( 0, 0, 0 );
 const _one$1 = /*@__PURE__*/ new Vector3$1( 1, 1, 1 );
 const _x$1 = /*@__PURE__*/ new Vector3$1();
 const _y$1 = /*@__PURE__*/ new Vector3$1();
 const _z$1 = /*@__PURE__*/ new Vector3$1();

 const _matrix$1$1 = /*@__PURE__*/ new Matrix4$1();
 const _quaternion$3$1 = /*@__PURE__*/ new Quaternion$1();

 class Euler$1 {

	 constructor( x = 0, y = 0, z = 0, order = Euler$1.DefaultOrder ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._order = order;

	 }

	 get x() {

		 return this._x;

	 }

	 set x( value ) {

		 this._x = value;
		 this._onChangeCallback();

	 }

	 get y() {

		 return this._y;

	 }

	 set y( value ) {

		 this._y = value;
		 this._onChangeCallback();

	 }

	 get z() {

		 return this._z;

	 }

	 set z( value ) {

		 this._z = value;
		 this._onChangeCallback();

	 }

	 get order() {

		 return this._order;

	 }

	 set order( value ) {

		 this._order = value;
		 this._onChangeCallback();

	 }

	 set( x, y, z, order = this._order ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._order = order;

		 this._onChangeCallback();

		 return this;

	 }

	 clone() {

		 return new this.constructor( this._x, this._y, this._z, this._order );

	 }

	 copy( euler ) {

		 this._x = euler._x;
		 this._y = euler._y;
		 this._z = euler._z;
		 this._order = euler._order;

		 this._onChangeCallback();

		 return this;

	 }

	 setFromRotationMatrix( m, order = this._order, update = true ) {

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 const te = m.elements;
		 const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		 const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		 const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		 switch ( order ) {

			 case 'XYZ':

				 this._y = Math.asin( clamp$1( m13, - 1, 1 ) );

				 if ( Math.abs( m13 ) < 0.9999999 ) {

					 this._x = Math.atan2( - m23, m33 );
					 this._z = Math.atan2( - m12, m11 );

				 } else {

					 this._x = Math.atan2( m32, m22 );
					 this._z = 0;

				 }

				 break;

			 case 'YXZ':

				 this._x = Math.asin( - clamp$1( m23, - 1, 1 ) );

				 if ( Math.abs( m23 ) < 0.9999999 ) {

					 this._y = Math.atan2( m13, m33 );
					 this._z = Math.atan2( m21, m22 );

				 } else {

					 this._y = Math.atan2( - m31, m11 );
					 this._z = 0;

				 }

				 break;

			 case 'ZXY':

				 this._x = Math.asin( clamp$1( m32, - 1, 1 ) );

				 if ( Math.abs( m32 ) < 0.9999999 ) {

					 this._y = Math.atan2( - m31, m33 );
					 this._z = Math.atan2( - m12, m22 );

				 } else {

					 this._y = 0;
					 this._z = Math.atan2( m21, m11 );

				 }

				 break;

			 case 'ZYX':

				 this._y = Math.asin( - clamp$1( m31, - 1, 1 ) );

				 if ( Math.abs( m31 ) < 0.9999999 ) {

					 this._x = Math.atan2( m32, m33 );
					 this._z = Math.atan2( m21, m11 );

				 } else {

					 this._x = 0;
					 this._z = Math.atan2( - m12, m22 );

				 }

				 break;

			 case 'YZX':

				 this._z = Math.asin( clamp$1( m21, - 1, 1 ) );

				 if ( Math.abs( m21 ) < 0.9999999 ) {

					 this._x = Math.atan2( - m23, m22 );
					 this._y = Math.atan2( - m31, m11 );

				 } else {

					 this._x = 0;
					 this._y = Math.atan2( m13, m33 );

				 }

				 break;

			 case 'XZY':

				 this._z = Math.asin( - clamp$1( m12, - 1, 1 ) );

				 if ( Math.abs( m12 ) < 0.9999999 ) {

					 this._x = Math.atan2( m32, m22 );
					 this._y = Math.atan2( m13, m11 );

				 } else {

					 this._x = Math.atan2( - m23, m33 );
					 this._y = 0;

				 }

				 break;

			 default:

				 console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		 }

		 this._order = order;

		 if ( update === true ) this._onChangeCallback();

		 return this;

	 }

	 setFromQuaternion( q, order, update ) {

		 _matrix$1$1.makeRotationFromQuaternion( q );

		 return this.setFromRotationMatrix( _matrix$1$1, order, update );

	 }

	 setFromVector3( v, order = this._order ) {

		 return this.set( v.x, v.y, v.z, order );

	 }

	 reorder( newOrder ) {

		 // WARNING: this discards revolution information -bhouston

		 _quaternion$3$1.setFromEuler( this );

		 return this.setFromQuaternion( _quaternion$3$1, newOrder );

	 }

	 equals( euler ) {

		 return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	 }

	 fromArray( array ) {

		 this._x = array[ 0 ];
		 this._y = array[ 1 ];
		 this._z = array[ 2 ];
		 if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		 this._onChangeCallback();

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this._x;
		 array[ offset + 1 ] = this._y;
		 array[ offset + 2 ] = this._z;
		 array[ offset + 3 ] = this._order;

		 return array;

	 }

	 toVector3( optionalResult ) {

		 if ( optionalResult ) {

			 return optionalResult.set( this._x, this._y, this._z );

		 } else {

			 return new Vector3$1( this._x, this._y, this._z );

		 }

	 }

	 _onChange( callback ) {

		 this._onChangeCallback = callback;

		 return this;

	 }

	 _onChangeCallback() {}

 }

 Euler$1.prototype.isEuler = true;

 Euler$1.DefaultOrder = 'XYZ';
 Euler$1.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

 class Layers$1 {

	 constructor() {

		 this.mask = 1 | 0;

	 }

	 set( channel ) {

		 this.mask = 1 << channel | 0;

	 }

	 enable( channel ) {

		 this.mask |= 1 << channel | 0;

	 }

	 enableAll() {

		 this.mask = 0xffffffff | 0;

	 }

	 toggle( channel ) {

		 this.mask ^= 1 << channel | 0;

	 }

	 disable( channel ) {

		 this.mask &= ~ ( 1 << channel | 0 );

	 }

	 disableAll() {

		 this.mask = 0;

	 }

	 test( layers ) {

		 return ( this.mask & layers.mask ) !== 0;

	 }

 }

 let _object3DId$1 = 0;

 const _v1$4$1 = /*@__PURE__*/ new Vector3$1();
 const _q1$1 = /*@__PURE__*/ new Quaternion$1();
 const _m1$1$1 = /*@__PURE__*/ new Matrix4$1();
 const _target$1 = /*@__PURE__*/ new Vector3$1();

 const _position$3$1 = /*@__PURE__*/ new Vector3$1();
 const _scale$2$1 = /*@__PURE__*/ new Vector3$1();
 const _quaternion$2$1 = /*@__PURE__*/ new Quaternion$1();

 const _xAxis$1 = /*@__PURE__*/ new Vector3$1( 1, 0, 0 );
 const _yAxis$1 = /*@__PURE__*/ new Vector3$1( 0, 1, 0 );
 const _zAxis$1 = /*@__PURE__*/ new Vector3$1( 0, 0, 1 );

 const _addedEvent$1 = { type: 'added' };
 const _removedEvent$1 = { type: 'removed' };

 class Object3D$1 extends EventDispatcher$1 {

	 constructor() {

		 super();

		 Object.defineProperty( this, 'id', { value: _object3DId$1 ++ } );

		 this.uuid = generateUUID$1();

		 this.name = '';
		 this.type = 'Object3D';

		 this.parent = null;
		 this.children = [];

		 this.up = Object3D$1.DefaultUp.clone();

		 const position = new Vector3$1();
		 const rotation = new Euler$1();
		 const quaternion = new Quaternion$1();
		 const scale = new Vector3$1( 1, 1, 1 );

		 function onRotationChange() {

			 quaternion.setFromEuler( rotation, false );

		 }

		 function onQuaternionChange() {

			 rotation.setFromQuaternion( quaternion, undefined, false );

		 }

		 rotation._onChange( onRotationChange );
		 quaternion._onChange( onQuaternionChange );

		 Object.defineProperties( this, {
			 position: {
				 configurable: true,
				 enumerable: true,
				 value: position
			 },
			 rotation: {
				 configurable: true,
				 enumerable: true,
				 value: rotation
			 },
			 quaternion: {
				 configurable: true,
				 enumerable: true,
				 value: quaternion
			 },
			 scale: {
				 configurable: true,
				 enumerable: true,
				 value: scale
			 },
			 modelViewMatrix: {
				 value: new Matrix4$1()
			 },
			 normalMatrix: {
				 value: new Matrix3$1()
			 }
		 } );

		 this.matrix = new Matrix4$1();
		 this.matrixWorld = new Matrix4$1();

		 this.matrixAutoUpdate = Object3D$1.DefaultMatrixAutoUpdate;
		 this.matrixWorldNeedsUpdate = false;

		 this.layers = new Layers$1();
		 this.visible = true;

		 this.castShadow = false;
		 this.receiveShadow = false;

		 this.frustumCulled = true;
		 this.renderOrder = 0;

		 this.animations = [];

		 this.userData = {};

	 }

	 onBeforeRender() {}
	 onAfterRender() {}

	 applyMatrix4( matrix ) {

		 if ( this.matrixAutoUpdate ) this.updateMatrix();

		 this.matrix.premultiply( matrix );

		 this.matrix.decompose( this.position, this.quaternion, this.scale );

	 }

	 applyQuaternion( q ) {

		 this.quaternion.premultiply( q );

		 return this;

	 }

	 setRotationFromAxisAngle( axis, angle ) {

		 // assumes axis is normalized

		 this.quaternion.setFromAxisAngle( axis, angle );

	 }

	 setRotationFromEuler( euler ) {

		 this.quaternion.setFromEuler( euler, true );

	 }

	 setRotationFromMatrix( m ) {

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 this.quaternion.setFromRotationMatrix( m );

	 }

	 setRotationFromQuaternion( q ) {

		 // assumes q is normalized

		 this.quaternion.copy( q );

	 }

	 rotateOnAxis( axis, angle ) {

		 // rotate object on axis in object space
		 // axis is assumed to be normalized

		 _q1$1.setFromAxisAngle( axis, angle );

		 this.quaternion.multiply( _q1$1 );

		 return this;

	 }

	 rotateOnWorldAxis( axis, angle ) {

		 // rotate object on axis in world space
		 // axis is assumed to be normalized
		 // method assumes no rotated parent

		 _q1$1.setFromAxisAngle( axis, angle );

		 this.quaternion.premultiply( _q1$1 );

		 return this;

	 }

	 rotateX( angle ) {

		 return this.rotateOnAxis( _xAxis$1, angle );

	 }

	 rotateY( angle ) {

		 return this.rotateOnAxis( _yAxis$1, angle );

	 }

	 rotateZ( angle ) {

		 return this.rotateOnAxis( _zAxis$1, angle );

	 }

	 translateOnAxis( axis, distance ) {

		 // translate object by distance along axis in object space
		 // axis is assumed to be normalized

		 _v1$4$1.copy( axis ).applyQuaternion( this.quaternion );

		 this.position.add( _v1$4$1.multiplyScalar( distance ) );

		 return this;

	 }

	 translateX( distance ) {

		 return this.translateOnAxis( _xAxis$1, distance );

	 }

	 translateY( distance ) {

		 return this.translateOnAxis( _yAxis$1, distance );

	 }

	 translateZ( distance ) {

		 return this.translateOnAxis( _zAxis$1, distance );

	 }

	 localToWorld( vector ) {

		 return vector.applyMatrix4( this.matrixWorld );

	 }

	 worldToLocal( vector ) {

		 return vector.applyMatrix4( _m1$1$1.copy( this.matrixWorld ).invert() );

	 }

	 lookAt( x, y, z ) {

		 // This method does not support objects having non-uniformly-scaled parent(s)

		 if ( x.isVector3 ) {

			 _target$1.copy( x );

		 } else {

			 _target$1.set( x, y, z );

		 }

		 const parent = this.parent;

		 this.updateWorldMatrix( true, false );

		 _position$3$1.setFromMatrixPosition( this.matrixWorld );

		 if ( this.isCamera || this.isLight ) {

			 _m1$1$1.lookAt( _position$3$1, _target$1, this.up );

		 } else {

			 _m1$1$1.lookAt( _target$1, _position$3$1, this.up );

		 }

		 this.quaternion.setFromRotationMatrix( _m1$1$1 );

		 if ( parent ) {

			 _m1$1$1.extractRotation( parent.matrixWorld );
			 _q1$1.setFromRotationMatrix( _m1$1$1 );
			 this.quaternion.premultiply( _q1$1.invert() );

		 }

	 }

	 add( object ) {

		 if ( arguments.length > 1 ) {

			 for ( let i = 0; i < arguments.length; i ++ ) {

				 this.add( arguments[ i ] );

			 }

			 return this;

		 }

		 if ( object === this ) {

			 console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			 return this;

		 }

		 if ( object && object.isObject3D ) {

			 if ( object.parent !== null ) {

				 object.parent.remove( object );

			 }

			 object.parent = this;
			 this.children.push( object );

			 object.dispatchEvent( _addedEvent$1 );

		 } else {

			 console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		 }

		 return this;

	 }

	 remove( object ) {

		 if ( arguments.length > 1 ) {

			 for ( let i = 0; i < arguments.length; i ++ ) {

				 this.remove( arguments[ i ] );

			 }

			 return this;

		 }

		 const index = this.children.indexOf( object );

		 if ( index !== - 1 ) {

			 object.parent = null;
			 this.children.splice( index, 1 );

			 object.dispatchEvent( _removedEvent$1 );

		 }

		 return this;

	 }

	 removeFromParent() {

		 const parent = this.parent;

		 if ( parent !== null ) {

			 parent.remove( this );

		 }

		 return this;

	 }

	 clear() {

		 for ( let i = 0; i < this.children.length; i ++ ) {

			 const object = this.children[ i ];

			 object.parent = null;

			 object.dispatchEvent( _removedEvent$1 );

		 }

		 this.children.length = 0;

		 return this;


	 }

	 attach( object ) {

		 // adds object as a child of this, while maintaining the object's world transform

		 this.updateWorldMatrix( true, false );

		 _m1$1$1.copy( this.matrixWorld ).invert();

		 if ( object.parent !== null ) {

			 object.parent.updateWorldMatrix( true, false );

			 _m1$1$1.multiply( object.parent.matrixWorld );

		 }

		 object.applyMatrix4( _m1$1$1 );

		 this.add( object );

		 object.updateWorldMatrix( false, true );

		 return this;

	 }

	 getObjectById( id ) {

		 return this.getObjectByProperty( 'id', id );

	 }

	 getObjectByName( name ) {

		 return this.getObjectByProperty( 'name', name );

	 }

	 getObjectByProperty( name, value ) {

		 if ( this[ name ] === value ) return this;

		 for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			 const child = this.children[ i ];
			 const object = child.getObjectByProperty( name, value );

			 if ( object !== undefined ) {

				 return object;

			 }

		 }

		 return undefined;

	 }

	 getWorldPosition( target ) {

		 this.updateWorldMatrix( true, false );

		 return target.setFromMatrixPosition( this.matrixWorld );

	 }

	 getWorldQuaternion( target ) {

		 this.updateWorldMatrix( true, false );

		 this.matrixWorld.decompose( _position$3$1, target, _scale$2$1 );

		 return target;

	 }

	 getWorldScale( target ) {

		 this.updateWorldMatrix( true, false );

		 this.matrixWorld.decompose( _position$3$1, _quaternion$2$1, target );

		 return target;

	 }

	 getWorldDirection( target ) {

		 this.updateWorldMatrix( true, false );

		 const e = this.matrixWorld.elements;

		 return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	 }

	 raycast() {}

	 traverse( callback ) {

		 callback( this );

		 const children = this.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 children[ i ].traverse( callback );

		 }

	 }

	 traverseVisible( callback ) {

		 if ( this.visible === false ) return;

		 callback( this );

		 const children = this.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 children[ i ].traverseVisible( callback );

		 }

	 }

	 traverseAncestors( callback ) {

		 const parent = this.parent;

		 if ( parent !== null ) {

			 callback( parent );

			 parent.traverseAncestors( callback );

		 }

	 }

	 updateMatrix() {

		 this.matrix.compose( this.position, this.quaternion, this.scale );

		 this.matrixWorldNeedsUpdate = true;

	 }

	 updateMatrixWorld( force ) {

		 if ( this.matrixAutoUpdate ) this.updateMatrix();

		 if ( this.matrixWorldNeedsUpdate || force ) {

			 if ( this.parent === null ) {

				 this.matrixWorld.copy( this.matrix );

			 } else {

				 this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			 }

			 this.matrixWorldNeedsUpdate = false;

			 force = true;

		 }

		 // update children

		 const children = this.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 children[ i ].updateMatrixWorld( force );

		 }

	 }

	 updateWorldMatrix( updateParents, updateChildren ) {

		 const parent = this.parent;

		 if ( updateParents === true && parent !== null ) {

			 parent.updateWorldMatrix( true, false );

		 }

		 if ( this.matrixAutoUpdate ) this.updateMatrix();

		 if ( this.parent === null ) {

			 this.matrixWorld.copy( this.matrix );

		 } else {

			 this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		 }

		 // update children

		 if ( updateChildren === true ) {

			 const children = this.children;

			 for ( let i = 0, l = children.length; i < l; i ++ ) {

				 children[ i ].updateWorldMatrix( false, true );

			 }

		 }

	 }

	 toJSON( meta ) {

		 // meta is a string when called from JSON.stringify
		 const isRootObject = ( meta === undefined || typeof meta === 'string' );

		 const output = {};

		 // meta is a hash used to collect geometries, materials.
		 // not providing it implies that this is the root object
		 // being serialized.
		 if ( isRootObject ) {

			 // initialize meta obj
			 meta = {
				 geometries: {},
				 materials: {},
				 textures: {},
				 images: {},
				 shapes: {},
				 skeletons: {},
				 animations: {}
			 };

			 output.metadata = {
				 version: 4.5,
				 type: 'Object',
				 generator: 'Object3D.toJSON'
			 };

		 }

		 // standard Object3D serialization

		 const object = {};

		 object.uuid = this.uuid;
		 object.type = this.type;

		 if ( this.name !== '' ) object.name = this.name;
		 if ( this.castShadow === true ) object.castShadow = true;
		 if ( this.receiveShadow === true ) object.receiveShadow = true;
		 if ( this.visible === false ) object.visible = false;
		 if ( this.frustumCulled === false ) object.frustumCulled = false;
		 if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		 if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		 object.layers = this.layers.mask;
		 object.matrix = this.matrix.toArray();

		 if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		 // object specific properties

		 if ( this.isInstancedMesh ) {

			 object.type = 'InstancedMesh';
			 object.count = this.count;
			 object.instanceMatrix = this.instanceMatrix.toJSON();
			 if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		 }

		 //

		 function serialize( library, element ) {

			 if ( library[ element.uuid ] === undefined ) {

				 library[ element.uuid ] = element.toJSON( meta );

			 }

			 return element.uuid;

		 }

		 if ( this.isScene ) {

			 if ( this.background ) {

				 if ( this.background.isColor ) {

					 object.background = this.background.toJSON();

				 } else if ( this.background.isTexture ) {

					 object.background = this.background.toJSON( meta ).uuid;

				 }

			 }

			 if ( this.environment && this.environment.isTexture ) {

				 object.environment = this.environment.toJSON( meta ).uuid;

			 }

		 } else if ( this.isMesh || this.isLine || this.isPoints ) {

			 object.geometry = serialize( meta.geometries, this.geometry );

			 const parameters = this.geometry.parameters;

			 if ( parameters !== undefined && parameters.shapes !== undefined ) {

				 const shapes = parameters.shapes;

				 if ( Array.isArray( shapes ) ) {

					 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						 const shape = shapes[ i ];

						 serialize( meta.shapes, shape );

					 }

				 } else {

					 serialize( meta.shapes, shapes );

				 }

			 }

		 }

		 if ( this.isSkinnedMesh ) {

			 object.bindMode = this.bindMode;
			 object.bindMatrix = this.bindMatrix.toArray();

			 if ( this.skeleton !== undefined ) {

				 serialize( meta.skeletons, this.skeleton );

				 object.skeleton = this.skeleton.uuid;

			 }

		 }

		 if ( this.material !== undefined ) {

			 if ( Array.isArray( this.material ) ) {

				 const uuids = [];

				 for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					 uuids.push( serialize( meta.materials, this.material[ i ] ) );

				 }

				 object.material = uuids;

			 } else {

				 object.material = serialize( meta.materials, this.material );

			 }

		 }

		 //

		 if ( this.children.length > 0 ) {

			 object.children = [];

			 for ( let i = 0; i < this.children.length; i ++ ) {

				 object.children.push( this.children[ i ].toJSON( meta ).object );

			 }

		 }

		 //

		 if ( this.animations.length > 0 ) {

			 object.animations = [];

			 for ( let i = 0; i < this.animations.length; i ++ ) {

				 const animation = this.animations[ i ];

				 object.animations.push( serialize( meta.animations, animation ) );

			 }

		 }

		 if ( isRootObject ) {

			 const geometries = extractFromCache( meta.geometries );
			 const materials = extractFromCache( meta.materials );
			 const textures = extractFromCache( meta.textures );
			 const images = extractFromCache( meta.images );
			 const shapes = extractFromCache( meta.shapes );
			 const skeletons = extractFromCache( meta.skeletons );
			 const animations = extractFromCache( meta.animations );

			 if ( geometries.length > 0 ) output.geometries = geometries;
			 if ( materials.length > 0 ) output.materials = materials;
			 if ( textures.length > 0 ) output.textures = textures;
			 if ( images.length > 0 ) output.images = images;
			 if ( shapes.length > 0 ) output.shapes = shapes;
			 if ( skeletons.length > 0 ) output.skeletons = skeletons;
			 if ( animations.length > 0 ) output.animations = animations;

		 }

		 output.object = object;

		 return output;

		 // extract data from the cache hash
		 // remove metadata on each item
		 // and return as array
		 function extractFromCache( cache ) {

			 const values = [];
			 for ( const key in cache ) {

				 const data = cache[ key ];
				 delete data.metadata;
				 values.push( data );

			 }

			 return values;

		 }

	 }

	 clone( recursive ) {

		 return new this.constructor().copy( this, recursive );

	 }

	 copy( source, recursive = true ) {

		 this.name = source.name;

		 this.up.copy( source.up );

		 this.position.copy( source.position );
		 this.rotation.order = source.rotation.order;
		 this.quaternion.copy( source.quaternion );
		 this.scale.copy( source.scale );

		 this.matrix.copy( source.matrix );
		 this.matrixWorld.copy( source.matrixWorld );

		 this.matrixAutoUpdate = source.matrixAutoUpdate;
		 this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		 this.layers.mask = source.layers.mask;
		 this.visible = source.visible;

		 this.castShadow = source.castShadow;
		 this.receiveShadow = source.receiveShadow;

		 this.frustumCulled = source.frustumCulled;
		 this.renderOrder = source.renderOrder;

		 this.userData = JSON.parse( JSON.stringify( source.userData ) );

		 if ( recursive === true ) {

			 for ( let i = 0; i < source.children.length; i ++ ) {

				 const child = source.children[ i ];
				 this.add( child.clone() );

			 }

		 }

		 return this;

	 }

 }

 Object3D$1.DefaultUp = new Vector3$1( 0, 1, 0 );
 Object3D$1.DefaultMatrixAutoUpdate = true;

 Object3D$1.prototype.isObject3D = true;

 const _v0$1$1 = /*@__PURE__*/ new Vector3$1();
 const _v1$3$1 = /*@__PURE__*/ new Vector3$1();
 const _v2$2$1 = /*@__PURE__*/ new Vector3$1();
 const _v3$1$1 = /*@__PURE__*/ new Vector3$1();

 const _vab$1 = /*@__PURE__*/ new Vector3$1();
 const _vac$1 = /*@__PURE__*/ new Vector3$1();
 const _vbc$1 = /*@__PURE__*/ new Vector3$1();
 const _vap$1 = /*@__PURE__*/ new Vector3$1();
 const _vbp$1 = /*@__PURE__*/ new Vector3$1();
 const _vcp$1 = /*@__PURE__*/ new Vector3$1();

 class Triangle$1 {

	 constructor( a = new Vector3$1(), b = new Vector3$1(), c = new Vector3$1() ) {

		 this.a = a;
		 this.b = b;
		 this.c = c;

	 }

	 static getNormal( a, b, c, target ) {

		 target.subVectors( c, b );
		 _v0$1$1.subVectors( a, b );
		 target.cross( _v0$1$1 );

		 const targetLengthSq = target.lengthSq();
		 if ( targetLengthSq > 0 ) {

			 return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		 }

		 return target.set( 0, 0, 0 );

	 }

	 // static/instance method to calculate barycentric coordinates
	 // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	 static getBarycoord( point, a, b, c, target ) {

		 _v0$1$1.subVectors( c, a );
		 _v1$3$1.subVectors( b, a );
		 _v2$2$1.subVectors( point, a );

		 const dot00 = _v0$1$1.dot( _v0$1$1 );
		 const dot01 = _v0$1$1.dot( _v1$3$1 );
		 const dot02 = _v0$1$1.dot( _v2$2$1 );
		 const dot11 = _v1$3$1.dot( _v1$3$1 );
		 const dot12 = _v1$3$1.dot( _v2$2$1 );

		 const denom = ( dot00 * dot11 - dot01 * dot01 );

		 // collinear or singular triangle
		 if ( denom === 0 ) {

			 // arbitrary location outside of triangle?
			 // not sure if this is the best idea, maybe should be returning undefined
			 return target.set( - 2, - 1, - 1 );

		 }

		 const invDenom = 1 / denom;
		 const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		 const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		 // barycentric coordinates must always sum to 1
		 return target.set( 1 - u - v, v, u );

	 }

	 static containsPoint( point, a, b, c ) {

		 this.getBarycoord( point, a, b, c, _v3$1$1 );

		 return ( _v3$1$1.x >= 0 ) && ( _v3$1$1.y >= 0 ) && ( ( _v3$1$1.x + _v3$1$1.y ) <= 1 );

	 }

	 static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		 this.getBarycoord( point, p1, p2, p3, _v3$1$1 );

		 target.set( 0, 0 );
		 target.addScaledVector( uv1, _v3$1$1.x );
		 target.addScaledVector( uv2, _v3$1$1.y );
		 target.addScaledVector( uv3, _v3$1$1.z );

		 return target;

	 }

	 static isFrontFacing( a, b, c, direction ) {

		 _v0$1$1.subVectors( c, b );
		 _v1$3$1.subVectors( a, b );

		 // strictly front facing
		 return ( _v0$1$1.cross( _v1$3$1 ).dot( direction ) < 0 ) ? true : false;

	 }

	 set( a, b, c ) {

		 this.a.copy( a );
		 this.b.copy( b );
		 this.c.copy( c );

		 return this;

	 }

	 setFromPointsAndIndices( points, i0, i1, i2 ) {

		 this.a.copy( points[ i0 ] );
		 this.b.copy( points[ i1 ] );
		 this.c.copy( points[ i2 ] );

		 return this;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( triangle ) {

		 this.a.copy( triangle.a );
		 this.b.copy( triangle.b );
		 this.c.copy( triangle.c );

		 return this;

	 }

	 getArea() {

		 _v0$1$1.subVectors( this.c, this.b );
		 _v1$3$1.subVectors( this.a, this.b );

		 return _v0$1$1.cross( _v1$3$1 ).length() * 0.5;

	 }

	 getMidpoint( target ) {

		 return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	 }

	 getNormal( target ) {

		 return Triangle$1.getNormal( this.a, this.b, this.c, target );

	 }

	 getPlane( target ) {

		 return target.setFromCoplanarPoints( this.a, this.b, this.c );

	 }

	 getBarycoord( point, target ) {

		 return Triangle$1.getBarycoord( point, this.a, this.b, this.c, target );

	 }

	 getUV( point, uv1, uv2, uv3, target ) {

		 return Triangle$1.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	 }

	 containsPoint( point ) {

		 return Triangle$1.containsPoint( point, this.a, this.b, this.c );

	 }

	 isFrontFacing( direction ) {

		 return Triangle$1.isFrontFacing( this.a, this.b, this.c, direction );

	 }

	 intersectsBox( box ) {

		 return box.intersectsTriangle( this );

	 }

	 closestPointToPoint( p, target ) {

		 const a = this.a, b = this.b, c = this.c;
		 let v, w;

		 // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		 // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		 // under the accompanying license; see chapter 5.1.5 for detailed explanation.
		 // basically, we're distinguishing which of the voronoi regions of the triangle
		 // the point lies in with the minimum amount of redundant computation.

		 _vab$1.subVectors( b, a );
		 _vac$1.subVectors( c, a );
		 _vap$1.subVectors( p, a );
		 const d1 = _vab$1.dot( _vap$1 );
		 const d2 = _vac$1.dot( _vap$1 );
		 if ( d1 <= 0 && d2 <= 0 ) {

			 // vertex region of A; barycentric coords (1, 0, 0)
			 return target.copy( a );

		 }

		 _vbp$1.subVectors( p, b );
		 const d3 = _vab$1.dot( _vbp$1 );
		 const d4 = _vac$1.dot( _vbp$1 );
		 if ( d3 >= 0 && d4 <= d3 ) {

			 // vertex region of B; barycentric coords (0, 1, 0)
			 return target.copy( b );

		 }

		 const vc = d1 * d4 - d3 * d2;
		 if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			 v = d1 / ( d1 - d3 );
			 // edge region of AB; barycentric coords (1-v, v, 0)
			 return target.copy( a ).addScaledVector( _vab$1, v );

		 }

		 _vcp$1.subVectors( p, c );
		 const d5 = _vab$1.dot( _vcp$1 );
		 const d6 = _vac$1.dot( _vcp$1 );
		 if ( d6 >= 0 && d5 <= d6 ) {

			 // vertex region of C; barycentric coords (0, 0, 1)
			 return target.copy( c );

		 }

		 const vb = d5 * d2 - d1 * d6;
		 if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			 w = d2 / ( d2 - d6 );
			 // edge region of AC; barycentric coords (1-w, 0, w)
			 return target.copy( a ).addScaledVector( _vac$1, w );

		 }

		 const va = d3 * d6 - d5 * d4;
		 if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			 _vbc$1.subVectors( c, b );
			 w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			 // edge region of BC; barycentric coords (0, 1-w, w)
			 return target.copy( b ).addScaledVector( _vbc$1, w ); // edge region of BC

		 }

		 // face region
		 const denom = 1 / ( va + vb + vc );
		 // u = va * denom
		 v = vb * denom;
		 w = vc * denom;

		 return target.copy( a ).addScaledVector( _vab$1, v ).addScaledVector( _vac$1, w );

	 }

	 equals( triangle ) {

		 return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	 }

 }

 let materialId$1 = 0;

 class Material$1 extends EventDispatcher$1 {

	 constructor() {

		 super();

		 Object.defineProperty( this, 'id', { value: materialId$1 ++ } );

		 this.uuid = generateUUID$1();

		 this.name = '';
		 this.type = 'Material';

		 this.fog = true;

		 this.blending = NormalBlending$1;
		 this.side = FrontSide$1;
		 this.vertexColors = false;

		 this.opacity = 1;
		 this.transparent = false;

		 this.blendSrc = SrcAlphaFactor$1;
		 this.blendDst = OneMinusSrcAlphaFactor$1;
		 this.blendEquation = AddEquation$1;
		 this.blendSrcAlpha = null;
		 this.blendDstAlpha = null;
		 this.blendEquationAlpha = null;

		 this.depthFunc = LessEqualDepth$1;
		 this.depthTest = true;
		 this.depthWrite = true;

		 this.stencilWriteMask = 0xff;
		 this.stencilFunc = AlwaysStencilFunc$1;
		 this.stencilRef = 0;
		 this.stencilFuncMask = 0xff;
		 this.stencilFail = KeepStencilOp$1;
		 this.stencilZFail = KeepStencilOp$1;
		 this.stencilZPass = KeepStencilOp$1;
		 this.stencilWrite = false;

		 this.clippingPlanes = null;
		 this.clipIntersection = false;
		 this.clipShadows = false;

		 this.shadowSide = null;

		 this.colorWrite = true;

		 this.precision = null; // override the renderer's default precision for this material

		 this.polygonOffset = false;
		 this.polygonOffsetFactor = 0;
		 this.polygonOffsetUnits = 0;

		 this.dithering = false;

		 this.alphaTest = 0;
		 this.alphaToCoverage = false;
		 this.premultipliedAlpha = false;

		 this.visible = true;

		 this.toneMapped = true;

		 this.userData = {};

		 this.version = 0;

	 }

	 onBuild( /* shaderobject, renderer */ ) {}

	 onBeforeCompile( /* shaderobject, renderer */ ) {}

	 customProgramCacheKey() {

		 return this.onBeforeCompile.toString();

	 }

	 setValues( values ) {

		 if ( values === undefined ) return;

		 for ( const key in values ) {

			 const newValue = values[ key ];

			 if ( newValue === undefined ) {

				 console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				 continue;

			 }

			 // for backward compatability if shading is set in the constructor
			 if ( key === 'shading' ) {

				 console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				 this.flatShading = ( newValue === FlatShading$1 ) ? true : false;
				 continue;

			 }

			 const currentValue = this[ key ];

			 if ( currentValue === undefined ) {

				 console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				 continue;

			 }

			 if ( currentValue && currentValue.isColor ) {

				 currentValue.set( newValue );

			 } else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				 currentValue.copy( newValue );

			 } else {

				 this[ key ] = newValue;

			 }

		 }

	 }

	 toJSON( meta ) {

		 const isRoot = ( meta === undefined || typeof meta === 'string' );

		 if ( isRoot ) {

			 meta = {
				 textures: {},
				 images: {}
			 };

		 }

		 const data = {
			 metadata: {
				 version: 4.5,
				 type: 'Material',
				 generator: 'Material.toJSON'
			 }
		 };

		 // standard Material serialization
		 data.uuid = this.uuid;
		 data.type = this.type;

		 if ( this.name !== '' ) data.name = this.name;

		 if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		 if ( this.roughness !== undefined ) data.roughness = this.roughness;
		 if ( this.metalness !== undefined ) data.metalness = this.metalness;

		 if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		 if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		 if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		 if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		 if ( this.shininess !== undefined ) data.shininess = this.shininess;
		 if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		 if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		 if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			 data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		 }

		 if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			 data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		 }

		 if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			 data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			 data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		 }

		 if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		 if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		 if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		 if ( this.lightMap && this.lightMap.isTexture ) {

			 data.lightMap = this.lightMap.toJSON( meta ).uuid;
			 data.lightMapIntensity = this.lightMapIntensity;

		 }

		 if ( this.aoMap && this.aoMap.isTexture ) {

			 data.aoMap = this.aoMap.toJSON( meta ).uuid;
			 data.aoMapIntensity = this.aoMapIntensity;

		 }

		 if ( this.bumpMap && this.bumpMap.isTexture ) {

			 data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			 data.bumpScale = this.bumpScale;

		 }

		 if ( this.normalMap && this.normalMap.isTexture ) {

			 data.normalMap = this.normalMap.toJSON( meta ).uuid;
			 data.normalMapType = this.normalMapType;
			 data.normalScale = this.normalScale.toArray();

		 }

		 if ( this.displacementMap && this.displacementMap.isTexture ) {

			 data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			 data.displacementScale = this.displacementScale;
			 data.displacementBias = this.displacementBias;

		 }

		 if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		 if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		 if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		 if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		 if ( this.envMap && this.envMap.isTexture ) {

			 data.envMap = this.envMap.toJSON( meta ).uuid;

			 if ( this.combine !== undefined ) data.combine = this.combine;

		 }

		 if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		 if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		 if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		 if ( this.gradientMap && this.gradientMap.isTexture ) {

			 data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		 }

		 if ( this.transmission !== undefined ) data.transmission = this.transmission;
		 if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		 if ( this.thickness !== undefined ) data.thickness = this.thickness;
		 if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		 if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
		 if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		 if ( this.size !== undefined ) data.size = this.size;
		 if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		 if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		 if ( this.blending !== NormalBlending$1 ) data.blending = this.blending;
		 if ( this.side !== FrontSide$1 ) data.side = this.side;
		 if ( this.vertexColors ) data.vertexColors = true;

		 if ( this.opacity < 1 ) data.opacity = this.opacity;
		 if ( this.transparent === true ) data.transparent = this.transparent;

		 data.depthFunc = this.depthFunc;
		 data.depthTest = this.depthTest;
		 data.depthWrite = this.depthWrite;
		 data.colorWrite = this.colorWrite;

		 data.stencilWrite = this.stencilWrite;
		 data.stencilWriteMask = this.stencilWriteMask;
		 data.stencilFunc = this.stencilFunc;
		 data.stencilRef = this.stencilRef;
		 data.stencilFuncMask = this.stencilFuncMask;
		 data.stencilFail = this.stencilFail;
		 data.stencilZFail = this.stencilZFail;
		 data.stencilZPass = this.stencilZPass;

		 // rotation (SpriteMaterial)
		 if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		 if ( this.polygonOffset === true ) data.polygonOffset = true;
		 if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		 if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		 if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		 if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		 if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		 if ( this.scale !== undefined ) data.scale = this.scale;

		 if ( this.dithering === true ) data.dithering = true;

		 if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		 if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		 if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		 if ( this.wireframe === true ) data.wireframe = this.wireframe;
		 if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		 if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		 if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		 if ( this.morphTargets === true ) data.morphTargets = true;
		 if ( this.morphNormals === true ) data.morphNormals = true;

		 if ( this.flatShading === true ) data.flatShading = this.flatShading;

		 if ( this.visible === false ) data.visible = false;

		 if ( this.toneMapped === false ) data.toneMapped = false;

		 if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		 // TODO: Copied from Object3D.toJSON

		 function extractFromCache( cache ) {

			 const values = [];

			 for ( const key in cache ) {

				 const data = cache[ key ];
				 delete data.metadata;
				 values.push( data );

			 }

			 return values;

		 }

		 if ( isRoot ) {

			 const textures = extractFromCache( meta.textures );
			 const images = extractFromCache( meta.images );

			 if ( textures.length > 0 ) data.textures = textures;
			 if ( images.length > 0 ) data.images = images;

		 }

		 return data;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.name = source.name;

		 this.fog = source.fog;

		 this.blending = source.blending;
		 this.side = source.side;
		 this.vertexColors = source.vertexColors;

		 this.opacity = source.opacity;
		 this.transparent = source.transparent;

		 this.blendSrc = source.blendSrc;
		 this.blendDst = source.blendDst;
		 this.blendEquation = source.blendEquation;
		 this.blendSrcAlpha = source.blendSrcAlpha;
		 this.blendDstAlpha = source.blendDstAlpha;
		 this.blendEquationAlpha = source.blendEquationAlpha;

		 this.depthFunc = source.depthFunc;
		 this.depthTest = source.depthTest;
		 this.depthWrite = source.depthWrite;

		 this.stencilWriteMask = source.stencilWriteMask;
		 this.stencilFunc = source.stencilFunc;
		 this.stencilRef = source.stencilRef;
		 this.stencilFuncMask = source.stencilFuncMask;
		 this.stencilFail = source.stencilFail;
		 this.stencilZFail = source.stencilZFail;
		 this.stencilZPass = source.stencilZPass;
		 this.stencilWrite = source.stencilWrite;

		 const srcPlanes = source.clippingPlanes;
		 let dstPlanes = null;

		 if ( srcPlanes !== null ) {

			 const n = srcPlanes.length;
			 dstPlanes = new Array( n );

			 for ( let i = 0; i !== n; ++ i ) {

				 dstPlanes[ i ] = srcPlanes[ i ].clone();

			 }

		 }

		 this.clippingPlanes = dstPlanes;
		 this.clipIntersection = source.clipIntersection;
		 this.clipShadows = source.clipShadows;

		 this.shadowSide = source.shadowSide;

		 this.colorWrite = source.colorWrite;

		 this.precision = source.precision;

		 this.polygonOffset = source.polygonOffset;
		 this.polygonOffsetFactor = source.polygonOffsetFactor;
		 this.polygonOffsetUnits = source.polygonOffsetUnits;

		 this.dithering = source.dithering;

		 this.alphaTest = source.alphaTest;
		 this.alphaToCoverage = source.alphaToCoverage;
		 this.premultipliedAlpha = source.premultipliedAlpha;

		 this.visible = source.visible;

		 this.toneMapped = source.toneMapped;

		 this.userData = JSON.parse( JSON.stringify( source.userData ) );

		 return this;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

 }

 Material$1.prototype.isMaterial = true;

 const _colorKeywords$1 = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	 'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	 'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	 'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	 'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	 'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	 'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	 'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	 'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	 'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	 'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	 'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	 'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	 'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	 'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	 'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	 'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	 'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	 'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	 'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	 'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	 'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	 'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	 'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

 const _hslA$1 = { h: 0, s: 0, l: 0 };
 const _hslB$1 = { h: 0, s: 0, l: 0 };

 function hue2rgb$1( p, q, t ) {

	 if ( t < 0 ) t += 1;
	 if ( t > 1 ) t -= 1;
	 if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	 if ( t < 1 / 2 ) return q;
	 if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	 return p;

 }

 function SRGBToLinear$1( c ) {

	 return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

 }

 function LinearToSRGB$1( c ) {

	 return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

 }

 class Color$2 {

	 constructor( r, g, b ) {

		 if ( g === undefined && b === undefined ) {

			 // r is THREE.Color, hex or string
			 return this.set( r );

		 }

		 return this.setRGB( r, g, b );

	 }

	 set( value ) {

		 if ( value && value.isColor ) {

			 this.copy( value );

		 } else if ( typeof value === 'number' ) {

			 this.setHex( value );

		 } else if ( typeof value === 'string' ) {

			 this.setStyle( value );

		 }

		 return this;

	 }

	 setScalar( scalar ) {

		 this.r = scalar;
		 this.g = scalar;
		 this.b = scalar;

		 return this;

	 }

	 setHex( hex ) {

		 hex = Math.floor( hex );

		 this.r = ( hex >> 16 & 255 ) / 255;
		 this.g = ( hex >> 8 & 255 ) / 255;
		 this.b = ( hex & 255 ) / 255;

		 return this;

	 }

	 setRGB( r, g, b ) {

		 this.r = r;
		 this.g = g;
		 this.b = b;

		 return this;

	 }

	 setHSL( h, s, l ) {

		 // h,s,l ranges are in 0.0 - 1.0
		 h = euclideanModulo$1( h, 1 );
		 s = clamp$1( s, 0, 1 );
		 l = clamp$1( l, 0, 1 );

		 if ( s === 0 ) {

			 this.r = this.g = this.b = l;

		 } else {

			 const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			 const q = ( 2 * l ) - p;

			 this.r = hue2rgb$1( q, p, h + 1 / 3 );
			 this.g = hue2rgb$1( q, p, h );
			 this.b = hue2rgb$1( q, p, h - 1 / 3 );

		 }

		 return this;

	 }

	 setStyle( style ) {

		 function handleAlpha( string ) {

			 if ( string === undefined ) return;

			 if ( parseFloat( string ) < 1 ) {

				 console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			 }

		 }


		 let m;

		 if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			 // rgb / hsl

			 let color;
			 const name = m[ 1 ];
			 const components = m[ 2 ];

			 switch ( name ) {

				 case 'rgb':
				 case 'rgba':

					 if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						 // rgb(255,0,0) rgba(255,0,0,0.5)
						 this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						 this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						 this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						 handleAlpha( color[ 4 ] );

						 return this;

					 }

					 if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						 // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						 this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						 this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						 this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						 handleAlpha( color[ 4 ] );

						 return this;

					 }

					 break;

				 case 'hsl':
				 case 'hsla':

					 if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						 // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						 const h = parseFloat( color[ 1 ] ) / 360;
						 const s = parseInt( color[ 2 ], 10 ) / 100;
						 const l = parseInt( color[ 3 ], 10 ) / 100;

						 handleAlpha( color[ 4 ] );

						 return this.setHSL( h, s, l );

					 }

					 break;

			 }

		 } else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			 // hex color

			 const hex = m[ 1 ];
			 const size = hex.length;

			 if ( size === 3 ) {

				 // #ff0
				 this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				 this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				 this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				 return this;

			 } else if ( size === 6 ) {

				 // #ff0000
				 this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				 this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				 this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				 return this;

			 }

		 }

		 if ( style && style.length > 0 ) {

			 return this.setColorName( style );

		 }

		 return this;

	 }

	 setColorName( style ) {

		 // color keywords
		 const hex = _colorKeywords$1[ style.toLowerCase() ];

		 if ( hex !== undefined ) {

			 // red
			 this.setHex( hex );

		 } else {

			 // unknown color
			 console.warn( 'THREE.Color: Unknown color ' + style );

		 }

		 return this;

	 }

	 clone() {

		 return new this.constructor( this.r, this.g, this.b );

	 }

	 copy( color ) {

		 this.r = color.r;
		 this.g = color.g;
		 this.b = color.b;

		 return this;

	 }

	 copyGammaToLinear( color, gammaFactor = 2.0 ) {

		 this.r = Math.pow( color.r, gammaFactor );
		 this.g = Math.pow( color.g, gammaFactor );
		 this.b = Math.pow( color.b, gammaFactor );

		 return this;

	 }

	 copyLinearToGamma( color, gammaFactor = 2.0 ) {

		 const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		 this.r = Math.pow( color.r, safeInverse );
		 this.g = Math.pow( color.g, safeInverse );
		 this.b = Math.pow( color.b, safeInverse );

		 return this;

	 }

	 convertGammaToLinear( gammaFactor ) {

		 this.copyGammaToLinear( this, gammaFactor );

		 return this;

	 }

	 convertLinearToGamma( gammaFactor ) {

		 this.copyLinearToGamma( this, gammaFactor );

		 return this;

	 }

	 copySRGBToLinear( color ) {

		 this.r = SRGBToLinear$1( color.r );
		 this.g = SRGBToLinear$1( color.g );
		 this.b = SRGBToLinear$1( color.b );

		 return this;

	 }

	 copyLinearToSRGB( color ) {

		 this.r = LinearToSRGB$1( color.r );
		 this.g = LinearToSRGB$1( color.g );
		 this.b = LinearToSRGB$1( color.b );

		 return this;

	 }

	 convertSRGBToLinear() {

		 this.copySRGBToLinear( this );

		 return this;

	 }

	 convertLinearToSRGB() {

		 this.copyLinearToSRGB( this );

		 return this;

	 }

	 getHex() {

		 return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	 }

	 getHexString() {

		 return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	 }

	 getHSL( target ) {

		 // h,s,l ranges are in 0.0 - 1.0

		 const r = this.r, g = this.g, b = this.b;

		 const max = Math.max( r, g, b );
		 const min = Math.min( r, g, b );

		 let hue, saturation;
		 const lightness = ( min + max ) / 2.0;

		 if ( min === max ) {

			 hue = 0;
			 saturation = 0;

		 } else {

			 const delta = max - min;

			 saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			 switch ( max ) {

				 case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				 case g: hue = ( b - r ) / delta + 2; break;
				 case b: hue = ( r - g ) / delta + 4; break;

			 }

			 hue /= 6;

		 }

		 target.h = hue;
		 target.s = saturation;
		 target.l = lightness;

		 return target;

	 }

	 getStyle() {

		 return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	 }

	 offsetHSL( h, s, l ) {

		 this.getHSL( _hslA$1 );

		 _hslA$1.h += h; _hslA$1.s += s; _hslA$1.l += l;

		 this.setHSL( _hslA$1.h, _hslA$1.s, _hslA$1.l );

		 return this;

	 }

	 add( color ) {

		 this.r += color.r;
		 this.g += color.g;
		 this.b += color.b;

		 return this;

	 }

	 addColors( color1, color2 ) {

		 this.r = color1.r + color2.r;
		 this.g = color1.g + color2.g;
		 this.b = color1.b + color2.b;

		 return this;

	 }

	 addScalar( s ) {

		 this.r += s;
		 this.g += s;
		 this.b += s;

		 return this;

	 }

	 sub( color ) {

		 this.r = Math.max( 0, this.r - color.r );
		 this.g = Math.max( 0, this.g - color.g );
		 this.b = Math.max( 0, this.b - color.b );

		 return this;

	 }

	 multiply( color ) {

		 this.r *= color.r;
		 this.g *= color.g;
		 this.b *= color.b;

		 return this;

	 }

	 multiplyScalar( s ) {

		 this.r *= s;
		 this.g *= s;
		 this.b *= s;

		 return this;

	 }

	 lerp( color, alpha ) {

		 this.r += ( color.r - this.r ) * alpha;
		 this.g += ( color.g - this.g ) * alpha;
		 this.b += ( color.b - this.b ) * alpha;

		 return this;

	 }

	 lerpColors( color1, color2, alpha ) {

		 this.r = color1.r + ( color2.r - color1.r ) * alpha;
		 this.g = color1.g + ( color2.g - color1.g ) * alpha;
		 this.b = color1.b + ( color2.b - color1.b ) * alpha;

		 return this;

	 }

	 lerpHSL( color, alpha ) {

		 this.getHSL( _hslA$1 );
		 color.getHSL( _hslB$1 );

		 const h = lerp$1( _hslA$1.h, _hslB$1.h, alpha );
		 const s = lerp$1( _hslA$1.s, _hslB$1.s, alpha );
		 const l = lerp$1( _hslA$1.l, _hslB$1.l, alpha );

		 this.setHSL( h, s, l );

		 return this;

	 }

	 equals( c ) {

		 return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	 }

	 fromArray( array, offset = 0 ) {

		 this.r = array[ offset ];
		 this.g = array[ offset + 1 ];
		 this.b = array[ offset + 2 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.r;
		 array[ offset + 1 ] = this.g;
		 array[ offset + 2 ] = this.b;

		 return array;

	 }

	 fromBufferAttribute( attribute, index ) {

		 this.r = attribute.getX( index );
		 this.g = attribute.getY( index );
		 this.b = attribute.getZ( index );

		 if ( attribute.normalized === true ) {

			 // assuming Uint8Array

			 this.r /= 255;
			 this.g /= 255;
			 this.b /= 255;

		 }

		 return this;

	 }

	 toJSON() {

		 return this.getHex();

	 }

 }

 Color$2.NAMES = _colorKeywords$1;

 Color$2.prototype.isColor = true;
 Color$2.prototype.r = 1;
 Color$2.prototype.g = 1;
 Color$2.prototype.b = 1;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  specularMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  combine: THREE.Multiply,
	*  reflectivity: <float>,
	*  refractionRatio: <float>,
	*
	*  depthTest: <bool>,
	*  depthWrite: <bool>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>
	* }
	*/

 class MeshBasicMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshBasicMaterial';

		 this.color = new Color$2( 0xffffff ); // emissive

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.specularMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.combine = MultiplyOperation$1;
		 this.reflectivity = 1;
		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.specularMap = source.specularMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.combine = source.combine;
		 this.reflectivity = source.reflectivity;
		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;

		 return this;

	 }

 }

 MeshBasicMaterial$1.prototype.isMeshBasicMaterial = true;

 const _vector$9$1 = /*@__PURE__*/ new Vector3$1();
 const _vector2$1$1 = /*@__PURE__*/ new Vector2$1();

 class BufferAttribute$1 {

	 constructor( array, itemSize, normalized ) {

		 if ( Array.isArray( array ) ) {

			 throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		 }

		 this.name = '';

		 this.array = array;
		 this.itemSize = itemSize;
		 this.count = array !== undefined ? array.length / itemSize : 0;
		 this.normalized = normalized === true;

		 this.usage = StaticDrawUsage$1;
		 this.updateRange = { offset: 0, count: - 1 };

		 this.version = 0;

	 }

	 onUploadCallback() {}

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

	 setUsage( value ) {

		 this.usage = value;

		 return this;

	 }

	 copy( source ) {

		 this.name = source.name;
		 this.array = new source.array.constructor( source.array );
		 this.itemSize = source.itemSize;
		 this.count = source.count;
		 this.normalized = source.normalized;

		 this.usage = source.usage;

		 return this;

	 }

	 copyAt( index1, attribute, index2 ) {

		 index1 *= this.itemSize;
		 index2 *= attribute.itemSize;

		 for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			 this.array[ index1 + i ] = attribute.array[ index2 + i ];

		 }

		 return this;

	 }

	 copyArray( array ) {

		 this.array.set( array );

		 return this;

	 }

	 copyColorsArray( colors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = colors.length; i < l; i ++ ) {

			 let color = colors[ i ];

			 if ( color === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				 color = new Color$2();

			 }

			 array[ offset ++ ] = color.r;
			 array[ offset ++ ] = color.g;
			 array[ offset ++ ] = color.b;

		 }

		 return this;

	 }

	 copyVector2sArray( vectors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			 let vector = vectors[ i ];

			 if ( vector === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				 vector = new Vector2$1();

			 }

			 array[ offset ++ ] = vector.x;
			 array[ offset ++ ] = vector.y;

		 }

		 return this;

	 }

	 copyVector3sArray( vectors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			 let vector = vectors[ i ];

			 if ( vector === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				 vector = new Vector3$1();

			 }

			 array[ offset ++ ] = vector.x;
			 array[ offset ++ ] = vector.y;
			 array[ offset ++ ] = vector.z;

		 }

		 return this;

	 }

	 copyVector4sArray( vectors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			 let vector = vectors[ i ];

			 if ( vector === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				 vector = new Vector4$1();

			 }

			 array[ offset ++ ] = vector.x;
			 array[ offset ++ ] = vector.y;
			 array[ offset ++ ] = vector.z;
			 array[ offset ++ ] = vector.w;

		 }

		 return this;

	 }

	 applyMatrix3( m ) {

		 if ( this.itemSize === 2 ) {

			 for ( let i = 0, l = this.count; i < l; i ++ ) {

				 _vector2$1$1.fromBufferAttribute( this, i );
				 _vector2$1$1.applyMatrix3( m );

				 this.setXY( i, _vector2$1$1.x, _vector2$1$1.y );

			 }

		 } else if ( this.itemSize === 3 ) {

			 for ( let i = 0, l = this.count; i < l; i ++ ) {

				 _vector$9$1.fromBufferAttribute( this, i );
				 _vector$9$1.applyMatrix3( m );

				 this.setXYZ( i, _vector$9$1.x, _vector$9$1.y, _vector$9$1.z );

			 }

		 }

		 return this;

	 }

	 applyMatrix4( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$9$1.x = this.getX( i );
			 _vector$9$1.y = this.getY( i );
			 _vector$9$1.z = this.getZ( i );

			 _vector$9$1.applyMatrix4( m );

			 this.setXYZ( i, _vector$9$1.x, _vector$9$1.y, _vector$9$1.z );

		 }

		 return this;

	 }

	 applyNormalMatrix( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$9$1.x = this.getX( i );
			 _vector$9$1.y = this.getY( i );
			 _vector$9$1.z = this.getZ( i );

			 _vector$9$1.applyNormalMatrix( m );

			 this.setXYZ( i, _vector$9$1.x, _vector$9$1.y, _vector$9$1.z );

		 }

		 return this;

	 }

	 transformDirection( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$9$1.x = this.getX( i );
			 _vector$9$1.y = this.getY( i );
			 _vector$9$1.z = this.getZ( i );

			 _vector$9$1.transformDirection( m );

			 this.setXYZ( i, _vector$9$1.x, _vector$9$1.y, _vector$9$1.z );

		 }

		 return this;

	 }

	 set( value, offset = 0 ) {

		 this.array.set( value, offset );

		 return this;

	 }

	 getX( index ) {

		 return this.array[ index * this.itemSize ];

	 }

	 setX( index, x ) {

		 this.array[ index * this.itemSize ] = x;

		 return this;

	 }

	 getY( index ) {

		 return this.array[ index * this.itemSize + 1 ];

	 }

	 setY( index, y ) {

		 this.array[ index * this.itemSize + 1 ] = y;

		 return this;

	 }

	 getZ( index ) {

		 return this.array[ index * this.itemSize + 2 ];

	 }

	 setZ( index, z ) {

		 this.array[ index * this.itemSize + 2 ] = z;

		 return this;

	 }

	 getW( index ) {

		 return this.array[ index * this.itemSize + 3 ];

	 }

	 setW( index, w ) {

		 this.array[ index * this.itemSize + 3 ] = w;

		 return this;

	 }

	 setXY( index, x, y ) {

		 index *= this.itemSize;

		 this.array[ index + 0 ] = x;
		 this.array[ index + 1 ] = y;

		 return this;

	 }

	 setXYZ( index, x, y, z ) {

		 index *= this.itemSize;

		 this.array[ index + 0 ] = x;
		 this.array[ index + 1 ] = y;
		 this.array[ index + 2 ] = z;

		 return this;

	 }

	 setXYZW( index, x, y, z, w ) {

		 index *= this.itemSize;

		 this.array[ index + 0 ] = x;
		 this.array[ index + 1 ] = y;
		 this.array[ index + 2 ] = z;
		 this.array[ index + 3 ] = w;

		 return this;

	 }

	 onUpload( callback ) {

		 this.onUploadCallback = callback;

		 return this;

	 }

	 clone() {

		 return new this.constructor( this.array, this.itemSize ).copy( this );

	 }

	 toJSON() {

		 const data = {
			 itemSize: this.itemSize,
			 type: this.array.constructor.name,
			 array: Array.prototype.slice.call( this.array ),
			 normalized: this.normalized
		 };

		 if ( this.name !== '' ) data.name = this.name;
		 if ( this.usage !== StaticDrawUsage$1 ) data.usage = this.usage;
		 if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		 return data;

	 }

 }

 BufferAttribute$1.prototype.isBufferAttribute = true;

 class Uint16BufferAttribute$1 extends BufferAttribute$1 {

	 constructor( array, itemSize, normalized ) {

		 super( new Uint16Array( array ), itemSize, normalized );

	 }

 }

 class Uint32BufferAttribute$1 extends BufferAttribute$1 {

	 constructor( array, itemSize, normalized ) {

		 super( new Uint32Array( array ), itemSize, normalized );

	 }

 }

 class Float16BufferAttribute$1 extends BufferAttribute$1 {

	 constructor( array, itemSize, normalized ) {

		 super( new Uint16Array( array ), itemSize, normalized );

	 }

 }

 Float16BufferAttribute$1.prototype.isFloat16BufferAttribute = true;

 class Float32BufferAttribute$1 extends BufferAttribute$1 {

	 constructor( array, itemSize, normalized ) {

		 super( new Float32Array( array ), itemSize, normalized );

	 }

 }

 function arrayMax$1( array ) {

	 if ( array.length === 0 ) return - Infinity;

	 let max = array[ 0 ];

	 for ( let i = 1, l = array.length; i < l; ++ i ) {

		 if ( array[ i ] > max ) max = array[ i ];

	 }

	 return max;

 }

 let _id$1 = 0;

 const _m1$3 = /*@__PURE__*/ new Matrix4$1();
 const _obj$1 = /*@__PURE__*/ new Object3D$1();
 const _offset$1 = /*@__PURE__*/ new Vector3$1();
 const _box$1$1 = /*@__PURE__*/ new Box3$1();
 const _boxMorphTargets$1 = /*@__PURE__*/ new Box3$1();
 const _vector$8$1 = /*@__PURE__*/ new Vector3$1();

 class BufferGeometry$1 extends EventDispatcher$1 {

	 constructor() {

		 super();

		 Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		 this.uuid = generateUUID$1();

		 this.name = '';
		 this.type = 'BufferGeometry';

		 this.index = null;
		 this.attributes = {};

		 this.morphAttributes = {};
		 this.morphTargetsRelative = false;

		 this.groups = [];

		 this.boundingBox = null;
		 this.boundingSphere = null;

		 this.drawRange = { start: 0, count: Infinity };

		 this.userData = {};

	 }

	 getIndex() {

		 return this.index;

	 }

	 setIndex( index ) {

		 if ( Array.isArray( index ) ) {

			 this.index = new ( arrayMax$1( index ) > 65535 ? Uint32BufferAttribute$1 : Uint16BufferAttribute$1 )( index, 1 );

		 } else {

			 this.index = index;

		 }

		 return this;

	 }

	 getAttribute( name ) {

		 return this.attributes[ name ];

	 }

	 setAttribute( name, attribute ) {

		 this.attributes[ name ] = attribute;

		 return this;

	 }

	 deleteAttribute( name ) {

		 delete this.attributes[ name ];

		 return this;

	 }

	 hasAttribute( name ) {

		 return this.attributes[ name ] !== undefined;

	 }

	 addGroup( start, count, materialIndex = 0 ) {

		 this.groups.push( {

			 start: start,
			 count: count,
			 materialIndex: materialIndex

		 } );

	 }

	 clearGroups() {

		 this.groups = [];

	 }

	 setDrawRange( start, count ) {

		 this.drawRange.start = start;
		 this.drawRange.count = count;

	 }

	 applyMatrix4( matrix ) {

		 const position = this.attributes.position;

		 if ( position !== undefined ) {

			 position.applyMatrix4( matrix );

			 position.needsUpdate = true;

		 }

		 const normal = this.attributes.normal;

		 if ( normal !== undefined ) {

			 const normalMatrix = new Matrix3$1().getNormalMatrix( matrix );

			 normal.applyNormalMatrix( normalMatrix );

			 normal.needsUpdate = true;

		 }

		 const tangent = this.attributes.tangent;

		 if ( tangent !== undefined ) {

			 tangent.transformDirection( matrix );

			 tangent.needsUpdate = true;

		 }

		 if ( this.boundingBox !== null ) {

			 this.computeBoundingBox();

		 }

		 if ( this.boundingSphere !== null ) {

			 this.computeBoundingSphere();

		 }

		 return this;

	 }

	 applyQuaternion( q ) {

		 _m1$3.makeRotationFromQuaternion( q );

		 this.applyMatrix4( _m1$3 );

		 return this;

	 }

	 rotateX( angle ) {

		 // rotate geometry around world x-axis

		 _m1$3.makeRotationX( angle );

		 this.applyMatrix4( _m1$3 );

		 return this;

	 }

	 rotateY( angle ) {

		 // rotate geometry around world y-axis

		 _m1$3.makeRotationY( angle );

		 this.applyMatrix4( _m1$3 );

		 return this;

	 }

	 rotateZ( angle ) {

		 // rotate geometry around world z-axis

		 _m1$3.makeRotationZ( angle );

		 this.applyMatrix4( _m1$3 );

		 return this;

	 }

	 translate( x, y, z ) {

		 // translate geometry

		 _m1$3.makeTranslation( x, y, z );

		 this.applyMatrix4( _m1$3 );

		 return this;

	 }

	 scale( x, y, z ) {

		 // scale geometry

		 _m1$3.makeScale( x, y, z );

		 this.applyMatrix4( _m1$3 );

		 return this;

	 }

	 lookAt( vector ) {

		 _obj$1.lookAt( vector );

		 _obj$1.updateMatrix();

		 this.applyMatrix4( _obj$1.matrix );

		 return this;

	 }

	 center() {

		 this.computeBoundingBox();

		 this.boundingBox.getCenter( _offset$1 ).negate();

		 this.translate( _offset$1.x, _offset$1.y, _offset$1.z );

		 return this;

	 }

	 setFromPoints( points ) {

		 const position = [];

		 for ( let i = 0, l = points.length; i < l; i ++ ) {

			 const point = points[ i ];
			 position.push( point.x, point.y, point.z || 0 );

		 }

		 this.setAttribute( 'position', new Float32BufferAttribute$1( position, 3 ) );

		 return this;

	 }

	 computeBoundingBox() {

		 if ( this.boundingBox === null ) {

			 this.boundingBox = new Box3$1();

		 }

		 const position = this.attributes.position;
		 const morphAttributesPosition = this.morphAttributes.position;

		 if ( position && position.isGLBufferAttribute ) {

			 console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			 this.boundingBox.set(
				 new Vector3$1( - Infinity, - Infinity, - Infinity ),
				 new Vector3$1( + Infinity, + Infinity, + Infinity )
			 );

			 return;

		 }

		 if ( position !== undefined ) {

			 this.boundingBox.setFromBufferAttribute( position );

			 // process morph attributes if present

			 if ( morphAttributesPosition ) {

				 for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					 const morphAttribute = morphAttributesPosition[ i ];
					 _box$1$1.setFromBufferAttribute( morphAttribute );

					 if ( this.morphTargetsRelative ) {

						 _vector$8$1.addVectors( this.boundingBox.min, _box$1$1.min );
						 this.boundingBox.expandByPoint( _vector$8$1 );

						 _vector$8$1.addVectors( this.boundingBox.max, _box$1$1.max );
						 this.boundingBox.expandByPoint( _vector$8$1 );

					 } else {

						 this.boundingBox.expandByPoint( _box$1$1.min );
						 this.boundingBox.expandByPoint( _box$1$1.max );

					 }

				 }

			 }

		 } else {

			 this.boundingBox.makeEmpty();

		 }

		 if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			 console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		 }

	 }

	 computeBoundingSphere() {

		 if ( this.boundingSphere === null ) {

			 this.boundingSphere = new Sphere$1();

		 }

		 const position = this.attributes.position;
		 const morphAttributesPosition = this.morphAttributes.position;

		 if ( position && position.isGLBufferAttribute ) {

			 console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			 this.boundingSphere.set( new Vector3$1(), Infinity );

			 return;

		 }

		 if ( position ) {

			 // first, find the center of the bounding sphere

			 const center = this.boundingSphere.center;

			 _box$1$1.setFromBufferAttribute( position );

			 // process morph attributes if present

			 if ( morphAttributesPosition ) {

				 for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					 const morphAttribute = morphAttributesPosition[ i ];
					 _boxMorphTargets$1.setFromBufferAttribute( morphAttribute );

					 if ( this.morphTargetsRelative ) {

						 _vector$8$1.addVectors( _box$1$1.min, _boxMorphTargets$1.min );
						 _box$1$1.expandByPoint( _vector$8$1 );

						 _vector$8$1.addVectors( _box$1$1.max, _boxMorphTargets$1.max );
						 _box$1$1.expandByPoint( _vector$8$1 );

					 } else {

						 _box$1$1.expandByPoint( _boxMorphTargets$1.min );
						 _box$1$1.expandByPoint( _boxMorphTargets$1.max );

					 }

				 }

			 }

			 _box$1$1.getCenter( center );

			 // second, try to find a boundingSphere with a radius smaller than the
			 // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			 let maxRadiusSq = 0;

			 for ( let i = 0, il = position.count; i < il; i ++ ) {

				 _vector$8$1.fromBufferAttribute( position, i );

				 maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8$1 ) );

			 }

			 // process morph attributes if present

			 if ( morphAttributesPosition ) {

				 for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					 const morphAttribute = morphAttributesPosition[ i ];
					 const morphTargetsRelative = this.morphTargetsRelative;

					 for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						 _vector$8$1.fromBufferAttribute( morphAttribute, j );

						 if ( morphTargetsRelative ) {

							 _offset$1.fromBufferAttribute( position, j );
							 _vector$8$1.add( _offset$1 );

						 }

						 maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8$1 ) );

					 }

				 }

			 }

			 this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			 if ( isNaN( this.boundingSphere.radius ) ) {

				 console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			 }

		 }

	 }

	 computeFaceNormals() {

		 // backwards compatibility

	 }

	 computeTangents() {

		 const index = this.index;
		 const attributes = this.attributes;

		 // based on http://www.terathon.com/code/tangent.html
		 // (per vertex tangents)

		 if ( index === null ||
				attributes.position === undefined ||
				attributes.normal === undefined ||
				attributes.uv === undefined ) {

			 console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			 return;

		 }

		 const indices = index.array;
		 const positions = attributes.position.array;
		 const normals = attributes.normal.array;
		 const uvs = attributes.uv.array;

		 const nVertices = positions.length / 3;

		 if ( attributes.tangent === undefined ) {

			 this.setAttribute( 'tangent', new BufferAttribute$1( new Float32Array( 4 * nVertices ), 4 ) );

		 }

		 const tangents = attributes.tangent.array;

		 const tan1 = [], tan2 = [];

		 for ( let i = 0; i < nVertices; i ++ ) {

			 tan1[ i ] = new Vector3$1();
			 tan2[ i ] = new Vector3$1();

		 }

		 const vA = new Vector3$1(),
			 vB = new Vector3$1(),
			 vC = new Vector3$1(),

			 uvA = new Vector2$1(),
			 uvB = new Vector2$1(),
			 uvC = new Vector2$1(),

			 sdir = new Vector3$1(),
			 tdir = new Vector3$1();

		 function handleTriangle( a, b, c ) {

			 vA.fromArray( positions, a * 3 );
			 vB.fromArray( positions, b * 3 );
			 vC.fromArray( positions, c * 3 );

			 uvA.fromArray( uvs, a * 2 );
			 uvB.fromArray( uvs, b * 2 );
			 uvC.fromArray( uvs, c * 2 );

			 vB.sub( vA );
			 vC.sub( vA );

			 uvB.sub( uvA );
			 uvC.sub( uvA );

			 const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			 // silently ignore degenerate uv triangles having coincident or colinear vertices

			 if ( ! isFinite( r ) ) return;

			 sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			 tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			 tan1[ a ].add( sdir );
			 tan1[ b ].add( sdir );
			 tan1[ c ].add( sdir );

			 tan2[ a ].add( tdir );
			 tan2[ b ].add( tdir );
			 tan2[ c ].add( tdir );

		 }

		 let groups = this.groups;

		 if ( groups.length === 0 ) {

			 groups = [ {
				 start: 0,
				 count: indices.length
			 } ];

		 }

		 for ( let i = 0, il = groups.length; i < il; ++ i ) {

			 const group = groups[ i ];

			 const start = group.start;
			 const count = group.count;

			 for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				 handleTriangle(
					 indices[ j + 0 ],
					 indices[ j + 1 ],
					 indices[ j + 2 ]
				 );

			 }

		 }

		 const tmp = new Vector3$1(), tmp2 = new Vector3$1();
		 const n = new Vector3$1(), n2 = new Vector3$1();

		 function handleVertex( v ) {

			 n.fromArray( normals, v * 3 );
			 n2.copy( n );

			 const t = tan1[ v ];

			 // Gram-Schmidt orthogonalize

			 tmp.copy( t );
			 tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			 // Calculate handedness

			 tmp2.crossVectors( n2, t );
			 const test = tmp2.dot( tan2[ v ] );
			 const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			 tangents[ v * 4 ] = tmp.x;
			 tangents[ v * 4 + 1 ] = tmp.y;
			 tangents[ v * 4 + 2 ] = tmp.z;
			 tangents[ v * 4 + 3 ] = w;

		 }

		 for ( let i = 0, il = groups.length; i < il; ++ i ) {

			 const group = groups[ i ];

			 const start = group.start;
			 const count = group.count;

			 for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				 handleVertex( indices[ j + 0 ] );
				 handleVertex( indices[ j + 1 ] );
				 handleVertex( indices[ j + 2 ] );

			 }

		 }

	 }

	 computeVertexNormals() {

		 const index = this.index;
		 const positionAttribute = this.getAttribute( 'position' );

		 if ( positionAttribute !== undefined ) {

			 let normalAttribute = this.getAttribute( 'normal' );

			 if ( normalAttribute === undefined ) {

				 normalAttribute = new BufferAttribute$1( new Float32Array( positionAttribute.count * 3 ), 3 );
				 this.setAttribute( 'normal', normalAttribute );

			 } else {

				 // reset existing normals to zero

				 for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					 normalAttribute.setXYZ( i, 0, 0, 0 );

				 }

			 }

			 const pA = new Vector3$1(), pB = new Vector3$1(), pC = new Vector3$1();
			 const nA = new Vector3$1(), nB = new Vector3$1(), nC = new Vector3$1();
			 const cb = new Vector3$1(), ab = new Vector3$1();

			 // indexed elements

			 if ( index ) {

				 for ( let i = 0, il = index.count; i < il; i += 3 ) {

					 const vA = index.getX( i + 0 );
					 const vB = index.getX( i + 1 );
					 const vC = index.getX( i + 2 );

					 pA.fromBufferAttribute( positionAttribute, vA );
					 pB.fromBufferAttribute( positionAttribute, vB );
					 pC.fromBufferAttribute( positionAttribute, vC );

					 cb.subVectors( pC, pB );
					 ab.subVectors( pA, pB );
					 cb.cross( ab );

					 nA.fromBufferAttribute( normalAttribute, vA );
					 nB.fromBufferAttribute( normalAttribute, vB );
					 nC.fromBufferAttribute( normalAttribute, vC );

					 nA.add( cb );
					 nB.add( cb );
					 nC.add( cb );

					 normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					 normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					 normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				 }

			 } else {

				 // non-indexed elements (unconnected triangle soup)

				 for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					 pA.fromBufferAttribute( positionAttribute, i + 0 );
					 pB.fromBufferAttribute( positionAttribute, i + 1 );
					 pC.fromBufferAttribute( positionAttribute, i + 2 );

					 cb.subVectors( pC, pB );
					 ab.subVectors( pA, pB );
					 cb.cross( ab );

					 normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					 normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					 normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				 }

			 }

			 this.normalizeNormals();

			 normalAttribute.needsUpdate = true;

		 }

	 }

	 merge( geometry, offset ) {

		 if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			 console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			 return;

		 }

		 if ( offset === undefined ) {

			 offset = 0;

			 console.warn(
				 'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				 + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			 );

		 }

		 const attributes = this.attributes;

		 for ( const key in attributes ) {

			 if ( geometry.attributes[ key ] === undefined ) continue;

			 const attribute1 = attributes[ key ];
			 const attributeArray1 = attribute1.array;

			 const attribute2 = geometry.attributes[ key ];
			 const attributeArray2 = attribute2.array;

			 const attributeOffset = attribute2.itemSize * offset;
			 const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			 for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				 attributeArray1[ j ] = attributeArray2[ i ];

			 }

		 }

		 return this;

	 }

	 normalizeNormals() {

		 const normals = this.attributes.normal;

		 for ( let i = 0, il = normals.count; i < il; i ++ ) {

			 _vector$8$1.fromBufferAttribute( normals, i );

			 _vector$8$1.normalize();

			 normals.setXYZ( i, _vector$8$1.x, _vector$8$1.y, _vector$8$1.z );

		 }

	 }

	 toNonIndexed() {

		 function convertBufferAttribute( attribute, indices ) {

			 const array = attribute.array;
			 const itemSize = attribute.itemSize;
			 const normalized = attribute.normalized;

			 const array2 = new array.constructor( indices.length * itemSize );

			 let index = 0, index2 = 0;

			 for ( let i = 0, l = indices.length; i < l; i ++ ) {

				 if ( attribute.isInterleavedBufferAttribute ) {

					 index = indices[ i ] * attribute.data.stride + attribute.offset;

				 } else {

					 index = indices[ i ] * itemSize;

				 }

				 for ( let j = 0; j < itemSize; j ++ ) {

					 array2[ index2 ++ ] = array[ index ++ ];

				 }

			 }

			 return new BufferAttribute$1( array2, itemSize, normalized );

		 }

		 //

		 if ( this.index === null ) {

			 console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			 return this;

		 }

		 const geometry2 = new BufferGeometry$1();

		 const indices = this.index.array;
		 const attributes = this.attributes;

		 // attributes

		 for ( const name in attributes ) {

			 const attribute = attributes[ name ];

			 const newAttribute = convertBufferAttribute( attribute, indices );

			 geometry2.setAttribute( name, newAttribute );

		 }

		 // morph attributes

		 const morphAttributes = this.morphAttributes;

		 for ( const name in morphAttributes ) {

			 const morphArray = [];
			 const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			 for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				 const attribute = morphAttribute[ i ];

				 const newAttribute = convertBufferAttribute( attribute, indices );

				 morphArray.push( newAttribute );

			 }

			 geometry2.morphAttributes[ name ] = morphArray;

		 }

		 geometry2.morphTargetsRelative = this.morphTargetsRelative;

		 // groups

		 const groups = this.groups;

		 for ( let i = 0, l = groups.length; i < l; i ++ ) {

			 const group = groups[ i ];
			 geometry2.addGroup( group.start, group.count, group.materialIndex );

		 }

		 return geometry2;

	 }

	 toJSON() {

		 const data = {
			 metadata: {
				 version: 4.5,
				 type: 'BufferGeometry',
				 generator: 'BufferGeometry.toJSON'
			 }
		 };

		 // standard BufferGeometry serialization

		 data.uuid = this.uuid;
		 data.type = this.type;
		 if ( this.name !== '' ) data.name = this.name;
		 if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		 if ( this.parameters !== undefined ) {

			 const parameters = this.parameters;

			 for ( const key in parameters ) {

				 if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			 }

			 return data;

		 }

		 // for simplicity the code assumes attributes are not shared across geometries, see #15811

		 data.data = { attributes: {} };

		 const index = this.index;

		 if ( index !== null ) {

			 data.data.index = {
				 type: index.array.constructor.name,
				 array: Array.prototype.slice.call( index.array )
			 };

		 }

		 const attributes = this.attributes;

		 for ( const key in attributes ) {

			 const attribute = attributes[ key ];

			 data.data.attributes[ key ] = attribute.toJSON( data.data );

		 }

		 const morphAttributes = {};
		 let hasMorphAttributes = false;

		 for ( const key in this.morphAttributes ) {

			 const attributeArray = this.morphAttributes[ key ];

			 const array = [];

			 for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				 const attribute = attributeArray[ i ];

				 array.push( attribute.toJSON( data.data ) );

			 }

			 if ( array.length > 0 ) {

				 morphAttributes[ key ] = array;

				 hasMorphAttributes = true;

			 }

		 }

		 if ( hasMorphAttributes ) {

			 data.data.morphAttributes = morphAttributes;
			 data.data.morphTargetsRelative = this.morphTargetsRelative;

		 }

		 const groups = this.groups;

		 if ( groups.length > 0 ) {

			 data.data.groups = JSON.parse( JSON.stringify( groups ) );

		 }

		 const boundingSphere = this.boundingSphere;

		 if ( boundingSphere !== null ) {

			 data.data.boundingSphere = {
				 center: boundingSphere.center.toArray(),
				 radius: boundingSphere.radius
			 };

		 }

		 return data;

	 }

	 clone() {

		 /*
			// Handle primitives

			const parameters = this.parameters;

			if ( parameters !== undefined ) {

			const values = [];

			for ( const key in parameters ) {

			values.push( parameters[ key ] );

			}

			const geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

			}

			return new this.constructor().copy( this );
			*/

		 return new BufferGeometry$1().copy( this );

	 }

	 copy( source ) {

		 // reset

		 this.index = null;
		 this.attributes = {};
		 this.morphAttributes = {};
		 this.groups = [];
		 this.boundingBox = null;
		 this.boundingSphere = null;

		 // used for storing cloned, shared data

		 const data = {};

		 // name

		 this.name = source.name;

		 // index

		 const index = source.index;

		 if ( index !== null ) {

			 this.setIndex( index.clone( data ) );

		 }

		 // attributes

		 const attributes = source.attributes;

		 for ( const name in attributes ) {

			 const attribute = attributes[ name ];
			 this.setAttribute( name, attribute.clone( data ) );

		 }

		 // morph attributes

		 const morphAttributes = source.morphAttributes;

		 for ( const name in morphAttributes ) {

			 const array = [];
			 const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			 for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				 array.push( morphAttribute[ i ].clone( data ) );

			 }

			 this.morphAttributes[ name ] = array;

		 }

		 this.morphTargetsRelative = source.morphTargetsRelative;

		 // groups

		 const groups = source.groups;

		 for ( let i = 0, l = groups.length; i < l; i ++ ) {

			 const group = groups[ i ];
			 this.addGroup( group.start, group.count, group.materialIndex );

		 }

		 // bounding box

		 const boundingBox = source.boundingBox;

		 if ( boundingBox !== null ) {

			 this.boundingBox = boundingBox.clone();

		 }

		 // bounding sphere

		 const boundingSphere = source.boundingSphere;

		 if ( boundingSphere !== null ) {

			 this.boundingSphere = boundingSphere.clone();

		 }

		 // draw range

		 this.drawRange.start = source.drawRange.start;
		 this.drawRange.count = source.drawRange.count;

		 // user data

		 this.userData = source.userData;

		 return this;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

 }

 BufferGeometry$1.prototype.isBufferGeometry = true;

 const _inverseMatrix$2$1 = /*@__PURE__*/ new Matrix4$1();
 const _ray$2$1 = /*@__PURE__*/ new Ray$1();
 const _sphere$3$1 = /*@__PURE__*/ new Sphere$1();

 const _vA$1$1 = /*@__PURE__*/ new Vector3$1();
 const _vB$1$1 = /*@__PURE__*/ new Vector3$1();
 const _vC$1$1 = /*@__PURE__*/ new Vector3$1();

 const _tempA$1 = /*@__PURE__*/ new Vector3$1();
 const _tempB$1 = /*@__PURE__*/ new Vector3$1();
 const _tempC$1 = /*@__PURE__*/ new Vector3$1();

 const _morphA$1 = /*@__PURE__*/ new Vector3$1();
 const _morphB$1 = /*@__PURE__*/ new Vector3$1();
 const _morphC$1 = /*@__PURE__*/ new Vector3$1();

 const _uvA$1$1 = /*@__PURE__*/ new Vector2$1();
 const _uvB$1$1 = /*@__PURE__*/ new Vector2$1();
 const _uvC$1$1 = /*@__PURE__*/ new Vector2$1();

 const _intersectionPoint$1 = /*@__PURE__*/ new Vector3$1();
 const _intersectionPointWorld$1 = /*@__PURE__*/ new Vector3$1();

 class Mesh$1 extends Object3D$1 {

	 constructor( geometry = new BufferGeometry$1(), material = new MeshBasicMaterial$1() ) {

		 super();

		 this.type = 'Mesh';

		 this.geometry = geometry;
		 this.material = material;

		 this.updateMorphTargets();

	 }

	 copy( source ) {

		 super.copy( source );

		 if ( source.morphTargetInfluences !== undefined ) {

			 this.morphTargetInfluences = source.morphTargetInfluences.slice();

		 }

		 if ( source.morphTargetDictionary !== undefined ) {

			 this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		 }

		 this.material = source.material;
		 this.geometry = source.geometry;

		 return this;

	 }

	 updateMorphTargets() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 const morphAttributes = geometry.morphAttributes;
			 const keys = Object.keys( morphAttributes );

			 if ( keys.length > 0 ) {

				 const morphAttribute = morphAttributes[ keys[ 0 ] ];

				 if ( morphAttribute !== undefined ) {

					 this.morphTargetInfluences = [];
					 this.morphTargetDictionary = {};

					 for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						 const name = morphAttribute[ m ].name || String( m );

						 this.morphTargetInfluences.push( 0 );
						 this.morphTargetDictionary[ name ] = m;

					 }

				 }

			 }

		 } else {

			 const morphTargets = geometry.morphTargets;

			 if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				 console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			 }

		 }

	 }

	 raycast( raycaster, intersects ) {

		 const geometry = this.geometry;
		 const material = this.material;
		 const matrixWorld = this.matrixWorld;

		 if ( material === undefined ) return;

		 // Checking boundingSphere distance to ray

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere$3$1.copy( geometry.boundingSphere );
		 _sphere$3$1.applyMatrix4( matrixWorld );

		 if ( raycaster.ray.intersectsSphere( _sphere$3$1 ) === false ) return;

		 //

		 _inverseMatrix$2$1.copy( matrixWorld ).invert();
		 _ray$2$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2$1 );

		 // Check boundingBox before continuing

		 if ( geometry.boundingBox !== null ) {

			 if ( _ray$2$1.intersectsBox( geometry.boundingBox ) === false ) return;

		 }

		 let intersection;

		 if ( geometry.isBufferGeometry ) {

			 const index = geometry.index;
			 const position = geometry.attributes.position;
			 const morphPosition = geometry.morphAttributes.position;
			 const morphTargetsRelative = geometry.morphTargetsRelative;
			 const uv = geometry.attributes.uv;
			 const uv2 = geometry.attributes.uv2;
			 const groups = geometry.groups;
			 const drawRange = geometry.drawRange;

			 if ( index !== null ) {

				 // indexed buffer geometry

				 if ( Array.isArray( material ) ) {

					 for ( let i = 0, il = groups.length; i < il; i ++ ) {

						 const group = groups[ i ];
						 const groupMaterial = material[ group.materialIndex ];

						 const start = Math.max( group.start, drawRange.start );
						 const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						 for ( let j = start, jl = end; j < jl; j += 3 ) {

							 const a = index.getX( j );
							 const b = index.getX( j + 1 );
							 const c = index.getX( j + 2 );

							 intersection = checkBufferGeometryIntersection$1( this, groupMaterial, raycaster, _ray$2$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							 if ( intersection ) {

								 intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								 intersection.face.materialIndex = group.materialIndex;
								 intersects.push( intersection );

							 }

						 }

					 }

				 } else {

					 const start = Math.max( 0, drawRange.start );
					 const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					 for ( let i = start, il = end; i < il; i += 3 ) {

						 const a = index.getX( i );
						 const b = index.getX( i + 1 );
						 const c = index.getX( i + 2 );

						 intersection = checkBufferGeometryIntersection$1( this, material, raycaster, _ray$2$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						 if ( intersection ) {

							 intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							 intersects.push( intersection );

						 }

					 }

				 }

			 } else if ( position !== undefined ) {

				 // non-indexed buffer geometry

				 if ( Array.isArray( material ) ) {

					 for ( let i = 0, il = groups.length; i < il; i ++ ) {

						 const group = groups[ i ];
						 const groupMaterial = material[ group.materialIndex ];

						 const start = Math.max( group.start, drawRange.start );
						 const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						 for ( let j = start, jl = end; j < jl; j += 3 ) {

							 const a = j;
							 const b = j + 1;
							 const c = j + 2;

							 intersection = checkBufferGeometryIntersection$1( this, groupMaterial, raycaster, _ray$2$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							 if ( intersection ) {

								 intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								 intersection.face.materialIndex = group.materialIndex;
								 intersects.push( intersection );

							 }

						 }

					 }

				 } else {

					 const start = Math.max( 0, drawRange.start );
					 const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					 for ( let i = start, il = end; i < il; i += 3 ) {

						 const a = i;
						 const b = i + 1;
						 const c = i + 2;

						 intersection = checkBufferGeometryIntersection$1( this, material, raycaster, _ray$2$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						 if ( intersection ) {

							 intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							 intersects.push( intersection );

						 }

					 }

				 }

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

	 }

 }

 Mesh$1.prototype.isMesh = true;

 function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

	 let intersect;

	 if ( material.side === BackSide$1 ) {

		 intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	 } else {

		 intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide$1, point );

	 }

	 if ( intersect === null ) return null;

	 _intersectionPointWorld$1.copy( point );
	 _intersectionPointWorld$1.applyMatrix4( object.matrixWorld );

	 const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld$1 );

	 if ( distance < raycaster.near || distance > raycaster.far ) return null;

	 return {
		 distance: distance,
		 point: _intersectionPointWorld$1.clone(),
		 object: object
	 };

 }

 function checkBufferGeometryIntersection$1( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	 _vA$1$1.fromBufferAttribute( position, a );
	 _vB$1$1.fromBufferAttribute( position, b );
	 _vC$1$1.fromBufferAttribute( position, c );

	 const morphInfluences = object.morphTargetInfluences;

	 if ( material.morphTargets && morphPosition && morphInfluences ) {

		 _morphA$1.set( 0, 0, 0 );
		 _morphB$1.set( 0, 0, 0 );
		 _morphC$1.set( 0, 0, 0 );

		 for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			 const influence = morphInfluences[ i ];
			 const morphAttribute = morphPosition[ i ];

			 if ( influence === 0 ) continue;

			 _tempA$1.fromBufferAttribute( morphAttribute, a );
			 _tempB$1.fromBufferAttribute( morphAttribute, b );
			 _tempC$1.fromBufferAttribute( morphAttribute, c );

			 if ( morphTargetsRelative ) {

				 _morphA$1.addScaledVector( _tempA$1, influence );
				 _morphB$1.addScaledVector( _tempB$1, influence );
				 _morphC$1.addScaledVector( _tempC$1, influence );

			 } else {

				 _morphA$1.addScaledVector( _tempA$1.sub( _vA$1$1 ), influence );
				 _morphB$1.addScaledVector( _tempB$1.sub( _vB$1$1 ), influence );
				 _morphC$1.addScaledVector( _tempC$1.sub( _vC$1$1 ), influence );

			 }

		 }

		 _vA$1$1.add( _morphA$1 );
		 _vB$1$1.add( _morphB$1 );
		 _vC$1$1.add( _morphC$1 );

	 }

	 if ( object.isSkinnedMesh ) {

		 object.boneTransform( a, _vA$1$1 );
		 object.boneTransform( b, _vB$1$1 );
		 object.boneTransform( c, _vC$1$1 );

	 }

	 const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1$1, _vB$1$1, _vC$1$1, _intersectionPoint$1 );

	 if ( intersection ) {

		 if ( uv ) {

			 _uvA$1$1.fromBufferAttribute( uv, a );
			 _uvB$1$1.fromBufferAttribute( uv, b );
			 _uvC$1$1.fromBufferAttribute( uv, c );

			 intersection.uv = Triangle$1.getUV( _intersectionPoint$1, _vA$1$1, _vB$1$1, _vC$1$1, _uvA$1$1, _uvB$1$1, _uvC$1$1, new Vector2$1() );

		 }

		 if ( uv2 ) {

			 _uvA$1$1.fromBufferAttribute( uv2, a );
			 _uvB$1$1.fromBufferAttribute( uv2, b );
			 _uvC$1$1.fromBufferAttribute( uv2, c );

			 intersection.uv2 = Triangle$1.getUV( _intersectionPoint$1, _vA$1$1, _vB$1$1, _vC$1$1, _uvA$1$1, _uvB$1$1, _uvC$1$1, new Vector2$1() );

		 }

		 const face = {
			 a: a,
			 b: b,
			 c: c,
			 normal: new Vector3$1(),
			 materialIndex: 0
		 };

		 Triangle$1.getNormal( _vA$1$1, _vB$1$1, _vC$1$1, face.normal );

		 intersection.face = face;

	 }

	 return intersection;

 }

 class BoxGeometry$1 extends BufferGeometry$1 {

	 constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		 super();

		 this.type = 'BoxGeometry';

		 this.parameters = {
			 width: width,
			 height: height,
			 depth: depth,
			 widthSegments: widthSegments,
			 heightSegments: heightSegments,
			 depthSegments: depthSegments
		 };

		 const scope = this;

		 // segments

		 widthSegments = Math.floor( widthSegments );
		 heightSegments = Math.floor( heightSegments );
		 depthSegments = Math.floor( depthSegments );

		 // buffers

		 const indices = [];
		 const vertices = [];
		 const normals = [];
		 const uvs = [];

		 // helper variables

		 let numberOfVertices = 0;
		 let groupStart = 0;

		 // build each side of the box geometry

		 buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		 buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		 buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		 buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		 buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		 buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		 // build geometry

		 this.setIndex( indices );
		 this.setAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
		 this.setAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

		 function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			 const segmentWidth = width / gridX;
			 const segmentHeight = height / gridY;

			 const widthHalf = width / 2;
			 const heightHalf = height / 2;
			 const depthHalf = depth / 2;

			 const gridX1 = gridX + 1;
			 const gridY1 = gridY + 1;

			 let vertexCounter = 0;
			 let groupCount = 0;

			 const vector = new Vector3$1();

			 // generate vertices, normals and uvs

			 for ( let iy = 0; iy < gridY1; iy ++ ) {

				 const y = iy * segmentHeight - heightHalf;

				 for ( let ix = 0; ix < gridX1; ix ++ ) {

					 const x = ix * segmentWidth - widthHalf;

					 // set values to correct vector component

					 vector[ u ] = x * udir;
					 vector[ v ] = y * vdir;
					 vector[ w ] = depthHalf;

					 // now apply vector to vertex buffer

					 vertices.push( vector.x, vector.y, vector.z );

					 // set values to correct vector component

					 vector[ u ] = 0;
					 vector[ v ] = 0;
					 vector[ w ] = depth > 0 ? 1 : - 1;

					 // now apply vector to normal buffer

					 normals.push( vector.x, vector.y, vector.z );

					 // uvs

					 uvs.push( ix / gridX );
					 uvs.push( 1 - ( iy / gridY ) );

					 // counters

					 vertexCounter += 1;

				 }

			 }

			 // indices

			 // 1. you need three indices to draw a single face
			 // 2. a single segment consists of two faces
			 // 3. so we need to generate six (2*3) indices per segment

			 for ( let iy = 0; iy < gridY; iy ++ ) {

				 for ( let ix = 0; ix < gridX; ix ++ ) {

					 const a = numberOfVertices + ix + gridX1 * iy;
					 const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					 const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					 const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					 // faces

					 indices.push( a, b, d );
					 indices.push( b, c, d );

					 // increase counter

					 groupCount += 6;

				 }

			 }

			 // add a group to the geometry. this will ensure multi material support

			 scope.addGroup( groupStart, groupCount, materialIndex );

			 // calculate new start value for groups

			 groupStart += groupCount;

			 // update total number of vertices

			 numberOfVertices += vertexCounter;

		 }

	 }

	 static fromJSON( data ) {

		 return new BoxGeometry$1( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	 }

 }

 /**
	* Uniform Utilities
	*/

 function cloneUniforms$1( src ) {

	 const dst = {};

	 for ( const u in src ) {

		 dst[ u ] = {};

		 for ( const p in src[ u ] ) {

			 const property = src[ u ][ p ];

			 if ( property && ( property.isColor ||
				 property.isMatrix3 || property.isMatrix4 ||
				 property.isVector2 || property.isVector3 || property.isVector4 ||
				 property.isTexture || property.isQuaternion ) ) {

				 dst[ u ][ p ] = property.clone();

			 } else if ( Array.isArray( property ) ) {

				 dst[ u ][ p ] = property.slice();

			 } else {

				 dst[ u ][ p ] = property;

			 }

		 }

	 }

	 return dst;

 }

 function mergeUniforms$1( uniforms ) {

	 const merged = {};

	 for ( let u = 0; u < uniforms.length; u ++ ) {

		 const tmp = cloneUniforms$1( uniforms[ u ] );

		 for ( const p in tmp ) {

			 merged[ p ] = tmp[ p ];

		 }

	 }

	 return merged;

 }

 // Legacy

 const UniformsUtils$1 = { clone: cloneUniforms$1, merge: mergeUniforms$1 };

 var default_vertex$1 = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

 var default_fragment$1 = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

 /**
	* parameters = {
	*  defines: { "label" : "value" },
	*  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	*
	*  fragmentShader: <string>,
	*  vertexShader: <string>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  lights: <bool>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	* }
	*/

 class ShaderMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'ShaderMaterial';

		 this.defines = {};
		 this.uniforms = {};

		 this.vertexShader = default_vertex$1;
		 this.fragmentShader = default_fragment$1;

		 this.linewidth = 1;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;

		 this.fog = false; // set to use scene fog
		 this.lights = false; // set to use scene lights
		 this.clipping = false; // set to use user-defined clipping planes

		 this.morphTargets = false; // set to use morph targets
		 this.morphNormals = false; // set to use morph normals

		 this.extensions = {
			 derivatives: false, // set to use derivatives
			 fragDepth: false, // set to use fragment depth values
			 drawBuffers: false, // set to use draw buffers
			 shaderTextureLOD: false // set to use shader texture LOD
		 };

		 // When rendered geometry doesn't include these attributes but the material does,
		 // use these default values in WebGL. This avoids errors when buffer data is missing.
		 this.defaultAttributeValues = {
			 'color': [ 1, 1, 1 ],
			 'uv': [ 0, 0 ],
			 'uv2': [ 0, 0 ]
		 };

		 this.index0AttributeName = undefined;
		 this.uniformsNeedUpdate = false;

		 this.glslVersion = null;

		 if ( parameters !== undefined ) {

			 if ( parameters.attributes !== undefined ) {

				 console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			 }

			 this.setValues( parameters );

		 }

	 }

	 copy( source ) {

		 super.copy( source );

		 this.fragmentShader = source.fragmentShader;
		 this.vertexShader = source.vertexShader;

		 this.uniforms = cloneUniforms$1( source.uniforms );

		 this.defines = Object.assign( {}, source.defines );

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;

		 this.lights = source.lights;
		 this.clipping = source.clipping;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.extensions = Object.assign( {}, source.extensions );

		 this.glslVersion = source.glslVersion;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.glslVersion = this.glslVersion;
		 data.uniforms = {};

		 for ( const name in this.uniforms ) {

			 const uniform = this.uniforms[ name ];
			 const value = uniform.value;

			 if ( value && value.isTexture ) {

				 data.uniforms[ name ] = {
					 type: 't',
					 value: value.toJSON( meta ).uuid
				 };

			 } else if ( value && value.isColor ) {

				 data.uniforms[ name ] = {
					 type: 'c',
					 value: value.getHex()
				 };

			 } else if ( value && value.isVector2 ) {

				 data.uniforms[ name ] = {
					 type: 'v2',
					 value: value.toArray()
				 };

			 } else if ( value && value.isVector3 ) {

				 data.uniforms[ name ] = {
					 type: 'v3',
					 value: value.toArray()
				 };

			 } else if ( value && value.isVector4 ) {

				 data.uniforms[ name ] = {
					 type: 'v4',
					 value: value.toArray()
				 };

			 } else if ( value && value.isMatrix3 ) {

				 data.uniforms[ name ] = {
					 type: 'm3',
					 value: value.toArray()
				 };

			 } else if ( value && value.isMatrix4 ) {

				 data.uniforms[ name ] = {
					 type: 'm4',
					 value: value.toArray()
				 };

			 } else {

				 data.uniforms[ name ] = {
					 value: value
				 };

				 // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			 }

		 }

		 if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		 data.vertexShader = this.vertexShader;
		 data.fragmentShader = this.fragmentShader;

		 const extensions = {};

		 for ( const key in this.extensions ) {

			 if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		 }

		 if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		 return data;

	 }

 }

 ShaderMaterial$1.prototype.isShaderMaterial = true;

 class Camera$1 extends Object3D$1 {

	 constructor() {

		 super();

		 this.type = 'Camera';

		 this.matrixWorldInverse = new Matrix4$1();

		 this.projectionMatrix = new Matrix4$1();
		 this.projectionMatrixInverse = new Matrix4$1();

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 this.matrixWorldInverse.copy( source.matrixWorldInverse );

		 this.projectionMatrix.copy( source.projectionMatrix );
		 this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		 return this;

	 }

	 getWorldDirection( target ) {

		 this.updateWorldMatrix( true, false );

		 const e = this.matrixWorld.elements;

		 return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	 }

	 updateMatrixWorld( force ) {

		 super.updateMatrixWorld( force );

		 this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	 }

	 updateWorldMatrix( updateParents, updateChildren ) {

		 super.updateWorldMatrix( updateParents, updateChildren );

		 this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 Camera$1.prototype.isCamera = true;

 class PerspectiveCamera$1 extends Camera$1 {

	 constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		 super();

		 this.type = 'PerspectiveCamera';

		 this.fov = fov;
		 this.zoom = 1;

		 this.near = near;
		 this.far = far;
		 this.focus = 10;

		 this.aspect = aspect;
		 this.view = null;

		 this.filmGauge = 35;	// width of the film (default in millimeters)
		 this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		 this.updateProjectionMatrix();

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 this.fov = source.fov;
		 this.zoom = source.zoom;

		 this.near = source.near;
		 this.far = source.far;
		 this.focus = source.focus;

		 this.aspect = source.aspect;
		 this.view = source.view === null ? null : Object.assign( {}, source.view );

		 this.filmGauge = source.filmGauge;
		 this.filmOffset = source.filmOffset;

		 return this;

	 }

	 /**
		* Sets the FOV by focal length in respect to the current .filmGauge.
		*
		* The default film gauge is 35, so that the focal length can be specified for
		* a 35mm (full frame) camera.
		*
		* Values for focal length and film gauge must have the same unit.
		*/
	 setFocalLength( focalLength ) {

		 /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		 const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		 this.fov = RAD2DEG$1 * 2 * Math.atan( vExtentSlope );
		 this.updateProjectionMatrix();

	 }

	 /**
		* Calculates the focal length from the current .fov and .filmGauge.
		*/
	 getFocalLength() {

		 const vExtentSlope = Math.tan( DEG2RAD$1 * 0.5 * this.fov );

		 return 0.5 * this.getFilmHeight() / vExtentSlope;

	 }

	 getEffectiveFOV() {

		 return RAD2DEG$1 * 2 * Math.atan(
			 Math.tan( DEG2RAD$1 * 0.5 * this.fov ) / this.zoom );

	 }

	 getFilmWidth() {

		 // film not completely covered in portrait format (aspect < 1)
		 return this.filmGauge * Math.min( this.aspect, 1 );

	 }

	 getFilmHeight() {

		 // film not completely covered in landscape format (aspect > 1)
		 return this.filmGauge / Math.max( this.aspect, 1 );

	 }

	 /**
		* Sets an offset in a larger frustum. This is useful for multi-window or
		* multi-monitor/multi-machine setups.
		*
		* For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		* the monitors are in grid like this
		*
		*   +---+---+---+
		*   | A | B | C |
		*   +---+---+---+
		*   | D | E | F |
		*   +---+---+---+
		*
		* then for each monitor you would call it like this
		*
		*   const w = 1920;
		*   const h = 1080;
		*   const fullWidth = w * 3;
		*   const fullHeight = h * 2;
		*
		*   --A--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		*   --B--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		*   --C--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		*   --D--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		*   --E--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		*   --F--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		*
		*   Note there is no reason monitors have to be the same size or in a grid.
		*/
	 setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		 this.aspect = fullWidth / fullHeight;

		 if ( this.view === null ) {

			 this.view = {
				 enabled: true,
				 fullWidth: 1,
				 fullHeight: 1,
				 offsetX: 0,
				 offsetY: 0,
				 width: 1,
				 height: 1
			 };

		 }

		 this.view.enabled = true;
		 this.view.fullWidth = fullWidth;
		 this.view.fullHeight = fullHeight;
		 this.view.offsetX = x;
		 this.view.offsetY = y;
		 this.view.width = width;
		 this.view.height = height;

		 this.updateProjectionMatrix();

	 }

	 clearViewOffset() {

		 if ( this.view !== null ) {

			 this.view.enabled = false;

		 }

		 this.updateProjectionMatrix();

	 }

	 updateProjectionMatrix() {

		 const near = this.near;
		 let top = near * Math.tan( DEG2RAD$1 * 0.5 * this.fov ) / this.zoom;
		 let height = 2 * top;
		 let width = this.aspect * height;
		 let left = - 0.5 * width;
		 const view = this.view;

		 if ( this.view !== null && this.view.enabled ) {

			 const fullWidth = view.fullWidth,
				 fullHeight = view.fullHeight;

			 left += view.offsetX * width / fullWidth;
			 top -= view.offsetY * height / fullHeight;
			 width *= view.width / fullWidth;
			 height *= view.height / fullHeight;

		 }

		 const skew = this.filmOffset;
		 if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		 this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		 this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.fov = this.fov;
		 data.object.zoom = this.zoom;

		 data.object.near = this.near;
		 data.object.far = this.far;
		 data.object.focus = this.focus;

		 data.object.aspect = this.aspect;

		 if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		 data.object.filmGauge = this.filmGauge;
		 data.object.filmOffset = this.filmOffset;

		 return data;

	 }

 }

 PerspectiveCamera$1.prototype.isPerspectiveCamera = true;

 const fov$1 = 90, aspect$1 = 1;

 class CubeCamera$1 extends Object3D$1 {

	 constructor( near, far, renderTarget ) {

		 super();

		 this.type = 'CubeCamera';

		 if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			 console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			 return;

		 }

		 this.renderTarget = renderTarget;

		 const cameraPX = new PerspectiveCamera$1( fov$1, aspect$1, near, far );
		 cameraPX.layers = this.layers;
		 cameraPX.up.set( 0, - 1, 0 );
		 cameraPX.lookAt( new Vector3$1( 1, 0, 0 ) );
		 this.add( cameraPX );

		 const cameraNX = new PerspectiveCamera$1( fov$1, aspect$1, near, far );
		 cameraNX.layers = this.layers;
		 cameraNX.up.set( 0, - 1, 0 );
		 cameraNX.lookAt( new Vector3$1( - 1, 0, 0 ) );
		 this.add( cameraNX );

		 const cameraPY = new PerspectiveCamera$1( fov$1, aspect$1, near, far );
		 cameraPY.layers = this.layers;
		 cameraPY.up.set( 0, 0, 1 );
		 cameraPY.lookAt( new Vector3$1( 0, 1, 0 ) );
		 this.add( cameraPY );

		 const cameraNY = new PerspectiveCamera$1( fov$1, aspect$1, near, far );
		 cameraNY.layers = this.layers;
		 cameraNY.up.set( 0, 0, - 1 );
		 cameraNY.lookAt( new Vector3$1( 0, - 1, 0 ) );
		 this.add( cameraNY );

		 const cameraPZ = new PerspectiveCamera$1( fov$1, aspect$1, near, far );
		 cameraPZ.layers = this.layers;
		 cameraPZ.up.set( 0, - 1, 0 );
		 cameraPZ.lookAt( new Vector3$1( 0, 0, 1 ) );
		 this.add( cameraPZ );

		 const cameraNZ = new PerspectiveCamera$1( fov$1, aspect$1, near, far );
		 cameraNZ.layers = this.layers;
		 cameraNZ.up.set( 0, - 1, 0 );
		 cameraNZ.lookAt( new Vector3$1( 0, 0, - 1 ) );
		 this.add( cameraNZ );

	 }

	 update( renderer, scene ) {

		 if ( this.parent === null ) this.updateMatrixWorld();

		 const renderTarget = this.renderTarget;

		 const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		 const currentXrEnabled = renderer.xr.enabled;
		 const currentRenderTarget = renderer.getRenderTarget();

		 renderer.xr.enabled = false;

		 const generateMipmaps = renderTarget.texture.generateMipmaps;

		 renderTarget.texture.generateMipmaps = false;

		 renderer.setRenderTarget( renderTarget, 0 );
		 renderer.render( scene, cameraPX );

		 renderer.setRenderTarget( renderTarget, 1 );
		 renderer.render( scene, cameraNX );

		 renderer.setRenderTarget( renderTarget, 2 );
		 renderer.render( scene, cameraPY );

		 renderer.setRenderTarget( renderTarget, 3 );
		 renderer.render( scene, cameraNY );

		 renderer.setRenderTarget( renderTarget, 4 );
		 renderer.render( scene, cameraPZ );

		 renderTarget.texture.generateMipmaps = generateMipmaps;

		 renderer.setRenderTarget( renderTarget, 5 );
		 renderer.render( scene, cameraNZ );

		 renderer.setRenderTarget( currentRenderTarget );

		 renderer.xr.enabled = currentXrEnabled;

	 }

 }

 class CubeTexture$1 extends Texture$1 {

	 constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		 images = images !== undefined ? images : [];
		 mapping = mapping !== undefined ? mapping : CubeReflectionMapping$1;
		 format = format !== undefined ? format : RGBFormat$1;

		 super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		 // Why CubeTexture._needsFlipEnvMap is necessary:
		 //
		 // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		 // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		 // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		 // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		 // and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
		 // when using WebGLCubeRenderTarget.texture as a cube texture.

		 this._needsFlipEnvMap = true;

		 this.flipY = false;

	 }

	 get images() {

		 return this.image;

	 }

	 set images( value ) {

		 this.image = value;

	 }

 }

 CubeTexture$1.prototype.isCubeTexture = true;

 class WebGLCubeRenderTarget$1 extends WebGLRenderTarget$1 {

	 constructor( size, options, dummy ) {

		 if ( Number.isInteger( options ) ) {

			 console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

			 options = dummy;

		 }

		 super( size, size, options );

		 options = options || {};

		 this.texture = new CubeTexture$1( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		 this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		 this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter$1;

		 this.texture._needsFlipEnvMap = false;

	 }

	 fromEquirectangularTexture( renderer, texture ) {

		 this.texture.type = texture.type;
		 this.texture.format = RGBAFormat$1; // see #18859
		 this.texture.encoding = texture.encoding;

		 this.texture.generateMipmaps = texture.generateMipmaps;
		 this.texture.minFilter = texture.minFilter;
		 this.texture.magFilter = texture.magFilter;

		 const shader = {

			 uniforms: {
				 tEquirect: { value: null },
			 },

			 vertexShader: /* glsl */`

				 varying vec3 vWorldDirection;

				 vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					 return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				 }

				 void main() {

					 vWorldDirection = transformDirection( position, modelMatrix );

					 #include <begin_vertex>
					 #include <project_vertex>

				 }
			 `,

			 fragmentShader: /* glsl */`

				 uniform sampler2D tEquirect;

				 varying vec3 vWorldDirection;

				 #include <common>

				 void main() {

					 vec3 direction = normalize( vWorldDirection );

					 vec2 sampleUV = equirectUv( direction );

					 gl_FragColor = texture2D( tEquirect, sampleUV );

				 }
			 `
		 };

		 const geometry = new BoxGeometry$1( 5, 5, 5 );

		 const material = new ShaderMaterial$1( {

			 name: 'CubemapFromEquirect',

			 uniforms: cloneUniforms$1( shader.uniforms ),
			 vertexShader: shader.vertexShader,
			 fragmentShader: shader.fragmentShader,
			 side: BackSide$1,
			 blending: NoBlending$1

		 } );

		 material.uniforms.tEquirect.value = texture;

		 const mesh = new Mesh$1( geometry, material );

		 const currentMinFilter = texture.minFilter;

		 // Avoid blurred poles
		 if ( texture.minFilter === LinearMipmapLinearFilter$1 ) texture.minFilter = LinearFilter$1;

		 const camera = new CubeCamera$1( 1, 10, this );
		 camera.update( renderer, mesh );

		 texture.minFilter = currentMinFilter;

		 mesh.geometry.dispose();
		 mesh.material.dispose();

		 return this;

	 }

	 clear( renderer, color, depth, stencil ) {

		 const currentRenderTarget = renderer.getRenderTarget();

		 for ( let i = 0; i < 6; i ++ ) {

			 renderer.setRenderTarget( this, i );

			 renderer.clear( color, depth, stencil );

		 }

		 renderer.setRenderTarget( currentRenderTarget );

	 }

 }

 WebGLCubeRenderTarget$1.prototype.isWebGLCubeRenderTarget = true;

 const _vector1$1 = /*@__PURE__*/ new Vector3$1();
 const _vector2$2 = /*@__PURE__*/ new Vector3$1();
 const _normalMatrix$1 = /*@__PURE__*/ new Matrix3$1();

 class Plane$1 {

	 constructor( normal = new Vector3$1( 1, 0, 0 ), constant = 0 ) {

		 // normal is assumed to be normalized

		 this.normal = normal;
		 this.constant = constant;

	 }

	 set( normal, constant ) {

		 this.normal.copy( normal );
		 this.constant = constant;

		 return this;

	 }

	 setComponents( x, y, z, w ) {

		 this.normal.set( x, y, z );
		 this.constant = w;

		 return this;

	 }

	 setFromNormalAndCoplanarPoint( normal, point ) {

		 this.normal.copy( normal );
		 this.constant = - point.dot( this.normal );

		 return this;

	 }

	 setFromCoplanarPoints( a, b, c ) {

		 const normal = _vector1$1.subVectors( c, b ).cross( _vector2$2.subVectors( a, b ) ).normalize();

		 // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		 this.setFromNormalAndCoplanarPoint( normal, a );

		 return this;

	 }

	 copy( plane ) {

		 this.normal.copy( plane.normal );
		 this.constant = plane.constant;

		 return this;

	 }

	 normalize() {

		 // Note: will lead to a divide by zero if the plane is invalid.

		 const inverseNormalLength = 1.0 / this.normal.length();
		 this.normal.multiplyScalar( inverseNormalLength );
		 this.constant *= inverseNormalLength;

		 return this;

	 }

	 negate() {

		 this.constant *= - 1;
		 this.normal.negate();

		 return this;

	 }

	 distanceToPoint( point ) {

		 return this.normal.dot( point ) + this.constant;

	 }

	 distanceToSphere( sphere ) {

		 return this.distanceToPoint( sphere.center ) - sphere.radius;

	 }

	 projectPoint( point, target ) {

		 return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	 }

	 intersectLine( line, target ) {

		 const direction = line.delta( _vector1$1 );

		 const denominator = this.normal.dot( direction );

		 if ( denominator === 0 ) {

			 // line is coplanar, return origin
			 if ( this.distanceToPoint( line.start ) === 0 ) {

				 return target.copy( line.start );

			 }

			 // Unsure if this is the correct method to handle this case.
			 return null;

		 }

		 const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		 if ( t < 0 || t > 1 ) {

			 return null;

		 }

		 return target.copy( direction ).multiplyScalar( t ).add( line.start );

	 }

	 intersectsLine( line ) {

		 // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		 const startSign = this.distanceToPoint( line.start );
		 const endSign = this.distanceToPoint( line.end );

		 return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	 }

	 intersectsBox( box ) {

		 return box.intersectsPlane( this );

	 }

	 intersectsSphere( sphere ) {

		 return sphere.intersectsPlane( this );

	 }

	 coplanarPoint( target ) {

		 return target.copy( this.normal ).multiplyScalar( - this.constant );

	 }

	 applyMatrix4( matrix, optionalNormalMatrix ) {

		 const normalMatrix = optionalNormalMatrix || _normalMatrix$1.getNormalMatrix( matrix );

		 const referencePoint = this.coplanarPoint( _vector1$1 ).applyMatrix4( matrix );

		 const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		 this.constant = - referencePoint.dot( normal );

		 return this;

	 }

	 translate( offset ) {

		 this.constant -= offset.dot( this.normal );

		 return this;

	 }

	 equals( plane ) {

		 return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 Plane$1.prototype.isPlane = true;

 const _sphere$2$1 = /*@__PURE__*/ new Sphere$1();
 const _vector$7$1 = /*@__PURE__*/ new Vector3$1();

 class Frustum$1 {

	 constructor( p0 = new Plane$1(), p1 = new Plane$1(), p2 = new Plane$1(), p3 = new Plane$1(), p4 = new Plane$1(), p5 = new Plane$1() ) {

		 this.planes = [ p0, p1, p2, p3, p4, p5 ];

	 }

	 set( p0, p1, p2, p3, p4, p5 ) {

		 const planes = this.planes;

		 planes[ 0 ].copy( p0 );
		 planes[ 1 ].copy( p1 );
		 planes[ 2 ].copy( p2 );
		 planes[ 3 ].copy( p3 );
		 planes[ 4 ].copy( p4 );
		 planes[ 5 ].copy( p5 );

		 return this;

	 }

	 copy( frustum ) {

		 const planes = this.planes;

		 for ( let i = 0; i < 6; i ++ ) {

			 planes[ i ].copy( frustum.planes[ i ] );

		 }

		 return this;

	 }

	 setFromProjectionMatrix( m ) {

		 const planes = this.planes;
		 const me = m.elements;
		 const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		 const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		 const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		 const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		 planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		 planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		 planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		 planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		 planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		 planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		 return this;

	 }

	 intersectsObject( object ) {

		 const geometry = object.geometry;

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere$2$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		 return this.intersectsSphere( _sphere$2$1 );

	 }

	 intersectsSprite( sprite ) {

		 _sphere$2$1.center.set( 0, 0, 0 );
		 _sphere$2$1.radius = 0.7071067811865476;
		 _sphere$2$1.applyMatrix4( sprite.matrixWorld );

		 return this.intersectsSphere( _sphere$2$1 );

	 }

	 intersectsSphere( sphere ) {

		 const planes = this.planes;
		 const center = sphere.center;
		 const negRadius = - sphere.radius;

		 for ( let i = 0; i < 6; i ++ ) {

			 const distance = planes[ i ].distanceToPoint( center );

			 if ( distance < negRadius ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 intersectsBox( box ) {

		 const planes = this.planes;

		 for ( let i = 0; i < 6; i ++ ) {

			 const plane = planes[ i ];

			 // corner at max distance

			 _vector$7$1.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			 _vector$7$1.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			 _vector$7$1.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			 if ( plane.distanceToPoint( _vector$7$1 ) < 0 ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 containsPoint( point ) {

		 const planes = this.planes;

		 for ( let i = 0; i < 6; i ++ ) {

			 if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 function WebGLAnimation$1() {

	 let context = null;
	 let isAnimating = false;
	 let animationLoop = null;
	 let requestId = null;

	 function onAnimationFrame( time, frame ) {

		 animationLoop( time, frame );

		 requestId = context.requestAnimationFrame( onAnimationFrame );

	 }

	 return {

		 start: function () {

			 if ( isAnimating === true ) return;
			 if ( animationLoop === null ) return;

			 requestId = context.requestAnimationFrame( onAnimationFrame );

			 isAnimating = true;

		 },

		 stop: function () {

			 context.cancelAnimationFrame( requestId );

			 isAnimating = false;

		 },

		 setAnimationLoop: function ( callback ) {

			 animationLoop = callback;

		 },

		 setContext: function ( value ) {

			 context = value;

		 }

	 };

 }

 function WebGLAttributes$1( gl, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 const buffers = new WeakMap();

	 function createBuffer( attribute, bufferType ) {

		 const array = attribute.array;
		 const usage = attribute.usage;

		 const buffer = gl.createBuffer();

		 gl.bindBuffer( bufferType, buffer );
		 gl.bufferData( bufferType, array, usage );

		 attribute.onUploadCallback();

		 let type = 5126;

		 if ( array instanceof Float32Array ) {

			 type = 5126;

		 } else if ( array instanceof Float64Array ) {

			 console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		 } else if ( array instanceof Uint16Array ) {

			 if ( attribute.isFloat16BufferAttribute ) {

				 if ( isWebGL2 ) {

					 type = 5131;

				 } else {

					 console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				 }

			 } else {

				 type = 5123;

			 }

		 } else if ( array instanceof Int16Array ) {

			 type = 5122;

		 } else if ( array instanceof Uint32Array ) {

			 type = 5125;

		 } else if ( array instanceof Int32Array ) {

			 type = 5124;

		 } else if ( array instanceof Int8Array ) {

			 type = 5120;

		 } else if ( array instanceof Uint8Array ) {

			 type = 5121;

		 } else if ( array instanceof Uint8ClampedArray ) {

			 type = 5121;

		 }

		 return {
			 buffer: buffer,
			 type: type,
			 bytesPerElement: array.BYTES_PER_ELEMENT,
			 version: attribute.version
		 };

	 }

	 function updateBuffer( buffer, attribute, bufferType ) {

		 const array = attribute.array;
		 const updateRange = attribute.updateRange;

		 gl.bindBuffer( bufferType, buffer );

		 if ( updateRange.count === - 1 ) {

			 // Not using update ranges

			 gl.bufferSubData( bufferType, 0, array );

		 } else {

			 if ( isWebGL2 ) {

				 gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					 array, updateRange.offset, updateRange.count );

			 } else {

				 gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					 array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			 }

			 updateRange.count = - 1; // reset range

		 }

	 }

	 //

	 function get( attribute ) {

		 if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		 return buffers.get( attribute );

	 }

	 function remove( attribute ) {

		 if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		 const data = buffers.get( attribute );

		 if ( data ) {

			 gl.deleteBuffer( data.buffer );

			 buffers.delete( attribute );

		 }

	 }

	 function update( attribute, bufferType ) {

		 if ( attribute.isGLBufferAttribute ) {

			 const cached = buffers.get( attribute );

			 if ( ! cached || cached.version < attribute.version ) {

				 buffers.set( attribute, {
					 buffer: attribute.buffer,
					 type: attribute.type,
					 bytesPerElement: attribute.elementSize,
					 version: attribute.version
				 } );

			 }

			 return;

		 }

		 if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		 const data = buffers.get( attribute );

		 if ( data === undefined ) {

			 buffers.set( attribute, createBuffer( attribute, bufferType ) );

		 } else if ( data.version < attribute.version ) {

			 updateBuffer( data.buffer, attribute, bufferType );

			 data.version = attribute.version;

		 }

	 }

	 return {

		 get: get,
		 remove: remove,
		 update: update

	 };

 }

 class PlaneGeometry$1 extends BufferGeometry$1 {

	 constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		 super();
		 this.type = 'PlaneGeometry';

		 this.parameters = {
			 width: width,
			 height: height,
			 widthSegments: widthSegments,
			 heightSegments: heightSegments
		 };

		 const width_half = width / 2;
		 const height_half = height / 2;

		 const gridX = Math.floor( widthSegments );
		 const gridY = Math.floor( heightSegments );

		 const gridX1 = gridX + 1;
		 const gridY1 = gridY + 1;

		 const segment_width = width / gridX;
		 const segment_height = height / gridY;

		 //

		 const indices = [];
		 const vertices = [];
		 const normals = [];
		 const uvs = [];

		 for ( let iy = 0; iy < gridY1; iy ++ ) {

			 const y = iy * segment_height - height_half;

			 for ( let ix = 0; ix < gridX1; ix ++ ) {

				 const x = ix * segment_width - width_half;

				 vertices.push( x, - y, 0 );

				 normals.push( 0, 0, 1 );

				 uvs.push( ix / gridX );
				 uvs.push( 1 - ( iy / gridY ) );

			 }

		 }

		 for ( let iy = 0; iy < gridY; iy ++ ) {

			 for ( let ix = 0; ix < gridX; ix ++ ) {

				 const a = ix + gridX1 * iy;
				 const b = ix + gridX1 * ( iy + 1 );
				 const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				 const d = ( ix + 1 ) + gridX1 * iy;

				 indices.push( a, b, d );
				 indices.push( b, c, d );

			 }

		 }

		 this.setIndex( indices );
		 this.setAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
		 this.setAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

	 }

	 static fromJSON( data ) {

		 return new PlaneGeometry$1( data.width, data.height, data.widthSegments, data.heightSegments );

	 }

 }

 var alphamap_fragment$1 = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

 var alphamap_pars_fragment$1 = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

 var alphatest_fragment$1 = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

 var aomap_fragment$1 = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

 var aomap_pars_fragment$1 = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

 var begin_vertex$1 = "vec3 transformed = vec3( position );";

 var beginnormal_vertex$1 = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

 var bsdfs$1 = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

 var bumpmap_pars_fragment$1 = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

 var clipping_planes_fragment$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

 var clipping_planes_pars_fragment$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

 var clipping_planes_pars_vertex$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

 var clipping_planes_vertex$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

 var color_fragment$1 = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

 var color_pars_fragment$1 = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

 var color_pars_vertex$1 = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

 var color_vertex$1 = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

 var common$1 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

 var cube_uv_reflection_fragment$1 = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

 var defaultnormal_vertex$1 = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

 var displacementmap_pars_vertex$1 = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

 var displacementmap_vertex$1 = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

 var emissivemap_fragment$1 = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

 var emissivemap_pars_fragment$1 = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

 var encodings_fragment$1 = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

 var encodings_pars_fragment$1 = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

 var envmap_fragment$1 = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

 var envmap_common_pars_fragment$1 = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

 var envmap_pars_fragment$1 = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

 var envmap_pars_vertex$1 = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

 var envmap_vertex$1 = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

 var fog_vertex$1 = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

 var fog_pars_vertex$1 = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

 var fog_fragment$1 = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

 var fog_pars_fragment$1 = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

 var gradientmap_pars_fragment$1 = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

 var lightmap_fragment$1 = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

 var lightmap_pars_fragment$1 = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

 var lights_lambert_vertex$1 = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

 var lights_pars_begin$1 = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

 var envmap_physical_pars_fragment$1 = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

 var lights_toon_fragment$1 = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

 var lights_toon_pars_fragment$1 = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

 var lights_phong_fragment$1 = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

 var lights_phong_pars_fragment$1 = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

 var lights_physical_fragment$1 = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

 var lights_physical_pars_fragment$1 = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

 var lights_fragment_begin$1 = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

 var lights_fragment_maps$1 = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

 var lights_fragment_end$1 = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

 var logdepthbuf_fragment$1 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

 var logdepthbuf_pars_fragment$1 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

 var logdepthbuf_pars_vertex$1 = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

 var logdepthbuf_vertex$1 = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

 var map_fragment$1 = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

 var map_pars_fragment$1 = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

 var map_particle_fragment$1 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

 var map_particle_pars_fragment$1 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

 var metalnessmap_fragment$1 = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

 var metalnessmap_pars_fragment$1 = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

 var morphnormal_vertex$1 = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

 var morphtarget_pars_vertex$1 = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

 var morphtarget_vertex$1 = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

 var normal_fragment_begin$1 = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

 var normal_fragment_maps$1 = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

 var normalmap_pars_fragment$1 = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

 var clearcoat_normal_fragment_begin$1 = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

 var clearcoat_normal_fragment_maps$1 = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

 var clearcoat_pars_fragment$1 = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

 var packing$1 = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

 var premultiplied_alpha_fragment$1 = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

 var project_vertex$1 = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

 var dithering_fragment$1 = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

 var dithering_pars_fragment$1 = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

 var roughnessmap_fragment$1 = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

 var roughnessmap_pars_fragment$1 = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

 var shadowmap_pars_fragment$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

 var shadowmap_pars_vertex$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

 var shadowmap_vertex$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

 var shadowmask_pars_fragment$1 = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

 var skinbase_vertex$1 = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

 var skinning_pars_vertex$1 = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

 var skinning_vertex$1 = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

 var skinnormal_vertex$1 = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

 var specularmap_fragment$1 = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

 var specularmap_pars_fragment$1 = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

 var tonemapping_fragment$1 = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

 var tonemapping_pars_fragment$1 = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

 var transmission_fragment$1 = "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";

 var transmission_pars_fragment$1 = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";

 var uv_pars_fragment$1 = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

 var uv_pars_vertex$1 = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

 var uv_vertex$1 = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

 var uv2_pars_fragment$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

 var uv2_pars_vertex$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

 var uv2_vertex$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

 var worldpos_vertex$1 = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

 var background_frag$1 = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

 var background_vert$1 = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

 var cube_frag$1 = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

 var cube_vert$1 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

 var depth_frag$1 = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

 var depth_vert$1 = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

 var distanceRGBA_frag$1 = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

 var distanceRGBA_vert$1 = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

 var equirect_frag$1 = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

 var equirect_vert$1 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

 var linedashed_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

 var linedashed_vert$1 = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

 var meshbasic_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshbasic_vert$1 = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshlambert_frag$1 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshlambert_vert$1 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshmatcap_frag$1 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshmatcap_vert$1 = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

 var meshtoon_frag$1 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshtoon_vert$1 = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshphong_frag$1 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshphong_vert$1 = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshphysical_frag$1 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshphysical_vert$1 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";

 var normal_frag$1 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

 var normal_vert$1 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

 var points_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

 var points_vert$1 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

 var shadow_frag$1 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

 var shadow_vert$1 = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var sprite_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

 var sprite_vert$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

 const ShaderChunk$1 = {
	 alphamap_fragment: alphamap_fragment$1,
	 alphamap_pars_fragment: alphamap_pars_fragment$1,
	 alphatest_fragment: alphatest_fragment$1,
	 aomap_fragment: aomap_fragment$1,
	 aomap_pars_fragment: aomap_pars_fragment$1,
	 begin_vertex: begin_vertex$1,
	 beginnormal_vertex: beginnormal_vertex$1,
	 bsdfs: bsdfs$1,
	 bumpmap_pars_fragment: bumpmap_pars_fragment$1,
	 clipping_planes_fragment: clipping_planes_fragment$1,
	 clipping_planes_pars_fragment: clipping_planes_pars_fragment$1,
	 clipping_planes_pars_vertex: clipping_planes_pars_vertex$1,
	 clipping_planes_vertex: clipping_planes_vertex$1,
	 color_fragment: color_fragment$1,
	 color_pars_fragment: color_pars_fragment$1,
	 color_pars_vertex: color_pars_vertex$1,
	 color_vertex: color_vertex$1,
	 common: common$1,
	 cube_uv_reflection_fragment: cube_uv_reflection_fragment$1,
	 defaultnormal_vertex: defaultnormal_vertex$1,
	 displacementmap_pars_vertex: displacementmap_pars_vertex$1,
	 displacementmap_vertex: displacementmap_vertex$1,
	 emissivemap_fragment: emissivemap_fragment$1,
	 emissivemap_pars_fragment: emissivemap_pars_fragment$1,
	 encodings_fragment: encodings_fragment$1,
	 encodings_pars_fragment: encodings_pars_fragment$1,
	 envmap_fragment: envmap_fragment$1,
	 envmap_common_pars_fragment: envmap_common_pars_fragment$1,
	 envmap_pars_fragment: envmap_pars_fragment$1,
	 envmap_pars_vertex: envmap_pars_vertex$1,
	 envmap_physical_pars_fragment: envmap_physical_pars_fragment$1,
	 envmap_vertex: envmap_vertex$1,
	 fog_vertex: fog_vertex$1,
	 fog_pars_vertex: fog_pars_vertex$1,
	 fog_fragment: fog_fragment$1,
	 fog_pars_fragment: fog_pars_fragment$1,
	 gradientmap_pars_fragment: gradientmap_pars_fragment$1,
	 lightmap_fragment: lightmap_fragment$1,
	 lightmap_pars_fragment: lightmap_pars_fragment$1,
	 lights_lambert_vertex: lights_lambert_vertex$1,
	 lights_pars_begin: lights_pars_begin$1,
	 lights_toon_fragment: lights_toon_fragment$1,
	 lights_toon_pars_fragment: lights_toon_pars_fragment$1,
	 lights_phong_fragment: lights_phong_fragment$1,
	 lights_phong_pars_fragment: lights_phong_pars_fragment$1,
	 lights_physical_fragment: lights_physical_fragment$1,
	 lights_physical_pars_fragment: lights_physical_pars_fragment$1,
	 lights_fragment_begin: lights_fragment_begin$1,
	 lights_fragment_maps: lights_fragment_maps$1,
	 lights_fragment_end: lights_fragment_end$1,
	 logdepthbuf_fragment: logdepthbuf_fragment$1,
	 logdepthbuf_pars_fragment: logdepthbuf_pars_fragment$1,
	 logdepthbuf_pars_vertex: logdepthbuf_pars_vertex$1,
	 logdepthbuf_vertex: logdepthbuf_vertex$1,
	 map_fragment: map_fragment$1,
	 map_pars_fragment: map_pars_fragment$1,
	 map_particle_fragment: map_particle_fragment$1,
	 map_particle_pars_fragment: map_particle_pars_fragment$1,
	 metalnessmap_fragment: metalnessmap_fragment$1,
	 metalnessmap_pars_fragment: metalnessmap_pars_fragment$1,
	 morphnormal_vertex: morphnormal_vertex$1,
	 morphtarget_pars_vertex: morphtarget_pars_vertex$1,
	 morphtarget_vertex: morphtarget_vertex$1,
	 normal_fragment_begin: normal_fragment_begin$1,
	 normal_fragment_maps: normal_fragment_maps$1,
	 normalmap_pars_fragment: normalmap_pars_fragment$1,
	 clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin$1,
	 clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps$1,
	 clearcoat_pars_fragment: clearcoat_pars_fragment$1,
	 packing: packing$1,
	 premultiplied_alpha_fragment: premultiplied_alpha_fragment$1,
	 project_vertex: project_vertex$1,
	 dithering_fragment: dithering_fragment$1,
	 dithering_pars_fragment: dithering_pars_fragment$1,
	 roughnessmap_fragment: roughnessmap_fragment$1,
	 roughnessmap_pars_fragment: roughnessmap_pars_fragment$1,
	 shadowmap_pars_fragment: shadowmap_pars_fragment$1,
	 shadowmap_pars_vertex: shadowmap_pars_vertex$1,
	 shadowmap_vertex: shadowmap_vertex$1,
	 shadowmask_pars_fragment: shadowmask_pars_fragment$1,
	 skinbase_vertex: skinbase_vertex$1,
	 skinning_pars_vertex: skinning_pars_vertex$1,
	 skinning_vertex: skinning_vertex$1,
	 skinnormal_vertex: skinnormal_vertex$1,
	 specularmap_fragment: specularmap_fragment$1,
	 specularmap_pars_fragment: specularmap_pars_fragment$1,
	 tonemapping_fragment: tonemapping_fragment$1,
	 tonemapping_pars_fragment: tonemapping_pars_fragment$1,
	 transmission_fragment: transmission_fragment$1,
	 transmission_pars_fragment: transmission_pars_fragment$1,
	 uv_pars_fragment: uv_pars_fragment$1,
	 uv_pars_vertex: uv_pars_vertex$1,
	 uv_vertex: uv_vertex$1,
	 uv2_pars_fragment: uv2_pars_fragment$1,
	 uv2_pars_vertex: uv2_pars_vertex$1,
	 uv2_vertex: uv2_vertex$1,
	 worldpos_vertex: worldpos_vertex$1,

	 background_frag: background_frag$1,
	 background_vert: background_vert$1,
	 cube_frag: cube_frag$1,
	 cube_vert: cube_vert$1,
	 depth_frag: depth_frag$1,
	 depth_vert: depth_vert$1,
	 distanceRGBA_frag: distanceRGBA_frag$1,
	 distanceRGBA_vert: distanceRGBA_vert$1,
	 equirect_frag: equirect_frag$1,
	 equirect_vert: equirect_vert$1,
	 linedashed_frag: linedashed_frag$1,
	 linedashed_vert: linedashed_vert$1,
	 meshbasic_frag: meshbasic_frag$1,
	 meshbasic_vert: meshbasic_vert$1,
	 meshlambert_frag: meshlambert_frag$1,
	 meshlambert_vert: meshlambert_vert$1,
	 meshmatcap_frag: meshmatcap_frag$1,
	 meshmatcap_vert: meshmatcap_vert$1,
	 meshtoon_frag: meshtoon_frag$1,
	 meshtoon_vert: meshtoon_vert$1,
	 meshphong_frag: meshphong_frag$1,
	 meshphong_vert: meshphong_vert$1,
	 meshphysical_frag: meshphysical_frag$1,
	 meshphysical_vert: meshphysical_vert$1,
	 normal_frag: normal_frag$1,
	 normal_vert: normal_vert$1,
	 points_frag: points_frag$1,
	 points_vert: points_vert$1,
	 shadow_frag: shadow_frag$1,
	 shadow_vert: shadow_vert$1,
	 sprite_frag: sprite_frag$1,
	 sprite_vert: sprite_vert$1
 };

 /**
	* Uniforms library for shared webgl shaders
	*/

 const UniformsLib$1 = {

	 common: {

		 diffuse: { value: new Color$2( 0xffffff ) },
		 opacity: { value: 1.0 },

		 map: { value: null },
		 uvTransform: { value: new Matrix3$1() },
		 uv2Transform: { value: new Matrix3$1() },

		 alphaMap: { value: null },

	 },

	 specularmap: {

		 specularMap: { value: null },

	 },

	 envmap: {

		 envMap: { value: null },
		 flipEnvMap: { value: - 1 },
		 reflectivity: { value: 1.0 },
		 refractionRatio: { value: 0.98 },
		 maxMipLevel: { value: 0 }

	 },

	 aomap: {

		 aoMap: { value: null },
		 aoMapIntensity: { value: 1 }

	 },

	 lightmap: {

		 lightMap: { value: null },
		 lightMapIntensity: { value: 1 }

	 },

	 emissivemap: {

		 emissiveMap: { value: null }

	 },

	 bumpmap: {

		 bumpMap: { value: null },
		 bumpScale: { value: 1 }

	 },

	 normalmap: {

		 normalMap: { value: null },
		 normalScale: { value: new Vector2$1( 1, 1 ) }

	 },

	 displacementmap: {

		 displacementMap: { value: null },
		 displacementScale: { value: 1 },
		 displacementBias: { value: 0 }

	 },

	 roughnessmap: {

		 roughnessMap: { value: null }

	 },

	 metalnessmap: {

		 metalnessMap: { value: null }

	 },

	 gradientmap: {

		 gradientMap: { value: null }

	 },

	 fog: {

		 fogDensity: { value: 0.00025 },
		 fogNear: { value: 1 },
		 fogFar: { value: 2000 },
		 fogColor: { value: new Color$2( 0xffffff ) }

	 },

	 lights: {

		 ambientLightColor: { value: [] },

		 lightProbe: { value: [] },

		 directionalLights: { value: [], properties: {
			 direction: {},
			 color: {}
		 } },

		 directionalLightShadows: { value: [], properties: {
			 shadowBias: {},
			 shadowNormalBias: {},
			 shadowRadius: {},
			 shadowMapSize: {}
		 } },

		 directionalShadowMap: { value: [] },
		 directionalShadowMatrix: { value: [] },

		 spotLights: { value: [], properties: {
			 color: {},
			 position: {},
			 direction: {},
			 distance: {},
			 coneCos: {},
			 penumbraCos: {},
			 decay: {}
		 } },

		 spotLightShadows: { value: [], properties: {
			 shadowBias: {},
			 shadowNormalBias: {},
			 shadowRadius: {},
			 shadowMapSize: {}
		 } },

		 spotShadowMap: { value: [] },
		 spotShadowMatrix: { value: [] },

		 pointLights: { value: [], properties: {
			 color: {},
			 position: {},
			 decay: {},
			 distance: {}
		 } },

		 pointLightShadows: { value: [], properties: {
			 shadowBias: {},
			 shadowNormalBias: {},
			 shadowRadius: {},
			 shadowMapSize: {},
			 shadowCameraNear: {},
			 shadowCameraFar: {}
		 } },

		 pointShadowMap: { value: [] },
		 pointShadowMatrix: { value: [] },

		 hemisphereLights: { value: [], properties: {
			 direction: {},
			 skyColor: {},
			 groundColor: {}
		 } },

		 // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		 rectAreaLights: { value: [], properties: {
			 color: {},
			 position: {},
			 width: {},
			 height: {}
		 } },

		 ltc_1: { value: null },
		 ltc_2: { value: null }

	 },

	 points: {

		 diffuse: { value: new Color$2( 0xffffff ) },
		 opacity: { value: 1.0 },
		 size: { value: 1.0 },
		 scale: { value: 1.0 },
		 map: { value: null },
		 alphaMap: { value: null },
		 uvTransform: { value: new Matrix3$1() }

	 },

	 sprite: {

		 diffuse: { value: new Color$2( 0xffffff ) },
		 opacity: { value: 1.0 },
		 center: { value: new Vector2$1( 0.5, 0.5 ) },
		 rotation: { value: 0.0 },
		 map: { value: null },
		 alphaMap: { value: null },
		 uvTransform: { value: new Matrix3$1() }

	 }

 };

 const ShaderLib$1 = {

	 basic: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.specularmap,
			 UniformsLib$1.envmap,
			 UniformsLib$1.aomap,
			 UniformsLib$1.lightmap,
			 UniformsLib$1.fog
		 ] ),

		 vertexShader: ShaderChunk$1.meshbasic_vert,
		 fragmentShader: ShaderChunk$1.meshbasic_frag

	 },

	 lambert: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.specularmap,
			 UniformsLib$1.envmap,
			 UniformsLib$1.aomap,
			 UniformsLib$1.lightmap,
			 UniformsLib$1.emissivemap,
			 UniformsLib$1.fog,
			 UniformsLib$1.lights,
			 {
				 emissive: { value: new Color$2( 0x000000 ) }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.meshlambert_vert,
		 fragmentShader: ShaderChunk$1.meshlambert_frag

	 },

	 phong: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.specularmap,
			 UniformsLib$1.envmap,
			 UniformsLib$1.aomap,
			 UniformsLib$1.lightmap,
			 UniformsLib$1.emissivemap,
			 UniformsLib$1.bumpmap,
			 UniformsLib$1.normalmap,
			 UniformsLib$1.displacementmap,
			 UniformsLib$1.fog,
			 UniformsLib$1.lights,
			 {
				 emissive: { value: new Color$2( 0x000000 ) },
				 specular: { value: new Color$2( 0x111111 ) },
				 shininess: { value: 30 }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.meshphong_vert,
		 fragmentShader: ShaderChunk$1.meshphong_frag

	 },

	 standard: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.envmap,
			 UniformsLib$1.aomap,
			 UniformsLib$1.lightmap,
			 UniformsLib$1.emissivemap,
			 UniformsLib$1.bumpmap,
			 UniformsLib$1.normalmap,
			 UniformsLib$1.displacementmap,
			 UniformsLib$1.roughnessmap,
			 UniformsLib$1.metalnessmap,
			 UniformsLib$1.fog,
			 UniformsLib$1.lights,
			 {
				 emissive: { value: new Color$2( 0x000000 ) },
				 roughness: { value: 1.0 },
				 metalness: { value: 0.0 },
				 envMapIntensity: { value: 1 } // temporary
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.meshphysical_vert,
		 fragmentShader: ShaderChunk$1.meshphysical_frag

	 },

	 toon: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.aomap,
			 UniformsLib$1.lightmap,
			 UniformsLib$1.emissivemap,
			 UniformsLib$1.bumpmap,
			 UniformsLib$1.normalmap,
			 UniformsLib$1.displacementmap,
			 UniformsLib$1.gradientmap,
			 UniformsLib$1.fog,
			 UniformsLib$1.lights,
			 {
				 emissive: { value: new Color$2( 0x000000 ) }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.meshtoon_vert,
		 fragmentShader: ShaderChunk$1.meshtoon_frag

	 },

	 matcap: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.bumpmap,
			 UniformsLib$1.normalmap,
			 UniformsLib$1.displacementmap,
			 UniformsLib$1.fog,
			 {
				 matcap: { value: null }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.meshmatcap_vert,
		 fragmentShader: ShaderChunk$1.meshmatcap_frag

	 },

	 points: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.points,
			 UniformsLib$1.fog
		 ] ),

		 vertexShader: ShaderChunk$1.points_vert,
		 fragmentShader: ShaderChunk$1.points_frag

	 },

	 dashed: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.fog,
			 {
				 scale: { value: 1 },
				 dashSize: { value: 1 },
				 totalSize: { value: 2 }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.linedashed_vert,
		 fragmentShader: ShaderChunk$1.linedashed_frag

	 },

	 depth: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.displacementmap
		 ] ),

		 vertexShader: ShaderChunk$1.depth_vert,
		 fragmentShader: ShaderChunk$1.depth_frag

	 },

	 normal: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.bumpmap,
			 UniformsLib$1.normalmap,
			 UniformsLib$1.displacementmap,
			 {
				 opacity: { value: 1.0 }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.normal_vert,
		 fragmentShader: ShaderChunk$1.normal_frag

	 },

	 sprite: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.sprite,
			 UniformsLib$1.fog
		 ] ),

		 vertexShader: ShaderChunk$1.sprite_vert,
		 fragmentShader: ShaderChunk$1.sprite_frag

	 },

	 background: {

		 uniforms: {
			 uvTransform: { value: new Matrix3$1() },
			 t2D: { value: null },
		 },

		 vertexShader: ShaderChunk$1.background_vert,
		 fragmentShader: ShaderChunk$1.background_frag

	 },
	 /* -------------------------------------------------------------------------
	 //	Cube map shader
		------------------------------------------------------------------------- */

	 cube: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.envmap,
			 {
				 opacity: { value: 1.0 }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.cube_vert,
		 fragmentShader: ShaderChunk$1.cube_frag

	 },

	 equirect: {

		 uniforms: {
			 tEquirect: { value: null },
		 },

		 vertexShader: ShaderChunk$1.equirect_vert,
		 fragmentShader: ShaderChunk$1.equirect_frag

	 },

	 distanceRGBA: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.common,
			 UniformsLib$1.displacementmap,
			 {
				 referencePosition: { value: new Vector3$1() },
				 nearDistance: { value: 1 },
				 farDistance: { value: 1000 }
			 }
		 ] ),

		 vertexShader: ShaderChunk$1.distanceRGBA_vert,
		 fragmentShader: ShaderChunk$1.distanceRGBA_frag

	 },

	 shadow: {

		 uniforms: mergeUniforms$1( [
			 UniformsLib$1.lights,
			 UniformsLib$1.fog,
			 {
				 color: { value: new Color$2( 0x00000 ) },
				 opacity: { value: 1.0 }
			 },
		 ] ),

		 vertexShader: ShaderChunk$1.shadow_vert,
		 fragmentShader: ShaderChunk$1.shadow_frag

	 }

 };

 ShaderLib$1.physical = {

	 uniforms: mergeUniforms$1( [
		 ShaderLib$1.standard.uniforms,
		 {
			 clearcoat: { value: 0 },
			 clearcoatMap: { value: null },
			 clearcoatRoughness: { value: 0 },
			 clearcoatRoughnessMap: { value: null },
			 clearcoatNormalScale: { value: new Vector2$1( 1, 1 ) },
			 clearcoatNormalMap: { value: null },
			 sheen: { value: new Color$2( 0x000000 ) },
			 transmission: { value: 0 },
			 transmissionMap: { value: null },
			 transmissionSamplerSize: { value: new Vector2$1() },
			 transmissionSamplerMap: { value: null },
			 thickness: { value: 0 },
			 thicknessMap: { value: null },
			 attenuationDistance: { value: 0 },
			 attenuationColor: { value: new Color$2( 0x000000 ) }
		 }
	 ] ),

	 vertexShader: ShaderChunk$1.meshphysical_vert,
	 fragmentShader: ShaderChunk$1.meshphysical_frag

 };

 function WebGLBackground$1( renderer, cubemaps, state, objects, premultipliedAlpha ) {

	 const clearColor = new Color$2( 0x000000 );
	 let clearAlpha = 0;

	 let planeMesh;
	 let boxMesh;

	 let currentBackground = null;
	 let currentBackgroundVersion = 0;
	 let currentTonemapping = null;

	 function render( renderList, scene ) {

		 let forceClear = false;
		 let background = scene.isScene === true ? scene.background : null;

		 if ( background && background.isTexture ) {

			 background = cubemaps.get( background );

		 }

		 // Ignore background in AR
		 // TODO: Reconsider this.

		 const xr = renderer.xr;
		 const session = xr.getSession && xr.getSession();

		 if ( session && session.environmentBlendMode === 'additive' ) {

			 background = null;

		 }

		 if ( background === null ) {

			 setClear( clearColor, clearAlpha );

		 } else if ( background && background.isColor ) {

			 setClear( background, 1 );
			 forceClear = true;

		 }

		 if ( renderer.autoClear || forceClear ) {

			 renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		 }

		 if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping$1 ) ) {

			 if ( boxMesh === undefined ) {

				 boxMesh = new Mesh$1(
					 new BoxGeometry$1( 1, 1, 1 ),
					 new ShaderMaterial$1( {
						 name: 'BackgroundCubeMaterial',
						 uniforms: cloneUniforms$1( ShaderLib$1.cube.uniforms ),
						 vertexShader: ShaderLib$1.cube.vertexShader,
						 fragmentShader: ShaderLib$1.cube.fragmentShader,
						 side: BackSide$1,
						 depthTest: false,
						 depthWrite: false,
						 fog: false
					 } )
				 );

				 boxMesh.geometry.deleteAttribute( 'normal' );
				 boxMesh.geometry.deleteAttribute( 'uv' );

				 boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					 this.matrixWorld.copyPosition( camera.matrixWorld );

				 };

				 // enable code injection for non-built-in material
				 Object.defineProperty( boxMesh.material, 'envMap', {

					 get: function () {

						 return this.uniforms.envMap.value;

					 }

				 } );

				 objects.update( boxMesh );

			 }

			 boxMesh.material.uniforms.envMap.value = background;
			 boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

			 if ( currentBackground !== background ||
				 currentBackgroundVersion !== background.version ||
				 currentTonemapping !== renderer.toneMapping ) {

				 boxMesh.material.needsUpdate = true;

				 currentBackground = background;
				 currentBackgroundVersion = background.version;
				 currentTonemapping = renderer.toneMapping;

			 }

			 // push to the pre-sorted opaque render list
			 renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		 } else if ( background && background.isTexture ) {

			 if ( planeMesh === undefined ) {

				 planeMesh = new Mesh$1(
					 new PlaneGeometry$1( 2, 2 ),
					 new ShaderMaterial$1( {
						 name: 'BackgroundMaterial',
						 uniforms: cloneUniforms$1( ShaderLib$1.background.uniforms ),
						 vertexShader: ShaderLib$1.background.vertexShader,
						 fragmentShader: ShaderLib$1.background.fragmentShader,
						 side: FrontSide$1,
						 depthTest: false,
						 depthWrite: false,
						 fog: false
					 } )
				 );

				 planeMesh.geometry.deleteAttribute( 'normal' );

				 // enable code injection for non-built-in material
				 Object.defineProperty( planeMesh.material, 'map', {

					 get: function () {

						 return this.uniforms.t2D.value;

					 }

				 } );

				 objects.update( planeMesh );

			 }

			 planeMesh.material.uniforms.t2D.value = background;

			 if ( background.matrixAutoUpdate === true ) {

				 background.updateMatrix();

			 }

			 planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			 if ( currentBackground !== background ||
				 currentBackgroundVersion !== background.version ||
				 currentTonemapping !== renderer.toneMapping ) {

				 planeMesh.material.needsUpdate = true;

				 currentBackground = background;
				 currentBackgroundVersion = background.version;
				 currentTonemapping = renderer.toneMapping;

			 }


			 // push to the pre-sorted opaque render list
			 renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		 }

	 }

	 function setClear( color, alpha ) {

		 state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	 }

	 return {

		 getClearColor: function () {

			 return clearColor;

		 },
		 setClearColor: function ( color, alpha = 1 ) {

			 clearColor.set( color );
			 clearAlpha = alpha;
			 setClear( clearColor, clearAlpha );

		 },
		 getClearAlpha: function () {

			 return clearAlpha;

		 },
		 setClearAlpha: function ( alpha ) {

			 clearAlpha = alpha;
			 setClear( clearColor, clearAlpha );

		 },
		 render: render

	 };

 }

 function WebGLBindingStates$1( gl, extensions, attributes, capabilities ) {

	 const maxVertexAttributes = gl.getParameter( 34921 );

	 const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	 const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	 const bindingStates = {};

	 const defaultState = createBindingState( null );
	 let currentState = defaultState;

	 function setup( object, material, program, geometry, index ) {

		 let updateBuffers = false;

		 if ( vaoAvailable ) {

			 const state = getBindingState( geometry, program, material );

			 if ( currentState !== state ) {

				 currentState = state;
				 bindVertexArrayObject( currentState.object );

			 }

			 updateBuffers = needsUpdate( geometry, index );

			 if ( updateBuffers ) saveCache( geometry, index );

		 } else {

			 const wireframe = ( material.wireframe === true );

			 if ( currentState.geometry !== geometry.id ||
				 currentState.program !== program.id ||
				 currentState.wireframe !== wireframe ) {

				 currentState.geometry = geometry.id;
				 currentState.program = program.id;
				 currentState.wireframe = wireframe;

				 updateBuffers = true;

			 }

		 }

		 if ( object.isInstancedMesh === true ) {

			 updateBuffers = true;

		 }

		 if ( index !== null ) {

			 attributes.update( index, 34963 );

		 }

		 if ( updateBuffers ) {

			 setupVertexAttributes( object, material, program, geometry );

			 if ( index !== null ) {

				 gl.bindBuffer( 34963, attributes.get( index ).buffer );

			 }

		 }

	 }

	 function createVertexArrayObject() {

		 if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		 return extension.createVertexArrayOES();

	 }

	 function bindVertexArrayObject( vao ) {

		 if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		 return extension.bindVertexArrayOES( vao );

	 }

	 function deleteVertexArrayObject( vao ) {

		 if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		 return extension.deleteVertexArrayOES( vao );

	 }

	 function getBindingState( geometry, program, material ) {

		 const wireframe = ( material.wireframe === true );

		 let programMap = bindingStates[ geometry.id ];

		 if ( programMap === undefined ) {

			 programMap = {};
			 bindingStates[ geometry.id ] = programMap;

		 }

		 let stateMap = programMap[ program.id ];

		 if ( stateMap === undefined ) {

			 stateMap = {};
			 programMap[ program.id ] = stateMap;

		 }

		 let state = stateMap[ wireframe ];

		 if ( state === undefined ) {

			 state = createBindingState( createVertexArrayObject() );
			 stateMap[ wireframe ] = state;

		 }

		 return state;

	 }

	 function createBindingState( vao ) {

		 const newAttributes = [];
		 const enabledAttributes = [];
		 const attributeDivisors = [];

		 for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			 newAttributes[ i ] = 0;
			 enabledAttributes[ i ] = 0;
			 attributeDivisors[ i ] = 0;

		 }

		 return {

			 // for backward compatibility on non-VAO support browser
			 geometry: null,
			 program: null,
			 wireframe: false,

			 newAttributes: newAttributes,
			 enabledAttributes: enabledAttributes,
			 attributeDivisors: attributeDivisors,
			 object: vao,
			 attributes: {},
			 index: null

		 };

	 }

	 function needsUpdate( geometry, index ) {

		 const cachedAttributes = currentState.attributes;
		 const geometryAttributes = geometry.attributes;

		 let attributesNum = 0;

		 for ( const key in geometryAttributes ) {

			 const cachedAttribute = cachedAttributes[ key ];
			 const geometryAttribute = geometryAttributes[ key ];

			 if ( cachedAttribute === undefined ) return true;

			 if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			 if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			 attributesNum ++;

		 }

		 if ( currentState.attributesNum !== attributesNum ) return true;

		 if ( currentState.index !== index ) return true;

		 return false;

	 }

	 function saveCache( geometry, index ) {

		 const cache = {};
		 const attributes = geometry.attributes;
		 let attributesNum = 0;

		 for ( const key in attributes ) {

			 const attribute = attributes[ key ];

			 const data = {};
			 data.attribute = attribute;

			 if ( attribute.data ) {

				 data.data = attribute.data;

			 }

			 cache[ key ] = data;

			 attributesNum ++;

		 }

		 currentState.attributes = cache;
		 currentState.attributesNum = attributesNum;

		 currentState.index = index;

	 }

	 function initAttributes() {

		 const newAttributes = currentState.newAttributes;

		 for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			 newAttributes[ i ] = 0;

		 }

	 }

	 function enableAttribute( attribute ) {

		 enableAttributeAndDivisor( attribute, 0 );

	 }

	 function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		 const newAttributes = currentState.newAttributes;
		 const enabledAttributes = currentState.enabledAttributes;
		 const attributeDivisors = currentState.attributeDivisors;

		 newAttributes[ attribute ] = 1;

		 if ( enabledAttributes[ attribute ] === 0 ) {

			 gl.enableVertexAttribArray( attribute );
			 enabledAttributes[ attribute ] = 1;

		 }

		 if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			 const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			 extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			 attributeDivisors[ attribute ] = meshPerAttribute;

		 }

	 }

	 function disableUnusedAttributes() {

		 const newAttributes = currentState.newAttributes;
		 const enabledAttributes = currentState.enabledAttributes;

		 for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			 if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				 gl.disableVertexAttribArray( i );
				 enabledAttributes[ i ] = 0;

			 }

		 }

	 }

	 function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		 if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			 gl.vertexAttribIPointer( index, size, type, stride, offset );

		 } else {

			 gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		 }

	 }

	 function setupVertexAttributes( object, material, program, geometry ) {

		 if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			 if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		 }

		 initAttributes();

		 const geometryAttributes = geometry.attributes;

		 const programAttributes = program.getAttributes();

		 const materialDefaultAttributeValues = material.defaultAttributeValues;

		 for ( const name in programAttributes ) {

			 const programAttribute = programAttributes[ name ];

			 if ( programAttribute >= 0 ) {

				 const geometryAttribute = geometryAttributes[ name ];

				 if ( geometryAttribute !== undefined ) {

					 const normalized = geometryAttribute.normalized;
					 const size = geometryAttribute.itemSize;

					 const attribute = attributes.get( geometryAttribute );

					 // TODO Attribute may not be available on context restore

					 if ( attribute === undefined ) continue;

					 const buffer = attribute.buffer;
					 const type = attribute.type;
					 const bytesPerElement = attribute.bytesPerElement;

					 if ( geometryAttribute.isInterleavedBufferAttribute ) {

						 const data = geometryAttribute.data;
						 const stride = data.stride;
						 const offset = geometryAttribute.offset;

						 if ( data && data.isInstancedInterleavedBuffer ) {

							 enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							 if ( geometry._maxInstanceCount === undefined ) {

								 geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							 }

						 } else {

							 enableAttribute( programAttribute );

						 }

						 gl.bindBuffer( 34962, buffer );
						 vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					 } else {

						 if ( geometryAttribute.isInstancedBufferAttribute ) {

							 enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							 if ( geometry._maxInstanceCount === undefined ) {

								 geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							 }

						 } else {

							 enableAttribute( programAttribute );

						 }

						 gl.bindBuffer( 34962, buffer );
						 vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					 }

				 } else if ( name === 'instanceMatrix' ) {

					 const attribute = attributes.get( object.instanceMatrix );

					 // TODO Attribute may not be available on context restore

					 if ( attribute === undefined ) continue;

					 const buffer = attribute.buffer;
					 const type = attribute.type;

					 enableAttributeAndDivisor( programAttribute + 0, 1 );
					 enableAttributeAndDivisor( programAttribute + 1, 1 );
					 enableAttributeAndDivisor( programAttribute + 2, 1 );
					 enableAttributeAndDivisor( programAttribute + 3, 1 );

					 gl.bindBuffer( 34962, buffer );

					 gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					 gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					 gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					 gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				 } else if ( name === 'instanceColor' ) {

					 const attribute = attributes.get( object.instanceColor );

					 // TODO Attribute may not be available on context restore

					 if ( attribute === undefined ) continue;

					 const buffer = attribute.buffer;
					 const type = attribute.type;

					 enableAttributeAndDivisor( programAttribute, 1 );

					 gl.bindBuffer( 34962, buffer );

					 gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

				 } else if ( materialDefaultAttributeValues !== undefined ) {

					 const value = materialDefaultAttributeValues[ name ];

					 if ( value !== undefined ) {

						 switch ( value.length ) {

							 case 2:
								 gl.vertexAttrib2fv( programAttribute, value );
								 break;

							 case 3:
								 gl.vertexAttrib3fv( programAttribute, value );
								 break;

							 case 4:
								 gl.vertexAttrib4fv( programAttribute, value );
								 break;

							 default:
								 gl.vertexAttrib1fv( programAttribute, value );

						 }

					 }

				 }

			 }

		 }

		 disableUnusedAttributes();

	 }

	 function dispose() {

		 reset();

		 for ( const geometryId in bindingStates ) {

			 const programMap = bindingStates[ geometryId ];

			 for ( const programId in programMap ) {

				 const stateMap = programMap[ programId ];

				 for ( const wireframe in stateMap ) {

					 deleteVertexArrayObject( stateMap[ wireframe ].object );

					 delete stateMap[ wireframe ];

				 }

				 delete programMap[ programId ];

			 }

			 delete bindingStates[ geometryId ];

		 }

	 }

	 function releaseStatesOfGeometry( geometry ) {

		 if ( bindingStates[ geometry.id ] === undefined ) return;

		 const programMap = bindingStates[ geometry.id ];

		 for ( const programId in programMap ) {

			 const stateMap = programMap[ programId ];

			 for ( const wireframe in stateMap ) {

				 deleteVertexArrayObject( stateMap[ wireframe ].object );

				 delete stateMap[ wireframe ];

			 }

			 delete programMap[ programId ];

		 }

		 delete bindingStates[ geometry.id ];

	 }

	 function releaseStatesOfProgram( program ) {

		 for ( const geometryId in bindingStates ) {

			 const programMap = bindingStates[ geometryId ];

			 if ( programMap[ program.id ] === undefined ) continue;

			 const stateMap = programMap[ program.id ];

			 for ( const wireframe in stateMap ) {

				 deleteVertexArrayObject( stateMap[ wireframe ].object );

				 delete stateMap[ wireframe ];

			 }

			 delete programMap[ program.id ];

		 }

	 }

	 function reset() {

		 resetDefaultState();

		 if ( currentState === defaultState ) return;

		 currentState = defaultState;
		 bindVertexArrayObject( currentState.object );

	 }

	 // for backward-compatilibity

	 function resetDefaultState() {

		 defaultState.geometry = null;
		 defaultState.program = null;
		 defaultState.wireframe = false;

	 }

	 return {

		 setup: setup,
		 reset: reset,
		 resetDefaultState: resetDefaultState,
		 dispose: dispose,
		 releaseStatesOfGeometry: releaseStatesOfGeometry,
		 releaseStatesOfProgram: releaseStatesOfProgram,

		 initAttributes: initAttributes,
		 enableAttribute: enableAttribute,
		 disableUnusedAttributes: disableUnusedAttributes

	 };

 }

 function WebGLBufferRenderer$1( gl, extensions, info, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 let mode;

	 function setMode( value ) {

		 mode = value;

	 }

	 function render( start, count ) {

		 gl.drawArrays( mode, start, count );

		 info.update( count, mode, 1 );

	 }

	 function renderInstances( start, count, primcount ) {

		 if ( primcount === 0 ) return;

		 let extension, methodName;

		 if ( isWebGL2 ) {

			 extension = gl;
			 methodName = 'drawArraysInstanced';

		 } else {

			 extension = extensions.get( 'ANGLE_instanced_arrays' );
			 methodName = 'drawArraysInstancedANGLE';

			 if ( extension === null ) {

				 console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				 return;

			 }

		 }

		 extension[ methodName ]( mode, start, count, primcount );

		 info.update( count, mode, primcount );

	 }

	 //

	 this.setMode = setMode;
	 this.render = render;
	 this.renderInstances = renderInstances;

 }

 function WebGLCapabilities$1( gl, extensions, parameters ) {

	 let maxAnisotropy;

	 function getMaxAnisotropy() {

		 if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		 if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			 const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			 maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		 } else {

			 maxAnisotropy = 0;

		 }

		 return maxAnisotropy;

	 }

	 function getMaxPrecision( precision ) {

		 if ( precision === 'highp' ) {

			 if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				 gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				 return 'highp';

			 }

			 precision = 'mediump';

		 }

		 if ( precision === 'mediump' ) {

			 if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				 gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				 return 'mediump';

			 }

		 }

		 return 'lowp';

	 }

	 /* eslint-disable no-undef */
	 const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		 ( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	 /* eslint-enable no-undef */

	 let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	 const maxPrecision = getMaxPrecision( precision );

	 if ( maxPrecision !== precision ) {

		 console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		 precision = maxPrecision;

	 }

	 const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

	 const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	 const maxTextures = gl.getParameter( 34930 );
	 const maxVertexTextures = gl.getParameter( 35660 );
	 const maxTextureSize = gl.getParameter( 3379 );
	 const maxCubemapSize = gl.getParameter( 34076 );

	 const maxAttributes = gl.getParameter( 34921 );
	 const maxVertexUniforms = gl.getParameter( 36347 );
	 const maxVaryings = gl.getParameter( 36348 );
	 const maxFragmentUniforms = gl.getParameter( 36349 );

	 const vertexTextures = maxVertexTextures > 0;
	 const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	 const floatVertexTextures = vertexTextures && floatFragmentTextures;

	 const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	 return {

		 isWebGL2: isWebGL2,

		 drawBuffers: drawBuffers,

		 getMaxAnisotropy: getMaxAnisotropy,
		 getMaxPrecision: getMaxPrecision,

		 precision: precision,
		 logarithmicDepthBuffer: logarithmicDepthBuffer,

		 maxTextures: maxTextures,
		 maxVertexTextures: maxVertexTextures,
		 maxTextureSize: maxTextureSize,
		 maxCubemapSize: maxCubemapSize,

		 maxAttributes: maxAttributes,
		 maxVertexUniforms: maxVertexUniforms,
		 maxVaryings: maxVaryings,
		 maxFragmentUniforms: maxFragmentUniforms,

		 vertexTextures: vertexTextures,
		 floatFragmentTextures: floatFragmentTextures,
		 floatVertexTextures: floatVertexTextures,

		 maxSamples: maxSamples

	 };

 }

 function WebGLClipping$1( properties ) {

	 const scope = this;

	 let globalState = null,
		 numGlobalPlanes = 0,
		 localClippingEnabled = false,
		 renderingShadows = false;

	 const plane = new Plane$1(),
		 viewNormalMatrix = new Matrix3$1(),

		 uniform = { value: null, needsUpdate: false };

	 this.uniform = uniform;
	 this.numPlanes = 0;
	 this.numIntersection = 0;

	 this.init = function ( planes, enableLocalClipping, camera ) {

		 const enabled =
			 planes.length !== 0 ||
			 enableLocalClipping ||
			 // enable state of previous frame - the clipping code has to
			 // run another frame in order to reset the state:
			 numGlobalPlanes !== 0 ||
			 localClippingEnabled;

		 localClippingEnabled = enableLocalClipping;

		 globalState = projectPlanes( planes, camera, 0 );
		 numGlobalPlanes = planes.length;

		 return enabled;

	 };

	 this.beginShadows = function () {

		 renderingShadows = true;
		 projectPlanes( null );

	 };

	 this.endShadows = function () {

		 renderingShadows = false;
		 resetGlobalState();

	 };

	 this.setState = function ( material, camera, useCache ) {

		 const planes = material.clippingPlanes,
			 clipIntersection = material.clipIntersection,
			 clipShadows = material.clipShadows;

		 const materialProperties = properties.get( material );

		 if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			 // there's no local clipping

			 if ( renderingShadows ) {

				 // there's no global clipping

				 projectPlanes( null );

			 } else {

				 resetGlobalState();

			 }

		 } else {

			 const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				 lGlobal = nGlobal * 4;

			 let dstArray = materialProperties.clippingState || null;

			 uniform.value = dstArray; // ensure unique state

			 dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			 for ( let i = 0; i !== lGlobal; ++ i ) {

				 dstArray[ i ] = globalState[ i ];

			 }

			 materialProperties.clippingState = dstArray;
			 this.numIntersection = clipIntersection ? this.numPlanes : 0;
			 this.numPlanes += nGlobal;

		 }


	 };

	 function resetGlobalState() {

		 if ( uniform.value !== globalState ) {

			 uniform.value = globalState;
			 uniform.needsUpdate = numGlobalPlanes > 0;

		 }

		 scope.numPlanes = numGlobalPlanes;
		 scope.numIntersection = 0;

	 }

	 function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		 const nPlanes = planes !== null ? planes.length : 0;
		 let dstArray = null;

		 if ( nPlanes !== 0 ) {

			 dstArray = uniform.value;

			 if ( skipTransform !== true || dstArray === null ) {

				 const flatSize = dstOffset + nPlanes * 4,
					 viewMatrix = camera.matrixWorldInverse;

				 viewNormalMatrix.getNormalMatrix( viewMatrix );

				 if ( dstArray === null || dstArray.length < flatSize ) {

					 dstArray = new Float32Array( flatSize );

				 }

				 for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					 plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					 plane.normal.toArray( dstArray, i4 );
					 dstArray[ i4 + 3 ] = plane.constant;

				 }

			 }

			 uniform.value = dstArray;
			 uniform.needsUpdate = true;

		 }

		 scope.numPlanes = nPlanes;
		 scope.numIntersection = 0;

		 return dstArray;

	 }

 }

 function WebGLCubeMaps$1( renderer ) {

	 let cubemaps = new WeakMap();

	 function mapTextureMapping( texture, mapping ) {

		 if ( mapping === EquirectangularReflectionMapping$1 ) {

			 texture.mapping = CubeReflectionMapping$1;

		 } else if ( mapping === EquirectangularRefractionMapping$1 ) {

			 texture.mapping = CubeRefractionMapping$1;

		 }

		 return texture;

	 }

	 function get( texture ) {

		 if ( texture && texture.isTexture ) {

			 const mapping = texture.mapping;

			 if ( mapping === EquirectangularReflectionMapping$1 || mapping === EquirectangularRefractionMapping$1 ) {

				 if ( cubemaps.has( texture ) ) {

					 const cubemap = cubemaps.get( texture ).texture;
					 return mapTextureMapping( cubemap, texture.mapping );

				 } else {

					 const image = texture.image;

					 if ( image && image.height > 0 ) {

						 const currentRenderTarget = renderer.getRenderTarget();

						 const renderTarget = new WebGLCubeRenderTarget$1( image.height / 2 );
						 renderTarget.fromEquirectangularTexture( renderer, texture );
						 cubemaps.set( texture, renderTarget );

						 renderer.setRenderTarget( currentRenderTarget );

						 texture.addEventListener( 'dispose', onTextureDispose );

						 return mapTextureMapping( renderTarget.texture, texture.mapping );

					 } else {

						 // image not yet ready. try the conversion next frame

						 return null;

					 }

				 }

			 }

		 }

		 return texture;

	 }

	 function onTextureDispose( event ) {

		 const texture = event.target;

		 texture.removeEventListener( 'dispose', onTextureDispose );

		 const cubemap = cubemaps.get( texture );

		 if ( cubemap !== undefined ) {

			 cubemaps.delete( texture );
			 cubemap.dispose();

		 }

	 }

	 function dispose() {

		 cubemaps = new WeakMap();

	 }

	 return {
		 get: get,
		 dispose: dispose
	 };

 }

 function WebGLExtensions$1( gl ) {

	 const extensions = {};

	 function getExtension( name ) {

		 if ( extensions[ name ] !== undefined ) {

			 return extensions[ name ];

		 }

		 let extension;

		 switch ( name ) {

			 case 'WEBGL_depth_texture':
				 extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				 break;

			 case 'EXT_texture_filter_anisotropic':
				 extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				 break;

			 case 'WEBGL_compressed_texture_s3tc':
				 extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				 break;

			 case 'WEBGL_compressed_texture_pvrtc':
				 extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				 break;

			 default:
				 extension = gl.getExtension( name );

		 }

		 extensions[ name ] = extension;

		 return extension;

	 }

	 return {

		 has: function ( name ) {

			 return getExtension( name ) !== null;

		 },

		 init: function ( capabilities ) {

			 if ( capabilities.isWebGL2 ) {

				 getExtension( 'EXT_color_buffer_float' );

			 } else {

				 getExtension( 'WEBGL_depth_texture' );
				 getExtension( 'OES_texture_float' );
				 getExtension( 'OES_texture_half_float' );
				 getExtension( 'OES_texture_half_float_linear' );
				 getExtension( 'OES_standard_derivatives' );
				 getExtension( 'OES_element_index_uint' );
				 getExtension( 'OES_vertex_array_object' );
				 getExtension( 'ANGLE_instanced_arrays' );

			 }

			 getExtension( 'OES_texture_float_linear' );
			 getExtension( 'EXT_color_buffer_half_float' );

		 },

		 get: function ( name ) {

			 const extension = getExtension( name );

			 if ( extension === null ) {

				 console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			 }

			 return extension;

		 }

	 };

 }

 function WebGLGeometries$1( gl, attributes, info, bindingStates ) {

	 const geometries = {};
	 const wireframeAttributes = new WeakMap();

	 function onGeometryDispose( event ) {

		 const geometry = event.target;

		 if ( geometry.index !== null ) {

			 attributes.remove( geometry.index );

		 }

		 for ( const name in geometry.attributes ) {

			 attributes.remove( geometry.attributes[ name ] );

		 }

		 geometry.removeEventListener( 'dispose', onGeometryDispose );

		 delete geometries[ geometry.id ];

		 const attribute = wireframeAttributes.get( geometry );

		 if ( attribute ) {

			 attributes.remove( attribute );
			 wireframeAttributes.delete( geometry );

		 }

		 bindingStates.releaseStatesOfGeometry( geometry );

		 if ( geometry.isInstancedBufferGeometry === true ) {

			 delete geometry._maxInstanceCount;

		 }

		 //

		 info.memory.geometries --;

	 }

	 function get( object, geometry ) {

		 if ( geometries[ geometry.id ] === true ) return geometry;

		 geometry.addEventListener( 'dispose', onGeometryDispose );

		 geometries[ geometry.id ] = true;

		 info.memory.geometries ++;

		 return geometry;

	 }

	 function update( geometry ) {

		 const geometryAttributes = geometry.attributes;

		 // Updating index buffer in VAO now. See WebGLBindingStates.

		 for ( const name in geometryAttributes ) {

			 attributes.update( geometryAttributes[ name ], 34962 );

		 }

		 // morph targets

		 const morphAttributes = geometry.morphAttributes;

		 for ( const name in morphAttributes ) {

			 const array = morphAttributes[ name ];

			 for ( let i = 0, l = array.length; i < l; i ++ ) {

				 attributes.update( array[ i ], 34962 );

			 }

		 }

	 }

	 function updateWireframeAttribute( geometry ) {

		 const indices = [];

		 const geometryIndex = geometry.index;
		 const geometryPosition = geometry.attributes.position;
		 let version = 0;

		 if ( geometryIndex !== null ) {

			 const array = geometryIndex.array;
			 version = geometryIndex.version;

			 for ( let i = 0, l = array.length; i < l; i += 3 ) {

				 const a = array[ i + 0 ];
				 const b = array[ i + 1 ];
				 const c = array[ i + 2 ];

				 indices.push( a, b, b, c, c, a );

			 }

		 } else {

			 const array = geometryPosition.array;
			 version = geometryPosition.version;

			 for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				 const a = i + 0;
				 const b = i + 1;
				 const c = i + 2;

				 indices.push( a, b, b, c, c, a );

			 }

		 }

		 const attribute = new ( arrayMax$1( indices ) > 65535 ? Uint32BufferAttribute$1 : Uint16BufferAttribute$1 )( indices, 1 );
		 attribute.version = version;

		 // Updating index buffer in VAO now. See WebGLBindingStates

		 //

		 const previousAttribute = wireframeAttributes.get( geometry );

		 if ( previousAttribute ) attributes.remove( previousAttribute );

		 //

		 wireframeAttributes.set( geometry, attribute );

	 }

	 function getWireframeAttribute( geometry ) {

		 const currentAttribute = wireframeAttributes.get( geometry );

		 if ( currentAttribute ) {

			 const geometryIndex = geometry.index;

			 if ( geometryIndex !== null ) {

				 // if the attribute is obsolete, create a new one

				 if ( currentAttribute.version < geometryIndex.version ) {

					 updateWireframeAttribute( geometry );

				 }

			 }

		 } else {

			 updateWireframeAttribute( geometry );

		 }

		 return wireframeAttributes.get( geometry );

	 }

	 return {

		 get: get,
		 update: update,

		 getWireframeAttribute: getWireframeAttribute

	 };

 }

 function WebGLIndexedBufferRenderer$1( gl, extensions, info, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 let mode;

	 function setMode( value ) {

		 mode = value;

	 }

	 let type, bytesPerElement;

	 function setIndex( value ) {

		 type = value.type;
		 bytesPerElement = value.bytesPerElement;

	 }

	 function render( start, count ) {

		 gl.drawElements( mode, count, type, start * bytesPerElement );

		 info.update( count, mode, 1 );

	 }

	 function renderInstances( start, count, primcount ) {

		 if ( primcount === 0 ) return;

		 let extension, methodName;

		 if ( isWebGL2 ) {

			 extension = gl;
			 methodName = 'drawElementsInstanced';

		 } else {

			 extension = extensions.get( 'ANGLE_instanced_arrays' );
			 methodName = 'drawElementsInstancedANGLE';

			 if ( extension === null ) {

				 console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				 return;

			 }

		 }

		 extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		 info.update( count, mode, primcount );

	 }

	 //

	 this.setMode = setMode;
	 this.setIndex = setIndex;
	 this.render = render;
	 this.renderInstances = renderInstances;

 }

 function WebGLInfo$1( gl ) {

	 const memory = {
		 geometries: 0,
		 textures: 0
	 };

	 const render = {
		 frame: 0,
		 calls: 0,
		 triangles: 0,
		 points: 0,
		 lines: 0
	 };

	 function update( count, mode, instanceCount ) {

		 render.calls ++;

		 switch ( mode ) {

			 case 4:
				 render.triangles += instanceCount * ( count / 3 );
				 break;

			 case 1:
				 render.lines += instanceCount * ( count / 2 );
				 break;

			 case 3:
				 render.lines += instanceCount * ( count - 1 );
				 break;

			 case 2:
				 render.lines += instanceCount * count;
				 break;

			 case 0:
				 render.points += instanceCount * count;
				 break;

			 default:
				 console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				 break;

		 }

	 }

	 function reset() {

		 render.frame ++;
		 render.calls = 0;
		 render.triangles = 0;
		 render.points = 0;
		 render.lines = 0;

	 }

	 return {
		 memory: memory,
		 render: render,
		 programs: null,
		 autoReset: true,
		 reset: reset,
		 update: update
	 };

 }

 function numericalSort$1( a, b ) {

	 return a[ 0 ] - b[ 0 ];

 }

 function absNumericalSort$1( a, b ) {

	 return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

 }

 function WebGLMorphtargets$1( gl ) {

	 const influencesList = {};
	 const morphInfluences = new Float32Array( 8 );

	 const workInfluences = [];

	 for ( let i = 0; i < 8; i ++ ) {

		 workInfluences[ i ] = [ i, 0 ];

	 }

	 function update( object, geometry, material, program ) {

		 const objectInfluences = object.morphTargetInfluences;

		 // When object doesn't have morph target influences defined, we treat it as a 0-length array
		 // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		 const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		 let influences = influencesList[ geometry.id ];

		 if ( influences === undefined || influences.length !== length ) {

			 // initialise list

			 influences = [];

			 for ( let i = 0; i < length; i ++ ) {

				 influences[ i ] = [ i, 0 ];

			 }

			 influencesList[ geometry.id ] = influences;

		 }

		 // Collect influences

		 for ( let i = 0; i < length; i ++ ) {

			 const influence = influences[ i ];

			 influence[ 0 ] = i;
			 influence[ 1 ] = objectInfluences[ i ];

		 }

		 influences.sort( absNumericalSort$1 );

		 for ( let i = 0; i < 8; i ++ ) {

			 if ( i < length && influences[ i ][ 1 ] ) {

				 workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
				 workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

			 } else {

				 workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
				 workInfluences[ i ][ 1 ] = 0;

			 }

		 }

		 workInfluences.sort( numericalSort$1 );

		 const morphTargets = material.morphTargets && geometry.morphAttributes.position;
		 const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		 let morphInfluencesSum = 0;

		 for ( let i = 0; i < 8; i ++ ) {

			 const influence = workInfluences[ i ];
			 const index = influence[ 0 ];
			 const value = influence[ 1 ];

			 if ( index !== Number.MAX_SAFE_INTEGER && value ) {

				 if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

					 geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

				 }

				 if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

					 geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

				 }

				 morphInfluences[ i ] = value;
				 morphInfluencesSum += value;

			 } else {

				 if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

					 geometry.deleteAttribute( 'morphTarget' + i );

				 }

				 if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

					 geometry.deleteAttribute( 'morphNormal' + i );

				 }

				 morphInfluences[ i ] = 0;

			 }

		 }

		 // GLSL shader uses formula baseinfluence * base + sum(target * influence)
		 // This allows us to switch between absolute morphs and relative morphs without changing shader code
		 // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		 const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		 program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		 program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	 }

	 return {

		 update: update

	 };

 }

 function WebGLObjects$1( gl, geometries, attributes, info ) {

	 let updateMap = new WeakMap();

	 function update( object ) {

		 const frame = info.render.frame;

		 const geometry = object.geometry;
		 const buffergeometry = geometries.get( object, geometry );

		 // Update once per frame

		 if ( updateMap.get( buffergeometry ) !== frame ) {

			 geometries.update( buffergeometry );

			 updateMap.set( buffergeometry, frame );

		 }

		 if ( object.isInstancedMesh ) {

			 if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				 object.addEventListener( 'dispose', onInstancedMeshDispose );

			 }

			 attributes.update( object.instanceMatrix, 34962 );

			 if ( object.instanceColor !== null ) {

				 attributes.update( object.instanceColor, 34962 );

			 }

		 }

		 return buffergeometry;

	 }

	 function dispose() {

		 updateMap = new WeakMap();

	 }

	 function onInstancedMeshDispose( event ) {

		 const instancedMesh = event.target;

		 instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		 attributes.remove( instancedMesh.instanceMatrix );

		 if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	 }

	 return {

		 update: update,
		 dispose: dispose

	 };

 }

 class DataTexture2DArray$1 extends Texture$1 {

	 constructor( data = null, width = 1, height = 1, depth = 1 ) {

		 super( null );

		 this.image = { data, width, height, depth };

		 this.magFilter = NearestFilter$1;
		 this.minFilter = NearestFilter$1;

		 this.wrapR = ClampToEdgeWrapping$1;

		 this.generateMipmaps = false;
		 this.flipY = false;
		 this.unpackAlignment = 1;

		 this.needsUpdate = true;

	 }

 }

 DataTexture2DArray$1.prototype.isDataTexture2DArray = true;

 class DataTexture3D$1 extends Texture$1 {

	 constructor( data = null, width = 1, height = 1, depth = 1 ) {

		 // We're going to add .setXXX() methods for setting properties later.
		 // Users can still set in DataTexture3D directly.
		 //
		 //	const texture = new THREE.DataTexture3D( data, width, height, depth );
		 // 	texture.anisotropy = 16;
		 //
		 // See #14839

		 super( null );

		 this.image = { data, width, height, depth };

		 this.magFilter = NearestFilter$1;
		 this.minFilter = NearestFilter$1;

		 this.wrapR = ClampToEdgeWrapping$1;

		 this.generateMipmaps = false;
		 this.flipY = false;
		 this.unpackAlignment = 1;

		 this.needsUpdate = true;

	 }

 }

 DataTexture3D$1.prototype.isDataTexture3D = true;

 /**
	* Uniforms of a program.
	* Those form a tree structure with a special top-level container for the root,
	* which you get by calling 'new WebGLUniforms( gl, program )'.
	*
	*
	* Properties of inner nodes including the top-level container:
	*
	* .seq - array of nested uniforms
	* .map - nested uniforms by name
	*
	*
	* Methods of all nodes except the top-level container:
	*
	* .setValue( gl, value, [textures] )
	*
	* 		uploads a uniform value(s)
	*  	the 'textures' parameter is needed for sampler uniforms
	*
	*
	* Static methods of the top-level container (textures factorizations):
	*
	* .upload( gl, seq, values, textures )
	*
	* 		sets uniforms in 'seq' to 'values[id].value'
	*
	* .seqWithValue( seq, values ) : filteredSeq
	*
	* 		filters 'seq' entries with corresponding entry in values
	*
	*
	* Methods of the top-level container (textures factorizations):
	*
	* .setValue( gl, name, value, textures )
	*
	* 		sets uniform with  name 'name' to 'value'
	*
	* .setOptional( gl, obj, prop )
	*
	* 		like .set for an optional property of the object
	*
	*/

 const emptyTexture$1 = new Texture$1();
 const emptyTexture2dArray$1 = new DataTexture2DArray$1();
 const emptyTexture3d$1 = new DataTexture3D$1();
 const emptyCubeTexture$1 = new CubeTexture$1();

 // --- Utilities ---

 // Array Caches (provide typed arrays for temporary by size)

 const arrayCacheF32$1 = [];
 const arrayCacheI32$1 = [];

 // Float32Array caches used for uploading Matrix uniforms

 const mat4array$1 = new Float32Array( 16 );
 const mat3array$1 = new Float32Array( 9 );
 const mat2array$1 = new Float32Array( 4 );

 // Flattening for arrays of vectors and matrices

 function flatten$1( array, nBlocks, blockSize ) {

	 const firstElem = array[ 0 ];

	 if ( firstElem <= 0 || firstElem > 0 ) return array;
	 // unoptimized: ! isNaN( firstElem )
	 // see http://jacksondunstan.com/articles/983

	 const n = nBlocks * blockSize;
	 let r = arrayCacheF32$1[ n ];

	 if ( r === undefined ) {

		 r = new Float32Array( n );
		 arrayCacheF32$1[ n ] = r;

	 }

	 if ( nBlocks !== 0 ) {

		 firstElem.toArray( r, 0 );

		 for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			 offset += blockSize;
			 array[ i ].toArray( r, offset );

		 }

	 }

	 return r;

 }

 function arraysEqual$1( a, b ) {

	 if ( a.length !== b.length ) return false;

	 for ( let i = 0, l = a.length; i < l; i ++ ) {

		 if ( a[ i ] !== b[ i ] ) return false;

	 }

	 return true;

 }

 function copyArray$1( a, b ) {

	 for ( let i = 0, l = b.length; i < l; i ++ ) {

		 a[ i ] = b[ i ];

	 }

 }

 // Texture unit allocation

 function allocTexUnits$1( textures, n ) {

	 let r = arrayCacheI32$1[ n ];

	 if ( r === undefined ) {

		 r = new Int32Array( n );
		 arrayCacheI32$1[ n ] = r;

	 }

	 for ( let i = 0; i !== n; ++ i ) {

		 r[ i ] = textures.allocateTextureUnit();

	 }

	 return r;

 }

 // --- Setters ---

 // Note: Defining these methods externally, because they come in a bunch
 // and this way their names minify.

 // Single scalar

 function setValueV1f$1( gl, v ) {

	 const cache = this.cache;

	 if ( cache[ 0 ] === v ) return;

	 gl.uniform1f( this.addr, v );

	 cache[ 0 ] = v;

 }

 // Single float vector (from flat array or THREE.VectorN)

 function setValueV2f$1( gl, v ) {

	 const cache = this.cache;

	 if ( v.x !== undefined ) {

		 if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			 gl.uniform2f( this.addr, v.x, v.y );

			 cache[ 0 ] = v.x;
			 cache[ 1 ] = v.y;

		 }

	 } else {

		 if ( arraysEqual$1( cache, v ) ) return;

		 gl.uniform2fv( this.addr, v );

		 copyArray$1( cache, v );

	 }

 }

 function setValueV3f$1( gl, v ) {

	 const cache = this.cache;

	 if ( v.x !== undefined ) {

		 if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			 gl.uniform3f( this.addr, v.x, v.y, v.z );

			 cache[ 0 ] = v.x;
			 cache[ 1 ] = v.y;
			 cache[ 2 ] = v.z;

		 }

	 } else if ( v.r !== undefined ) {

		 if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			 gl.uniform3f( this.addr, v.r, v.g, v.b );

			 cache[ 0 ] = v.r;
			 cache[ 1 ] = v.g;
			 cache[ 2 ] = v.b;

		 }

	 } else {

		 if ( arraysEqual$1( cache, v ) ) return;

		 gl.uniform3fv( this.addr, v );

		 copyArray$1( cache, v );

	 }

 }

 function setValueV4f$1( gl, v ) {

	 const cache = this.cache;

	 if ( v.x !== undefined ) {

		 if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			 gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			 cache[ 0 ] = v.x;
			 cache[ 1 ] = v.y;
			 cache[ 2 ] = v.z;
			 cache[ 3 ] = v.w;

		 }

	 } else {

		 if ( arraysEqual$1( cache, v ) ) return;

		 gl.uniform4fv( this.addr, v );

		 copyArray$1( cache, v );

	 }

 }

 // Single matrix (from flat array or THREE.MatrixN)

 function setValueM2$1( gl, v ) {

	 const cache = this.cache;
	 const elements = v.elements;

	 if ( elements === undefined ) {

		 if ( arraysEqual$1( cache, v ) ) return;

		 gl.uniformMatrix2fv( this.addr, false, v );

		 copyArray$1( cache, v );

	 } else {

		 if ( arraysEqual$1( cache, elements ) ) return;

		 mat2array$1.set( elements );

		 gl.uniformMatrix2fv( this.addr, false, mat2array$1 );

		 copyArray$1( cache, elements );

	 }

 }

 function setValueM3$1( gl, v ) {

	 const cache = this.cache;
	 const elements = v.elements;

	 if ( elements === undefined ) {

		 if ( arraysEqual$1( cache, v ) ) return;

		 gl.uniformMatrix3fv( this.addr, false, v );

		 copyArray$1( cache, v );

	 } else {

		 if ( arraysEqual$1( cache, elements ) ) return;

		 mat3array$1.set( elements );

		 gl.uniformMatrix3fv( this.addr, false, mat3array$1 );

		 copyArray$1( cache, elements );

	 }

 }

 function setValueM4$1( gl, v ) {

	 const cache = this.cache;
	 const elements = v.elements;

	 if ( elements === undefined ) {

		 if ( arraysEqual$1( cache, v ) ) return;

		 gl.uniformMatrix4fv( this.addr, false, v );

		 copyArray$1( cache, v );

	 } else {

		 if ( arraysEqual$1( cache, elements ) ) return;

		 mat4array$1.set( elements );

		 gl.uniformMatrix4fv( this.addr, false, mat4array$1 );

		 copyArray$1( cache, elements );

	 }

 }

 // Single integer / boolean

 function setValueV1i$1( gl, v ) {

	 const cache = this.cache;

	 if ( cache[ 0 ] === v ) return;

	 gl.uniform1i( this.addr, v );

	 cache[ 0 ] = v;

 }

 // Single integer / boolean vector (from flat array)

 function setValueV2i$1( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual$1( cache, v ) ) return;

	 gl.uniform2iv( this.addr, v );

	 copyArray$1( cache, v );

 }

 function setValueV3i$1( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual$1( cache, v ) ) return;

	 gl.uniform3iv( this.addr, v );

	 copyArray$1( cache, v );

 }

 function setValueV4i$1( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual$1( cache, v ) ) return;

	 gl.uniform4iv( this.addr, v );

	 copyArray$1( cache, v );

 }

 // Single unsigned integer

 function setValueV1ui$1( gl, v ) {

	 const cache = this.cache;

	 if ( cache[ 0 ] === v ) return;

	 gl.uniform1ui( this.addr, v );

	 cache[ 0 ] = v;

 }

 // Single unsigned integer vector (from flat array)

 function setValueV2ui$1( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual$1( cache, v ) ) return;

	 gl.uniform2uiv( this.addr, v );

	 copyArray$1( cache, v );

 }

 function setValueV3ui$1( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual$1( cache, v ) ) return;

	 gl.uniform3uiv( this.addr, v );

	 copyArray$1( cache, v );

 }

 function setValueV4ui$1( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual$1( cache, v ) ) return;

	 gl.uniform4uiv( this.addr, v );

	 copyArray$1( cache, v );

 }


 // Single texture (2D / Cube)

 function setValueT1$1( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.safeSetTexture2D( v || emptyTexture$1, unit );

 }

 function setValueT3D1$1( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.setTexture3D( v || emptyTexture3d$1, unit );

 }

 function setValueT6$1( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.safeSetTextureCube( v || emptyCubeTexture$1, unit );

 }

 function setValueT2DArray1$1( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.setTexture2DArray( v || emptyTexture2dArray$1, unit );

 }

 // Helper to pick the right setter for the singular case

 function getSingularSetter$1( type ) {

	 switch ( type ) {

		 case 0x1406: return setValueV1f$1; // FLOAT
		 case 0x8b50: return setValueV2f$1; // _VEC2
		 case 0x8b51: return setValueV3f$1; // _VEC3
		 case 0x8b52: return setValueV4f$1; // _VEC4

		 case 0x8b5a: return setValueM2$1; // _MAT2
		 case 0x8b5b: return setValueM3$1; // _MAT3
		 case 0x8b5c: return setValueM4$1; // _MAT4

		 case 0x1404: case 0x8b56: return setValueV1i$1; // INT, BOOL
		 case 0x8b53: case 0x8b57: return setValueV2i$1; // _VEC2
		 case 0x8b54: case 0x8b58: return setValueV3i$1; // _VEC3
		 case 0x8b55: case 0x8b59: return setValueV4i$1; // _VEC4

		 case 0x1405: return setValueV1ui$1; // UINT
		 case 0x8dc6: return setValueV2ui$1; // _VEC2
		 case 0x8dc7: return setValueV3ui$1; // _VEC3
		 case 0x8dc8: return setValueV4ui$1; // _VEC4

		 case 0x8b5e: // SAMPLER_2D
		 case 0x8d66: // SAMPLER_EXTERNAL_OES
		 case 0x8dca: // INT_SAMPLER_2D
		 case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		 case 0x8b62: // SAMPLER_2D_SHADOW
			 return setValueT1$1;

		 case 0x8b5f: // SAMPLER_3D
		 case 0x8dcb: // INT_SAMPLER_3D
		 case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			 return setValueT3D1$1;

		 case 0x8b60: // SAMPLER_CUBE
		 case 0x8dcc: // INT_SAMPLER_CUBE
		 case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		 case 0x8dc5: // SAMPLER_CUBE_SHADOW
			 return setValueT6$1;

		 case 0x8dc1: // SAMPLER_2D_ARRAY
		 case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		 case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		 case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			 return setValueT2DArray1$1;

	 }

 }


 // Array of scalars

 function setValueV1fArray$1( gl, v ) {

	 gl.uniform1fv( this.addr, v );

 }

 // Array of vectors (from flat array or array of THREE.VectorN)

 function setValueV2fArray$1( gl, v ) {

	 const data = flatten$1( v, this.size, 2 );

	 gl.uniform2fv( this.addr, data );

 }

 function setValueV3fArray$1( gl, v ) {

	 const data = flatten$1( v, this.size, 3 );

	 gl.uniform3fv( this.addr, data );

 }

 function setValueV4fArray$1( gl, v ) {

	 const data = flatten$1( v, this.size, 4 );

	 gl.uniform4fv( this.addr, data );

 }

 // Array of matrices (from flat array or array of THREE.MatrixN)

 function setValueM2Array$1( gl, v ) {

	 const data = flatten$1( v, this.size, 4 );

	 gl.uniformMatrix2fv( this.addr, false, data );

 }

 function setValueM3Array$1( gl, v ) {

	 const data = flatten$1( v, this.size, 9 );

	 gl.uniformMatrix3fv( this.addr, false, data );

 }

 function setValueM4Array$1( gl, v ) {

	 const data = flatten$1( v, this.size, 16 );

	 gl.uniformMatrix4fv( this.addr, false, data );

 }

 // Array of integer / boolean

 function setValueV1iArray$1( gl, v ) {

	 gl.uniform1iv( this.addr, v );

 }

 // Array of integer / boolean vectors (from flat array)

 function setValueV2iArray$1( gl, v ) {

	 gl.uniform2iv( this.addr, v );

 }

 function setValueV3iArray$1( gl, v ) {

	 gl.uniform3iv( this.addr, v );

 }

 function setValueV4iArray$1( gl, v ) {

	 gl.uniform4iv( this.addr, v );

 }

 // Array of unsigned integer

 function setValueV1uiArray$1( gl, v ) {

	 gl.uniform1uiv( this.addr, v );

 }

 // Array of unsigned integer vectors (from flat array)

 function setValueV2uiArray$1( gl, v ) {

	 gl.uniform2uiv( this.addr, v );

 }

 function setValueV3uiArray$1( gl, v ) {

	 gl.uniform3uiv( this.addr, v );

 }

 function setValueV4uiArray$1( gl, v ) {

	 gl.uniform4uiv( this.addr, v );

 }


 // Array of textures (2D / Cube)

 function setValueT1Array$1( gl, v, textures ) {

	 const n = v.length;

	 const units = allocTexUnits$1( textures, n );

	 gl.uniform1iv( this.addr, units );

	 for ( let i = 0; i !== n; ++ i ) {

		 textures.safeSetTexture2D( v[ i ] || emptyTexture$1, units[ i ] );

	 }

 }

 function setValueT6Array$1( gl, v, textures ) {

	 const n = v.length;

	 const units = allocTexUnits$1( textures, n );

	 gl.uniform1iv( this.addr, units );

	 for ( let i = 0; i !== n; ++ i ) {

		 textures.safeSetTextureCube( v[ i ] || emptyCubeTexture$1, units[ i ] );

	 }

 }

 // Helper to pick the right setter for a pure (bottom-level) array

 function getPureArraySetter$1( type ) {

	 switch ( type ) {

		 case 0x1406: return setValueV1fArray$1; // FLOAT
		 case 0x8b50: return setValueV2fArray$1; // _VEC2
		 case 0x8b51: return setValueV3fArray$1; // _VEC3
		 case 0x8b52: return setValueV4fArray$1; // _VEC4

		 case 0x8b5a: return setValueM2Array$1; // _MAT2
		 case 0x8b5b: return setValueM3Array$1; // _MAT3
		 case 0x8b5c: return setValueM4Array$1; // _MAT4

		 case 0x1404: case 0x8b56: return setValueV1iArray$1; // INT, BOOL
		 case 0x8b53: case 0x8b57: return setValueV2iArray$1; // _VEC2
		 case 0x8b54: case 0x8b58: return setValueV3iArray$1; // _VEC3
		 case 0x8b55: case 0x8b59: return setValueV4iArray$1; // _VEC4

		 case 0x1405: return setValueV1uiArray$1; // UINT
		 case 0x8dc6: return setValueV2uiArray$1; // _VEC2
		 case 0x8dc7: return setValueV3uiArray$1; // _VEC3
		 case 0x8dc8: return setValueV4uiArray$1; // _VEC4

		 case 0x8b5e: // SAMPLER_2D
		 case 0x8d66: // SAMPLER_EXTERNAL_OES
		 case 0x8dca: // INT_SAMPLER_2D
		 case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		 case 0x8b62: // SAMPLER_2D_SHADOW
			 return setValueT1Array$1;

		 case 0x8b60: // SAMPLER_CUBE
		 case 0x8dcc: // INT_SAMPLER_CUBE
		 case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		 case 0x8dc5: // SAMPLER_CUBE_SHADOW
			 return setValueT6Array$1;

	 }

 }

 // --- Uniform Classes ---

 function SingleUniform$1( id, activeInfo, addr ) {

	 this.id = id;
	 this.addr = addr;
	 this.cache = [];
	 this.setValue = getSingularSetter$1( activeInfo.type );

	 // this.path = activeInfo.name; // DEBUG

 }

 function PureArrayUniform$1( id, activeInfo, addr ) {

	 this.id = id;
	 this.addr = addr;
	 this.cache = [];
	 this.size = activeInfo.size;
	 this.setValue = getPureArraySetter$1( activeInfo.type );

	 // this.path = activeInfo.name; // DEBUG

 }

 PureArrayUniform$1.prototype.updateCache = function ( data ) {

	 const cache = this.cache;

	 if ( data instanceof Float32Array && cache.length !== data.length ) {

		 this.cache = new Float32Array( data.length );

	 }

	 copyArray$1( cache, data );

 };

 function StructuredUniform$1( id ) {

	 this.id = id;

	 this.seq = [];
	 this.map = {};

 }

 StructuredUniform$1.prototype.setValue = function ( gl, value, textures ) {

	 const seq = this.seq;

	 for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		 const u = seq[ i ];
		 u.setValue( gl, value[ u.id ], textures );

	 }

 };

 // --- Top-level ---

 // Parser - builds up the property tree from the path strings

 const RePathPart$1 = /(\w+)(\])?(\[|\.)?/g;

 // extracts
 // 	- the identifier (member name or array index)
 //  - followed by an optional right bracket (found when array index)
 //  - followed by an optional left bracket or dot (type of subscript)
 //
 // Note: These portions can be read in a non-overlapping fashion and
 // allow straightforward parsing of the hierarchy that WebGL encodes
 // in the uniform names.

 function addUniform$1( container, uniformObject ) {

	 container.seq.push( uniformObject );
	 container.map[ uniformObject.id ] = uniformObject;

 }

 function parseUniform$1( activeInfo, addr, container ) {

	 const path = activeInfo.name,
		 pathLength = path.length;

	 // reset RegExp object, because of the early exit of a previous run
	 RePathPart$1.lastIndex = 0;

	 while ( true ) {

		 const match = RePathPart$1.exec( path ),
			 matchEnd = RePathPart$1.lastIndex;

		 let id = match[ 1 ];
		 const idIsIndex = match[ 2 ] === ']',
			 subscript = match[ 3 ];

		 if ( idIsIndex ) id = id | 0; // convert to integer

		 if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			 // bare name or "pure" bottom-level array "[0]" suffix

			 addUniform$1( container, subscript === undefined ?
				 new SingleUniform$1( id, activeInfo, addr ) :
				 new PureArrayUniform$1( id, activeInfo, addr ) );

			 break;

		 } else {

			 // step into inner node / create it in case it doesn't exist

			 const map = container.map;
			 let next = map[ id ];

			 if ( next === undefined ) {

				 next = new StructuredUniform$1( id );
				 addUniform$1( container, next );

			 }

			 container = next;

		 }

	 }

 }

 // Root Container

 function WebGLUniforms$1( gl, program ) {

	 this.seq = [];
	 this.map = {};

	 const n = gl.getProgramParameter( program, 35718 );

	 for ( let i = 0; i < n; ++ i ) {

		 const info = gl.getActiveUniform( program, i ),
			 addr = gl.getUniformLocation( program, info.name );

		 parseUniform$1( info, addr, this );

	 }

 }

 WebGLUniforms$1.prototype.setValue = function ( gl, name, value, textures ) {

	 const u = this.map[ name ];

	 if ( u !== undefined ) u.setValue( gl, value, textures );

 };

 WebGLUniforms$1.prototype.setOptional = function ( gl, object, name ) {

	 const v = object[ name ];

	 if ( v !== undefined ) this.setValue( gl, name, v );

 };


 // Static interface

 WebGLUniforms$1.upload = function ( gl, seq, values, textures ) {

	 for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		 const u = seq[ i ],
			 v = values[ u.id ];

		 if ( v.needsUpdate !== false ) {

			 // note: always updating when .needsUpdate is undefined
			 u.setValue( gl, v.value, textures );

		 }

	 }

 };

 WebGLUniforms$1.seqWithValue = function ( seq, values ) {

	 const r = [];

	 for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		 const u = seq[ i ];
		 if ( u.id in values ) r.push( u );

	 }

	 return r;

 };

 function WebGLShader$1( gl, type, string ) {

	 const shader = gl.createShader( type );

	 gl.shaderSource( shader, string );
	 gl.compileShader( shader );

	 return shader;

 }

 let programIdCount$1 = 0;

 function addLineNumbers$1( string ) {

	 const lines = string.split( '\n' );

	 for ( let i = 0; i < lines.length; i ++ ) {

		 lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	 }

	 return lines.join( '\n' );

 }

 function getEncodingComponents$1( encoding ) {

	 switch ( encoding ) {

		 case LinearEncoding$1:
			 return [ 'Linear', '( value )' ];
		 case sRGBEncoding$1:
			 return [ 'sRGB', '( value )' ];
		 case RGBEEncoding$1:
			 return [ 'RGBE', '( value )' ];
		 case RGBM7Encoding$1:
			 return [ 'RGBM', '( value, 7.0 )' ];
		 case RGBM16Encoding$1:
			 return [ 'RGBM', '( value, 16.0 )' ];
		 case RGBDEncoding$1:
			 return [ 'RGBD', '( value, 256.0 )' ];
		 case GammaEncoding$1:
			 return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		 case LogLuvEncoding$1:
			 return [ 'LogLuv', '( value )' ];
		 default:
			 console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			 return [ 'Linear', '( value )' ];

	 }

 }

 function getShaderErrors$1( gl, shader, type ) {

	 const status = gl.getShaderParameter( shader, 35713 );
	 const log = gl.getShaderInfoLog( shader ).trim();

	 if ( status && log === '' ) return '';

	 // --enable-privileged-webgl-extension
	 // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	 const source = gl.getShaderSource( shader );

	 return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers$1( source );

 }

 function getTexelDecodingFunction$1( functionName, encoding ) {

	 const components = getEncodingComponents$1( encoding );
	 return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

 }

 function getTexelEncodingFunction$1( functionName, encoding ) {

	 const components = getEncodingComponents$1( encoding );
	 return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

 }

 function getToneMappingFunction$1( functionName, toneMapping ) {

	 let toneMappingName;

	 switch ( toneMapping ) {

		 case LinearToneMapping$1:
			 toneMappingName = 'Linear';
			 break;

		 case ReinhardToneMapping$1:
			 toneMappingName = 'Reinhard';
			 break;

		 case CineonToneMapping$1:
			 toneMappingName = 'OptimizedCineon';
			 break;

		 case ACESFilmicToneMapping$1:
			 toneMappingName = 'ACESFilmic';
			 break;

		 case CustomToneMapping$1:
			 toneMappingName = 'Custom';
			 break;

		 default:
			 console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			 toneMappingName = 'Linear';

	 }

	 return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

 }

 function generateExtensions$1( parameters ) {

	 const chunks = [
		 ( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		 ( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		 ( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		 ( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0 ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	 ];

	 return chunks.filter( filterEmptyLine$1 ).join( '\n' );

 }

 function generateDefines$1( defines ) {

	 const chunks = [];

	 for ( const name in defines ) {

		 const value = defines[ name ];

		 if ( value === false ) continue;

		 chunks.push( '#define ' + name + ' ' + value );

	 }

	 return chunks.join( '\n' );

 }

 function fetchAttributeLocations$1( gl, program ) {

	 const attributes = {};

	 const n = gl.getProgramParameter( program, 35721 );

	 for ( let i = 0; i < n; i ++ ) {

		 const info = gl.getActiveAttrib( program, i );
		 const name = info.name;

		 // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		 attributes[ name ] = gl.getAttribLocation( program, name );

	 }

	 return attributes;

 }

 function filterEmptyLine$1( string ) {

	 return string !== '';

 }

 function replaceLightNums$1( string, parameters ) {

	 return string
		 .replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		 .replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		 .replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		 .replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		 .replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		 .replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		 .replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		 .replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

 }

 function replaceClippingPlaneNums$1( string, parameters ) {

	 return string
		 .replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		 .replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

 }

 // Resolve Includes

 const includePattern$1 = /^[ \t]*#include +<([\w\d./]+)>/gm;

 function resolveIncludes$1( string ) {

	 return string.replace( includePattern$1, includeReplacer$1 );

 }

 function includeReplacer$1( match, include ) {

	 const string = ShaderChunk$1[ include ];

	 if ( string === undefined ) {

		 throw new Error( 'Can not resolve #include <' + include + '>' );

	 }

	 return resolveIncludes$1( string );

 }

 // Unroll Loops

 const deprecatedUnrollLoopPattern$1 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
 const unrollLoopPattern$1 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

 function unrollLoops$1( string ) {

	 return string
		 .replace( unrollLoopPattern$1, loopReplacer$1 )
		 .replace( deprecatedUnrollLoopPattern$1, deprecatedLoopReplacer$1 );

 }

 function deprecatedLoopReplacer$1( match, start, end, snippet ) {

	 console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	 return loopReplacer$1( match, start, end, snippet );

 }

 function loopReplacer$1( match, start, end, snippet ) {

	 let string = '';

	 for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		 string += snippet
			 .replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			 .replace( /UNROLLED_LOOP_INDEX/g, i );

	 }

	 return string;

 }

 //

 function generatePrecision$1( parameters ) {

	 let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	 if ( parameters.precision === 'highp' ) {

		 precisionstring += '\n#define HIGH_PRECISION';

	 } else if ( parameters.precision === 'mediump' ) {

		 precisionstring += '\n#define MEDIUM_PRECISION';

	 } else if ( parameters.precision === 'lowp' ) {

		 precisionstring += '\n#define LOW_PRECISION';

	 }

	 return precisionstring;

 }

 function generateShadowMapTypeDefine$1( parameters ) {

	 let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	 if ( parameters.shadowMapType === PCFShadowMap$1 ) {

		 shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	 } else if ( parameters.shadowMapType === PCFSoftShadowMap$1 ) {

		 shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	 } else if ( parameters.shadowMapType === VSMShadowMap$1 ) {

		 shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	 }

	 return shadowMapTypeDefine;

 }

 function generateEnvMapTypeDefine$1( parameters ) {

	 let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	 if ( parameters.envMap ) {

		 switch ( parameters.envMapMode ) {

			 case CubeReflectionMapping$1:
			 case CubeRefractionMapping$1:
				 envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				 break;

			 case CubeUVReflectionMapping$1:
			 case CubeUVRefractionMapping$1:
				 envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				 break;

		 }

	 }

	 return envMapTypeDefine;

 }

 function generateEnvMapModeDefine$1( parameters ) {

	 let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	 if ( parameters.envMap ) {

		 switch ( parameters.envMapMode ) {

			 case CubeRefractionMapping$1:
			 case CubeUVRefractionMapping$1:

				 envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				 break;

		 }

	 }

	 return envMapModeDefine;

 }

 function generateEnvMapBlendingDefine$1( parameters ) {

	 let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	 if ( parameters.envMap ) {

		 switch ( parameters.combine ) {

			 case MultiplyOperation$1:
				 envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				 break;

			 case MixOperation$1:
				 envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				 break;

			 case AddOperation$1:
				 envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				 break;

		 }

	 }

	 return envMapBlendingDefine;

 }

 function WebGLProgram$1( renderer, cacheKey, parameters, bindingStates ) {

	 const gl = renderer.getContext();

	 const defines = parameters.defines;

	 let vertexShader = parameters.vertexShader;
	 let fragmentShader = parameters.fragmentShader;

	 const shadowMapTypeDefine = generateShadowMapTypeDefine$1( parameters );
	 const envMapTypeDefine = generateEnvMapTypeDefine$1( parameters );
	 const envMapModeDefine = generateEnvMapModeDefine$1( parameters );
	 const envMapBlendingDefine = generateEnvMapBlendingDefine$1( parameters );


	 const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	 const customExtensions = parameters.isWebGL2 ? '' : generateExtensions$1( parameters );

	 const customDefines = generateDefines$1( defines );

	 const program = gl.createProgram();

	 let prefixVertex, prefixFragment;
	 let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	 if ( parameters.isRawShaderMaterial ) {

		 prefixVertex = [

			 customDefines

		 ].filter( filterEmptyLine$1 ).join( '\n' );

		 if ( prefixVertex.length > 0 ) {

			 prefixVertex += '\n';

		 }

		 prefixFragment = [

			 customExtensions,
			 customDefines

		 ].filter( filterEmptyLine$1 ).join( '\n' );

		 if ( prefixFragment.length > 0 ) {

			 prefixFragment += '\n';

		 }

	 } else {

		 prefixVertex = [

			 generatePrecision$1( parameters ),

			 '#define SHADER_NAME ' + parameters.shaderName,

			 customDefines,

			 parameters.instancing ? '#define USE_INSTANCING' : '',
			 parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			 parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			 '#define GAMMA_FACTOR ' + gammaFactorDefine,

			 '#define MAX_BONES ' + parameters.maxBones,
			 ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			 ( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			 parameters.map ? '#define USE_MAP' : '',
			 parameters.envMap ? '#define USE_ENVMAP' : '',
			 parameters.envMap ? '#define ' + envMapModeDefine : '',
			 parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			 parameters.aoMap ? '#define USE_AOMAP' : '',
			 parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			 parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			 parameters.normalMap ? '#define USE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			 parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			 parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			 parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			 parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			 parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			 parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			 parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			 parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			 parameters.transmission ? '#define USE_TRANSMISSION' : '',
			 parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			 parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			 parameters.vertexTangents ? '#define USE_TANGENT' : '',
			 parameters.vertexColors ? '#define USE_COLOR' : '',
			 parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			 parameters.vertexUvs ? '#define USE_UV' : '',
			 parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			 parameters.flatShading ? '#define FLAT_SHADED' : '',

			 parameters.skinning ? '#define USE_SKINNING' : '',
			 parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			 parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			 parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			 parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			 parameters.flipSided ? '#define FLIP_SIDED' : '',

			 parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			 parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			 parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			 parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			 ( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			 'uniform mat4 modelMatrix;',
			 'uniform mat4 modelViewMatrix;',
			 'uniform mat4 projectionMatrix;',
			 'uniform mat4 viewMatrix;',
			 'uniform mat3 normalMatrix;',
			 'uniform vec3 cameraPosition;',
			 'uniform bool isOrthographic;',

			 '#ifdef USE_INSTANCING',

			 '	attribute mat4 instanceMatrix;',

			 '#endif',

			 '#ifdef USE_INSTANCING_COLOR',

			 '	attribute vec3 instanceColor;',

			 '#endif',

			 'attribute vec3 position;',
			 'attribute vec3 normal;',
			 'attribute vec2 uv;',

			 '#ifdef USE_TANGENT',

			 '	attribute vec4 tangent;',

			 '#endif',

			 '#if defined( USE_COLOR_ALPHA )',

			 '	attribute vec4 color;',

			 '#elif defined( USE_COLOR )',

			 '	attribute vec3 color;',

			 '#endif',

			 '#ifdef USE_MORPHTARGETS',

			 '	attribute vec3 morphTarget0;',
			 '	attribute vec3 morphTarget1;',
			 '	attribute vec3 morphTarget2;',
			 '	attribute vec3 morphTarget3;',

			 '	#ifdef USE_MORPHNORMALS',

			 '		attribute vec3 morphNormal0;',
			 '		attribute vec3 morphNormal1;',
			 '		attribute vec3 morphNormal2;',
			 '		attribute vec3 morphNormal3;',

			 '	#else',

			 '		attribute vec3 morphTarget4;',
			 '		attribute vec3 morphTarget5;',
			 '		attribute vec3 morphTarget6;',
			 '		attribute vec3 morphTarget7;',

			 '	#endif',

			 '#endif',

			 '#ifdef USE_SKINNING',

			 '	attribute vec4 skinIndex;',
			 '	attribute vec4 skinWeight;',

			 '#endif',

			 '\n'

		 ].filter( filterEmptyLine$1 ).join( '\n' );

		 prefixFragment = [

			 customExtensions,

			 generatePrecision$1( parameters ),

			 '#define SHADER_NAME ' + parameters.shaderName,

			 customDefines,

			 parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			 '#define GAMMA_FACTOR ' + gammaFactorDefine,

			 ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			 ( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			 parameters.map ? '#define USE_MAP' : '',
			 parameters.matcap ? '#define USE_MATCAP' : '',
			 parameters.envMap ? '#define USE_ENVMAP' : '',
			 parameters.envMap ? '#define ' + envMapTypeDefine : '',
			 parameters.envMap ? '#define ' + envMapModeDefine : '',
			 parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			 parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			 parameters.aoMap ? '#define USE_AOMAP' : '',
			 parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			 parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			 parameters.normalMap ? '#define USE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			 parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			 parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			 parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			 parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			 parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			 parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			 parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			 parameters.sheen ? '#define USE_SHEEN' : '',
			 parameters.transmission ? '#define USE_TRANSMISSION' : '',
			 parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			 parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			 parameters.vertexTangents ? '#define USE_TANGENT' : '',
			 parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			 parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			 parameters.vertexUvs ? '#define USE_UV' : '',
			 parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			 parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			 parameters.flatShading ? '#define FLAT_SHADED' : '',

			 parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			 parameters.flipSided ? '#define FLIP_SIDED' : '',

			 parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			 parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			 parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			 parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			 parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			 ( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			 ( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			 'uniform mat4 viewMatrix;',
			 'uniform vec3 cameraPosition;',
			 'uniform bool isOrthographic;',

			 ( parameters.toneMapping !== NoToneMapping$1 ) ? '#define TONE_MAPPING' : '',
			 ( parameters.toneMapping !== NoToneMapping$1 ) ? ShaderChunk$1[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			 ( parameters.toneMapping !== NoToneMapping$1 ) ? getToneMappingFunction$1( 'toneMapping', parameters.toneMapping ) : '',

			 parameters.dithering ? '#define DITHERING' : '',

			 ShaderChunk$1[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			 parameters.map ? getTexelDecodingFunction$1( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			 parameters.matcap ? getTexelDecodingFunction$1( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			 parameters.envMap ? getTexelDecodingFunction$1( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			 parameters.emissiveMap ? getTexelDecodingFunction$1( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			 parameters.lightMap ? getTexelDecodingFunction$1( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			 getTexelEncodingFunction$1( 'linearToOutputTexel', parameters.outputEncoding ),

			 parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			 '\n'

		 ].filter( filterEmptyLine$1 ).join( '\n' );

	 }

	 vertexShader = resolveIncludes$1( vertexShader );
	 vertexShader = replaceLightNums$1( vertexShader, parameters );
	 vertexShader = replaceClippingPlaneNums$1( vertexShader, parameters );

	 fragmentShader = resolveIncludes$1( fragmentShader );
	 fragmentShader = replaceLightNums$1( fragmentShader, parameters );
	 fragmentShader = replaceClippingPlaneNums$1( fragmentShader, parameters );

	 vertexShader = unrollLoops$1( vertexShader );
	 fragmentShader = unrollLoops$1( fragmentShader );

	 if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		 // GLSL 3.0 conversion for built-in materials and ShaderMaterial

		 versionString = '#version 300 es\n';

		 prefixVertex = [
			 '#define attribute in',
			 '#define varying out',
			 '#define texture2D texture'
		 ].join( '\n' ) + '\n' + prefixVertex;

		 prefixFragment = [
			 '#define varying in',
			 ( parameters.glslVersion === GLSL3$1 ) ? '' : 'out highp vec4 pc_fragColor;',
			 ( parameters.glslVersion === GLSL3$1 ) ? '' : '#define gl_FragColor pc_fragColor',
			 '#define gl_FragDepthEXT gl_FragDepth',
			 '#define texture2D texture',
			 '#define textureCube texture',
			 '#define texture2DProj textureProj',
			 '#define texture2DLodEXT textureLod',
			 '#define texture2DProjLodEXT textureProjLod',
			 '#define textureCubeLodEXT textureLod',
			 '#define texture2DGradEXT textureGrad',
			 '#define texture2DProjGradEXT textureProjGrad',
			 '#define textureCubeGradEXT textureGrad'
		 ].join( '\n' ) + '\n' + prefixFragment;

	 }

	 const vertexGlsl = versionString + prefixVertex + vertexShader;
	 const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	 // console.log( '*VERTEX*', vertexGlsl );
	 // console.log( '*FRAGMENT*', fragmentGlsl );

	 const glVertexShader = WebGLShader$1( gl, 35633, vertexGlsl );
	 const glFragmentShader = WebGLShader$1( gl, 35632, fragmentGlsl );

	 gl.attachShader( program, glVertexShader );
	 gl.attachShader( program, glFragmentShader );

	 // Force a particular attribute to index 0.

	 if ( parameters.index0AttributeName !== undefined ) {

		 gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	 } else if ( parameters.morphTargets === true ) {

		 // programs with morphTargets displace position out of attribute 0
		 gl.bindAttribLocation( program, 0, 'position' );

	 }

	 gl.linkProgram( program );

	 // check for link errors
	 if ( renderer.debug.checkShaderErrors ) {

		 const programLog = gl.getProgramInfoLog( program ).trim();
		 const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		 const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		 let runnable = true;
		 let haveDiagnostics = true;

		 if ( gl.getProgramParameter( program, 35714 ) === false ) {

			 runnable = false;

			 const vertexErrors = getShaderErrors$1( gl, glVertexShader, 'vertex' );
			 const fragmentErrors = getShaderErrors$1( gl, glFragmentShader, 'fragment' );

			 console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		 } else if ( programLog !== '' ) {

			 console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		 } else if ( vertexLog === '' || fragmentLog === '' ) {

			 haveDiagnostics = false;

		 }

		 if ( haveDiagnostics ) {

			 this.diagnostics = {

				 runnable: runnable,

				 programLog: programLog,

				 vertexShader: {

					 log: vertexLog,
					 prefix: prefixVertex

				 },

				 fragmentShader: {

					 log: fragmentLog,
					 prefix: prefixFragment

				 }

			 };

		 }

	 }

	 // Clean up

	 // Crashes in iOS9 and iOS10. #18402
	 // gl.detachShader( program, glVertexShader );
	 // gl.detachShader( program, glFragmentShader );

	 gl.deleteShader( glVertexShader );
	 gl.deleteShader( glFragmentShader );

	 // set up caching for uniform locations

	 let cachedUniforms;

	 this.getUniforms = function () {

		 if ( cachedUniforms === undefined ) {

			 cachedUniforms = new WebGLUniforms$1( gl, program );

		 }

		 return cachedUniforms;

	 };

	 // set up caching for attribute locations

	 let cachedAttributes;

	 this.getAttributes = function () {

		 if ( cachedAttributes === undefined ) {

			 cachedAttributes = fetchAttributeLocations$1( gl, program );

		 }

		 return cachedAttributes;

	 };

	 // free resource

	 this.destroy = function () {

		 bindingStates.releaseStatesOfProgram( this );

		 gl.deleteProgram( program );
		 this.program = undefined;

	 };

	 //

	 this.name = parameters.shaderName;
	 this.id = programIdCount$1 ++;
	 this.cacheKey = cacheKey;
	 this.usedTimes = 1;
	 this.program = program;
	 this.vertexShader = glVertexShader;
	 this.fragmentShader = glFragmentShader;

	 return this;

 }

 function WebGLPrograms$1( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

	 const programs = [];

	 const isWebGL2 = capabilities.isWebGL2;
	 const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	 const floatVertexTextures = capabilities.floatVertexTextures;
	 const maxVertexUniforms = capabilities.maxVertexUniforms;
	 const vertexTextures = capabilities.vertexTextures;

	 let precision = capabilities.precision;

	 const shaderIDs = {
		 MeshDepthMaterial: 'depth',
		 MeshDistanceMaterial: 'distanceRGBA',
		 MeshNormalMaterial: 'normal',
		 MeshBasicMaterial: 'basic',
		 MeshLambertMaterial: 'lambert',
		 MeshPhongMaterial: 'phong',
		 MeshToonMaterial: 'toon',
		 MeshStandardMaterial: 'physical',
		 MeshPhysicalMaterial: 'physical',
		 MeshMatcapMaterial: 'matcap',
		 LineBasicMaterial: 'basic',
		 LineDashedMaterial: 'dashed',
		 PointsMaterial: 'points',
		 ShadowMaterial: 'shadow',
		 SpriteMaterial: 'sprite'
	 };

	 const parameterNames = [
		 'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
		 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
		 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
		 'roughnessMap', 'metalnessMap', 'gradientMap',
		 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
		 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
		 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',
		 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
		 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
		 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
		 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
		 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'
	 ];

	 function getMaxBones( object ) {

		 const skeleton = object.skeleton;
		 const bones = skeleton.bones;

		 if ( floatVertexTextures ) {

			 return 1024;

		 } else {

			 // default for when object is not specified
			 // ( for example when prebuilding shader to be used with multiple objects )
			 //
			 //  - leave some extra space for other uniforms
			 //  - limit here is ANGLE's 254 max uniform vectors
			 //    (up to 54 should be safe)

			 const nVertexUniforms = maxVertexUniforms;
			 const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			 const maxBones = Math.min( nVertexMatrices, bones.length );

			 if ( maxBones < bones.length ) {

				 console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				 return 0;

			 }

			 return maxBones;

		 }

	 }

	 function getTextureEncodingFromMap( map ) {

		 let encoding;

		 if ( map && map.isTexture ) {

			 encoding = map.encoding;

		 } else if ( map && map.isWebGLRenderTarget ) {

			 console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
			 encoding = map.texture.encoding;

		 } else {

			 encoding = LinearEncoding$1;

		 }

		 return encoding;

	 }

	 function getParameters( material, lights, shadows, scene, object ) {

		 const fog = scene.fog;
		 const environment = material.isMeshStandardMaterial ? scene.environment : null;

		 const envMap = cubemaps.get( material.envMap || environment );

		 const shaderID = shaderIDs[ material.type ];

		 // heuristics to create shader parameters according to lights in the scene
		 // (not to blow over maxLights budget)

		 const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		 if ( material.precision !== null ) {

			 precision = capabilities.getMaxPrecision( material.precision );

			 if ( precision !== material.precision ) {

				 console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			 }

		 }

		 let vertexShader, fragmentShader;

		 if ( shaderID ) {

			 const shader = ShaderLib$1[ shaderID ];

			 vertexShader = shader.vertexShader;
			 fragmentShader = shader.fragmentShader;

		 } else {

			 vertexShader = material.vertexShader;
			 fragmentShader = material.fragmentShader;

		 }

		 const currentRenderTarget = renderer.getRenderTarget();

		 const parameters = {

			 isWebGL2: isWebGL2,

			 shaderID: shaderID,
			 shaderName: material.type,

			 vertexShader: vertexShader,
			 fragmentShader: fragmentShader,
			 defines: material.defines,

			 isRawShaderMaterial: material.isRawShaderMaterial === true,
			 glslVersion: material.glslVersion,

			 precision: precision,

			 instancing: object.isInstancedMesh === true,
			 instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			 supportsVertexTextures: vertexTextures,
			 outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			 map: !! material.map,
			 mapEncoding: getTextureEncodingFromMap( material.map ),
			 matcap: !! material.matcap,
			 matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			 envMap: !! envMap,
			 envMapMode: envMap && envMap.mapping,
			 envMapEncoding: getTextureEncodingFromMap( envMap ),
			 envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping$1 ) || ( envMap.mapping === CubeUVRefractionMapping$1 ) ),
			 lightMap: !! material.lightMap,
			 lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			 aoMap: !! material.aoMap,
			 emissiveMap: !! material.emissiveMap,
			 emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			 bumpMap: !! material.bumpMap,
			 normalMap: !! material.normalMap,
			 objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap$1,
			 tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap$1,
			 clearcoatMap: !! material.clearcoatMap,
			 clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			 clearcoatNormalMap: !! material.clearcoatNormalMap,
			 displacementMap: !! material.displacementMap,
			 roughnessMap: !! material.roughnessMap,
			 metalnessMap: !! material.metalnessMap,
			 specularMap: !! material.specularMap,
			 alphaMap: !! material.alphaMap,

			 gradientMap: !! material.gradientMap,

			 sheen: !! material.sheen,

			 transmission: !! material.transmission,
			 transmissionMap: !! material.transmissionMap,
			 thicknessMap: !! material.thicknessMap,

			 combine: material.combine,

			 vertexTangents: ( material.normalMap && material.vertexTangents ),
			 vertexColors: material.vertexColors,
			 vertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
			 vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap,
			 uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmission || !! material.transmissionMap || !! material.thicknessMap ) && !! material.displacementMap,

			 fog: !! fog,
			 useFog: material.fog,
			 fogExp2: ( fog && fog.isFogExp2 ),

			 flatShading: !! material.flatShading,

			 sizeAttenuation: material.sizeAttenuation,
			 logarithmicDepthBuffer: logarithmicDepthBuffer,

			 skinning: object.isSkinnedMesh === true && maxBones > 0,
			 maxBones: maxBones,
			 useVertexTexture: floatVertexTextures,

			 morphTargets: material.morphTargets,
			 morphNormals: material.morphNormals,

			 numDirLights: lights.directional.length,
			 numPointLights: lights.point.length,
			 numSpotLights: lights.spot.length,
			 numRectAreaLights: lights.rectArea.length,
			 numHemiLights: lights.hemi.length,

			 numDirLightShadows: lights.directionalShadowMap.length,
			 numPointLightShadows: lights.pointShadowMap.length,
			 numSpotLightShadows: lights.spotShadowMap.length,

			 numClippingPlanes: clipping.numPlanes,
			 numClipIntersection: clipping.numIntersection,

			 dithering: material.dithering,

			 shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			 shadowMapType: renderer.shadowMap.type,

			 toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping$1,
			 physicallyCorrectLights: renderer.physicallyCorrectLights,

			 premultipliedAlpha: material.premultipliedAlpha,

			 alphaTest: material.alphaTest,
			 doubleSided: material.side === DoubleSide$1,
			 flipSided: material.side === BackSide$1,

			 depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			 index0AttributeName: material.index0AttributeName,

			 extensionDerivatives: material.extensions && material.extensions.derivatives,
			 extensionFragDepth: material.extensions && material.extensions.fragDepth,
			 extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			 extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			 rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			 rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			 rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			 customProgramCacheKey: material.customProgramCacheKey()

		 };

		 return parameters;

	 }

	 function getProgramCacheKey( parameters ) {

		 const array = [];

		 if ( parameters.shaderID ) {

			 array.push( parameters.shaderID );

		 } else {

			 array.push( parameters.fragmentShader );
			 array.push( parameters.vertexShader );

		 }

		 if ( parameters.defines !== undefined ) {

			 for ( const name in parameters.defines ) {

				 array.push( name );
				 array.push( parameters.defines[ name ] );

			 }

		 }

		 if ( parameters.isRawShaderMaterial === false ) {

			 for ( let i = 0; i < parameterNames.length; i ++ ) {

				 array.push( parameters[ parameterNames[ i ] ] );

			 }

			 array.push( renderer.outputEncoding );
			 array.push( renderer.gammaFactor );

		 }

		 array.push( parameters.customProgramCacheKey );

		 return array.join();

	 }

	 function getUniforms( material ) {

		 const shaderID = shaderIDs[ material.type ];
		 let uniforms;

		 if ( shaderID ) {

			 const shader = ShaderLib$1[ shaderID ];
			 uniforms = UniformsUtils$1.clone( shader.uniforms );

		 } else {

			 uniforms = material.uniforms;

		 }

		 return uniforms;

	 }

	 function acquireProgram( parameters, cacheKey ) {

		 let program;

		 // Check if code has been already compiled
		 for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			 const preexistingProgram = programs[ p ];

			 if ( preexistingProgram.cacheKey === cacheKey ) {

				 program = preexistingProgram;
				 ++ program.usedTimes;

				 break;

			 }

		 }

		 if ( program === undefined ) {

			 program = new WebGLProgram$1( renderer, cacheKey, parameters, bindingStates );
			 programs.push( program );

		 }

		 return program;

	 }

	 function releaseProgram( program ) {

		 if ( -- program.usedTimes === 0 ) {

			 // Remove from unordered set
			 const i = programs.indexOf( program );
			 programs[ i ] = programs[ programs.length - 1 ];
			 programs.pop();

			 // Free WebGL resources
			 program.destroy();

		 }

	 }

	 return {
		 getParameters: getParameters,
		 getProgramCacheKey: getProgramCacheKey,
		 getUniforms: getUniforms,
		 acquireProgram: acquireProgram,
		 releaseProgram: releaseProgram,
		 // Exposed for resource monitoring & error feedback via renderer.info:
		 programs: programs
	 };

 }

 function WebGLProperties$1() {

	 let properties = new WeakMap();

	 function get( object ) {

		 let map = properties.get( object );

		 if ( map === undefined ) {

			 map = {};
			 properties.set( object, map );

		 }

		 return map;

	 }

	 function remove( object ) {

		 properties.delete( object );

	 }

	 function update( object, key, value ) {

		 properties.get( object )[ key ] = value;

	 }

	 function dispose() {

		 properties = new WeakMap();

	 }

	 return {
		 get: get,
		 remove: remove,
		 update: update,
		 dispose: dispose
	 };

 }

 function painterSortStable$1( a, b ) {

	 if ( a.groupOrder !== b.groupOrder ) {

		 return a.groupOrder - b.groupOrder;

	 } else if ( a.renderOrder !== b.renderOrder ) {

		 return a.renderOrder - b.renderOrder;

	 } else if ( a.program !== b.program ) {

		 return a.program.id - b.program.id;

	 } else if ( a.material.id !== b.material.id ) {

		 return a.material.id - b.material.id;

	 } else if ( a.z !== b.z ) {

		 return a.z - b.z;

	 } else {

		 return a.id - b.id;

	 }

 }

 function reversePainterSortStable$1( a, b ) {

	 if ( a.groupOrder !== b.groupOrder ) {

		 return a.groupOrder - b.groupOrder;

	 } else if ( a.renderOrder !== b.renderOrder ) {

		 return a.renderOrder - b.renderOrder;

	 } else if ( a.z !== b.z ) {

		 return b.z - a.z;

	 } else {

		 return a.id - b.id;

	 }

 }


 function WebGLRenderList$1( properties ) {

	 const renderItems = [];
	 let renderItemsIndex = 0;

	 const opaque = [];
	 const transmissive = [];
	 const transparent = [];

	 const defaultProgram = { id: - 1 };

	 function init() {

		 renderItemsIndex = 0;

		 opaque.length = 0;
		 transmissive.length = 0;
		 transparent.length = 0;

	 }

	 function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		 let renderItem = renderItems[ renderItemsIndex ];
		 const materialProperties = properties.get( material );

		 if ( renderItem === undefined ) {

			 renderItem = {
				 id: object.id,
				 object: object,
				 geometry: geometry,
				 material: material,
				 program: materialProperties.program || defaultProgram,
				 groupOrder: groupOrder,
				 renderOrder: object.renderOrder,
				 z: z,
				 group: group
			 };

			 renderItems[ renderItemsIndex ] = renderItem;

		 } else {

			 renderItem.id = object.id;
			 renderItem.object = object;
			 renderItem.geometry = geometry;
			 renderItem.material = material;
			 renderItem.program = materialProperties.program || defaultProgram;
			 renderItem.groupOrder = groupOrder;
			 renderItem.renderOrder = object.renderOrder;
			 renderItem.z = z;
			 renderItem.group = group;

		 }

		 renderItemsIndex ++;

		 return renderItem;

	 }

	 function push( object, geometry, material, groupOrder, z, group ) {

		 const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		 if ( material.transmission > 0.0 ) {

			 transmissive.push( renderItem );

		 } else if ( material.transparent === true ) {

			 transparent.push( renderItem );

		 } else {

			 opaque.push( renderItem );

		 }

	 }

	 function unshift( object, geometry, material, groupOrder, z, group ) {

		 const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		 if ( material.transmission > 0.0 ) {

			 transmissive.unshift( renderItem );

		 } else if ( material.transparent === true ) {

			 transparent.unshift( renderItem );

		 } else {

			 opaque.unshift( renderItem );

		 }

	 }

	 function sort( customOpaqueSort, customTransparentSort ) {

		 if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable$1 );
		 if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable$1 );
		 if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable$1 );

	 }

	 function finish() {

		 // Clear references from inactive renderItems in the list

		 for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			 const renderItem = renderItems[ i ];

			 if ( renderItem.id === null ) break;

			 renderItem.id = null;
			 renderItem.object = null;
			 renderItem.geometry = null;
			 renderItem.material = null;
			 renderItem.program = null;
			 renderItem.group = null;

		 }

	 }

	 return {

		 opaque: opaque,
		 transmissive: transmissive,
		 transparent: transparent,

		 init: init,
		 push: push,
		 unshift: unshift,
		 finish: finish,

		 sort: sort
	 };

 }

 function WebGLRenderLists$1( properties ) {

	 let lists = new WeakMap();

	 function get( scene, renderCallDepth ) {

		 let list;

		 if ( lists.has( scene ) === false ) {

			 list = new WebGLRenderList$1( properties );
			 lists.set( scene, [ list ] );

		 } else {

			 if ( renderCallDepth >= lists.get( scene ).length ) {

				 list = new WebGLRenderList$1( properties );
				 lists.get( scene ).push( list );

			 } else {

				 list = lists.get( scene )[ renderCallDepth ];

			 }

		 }

		 return list;

	 }

	 function dispose() {

		 lists = new WeakMap();

	 }

	 return {
		 get: get,
		 dispose: dispose
	 };

 }

 function UniformsCache$1() {

	 const lights = {};

	 return {

		 get: function ( light ) {

			 if ( lights[ light.id ] !== undefined ) {

				 return lights[ light.id ];

			 }

			 let uniforms;

			 switch ( light.type ) {

				 case 'DirectionalLight':
					 uniforms = {
						 direction: new Vector3$1(),
						 color: new Color$2()
					 };
					 break;

				 case 'SpotLight':
					 uniforms = {
						 position: new Vector3$1(),
						 direction: new Vector3$1(),
						 color: new Color$2(),
						 distance: 0,
						 coneCos: 0,
						 penumbraCos: 0,
						 decay: 0
					 };
					 break;

				 case 'PointLight':
					 uniforms = {
						 position: new Vector3$1(),
						 color: new Color$2(),
						 distance: 0,
						 decay: 0
					 };
					 break;

				 case 'HemisphereLight':
					 uniforms = {
						 direction: new Vector3$1(),
						 skyColor: new Color$2(),
						 groundColor: new Color$2()
					 };
					 break;

				 case 'RectAreaLight':
					 uniforms = {
						 color: new Color$2(),
						 position: new Vector3$1(),
						 halfWidth: new Vector3$1(),
						 halfHeight: new Vector3$1()
					 };
					 break;

			 }

			 lights[ light.id ] = uniforms;

			 return uniforms;

		 }

	 };

 }

 function ShadowUniformsCache$1() {

	 const lights = {};

	 return {

		 get: function ( light ) {

			 if ( lights[ light.id ] !== undefined ) {

				 return lights[ light.id ];

			 }

			 let uniforms;

			 switch ( light.type ) {

				 case 'DirectionalLight':
					 uniforms = {
						 shadowBias: 0,
						 shadowNormalBias: 0,
						 shadowRadius: 1,
						 shadowMapSize: new Vector2$1()
					 };
					 break;

				 case 'SpotLight':
					 uniforms = {
						 shadowBias: 0,
						 shadowNormalBias: 0,
						 shadowRadius: 1,
						 shadowMapSize: new Vector2$1()
					 };
					 break;

				 case 'PointLight':
					 uniforms = {
						 shadowBias: 0,
						 shadowNormalBias: 0,
						 shadowRadius: 1,
						 shadowMapSize: new Vector2$1(),
						 shadowCameraNear: 1,
						 shadowCameraFar: 1000
					 };
					 break;

				 // TODO (abelnation): set RectAreaLight shadow uniforms

			 }

			 lights[ light.id ] = uniforms;

			 return uniforms;

		 }

	 };

 }



 let nextVersion$1 = 0;

 function shadowCastingLightsFirst$1( lightA, lightB ) {

	 return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

 }

 function WebGLLights$1( extensions, capabilities ) {

	 const cache = new UniformsCache$1();

	 const shadowCache = ShadowUniformsCache$1();

	 const state = {

		 version: 0,

		 hash: {
			 directionalLength: - 1,
			 pointLength: - 1,
			 spotLength: - 1,
			 rectAreaLength: - 1,
			 hemiLength: - 1,

			 numDirectionalShadows: - 1,
			 numPointShadows: - 1,
			 numSpotShadows: - 1
		 },

		 ambient: [ 0, 0, 0 ],
		 probe: [],
		 directional: [],
		 directionalShadow: [],
		 directionalShadowMap: [],
		 directionalShadowMatrix: [],
		 spot: [],
		 spotShadow: [],
		 spotShadowMap: [],
		 spotShadowMatrix: [],
		 rectArea: [],
		 rectAreaLTC1: null,
		 rectAreaLTC2: null,
		 point: [],
		 pointShadow: [],
		 pointShadowMap: [],
		 pointShadowMatrix: [],
		 hemi: []

	 };

	 for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3$1() );

	 const vector3 = new Vector3$1();
	 const matrix4 = new Matrix4$1();
	 const matrix42 = new Matrix4$1();

	 function setup( lights ) {

		 let r = 0, g = 0, b = 0;

		 for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		 let directionalLength = 0;
		 let pointLength = 0;
		 let spotLength = 0;
		 let rectAreaLength = 0;
		 let hemiLength = 0;

		 let numDirectionalShadows = 0;
		 let numPointShadows = 0;
		 let numSpotShadows = 0;

		 lights.sort( shadowCastingLightsFirst$1 );

		 for ( let i = 0, l = lights.length; i < l; i ++ ) {

			 const light = lights[ i ];

			 const color = light.color;
			 const intensity = light.intensity;
			 const distance = light.distance;

			 const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			 if ( light.isAmbientLight ) {

				 r += color.r * intensity;
				 g += color.g * intensity;
				 b += color.b * intensity;

			 } else if ( light.isLightProbe ) {

				 for ( let j = 0; j < 9; j ++ ) {

					 state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				 }

			 } else if ( light.isDirectionalLight ) {

				 const uniforms = cache.get( light );

				 uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

				 if ( light.castShadow ) {

					 const shadow = light.shadow;

					 const shadowUniforms = shadowCache.get( light );

					 shadowUniforms.shadowBias = shadow.bias;
					 shadowUniforms.shadowNormalBias = shadow.normalBias;
					 shadowUniforms.shadowRadius = shadow.radius;
					 shadowUniforms.shadowMapSize = shadow.mapSize;

					 state.directionalShadow[ directionalLength ] = shadowUniforms;
					 state.directionalShadowMap[ directionalLength ] = shadowMap;
					 state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					 numDirectionalShadows ++;

				 }

				 state.directional[ directionalLength ] = uniforms;

				 directionalLength ++;

			 } else if ( light.isSpotLight ) {

				 const uniforms = cache.get( light );

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );

				 uniforms.color.copy( color ).multiplyScalar( intensity );
				 uniforms.distance = distance;

				 uniforms.coneCos = Math.cos( light.angle );
				 uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				 uniforms.decay = light.decay;

				 if ( light.castShadow ) {

					 const shadow = light.shadow;

					 const shadowUniforms = shadowCache.get( light );

					 shadowUniforms.shadowBias = shadow.bias;
					 shadowUniforms.shadowNormalBias = shadow.normalBias;
					 shadowUniforms.shadowRadius = shadow.radius;
					 shadowUniforms.shadowMapSize = shadow.mapSize;

					 state.spotShadow[ spotLength ] = shadowUniforms;
					 state.spotShadowMap[ spotLength ] = shadowMap;
					 state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					 numSpotShadows ++;

				 }

				 state.spot[ spotLength ] = uniforms;

				 spotLength ++;

			 } else if ( light.isRectAreaLight ) {

				 const uniforms = cache.get( light );

				 // (a) intensity is the total visible light emitted
				 //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				 // (b) intensity is the brightness of the light
				 uniforms.color.copy( color ).multiplyScalar( intensity );

				 uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				 uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				 state.rectArea[ rectAreaLength ] = uniforms;

				 rectAreaLength ++;

			 } else if ( light.isPointLight ) {

				 const uniforms = cache.get( light );

				 uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				 uniforms.distance = light.distance;
				 uniforms.decay = light.decay;

				 if ( light.castShadow ) {

					 const shadow = light.shadow;

					 const shadowUniforms = shadowCache.get( light );

					 shadowUniforms.shadowBias = shadow.bias;
					 shadowUniforms.shadowNormalBias = shadow.normalBias;
					 shadowUniforms.shadowRadius = shadow.radius;
					 shadowUniforms.shadowMapSize = shadow.mapSize;
					 shadowUniforms.shadowCameraNear = shadow.camera.near;
					 shadowUniforms.shadowCameraFar = shadow.camera.far;

					 state.pointShadow[ pointLength ] = shadowUniforms;
					 state.pointShadowMap[ pointLength ] = shadowMap;
					 state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					 numPointShadows ++;

				 }

				 state.point[ pointLength ] = uniforms;

				 pointLength ++;

			 } else if ( light.isHemisphereLight ) {

				 const uniforms = cache.get( light );

				 uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				 uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				 state.hemi[ hemiLength ] = uniforms;

				 hemiLength ++;

			 }

		 }

		 if ( rectAreaLength > 0 ) {

			 if ( capabilities.isWebGL2 ) {

				 // WebGL 2

				 state.rectAreaLTC1 = UniformsLib$1.LTC_FLOAT_1;
				 state.rectAreaLTC2 = UniformsLib$1.LTC_FLOAT_2;

			 } else {

				 // WebGL 1

				 if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					 state.rectAreaLTC1 = UniformsLib$1.LTC_FLOAT_1;
					 state.rectAreaLTC2 = UniformsLib$1.LTC_FLOAT_2;

				 } else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					 state.rectAreaLTC1 = UniformsLib$1.LTC_HALF_1;
					 state.rectAreaLTC2 = UniformsLib$1.LTC_HALF_2;

				 } else {

					 console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				 }

			 }

		 }

		 state.ambient[ 0 ] = r;
		 state.ambient[ 1 ] = g;
		 state.ambient[ 2 ] = b;

		 const hash = state.hash;

		 if ( hash.directionalLength !== directionalLength ||
			 hash.pointLength !== pointLength ||
			 hash.spotLength !== spotLength ||
			 hash.rectAreaLength !== rectAreaLength ||
			 hash.hemiLength !== hemiLength ||
			 hash.numDirectionalShadows !== numDirectionalShadows ||
			 hash.numPointShadows !== numPointShadows ||
			 hash.numSpotShadows !== numSpotShadows ) {

			 state.directional.length = directionalLength;
			 state.spot.length = spotLength;
			 state.rectArea.length = rectAreaLength;
			 state.point.length = pointLength;
			 state.hemi.length = hemiLength;

			 state.directionalShadow.length = numDirectionalShadows;
			 state.directionalShadowMap.length = numDirectionalShadows;
			 state.pointShadow.length = numPointShadows;
			 state.pointShadowMap.length = numPointShadows;
			 state.spotShadow.length = numSpotShadows;
			 state.spotShadowMap.length = numSpotShadows;
			 state.directionalShadowMatrix.length = numDirectionalShadows;
			 state.pointShadowMatrix.length = numPointShadows;
			 state.spotShadowMatrix.length = numSpotShadows;

			 hash.directionalLength = directionalLength;
			 hash.pointLength = pointLength;
			 hash.spotLength = spotLength;
			 hash.rectAreaLength = rectAreaLength;
			 hash.hemiLength = hemiLength;

			 hash.numDirectionalShadows = numDirectionalShadows;
			 hash.numPointShadows = numPointShadows;
			 hash.numSpotShadows = numSpotShadows;

			 state.version = nextVersion$1 ++;

		 }

	 }

	 function setupView( lights, camera ) {

		 let directionalLength = 0;
		 let pointLength = 0;
		 let spotLength = 0;
		 let rectAreaLength = 0;
		 let hemiLength = 0;

		 const viewMatrix = camera.matrixWorldInverse;

		 for ( let i = 0, l = lights.length; i < l; i ++ ) {

			 const light = lights[ i ];

			 if ( light.isDirectionalLight ) {

				 const uniforms = state.directional[ directionalLength ];

				 uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				 vector3.setFromMatrixPosition( light.target.matrixWorld );
				 uniforms.direction.sub( vector3 );
				 uniforms.direction.transformDirection( viewMatrix );

				 directionalLength ++;

			 } else if ( light.isSpotLight ) {

				 const uniforms = state.spot[ spotLength ];

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );
				 uniforms.position.applyMatrix4( viewMatrix );

				 uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				 vector3.setFromMatrixPosition( light.target.matrixWorld );
				 uniforms.direction.sub( vector3 );
				 uniforms.direction.transformDirection( viewMatrix );

				 spotLength ++;

			 } else if ( light.isRectAreaLight ) {

				 const uniforms = state.rectArea[ rectAreaLength ];

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );
				 uniforms.position.applyMatrix4( viewMatrix );

				 // extract local rotation of light to derive width/height half vectors
				 matrix42.identity();
				 matrix4.copy( light.matrixWorld );
				 matrix4.premultiply( viewMatrix );
				 matrix42.extractRotation( matrix4 );

				 uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				 uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				 uniforms.halfWidth.applyMatrix4( matrix42 );
				 uniforms.halfHeight.applyMatrix4( matrix42 );

				 rectAreaLength ++;

			 } else if ( light.isPointLight ) {

				 const uniforms = state.point[ pointLength ];

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );
				 uniforms.position.applyMatrix4( viewMatrix );

				 pointLength ++;

			 } else if ( light.isHemisphereLight ) {

				 const uniforms = state.hemi[ hemiLength ];

				 uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				 uniforms.direction.transformDirection( viewMatrix );
				 uniforms.direction.normalize();

				 hemiLength ++;

			 }

		 }

	 }

	 return {
		 setup: setup,
		 setupView: setupView,
		 state: state
	 };

 }

 function WebGLRenderState$1( extensions, capabilities ) {

	 const lights = new WebGLLights$1( extensions, capabilities );

	 const lightsArray = [];
	 const shadowsArray = [];

	 function init() {

		 lightsArray.length = 0;
		 shadowsArray.length = 0;

	 }

	 function pushLight( light ) {

		 lightsArray.push( light );

	 }

	 function pushShadow( shadowLight ) {

		 shadowsArray.push( shadowLight );

	 }

	 function setupLights() {

		 lights.setup( lightsArray );

	 }

	 function setupLightsView( camera ) {

		 lights.setupView( lightsArray, camera );

	 }

	 const state = {
		 lightsArray: lightsArray,
		 shadowsArray: shadowsArray,

		 lights: lights
	 };

	 return {
		 init: init,
		 state: state,
		 setupLights: setupLights,
		 setupLightsView: setupLightsView,

		 pushLight: pushLight,
		 pushShadow: pushShadow
	 };

 }

 function WebGLRenderStates$1( extensions, capabilities ) {

	 let renderStates = new WeakMap();

	 function get( scene, renderCallDepth = 0 ) {

		 let renderState;

		 if ( renderStates.has( scene ) === false ) {

			 renderState = new WebGLRenderState$1( extensions, capabilities );
			 renderStates.set( scene, [ renderState ] );

		 } else {

			 if ( renderCallDepth >= renderStates.get( scene ).length ) {

				 renderState = new WebGLRenderState$1( extensions, capabilities );
				 renderStates.get( scene ).push( renderState );

			 } else {

				 renderState = renderStates.get( scene )[ renderCallDepth ];

			 }

		 }

		 return renderState;

	 }

	 function dispose() {

		 renderStates = new WeakMap();

	 }

	 return {
		 get: get,
		 dispose: dispose
	 };

 }

 /**
	* parameters = {
	*
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>
	* }
	*/

 class MeshDepthMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshDepthMaterial';

		 this.depthPacking = BasicDepthPacking$1;

		 this.morphTargets = false;

		 this.map = null;

		 this.alphaMap = null;

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;

		 this.fog = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.depthPacking = source.depthPacking;

		 this.morphTargets = source.morphTargets;

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;

		 return this;

	 }

 }

 MeshDepthMaterial$1.prototype.isMeshDepthMaterial = true;

 /**
	* parameters = {
	*
	*  referencePosition: <float>,
	*  nearDistance: <float>,
	*  farDistance: <float>,
	*
	*  morphTargets: <bool>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>
	*
	* }
	*/

 class MeshDistanceMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshDistanceMaterial';

		 this.referencePosition = new Vector3$1();
		 this.nearDistance = 1;
		 this.farDistance = 1000;

		 this.morphTargets = false;

		 this.map = null;

		 this.alphaMap = null;

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.fog = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.referencePosition.copy( source.referencePosition );
		 this.nearDistance = source.nearDistance;
		 this.farDistance = source.farDistance;

		 this.morphTargets = source.morphTargets;

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 return this;

	 }

 }

 MeshDistanceMaterial$1.prototype.isMeshDistanceMaterial = true;

 var vsm_frag$1 = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

 var vsm_vert$1 = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

 function WebGLShadowMap$1( _renderer, _objects, _capabilities ) {

	 let _frustum = new Frustum$1();

	 const _shadowMapSize = new Vector2$1(),
		 _viewportSize = new Vector2$1(),

		 _viewport = new Vector4$1(),

		 _depthMaterials = [],
		 _distanceMaterials = [],

		 _materialCache = {},

		 _maxTextureSize = _capabilities.maxTextureSize;

	 const shadowSide = { 0: BackSide$1, 1: FrontSide$1, 2: DoubleSide$1 };

	 const shadowMaterialVertical = new ShaderMaterial$1( {

		 defines: {
			 SAMPLE_RATE: 2.0 / 8.0,
			 HALF_SAMPLE_RATE: 1.0 / 8.0
		 },

		 uniforms: {
			 shadow_pass: { value: null },
			 resolution: { value: new Vector2$1() },
			 radius: { value: 4.0 }
		 },

		 vertexShader: vsm_vert$1,

		 fragmentShader: vsm_frag$1

	 } );

	 const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	 shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	 const fullScreenTri = new BufferGeometry$1();
	 fullScreenTri.setAttribute(
		 'position',
		 new BufferAttribute$1(
			 new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			 3
		 )
	 );

	 const fullScreenMesh = new Mesh$1( fullScreenTri, shadowMaterialVertical );

	 const scope = this;

	 this.enabled = false;

	 this.autoUpdate = true;
	 this.needsUpdate = false;

	 this.type = PCFShadowMap$1;

	 this.render = function ( lights, scene, camera ) {

		 if ( scope.enabled === false ) return;
		 if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		 if ( lights.length === 0 ) return;

		 const currentRenderTarget = _renderer.getRenderTarget();
		 const activeCubeFace = _renderer.getActiveCubeFace();
		 const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		 const _state = _renderer.state;

		 // Set GL state for depth map.
		 _state.setBlending( NoBlending$1 );
		 _state.buffers.color.setClear( 1, 1, 1, 1 );
		 _state.buffers.depth.setTest( true );
		 _state.setScissorTest( false );

		 // render depth map

		 for ( let i = 0, il = lights.length; i < il; i ++ ) {

			 const light = lights[ i ];
			 const shadow = light.shadow;

			 if ( shadow === undefined ) {

				 console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				 continue;

			 }

			 if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			 _shadowMapSize.copy( shadow.mapSize );

			 const shadowFrameExtents = shadow.getFrameExtents();

			 _shadowMapSize.multiply( shadowFrameExtents );

			 _viewportSize.copy( shadow.mapSize );

			 if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				 if ( _shadowMapSize.x > _maxTextureSize ) {

					 _viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					 _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					 shadow.mapSize.x = _viewportSize.x;

				 }

				 if ( _shadowMapSize.y > _maxTextureSize ) {

					 _viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					 _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					 shadow.mapSize.y = _viewportSize.y;

				 }

			 }

			 if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap$1 ) {

				 const pars = { minFilter: LinearFilter$1, magFilter: LinearFilter$1, format: RGBAFormat$1 };

				 shadow.map = new WebGLRenderTarget$1( _shadowMapSize.x, _shadowMapSize.y, pars );
				 shadow.map.texture.name = light.name + '.shadowMap';

				 shadow.mapPass = new WebGLRenderTarget$1( _shadowMapSize.x, _shadowMapSize.y, pars );

				 shadow.camera.updateProjectionMatrix();

			 }

			 if ( shadow.map === null ) {

				 const pars = { minFilter: NearestFilter$1, magFilter: NearestFilter$1, format: RGBAFormat$1 };

				 shadow.map = new WebGLRenderTarget$1( _shadowMapSize.x, _shadowMapSize.y, pars );
				 shadow.map.texture.name = light.name + '.shadowMap';

				 shadow.camera.updateProjectionMatrix();

			 }

			 _renderer.setRenderTarget( shadow.map );
			 _renderer.clear();

			 const viewportCount = shadow.getViewportCount();

			 for ( let vp = 0; vp < viewportCount; vp ++ ) {

				 const viewport = shadow.getViewport( vp );

				 _viewport.set(
					 _viewportSize.x * viewport.x,
					 _viewportSize.y * viewport.y,
					 _viewportSize.x * viewport.z,
					 _viewportSize.y * viewport.w
				 );

				 _state.viewport( _viewport );

				 shadow.updateMatrices( light, vp );

				 _frustum = shadow.getFrustum();

				 renderObject( scene, camera, shadow.camera, light, this.type );

			 }

			 // do blur pass for VSM

			 if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap$1 ) {

				 VSMPass( shadow, camera );

			 }

			 shadow.needsUpdate = false;

		 }

		 scope.needsUpdate = false;

		 _renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	 };

	 function VSMPass( shadow, camera ) {

		 const geometry = _objects.update( fullScreenMesh );

		 // vertical pass

		 shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		 shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		 shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		 _renderer.setRenderTarget( shadow.mapPass );
		 _renderer.clear();
		 _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		 // horizontal pass

		 shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		 shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		 shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		 _renderer.setRenderTarget( shadow.map );
		 _renderer.clear();
		 _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	 }

	 function getDepthMaterialVariant( useMorphing ) {

		 const index = useMorphing << 0;

		 let material = _depthMaterials[ index ];

		 if ( material === undefined ) {

			 material = new MeshDepthMaterial$1( {

				 depthPacking: RGBADepthPacking$1,

				 morphTargets: useMorphing

			 } );

			 _depthMaterials[ index ] = material;

		 }

		 return material;

	 }

	 function getDistanceMaterialVariant( useMorphing ) {

		 const index = useMorphing << 0;

		 let material = _distanceMaterials[ index ];

		 if ( material === undefined ) {

			 material = new MeshDistanceMaterial$1( {

				 morphTargets: useMorphing

			 } );

			 _distanceMaterials[ index ] = material;

		 }

		 return material;

	 }

	 function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		 let result = null;

		 let getMaterialVariant = getDepthMaterialVariant;
		 let customMaterial = object.customDepthMaterial;

		 if ( light.isPointLight === true ) {

			 getMaterialVariant = getDistanceMaterialVariant;
			 customMaterial = object.customDistanceMaterial;

		 }

		 if ( customMaterial === undefined ) {

			 let useMorphing = false;

			 if ( material.morphTargets === true ) {

				 useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			 }

			 result = getMaterialVariant( useMorphing );

		 } else {

			 result = customMaterial;

		 }

		 if ( _renderer.localClippingEnabled &&
				 material.clipShadows === true &&
				 material.clippingPlanes.length !== 0 ) {

			 // in this case we need a unique material instance reflecting the
			 // appropriate state

			 const keyA = result.uuid, keyB = material.uuid;

			 let materialsForVariant = _materialCache[ keyA ];

			 if ( materialsForVariant === undefined ) {

				 materialsForVariant = {};
				 _materialCache[ keyA ] = materialsForVariant;

			 }

			 let cachedMaterial = materialsForVariant[ keyB ];

			 if ( cachedMaterial === undefined ) {

				 cachedMaterial = result.clone();
				 materialsForVariant[ keyB ] = cachedMaterial;

			 }

			 result = cachedMaterial;

		 }

		 result.visible = material.visible;
		 result.wireframe = material.wireframe;

		 if ( type === VSMShadowMap$1 ) {

			 result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		 } else {

			 result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		 }

		 result.clipShadows = material.clipShadows;
		 result.clippingPlanes = material.clippingPlanes;
		 result.clipIntersection = material.clipIntersection;

		 result.wireframeLinewidth = material.wireframeLinewidth;
		 result.linewidth = material.linewidth;

		 if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			 result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			 result.nearDistance = shadowCameraNear;
			 result.farDistance = shadowCameraFar;

		 }

		 return result;

	 }

	 function renderObject( object, camera, shadowCamera, light, type ) {

		 if ( object.visible === false ) return;

		 const visible = object.layers.test( camera.layers );

		 if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			 if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap$1 ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				 object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				 const geometry = _objects.update( object );
				 const material = object.material;

				 if ( Array.isArray( material ) ) {

					 const groups = geometry.groups;

					 for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						 const group = groups[ k ];
						 const groupMaterial = material[ group.materialIndex ];

						 if ( groupMaterial && groupMaterial.visible ) {

							 const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							 _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						 }

					 }

				 } else if ( material.visible ) {

					 const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					 _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				 }

			 }

		 }

		 const children = object.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 renderObject( children[ i ], camera, shadowCamera, light, type );

		 }

	 }

 }

 function WebGLState$1( gl, extensions, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 function ColorBuffer() {

		 let locked = false;

		 const color = new Vector4$1();
		 let currentColorMask = null;
		 const currentColorClear = new Vector4$1( 0, 0, 0, 0 );

		 return {

			 setMask: function ( colorMask ) {

				 if ( currentColorMask !== colorMask && ! locked ) {

					 gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					 currentColorMask = colorMask;

				 }

			 },

			 setLocked: function ( lock ) {

				 locked = lock;

			 },

			 setClear: function ( r, g, b, a, premultipliedAlpha ) {

				 if ( premultipliedAlpha === true ) {

					 r *= a; g *= a; b *= a;

				 }

				 color.set( r, g, b, a );

				 if ( currentColorClear.equals( color ) === false ) {

					 gl.clearColor( r, g, b, a );
					 currentColorClear.copy( color );

				 }

			 },

			 reset: function () {

				 locked = false;

				 currentColorMask = null;
				 currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			 }

		 };

	 }

	 function DepthBuffer() {

		 let locked = false;

		 let currentDepthMask = null;
		 let currentDepthFunc = null;
		 let currentDepthClear = null;

		 return {

			 setTest: function ( depthTest ) {

				 if ( depthTest ) {

					 enable( 2929 );

				 } else {

					 disable( 2929 );

				 }

			 },

			 setMask: function ( depthMask ) {

				 if ( currentDepthMask !== depthMask && ! locked ) {

					 gl.depthMask( depthMask );
					 currentDepthMask = depthMask;

				 }

			 },

			 setFunc: function ( depthFunc ) {

				 if ( currentDepthFunc !== depthFunc ) {

					 if ( depthFunc ) {

						 switch ( depthFunc ) {

							 case NeverDepth$1:

								 gl.depthFunc( 512 );
								 break;

							 case AlwaysDepth$1:

								 gl.depthFunc( 519 );
								 break;

							 case LessDepth$1:

								 gl.depthFunc( 513 );
								 break;

							 case LessEqualDepth$1:

								 gl.depthFunc( 515 );
								 break;

							 case EqualDepth$1:

								 gl.depthFunc( 514 );
								 break;

							 case GreaterEqualDepth$1:

								 gl.depthFunc( 518 );
								 break;

							 case GreaterDepth$1:

								 gl.depthFunc( 516 );
								 break;

							 case NotEqualDepth$1:

								 gl.depthFunc( 517 );
								 break;

							 default:

								 gl.depthFunc( 515 );

						 }

					 } else {

						 gl.depthFunc( 515 );

					 }

					 currentDepthFunc = depthFunc;

				 }

			 },

			 setLocked: function ( lock ) {

				 locked = lock;

			 },

			 setClear: function ( depth ) {

				 if ( currentDepthClear !== depth ) {

					 gl.clearDepth( depth );
					 currentDepthClear = depth;

				 }

			 },

			 reset: function () {

				 locked = false;

				 currentDepthMask = null;
				 currentDepthFunc = null;
				 currentDepthClear = null;

			 }

		 };

	 }

	 function StencilBuffer() {

		 let locked = false;

		 let currentStencilMask = null;
		 let currentStencilFunc = null;
		 let currentStencilRef = null;
		 let currentStencilFuncMask = null;
		 let currentStencilFail = null;
		 let currentStencilZFail = null;
		 let currentStencilZPass = null;
		 let currentStencilClear = null;

		 return {

			 setTest: function ( stencilTest ) {

				 if ( ! locked ) {

					 if ( stencilTest ) {

						 enable( 2960 );

					 } else {

						 disable( 2960 );

					 }

				 }

			 },

			 setMask: function ( stencilMask ) {

				 if ( currentStencilMask !== stencilMask && ! locked ) {

					 gl.stencilMask( stencilMask );
					 currentStencilMask = stencilMask;

				 }

			 },

			 setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				 if ( currentStencilFunc !== stencilFunc ||
							currentStencilRef !== stencilRef ||
							currentStencilFuncMask !== stencilMask ) {

					 gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					 currentStencilFunc = stencilFunc;
					 currentStencilRef = stencilRef;
					 currentStencilFuncMask = stencilMask;

				 }

			 },

			 setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				 if ( currentStencilFail !== stencilFail ||
							currentStencilZFail !== stencilZFail ||
							currentStencilZPass !== stencilZPass ) {

					 gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					 currentStencilFail = stencilFail;
					 currentStencilZFail = stencilZFail;
					 currentStencilZPass = stencilZPass;

				 }

			 },

			 setLocked: function ( lock ) {

				 locked = lock;

			 },

			 setClear: function ( stencil ) {

				 if ( currentStencilClear !== stencil ) {

					 gl.clearStencil( stencil );
					 currentStencilClear = stencil;

				 }

			 },

			 reset: function () {

				 locked = false;

				 currentStencilMask = null;
				 currentStencilFunc = null;
				 currentStencilRef = null;
				 currentStencilFuncMask = null;
				 currentStencilFail = null;
				 currentStencilZFail = null;
				 currentStencilZPass = null;
				 currentStencilClear = null;

			 }

		 };

	 }

	 //

	 const colorBuffer = new ColorBuffer();
	 const depthBuffer = new DepthBuffer();
	 const stencilBuffer = new StencilBuffer();

	 let enabledCapabilities = {};

	 let xrFramebuffer = null;
	 let currentBoundFramebuffers = {};

	 let currentProgram = null;

	 let currentBlendingEnabled = false;
	 let currentBlending = null;
	 let currentBlendEquation = null;
	 let currentBlendSrc = null;
	 let currentBlendDst = null;
	 let currentBlendEquationAlpha = null;
	 let currentBlendSrcAlpha = null;
	 let currentBlendDstAlpha = null;
	 let currentPremultipledAlpha = false;

	 let currentFlipSided = null;
	 let currentCullFace = null;

	 let currentLineWidth = null;

	 let currentPolygonOffsetFactor = null;
	 let currentPolygonOffsetUnits = null;

	 const maxTextures = gl.getParameter( 35661 );

	 let lineWidthAvailable = false;
	 let version = 0;
	 const glVersion = gl.getParameter( 7938 );

	 if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		 version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		 lineWidthAvailable = ( version >= 1.0 );

	 } else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		 version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		 lineWidthAvailable = ( version >= 2.0 );

	 }

	 let currentTextureSlot = null;
	 let currentBoundTextures = {};

	 const scissorParam = gl.getParameter( 3088 );
	 const viewportParam = gl.getParameter( 2978 );

	 const currentScissor = new Vector4$1().fromArray( scissorParam );
	 const currentViewport = new Vector4$1().fromArray( viewportParam );

	 function createTexture( type, target, count ) {

		 const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		 const texture = gl.createTexture();

		 gl.bindTexture( type, texture );
		 gl.texParameteri( type, 10241, 9728 );
		 gl.texParameteri( type, 10240, 9728 );

		 for ( let i = 0; i < count; i ++ ) {

			 gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		 }

		 return texture;

	 }

	 const emptyTextures = {};
	 emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	 emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	 // init

	 colorBuffer.setClear( 0, 0, 0, 1 );
	 depthBuffer.setClear( 1 );
	 stencilBuffer.setClear( 0 );

	 enable( 2929 );
	 depthBuffer.setFunc( LessEqualDepth$1 );

	 setFlipSided( false );
	 setCullFace( CullFaceBack$1 );
	 enable( 2884 );

	 setBlending( NoBlending$1 );

	 //

	 function enable( id ) {

		 if ( enabledCapabilities[ id ] !== true ) {

			 gl.enable( id );
			 enabledCapabilities[ id ] = true;

		 }

	 }

	 function disable( id ) {

		 if ( enabledCapabilities[ id ] !== false ) {

			 gl.disable( id );
			 enabledCapabilities[ id ] = false;

		 }

	 }

	 function bindXRFramebuffer( framebuffer ) {

		 if ( framebuffer !== xrFramebuffer ) {

			 gl.bindFramebuffer( 36160, framebuffer );

			 xrFramebuffer = framebuffer;

		 }

	 }

	 function bindFramebuffer( target, framebuffer ) {

		 if ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available

		 if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			 gl.bindFramebuffer( target, framebuffer );

			 currentBoundFramebuffers[ target ] = framebuffer;

			 if ( isWebGL2 ) {

				 // 36009 is equivalent to 36160

				 if ( target === 36009 ) {

					 currentBoundFramebuffers[ 36160 ] = framebuffer;

				 }

				 if ( target === 36160 ) {

					 currentBoundFramebuffers[ 36009 ] = framebuffer;

				 }

			 }

			 return true;

		 }

		 return false;

	 }

	 function useProgram( program ) {

		 if ( currentProgram !== program ) {

			 gl.useProgram( program );

			 currentProgram = program;

			 return true;

		 }

		 return false;

	 }

	 const equationToGL = {
		 [ AddEquation$1 ]: 32774,
		 [ SubtractEquation$1 ]: 32778,
		 [ ReverseSubtractEquation$1 ]: 32779
	 };

	 if ( isWebGL2 ) {

		 equationToGL[ MinEquation$1 ] = 32775;
		 equationToGL[ MaxEquation$1 ] = 32776;

	 } else {

		 const extension = extensions.get( 'EXT_blend_minmax' );

		 if ( extension !== null ) {

			 equationToGL[ MinEquation$1 ] = extension.MIN_EXT;
			 equationToGL[ MaxEquation$1 ] = extension.MAX_EXT;

		 }

	 }

	 const factorToGL = {
		 [ ZeroFactor$1 ]: 0,
		 [ OneFactor$1 ]: 1,
		 [ SrcColorFactor$1 ]: 768,
		 [ SrcAlphaFactor$1 ]: 770,
		 [ SrcAlphaSaturateFactor$1 ]: 776,
		 [ DstColorFactor$1 ]: 774,
		 [ DstAlphaFactor$1 ]: 772,
		 [ OneMinusSrcColorFactor$1 ]: 769,
		 [ OneMinusSrcAlphaFactor$1 ]: 771,
		 [ OneMinusDstColorFactor$1 ]: 775,
		 [ OneMinusDstAlphaFactor$1 ]: 773
	 };

	 function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		 if ( blending === NoBlending$1 ) {

			 if ( currentBlendingEnabled === true ) {

				 disable( 3042 );
				 currentBlendingEnabled = false;

			 }

			 return;

		 }

		 if ( currentBlendingEnabled === false ) {

			 enable( 3042 );
			 currentBlendingEnabled = true;

		 }

		 if ( blending !== CustomBlending$1 ) {

			 if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				 if ( currentBlendEquation !== AddEquation$1 || currentBlendEquationAlpha !== AddEquation$1 ) {

					 gl.blendEquation( 32774 );

					 currentBlendEquation = AddEquation$1;
					 currentBlendEquationAlpha = AddEquation$1;

				 }

				 if ( premultipliedAlpha ) {

					 switch ( blending ) {

						 case NormalBlending$1:
							 gl.blendFuncSeparate( 1, 771, 1, 771 );
							 break;

						 case AdditiveBlending$1:
							 gl.blendFunc( 1, 1 );
							 break;

						 case SubtractiveBlending$1:
							 gl.blendFuncSeparate( 0, 0, 769, 771 );
							 break;

						 case MultiplyBlending$1:
							 gl.blendFuncSeparate( 0, 768, 0, 770 );
							 break;

						 default:
							 console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							 break;

					 }

				 } else {

					 switch ( blending ) {

						 case NormalBlending$1:
							 gl.blendFuncSeparate( 770, 771, 1, 771 );
							 break;

						 case AdditiveBlending$1:
							 gl.blendFunc( 770, 1 );
							 break;

						 case SubtractiveBlending$1:
							 gl.blendFunc( 0, 769 );
							 break;

						 case MultiplyBlending$1:
							 gl.blendFunc( 0, 768 );
							 break;

						 default:
							 console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							 break;

					 }

				 }

				 currentBlendSrc = null;
				 currentBlendDst = null;
				 currentBlendSrcAlpha = null;
				 currentBlendDstAlpha = null;

				 currentBlending = blending;
				 currentPremultipledAlpha = premultipliedAlpha;

			 }

			 return;

		 }

		 // custom blending

		 blendEquationAlpha = blendEquationAlpha || blendEquation;
		 blendSrcAlpha = blendSrcAlpha || blendSrc;
		 blendDstAlpha = blendDstAlpha || blendDst;

		 if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			 gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			 currentBlendEquation = blendEquation;
			 currentBlendEquationAlpha = blendEquationAlpha;

		 }

		 if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			 gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			 currentBlendSrc = blendSrc;
			 currentBlendDst = blendDst;
			 currentBlendSrcAlpha = blendSrcAlpha;
			 currentBlendDstAlpha = blendDstAlpha;

		 }

		 currentBlending = blending;
		 currentPremultipledAlpha = null;

	 }

	 function setMaterial( material, frontFaceCW ) {

		 material.side === DoubleSide$1
			 ? disable( 2884 )
			 : enable( 2884 );

		 let flipSided = ( material.side === BackSide$1 );
		 if ( frontFaceCW ) flipSided = ! flipSided;

		 setFlipSided( flipSided );

		 ( material.blending === NormalBlending$1 && material.transparent === false )
			 ? setBlending( NoBlending$1 )
			 : setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		 depthBuffer.setFunc( material.depthFunc );
		 depthBuffer.setTest( material.depthTest );
		 depthBuffer.setMask( material.depthWrite );
		 colorBuffer.setMask( material.colorWrite );

		 const stencilWrite = material.stencilWrite;
		 stencilBuffer.setTest( stencilWrite );
		 if ( stencilWrite ) {

			 stencilBuffer.setMask( material.stencilWriteMask );
			 stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			 stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		 }

		 setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		 material.alphaToCoverage === true
			 ? enable( 32926 )
			 : disable( 32926 );

	 }

	 //

	 function setFlipSided( flipSided ) {

		 if ( currentFlipSided !== flipSided ) {

			 if ( flipSided ) {

				 gl.frontFace( 2304 );

			 } else {

				 gl.frontFace( 2305 );

			 }

			 currentFlipSided = flipSided;

		 }

	 }

	 function setCullFace( cullFace ) {

		 if ( cullFace !== CullFaceNone$1 ) {

			 enable( 2884 );

			 if ( cullFace !== currentCullFace ) {

				 if ( cullFace === CullFaceBack$1 ) {

					 gl.cullFace( 1029 );

				 } else if ( cullFace === CullFaceFront$1 ) {

					 gl.cullFace( 1028 );

				 } else {

					 gl.cullFace( 1032 );

				 }

			 }

		 } else {

			 disable( 2884 );

		 }

		 currentCullFace = cullFace;

	 }

	 function setLineWidth( width ) {

		 if ( width !== currentLineWidth ) {

			 if ( lineWidthAvailable ) gl.lineWidth( width );

			 currentLineWidth = width;

		 }

	 }

	 function setPolygonOffset( polygonOffset, factor, units ) {

		 if ( polygonOffset ) {

			 enable( 32823 );

			 if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				 gl.polygonOffset( factor, units );

				 currentPolygonOffsetFactor = factor;
				 currentPolygonOffsetUnits = units;

			 }

		 } else {

			 disable( 32823 );

		 }

	 }

	 function setScissorTest( scissorTest ) {

		 if ( scissorTest ) {

			 enable( 3089 );

		 } else {

			 disable( 3089 );

		 }

	 }

	 // texture

	 function activeTexture( webglSlot ) {

		 if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		 if ( currentTextureSlot !== webglSlot ) {

			 gl.activeTexture( webglSlot );
			 currentTextureSlot = webglSlot;

		 }

	 }

	 function bindTexture( webglType, webglTexture ) {

		 if ( currentTextureSlot === null ) {

			 activeTexture();

		 }

		 let boundTexture = currentBoundTextures[ currentTextureSlot ];

		 if ( boundTexture === undefined ) {

			 boundTexture = { type: undefined, texture: undefined };
			 currentBoundTextures[ currentTextureSlot ] = boundTexture;

		 }

		 if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			 gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			 boundTexture.type = webglType;
			 boundTexture.texture = webglTexture;

		 }

	 }

	 function unbindTexture() {

		 const boundTexture = currentBoundTextures[ currentTextureSlot ];

		 if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			 gl.bindTexture( boundTexture.type, null );

			 boundTexture.type = undefined;
			 boundTexture.texture = undefined;

		 }

	 }

	 function compressedTexImage2D() {

		 try {

			 gl.compressedTexImage2D.apply( gl, arguments );

		 } catch ( error ) {

			 console.error( 'THREE.WebGLState:', error );

		 }

	 }

	 function texImage2D() {

		 try {

			 gl.texImage2D.apply( gl, arguments );

		 } catch ( error ) {

			 console.error( 'THREE.WebGLState:', error );

		 }

	 }

	 function texImage3D() {

		 try {

			 gl.texImage3D.apply( gl, arguments );

		 } catch ( error ) {

			 console.error( 'THREE.WebGLState:', error );

		 }

	 }

	 //

	 function scissor( scissor ) {

		 if ( currentScissor.equals( scissor ) === false ) {

			 gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			 currentScissor.copy( scissor );

		 }

	 }

	 function viewport( viewport ) {

		 if ( currentViewport.equals( viewport ) === false ) {

			 gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			 currentViewport.copy( viewport );

		 }

	 }

	 //

	 function reset() {

		 // reset state

		 gl.disable( 3042 );
		 gl.disable( 2884 );
		 gl.disable( 2929 );
		 gl.disable( 32823 );
		 gl.disable( 3089 );
		 gl.disable( 2960 );
		 gl.disable( 32926 );

		 gl.blendEquation( 32774 );
		 gl.blendFunc( 1, 0 );
		 gl.blendFuncSeparate( 1, 0, 1, 0 );

		 gl.colorMask( true, true, true, true );
		 gl.clearColor( 0, 0, 0, 0 );

		 gl.depthMask( true );
		 gl.depthFunc( 513 );
		 gl.clearDepth( 1 );

		 gl.stencilMask( 0xffffffff );
		 gl.stencilFunc( 519, 0, 0xffffffff );
		 gl.stencilOp( 7680, 7680, 7680 );
		 gl.clearStencil( 0 );

		 gl.cullFace( 1029 );
		 gl.frontFace( 2305 );

		 gl.polygonOffset( 0, 0 );

		 gl.activeTexture( 33984 );

		 gl.bindFramebuffer( 36160, null );

		 if ( isWebGL2 === true ) {

			 gl.bindFramebuffer( 36009, null );
			 gl.bindFramebuffer( 36008, null );

		 }

		 gl.useProgram( null );

		 gl.lineWidth( 1 );

		 gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		 gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		 // reset internals

		 enabledCapabilities = {};

		 currentTextureSlot = null;
		 currentBoundTextures = {};

		 xrFramebuffer = null;
		 currentBoundFramebuffers = {};

		 currentProgram = null;

		 currentBlendingEnabled = false;
		 currentBlending = null;
		 currentBlendEquation = null;
		 currentBlendSrc = null;
		 currentBlendDst = null;
		 currentBlendEquationAlpha = null;
		 currentBlendSrcAlpha = null;
		 currentBlendDstAlpha = null;
		 currentPremultipledAlpha = false;

		 currentFlipSided = null;
		 currentCullFace = null;

		 currentLineWidth = null;

		 currentPolygonOffsetFactor = null;
		 currentPolygonOffsetUnits = null;

		 currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		 currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		 colorBuffer.reset();
		 depthBuffer.reset();
		 stencilBuffer.reset();

	 }

	 return {

		 buffers: {
			 color: colorBuffer,
			 depth: depthBuffer,
			 stencil: stencilBuffer
		 },

		 enable: enable,
		 disable: disable,

		 bindFramebuffer: bindFramebuffer,
		 bindXRFramebuffer: bindXRFramebuffer,

		 useProgram: useProgram,

		 setBlending: setBlending,
		 setMaterial: setMaterial,

		 setFlipSided: setFlipSided,
		 setCullFace: setCullFace,

		 setLineWidth: setLineWidth,
		 setPolygonOffset: setPolygonOffset,

		 setScissorTest: setScissorTest,

		 activeTexture: activeTexture,
		 bindTexture: bindTexture,
		 unbindTexture: unbindTexture,
		 compressedTexImage2D: compressedTexImage2D,
		 texImage2D: texImage2D,
		 texImage3D: texImage3D,

		 scissor: scissor,
		 viewport: viewport,

		 reset: reset

	 };

 }

 function WebGLTextures$1( _gl, extensions, state, properties, capabilities, utils, info ) {

	 const isWebGL2 = capabilities.isWebGL2;
	 const maxTextures = capabilities.maxTextures;
	 const maxCubemapSize = capabilities.maxCubemapSize;
	 const maxTextureSize = capabilities.maxTextureSize;
	 const maxSamples = capabilities.maxSamples;

	 const _videoTextures = new WeakMap();
	 let _canvas;

	 // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	 // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	 // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	 let useOffscreenCanvas = false;

	 try {

		 useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			 && ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	 } catch ( err ) {

		 // Ignore any errors

	 }

	 function createCanvas( width, height ) {

		 // Use OffscreenCanvas when available. Specially needed in web workers

		 return useOffscreenCanvas ?
			 new OffscreenCanvas( width, height ) :
			 document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	 }

	 function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		 let scale = 1;

		 // handle case if texture exceeds max size

		 if ( image.width > maxSize || image.height > maxSize ) {

			 scale = maxSize / Math.max( image.width, image.height );

		 }

		 // only perform resize if necessary

		 if ( scale < 1 || needsPowerOfTwo === true ) {

			 // only perform resize for certain image types

			 if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				 ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				 ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				 const floor = needsPowerOfTwo ? floorPowerOfTwo$1 : Math.floor;

				 const width = floor( scale * image.width );
				 const height = floor( scale * image.height );

				 if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				 // cube textures can't reuse the same canvas

				 const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				 canvas.width = width;
				 canvas.height = height;

				 const context = canvas.getContext( '2d' );
				 context.drawImage( image, 0, 0, width, height );

				 console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				 return canvas;

			 } else {

				 if ( 'data' in image ) {

					 console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				 }

				 return image;

			 }

		 }

		 return image;

	 }

	 function isPowerOfTwo$1$1( image ) {

		 return isPowerOfTwo$1( image.width ) && isPowerOfTwo$1( image.height );

	 }

	 function textureNeedsPowerOfTwo( texture ) {

		 if ( isWebGL2 ) return false;

		 return ( texture.wrapS !== ClampToEdgeWrapping$1 || texture.wrapT !== ClampToEdgeWrapping$1 ) ||
			 ( texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1 );

	 }

	 function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		 return texture.generateMipmaps && supportsMips &&
			 texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1;

	 }

	 function generateMipmap( target, texture, width, height, depth = 1 ) {

		 _gl.generateMipmap( target );

		 const textureProperties = properties.get( texture );

		 textureProperties.__maxMipLevel = Math.log2( Math.max( width, height, depth ) );

	 }

	 function getInternalFormat( internalFormatName, glFormat, glType ) {

		 if ( isWebGL2 === false ) return glFormat;

		 if ( internalFormatName !== null ) {

			 if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			 console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		 }

		 let internalFormat = glFormat;

		 if ( glFormat === 6403 ) {

			 if ( glType === 5126 ) internalFormat = 33326;
			 if ( glType === 5131 ) internalFormat = 33325;
			 if ( glType === 5121 ) internalFormat = 33321;

		 }

		 if ( glFormat === 6407 ) {

			 if ( glType === 5126 ) internalFormat = 34837;
			 if ( glType === 5131 ) internalFormat = 34843;
			 if ( glType === 5121 ) internalFormat = 32849;

		 }

		 if ( glFormat === 6408 ) {

			 if ( glType === 5126 ) internalFormat = 34836;
			 if ( glType === 5131 ) internalFormat = 34842;
			 if ( glType === 5121 ) internalFormat = 32856;

		 }

		 if ( internalFormat === 33325 || internalFormat === 33326 ||
			 internalFormat === 34842 || internalFormat === 34836 ) {

			 extensions.get( 'EXT_color_buffer_float' );

		 }

		 return internalFormat;

	 }

	 // Fallback filters for non-power-of-2 textures

	 function filterFallback( f ) {

		 if ( f === NearestFilter$1 || f === NearestMipmapNearestFilter$1 || f === NearestMipmapLinearFilter$1 ) {

			 return 9728;

		 }

		 return 9729;

	 }

	 //

	 function onTextureDispose( event ) {

		 const texture = event.target;

		 texture.removeEventListener( 'dispose', onTextureDispose );

		 deallocateTexture( texture );

		 if ( texture.isVideoTexture ) {

			 _videoTextures.delete( texture );

		 }

		 info.memory.textures --;

	 }

	 function onRenderTargetDispose( event ) {

		 const renderTarget = event.target;

		 renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		 deallocateRenderTarget( renderTarget );

	 }

	 //

	 function deallocateTexture( texture ) {

		 const textureProperties = properties.get( texture );

		 if ( textureProperties.__webglInit === undefined ) return;

		 _gl.deleteTexture( textureProperties.__webglTexture );

		 properties.remove( texture );

	 }

	 function deallocateRenderTarget( renderTarget ) {

		 const texture = renderTarget.texture;

		 const renderTargetProperties = properties.get( renderTarget );
		 const textureProperties = properties.get( texture );

		 if ( ! renderTarget ) return;

		 if ( textureProperties.__webglTexture !== undefined ) {

			 _gl.deleteTexture( textureProperties.__webglTexture );

			 info.memory.textures --;

		 }

		 if ( renderTarget.depthTexture ) {

			 renderTarget.depthTexture.dispose();

		 }

		 if ( renderTarget.isWebGLCubeRenderTarget ) {

			 for ( let i = 0; i < 6; i ++ ) {

				 _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				 if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			 }

		 } else {

			 _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			 if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			 if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			 if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			 if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		 }

		 if ( renderTarget.isWebGLMultipleRenderTargets ) {

			 for ( let i = 0, il = texture.length; i < il; i ++ ) {

				 const attachmentProperties = properties.get( texture[ i ] );

				 if ( attachmentProperties.__webglTexture ) {

					 _gl.deleteTexture( attachmentProperties.__webglTexture );

					 info.memory.textures --;

				 }

				 properties.remove( texture[ i ] );

			 }

		 }

		 properties.remove( texture );
		 properties.remove( renderTarget );

	 }

	 //

	 let textureUnits = 0;

	 function resetTextureUnits() {

		 textureUnits = 0;

	 }

	 function allocateTextureUnit() {

		 const textureUnit = textureUnits;

		 if ( textureUnit >= maxTextures ) {

			 console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		 }

		 textureUnits += 1;

		 return textureUnit;

	 }

	 //

	 function setTexture2D( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.isVideoTexture ) updateVideoTexture( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 const image = texture.image;

			 if ( image === undefined ) {

				 console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			 } else if ( image.complete === false ) {

				 console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			 } else {

				 uploadTexture( textureProperties, texture, slot );
				 return;

			 }

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 3553, textureProperties.__webglTexture );

	 }

	 function setTexture2DArray( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 uploadTexture( textureProperties, texture, slot );
			 return;

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 35866, textureProperties.__webglTexture );

	 }

	 function setTexture3D( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 uploadTexture( textureProperties, texture, slot );
			 return;

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 32879, textureProperties.__webglTexture );

	 }

	 function setTextureCube( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 uploadCubeTexture( textureProperties, texture, slot );
			 return;

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 34067, textureProperties.__webglTexture );

	 }

	 const wrappingToGL = {
		 [ RepeatWrapping$1 ]: 10497,
		 [ ClampToEdgeWrapping$1 ]: 33071,
		 [ MirroredRepeatWrapping$1 ]: 33648
	 };

	 const filterToGL = {
		 [ NearestFilter$1 ]: 9728,
		 [ NearestMipmapNearestFilter$1 ]: 9984,
		 [ NearestMipmapLinearFilter$1 ]: 9986,

		 [ LinearFilter$1 ]: 9729,
		 [ LinearMipmapNearestFilter$1 ]: 9985,
		 [ LinearMipmapLinearFilter$1 ]: 9987
	 };

	 function setTextureParameters( textureType, texture, supportsMips ) {

		 if ( supportsMips ) {

			 _gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			 _gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			 if ( textureType === 32879 || textureType === 35866 ) {

				 _gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			 }

			 _gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			 _gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		 } else {

			 _gl.texParameteri( textureType, 10242, 33071 );
			 _gl.texParameteri( textureType, 10243, 33071 );

			 if ( textureType === 32879 || textureType === 35866 ) {

				 _gl.texParameteri( textureType, 32882, 33071 );

			 }

			 if ( texture.wrapS !== ClampToEdgeWrapping$1 || texture.wrapT !== ClampToEdgeWrapping$1 ) {

				 console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			 }

			 _gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			 _gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			 if ( texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1 ) {

				 console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			 }

		 }

		 if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			 const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			 if ( texture.type === FloatType$1 && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			 if ( isWebGL2 === false && ( texture.type === HalfFloatType$1 && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			 if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				 _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				 properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			 }

		 }

	 }

	 function initTexture( textureProperties, texture ) {

		 if ( textureProperties.__webglInit === undefined ) {

			 textureProperties.__webglInit = true;

			 texture.addEventListener( 'dispose', onTextureDispose );

			 textureProperties.__webglTexture = _gl.createTexture();

			 info.memory.textures ++;

		 }

	 }

	 function uploadTexture( textureProperties, texture, slot ) {

		 let textureType = 3553;

		 if ( texture.isDataTexture2DArray ) textureType = 35866;
		 if ( texture.isDataTexture3D ) textureType = 32879;

		 initTexture( textureProperties, texture );

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( textureType, textureProperties.__webglTexture );

		 _gl.pixelStorei( 37440, texture.flipY );
		 _gl.pixelStorei( 37441, texture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, texture.unpackAlignment );
		 _gl.pixelStorei( 37443, 0 );

		 const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1$1( texture.image ) === false;
		 const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		 const supportsMips = isPowerOfTwo$1$1( image ) || isWebGL2,
			 glFormat = utils.convert( texture.format );

		 let glType = utils.convert( texture.type ),
			 glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		 setTextureParameters( textureType, texture, supportsMips );

		 let mipmap;
		 const mipmaps = texture.mipmaps;

		 if ( texture.isDepthTexture ) {

			 // populate depth texture with dummy data

			 glInternalFormat = 6402;

			 if ( isWebGL2 ) {

				 if ( texture.type === FloatType$1 ) {

					 glInternalFormat = 36012;

				 } else if ( texture.type === UnsignedIntType$1 ) {

					 glInternalFormat = 33190;

				 } else if ( texture.type === UnsignedInt248Type$1 ) {

					 glInternalFormat = 35056;

				 } else {

					 glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				 }

			 } else {

				 if ( texture.type === FloatType$1 ) {

					 console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				 }

			 }

			 // validation checks for WebGL 1

			 if ( texture.format === DepthFormat$1 && glInternalFormat === 6402 ) {

				 // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				 // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				 // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				 if ( texture.type !== UnsignedShortType$1 && texture.type !== UnsignedIntType$1 ) {

					 console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					 texture.type = UnsignedShortType$1;
					 glType = utils.convert( texture.type );

				 }

			 }

			 if ( texture.format === DepthStencilFormat$1 && glInternalFormat === 6402 ) {

				 // Depth stencil textures need the DEPTH_STENCIL internal format
				 // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				 glInternalFormat = 34041;

				 // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				 // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				 // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				 if ( texture.type !== UnsignedInt248Type$1 ) {

					 console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					 texture.type = UnsignedInt248Type$1;
					 glType = utils.convert( texture.type );

				 }

			 }

			 //

			 state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		 } else if ( texture.isDataTexture ) {

			 // use manually created mipmaps if available
			 // if there are no manual mipmaps
			 // set 0 level mipmap and then use GL to generate other mipmap levels

			 if ( mipmaps.length > 0 && supportsMips ) {

				 for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					 mipmap = mipmaps[ i ];
					 state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				 }

				 texture.generateMipmaps = false;
				 textureProperties.__maxMipLevel = mipmaps.length - 1;

			 } else {

				 state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				 textureProperties.__maxMipLevel = 0;

			 }

		 } else if ( texture.isCompressedTexture ) {

			 for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

				 mipmap = mipmaps[ i ];

				 if ( texture.format !== RGBAFormat$1 && texture.format !== RGBFormat$1 ) {

					 if ( glFormat !== null ) {

						 state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					 } else {

						 console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					 }

				 } else {

					 state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				 }

			 }

			 textureProperties.__maxMipLevel = mipmaps.length - 1;

		 } else if ( texture.isDataTexture2DArray ) {

			 state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			 textureProperties.__maxMipLevel = 0;

		 } else if ( texture.isDataTexture3D ) {

			 state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			 textureProperties.__maxMipLevel = 0;

		 } else {

			 // regular Texture (image, video, canvas)

			 // use manually created mipmaps if available
			 // if there are no manual mipmaps
			 // set 0 level mipmap and then use GL to generate other mipmap levels

			 if ( mipmaps.length > 0 && supportsMips ) {

				 for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					 mipmap = mipmaps[ i ];
					 state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				 }

				 texture.generateMipmaps = false;
				 textureProperties.__maxMipLevel = mipmaps.length - 1;

			 } else {

				 state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				 textureProperties.__maxMipLevel = 0;

			 }

		 }

		 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			 generateMipmap( textureType, texture, image.width, image.height );

		 }

		 textureProperties.__version = texture.version;

		 if ( texture.onUpdate ) texture.onUpdate( texture );

	 }

	 function uploadCubeTexture( textureProperties, texture, slot ) {

		 if ( texture.image.length !== 6 ) return;

		 initTexture( textureProperties, texture );

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 34067, textureProperties.__webglTexture );

		 _gl.pixelStorei( 37440, texture.flipY );
		 _gl.pixelStorei( 37441, texture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, texture.unpackAlignment );
		 _gl.pixelStorei( 37443, 0 );

		 const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
		 const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

		 const cubeImage = [];

		 for ( let i = 0; i < 6; i ++ ) {

			 if ( ! isCompressed && ! isDataTexture ) {

				 cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

			 } else {

				 cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

			 }

		 }

		 const image = cubeImage[ 0 ],
			 supportsMips = isPowerOfTwo$1$1( image ) || isWebGL2,
			 glFormat = utils.convert( texture.format ),
			 glType = utils.convert( texture.type ),
			 glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		 setTextureParameters( 34067, texture, supportsMips );

		 let mipmaps;

		 if ( isCompressed ) {

			 for ( let i = 0; i < 6; i ++ ) {

				 mipmaps = cubeImage[ i ].mipmaps;

				 for ( let j = 0; j < mipmaps.length; j ++ ) {

					 const mipmap = mipmaps[ j ];

					 if ( texture.format !== RGBAFormat$1 && texture.format !== RGBFormat$1 ) {

						 if ( glFormat !== null ) {

							 state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						 } else {

							 console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

						 }

					 } else {

						 state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					 }

				 }

			 }

			 textureProperties.__maxMipLevel = mipmaps.length - 1;

		 } else {

			 mipmaps = texture.mipmaps;

			 for ( let i = 0; i < 6; i ++ ) {

				 if ( isDataTexture ) {

					 state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

					 for ( let j = 0; j < mipmaps.length; j ++ ) {

						 const mipmap = mipmaps[ j ];
						 const mipmapImage = mipmap.image[ i ].image;

						 state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

					 }

				 } else {

					 state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

					 for ( let j = 0; j < mipmaps.length; j ++ ) {

						 const mipmap = mipmaps[ j ];

						 state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

					 }

				 }

			 }

			 textureProperties.__maxMipLevel = mipmaps.length;

		 }

		 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			 // We assume images for cube map have the same size.
			 generateMipmap( 34067, texture, image.width, image.height );

		 }

		 textureProperties.__version = texture.version;

		 if ( texture.onUpdate ) texture.onUpdate( texture );

	 }

	 // Render targets

	 // Setup storage for target texture and bind it to correct framebuffer
	 function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

		 const glFormat = utils.convert( texture.format );
		 const glType = utils.convert( texture.type );
		 const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		 if ( textureTarget === 32879 || textureTarget === 35866 ) {

			 state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

		 } else {

			 state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

		 }

		 state.bindFramebuffer( 36160, framebuffer );
		 _gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
		 state.bindFramebuffer( 36160, null );

	 }

	 // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	 function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		 _gl.bindRenderbuffer( 36161, renderbuffer );

		 if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			 let glInternalFormat = 33189;

			 if ( isMultisample ) {

				 const depthTexture = renderTarget.depthTexture;

				 if ( depthTexture && depthTexture.isDepthTexture ) {

					 if ( depthTexture.type === FloatType$1 ) {

						 glInternalFormat = 36012;

					 } else if ( depthTexture.type === UnsignedIntType$1 ) {

						 glInternalFormat = 33190;

					 }

				 }

				 const samples = getRenderTargetSamples( renderTarget );

				 _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			 } else {

				 _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			 }

			 _gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		 } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			 if ( isMultisample ) {

				 const samples = getRenderTargetSamples( renderTarget );

				 _gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			 } else {

				 _gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			 }


			 _gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		 } else {

			 // Use the first texture for MRT so far
			 const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[ 0 ] : renderTarget.texture;

			 const glFormat = utils.convert( texture.format );
			 const glType = utils.convert( texture.type );
			 const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			 if ( isMultisample ) {

				 const samples = getRenderTargetSamples( renderTarget );

				 _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			 } else {

				 _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			 }

		 }

		 _gl.bindRenderbuffer( 36161, null );

	 }

	 // Setup resources for a Depth Texture for a FBO (needs an extension)
	 function setupDepthTexture( framebuffer, renderTarget ) {

		 const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		 if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		 state.bindFramebuffer( 36160, framebuffer );

		 if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			 throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		 }

		 // upload an empty depth texture with framebuffer size
		 if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				 renderTarget.depthTexture.image.width !== renderTarget.width ||
				 renderTarget.depthTexture.image.height !== renderTarget.height ) {

			 renderTarget.depthTexture.image.width = renderTarget.width;
			 renderTarget.depthTexture.image.height = renderTarget.height;
			 renderTarget.depthTexture.needsUpdate = true;

		 }

		 setTexture2D( renderTarget.depthTexture, 0 );

		 const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		 if ( renderTarget.depthTexture.format === DepthFormat$1 ) {

			 _gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		 } else if ( renderTarget.depthTexture.format === DepthStencilFormat$1 ) {

			 _gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		 } else {

			 throw new Error( 'Unknown depthTexture format' );

		 }

	 }

	 // Setup GL resources for a non-texture depth buffer
	 function setupDepthRenderbuffer( renderTarget ) {

		 const renderTargetProperties = properties.get( renderTarget );

		 const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		 if ( renderTarget.depthTexture ) {

			 if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			 setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		 } else {

			 if ( isCube ) {

				 renderTargetProperties.__webglDepthbuffer = [];

				 for ( let i = 0; i < 6; i ++ ) {

					 state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					 renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					 setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				 }

			 } else {

				 state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				 renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				 setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			 }

		 }

		 state.bindFramebuffer( 36160, null );

	 }

	 // Set up GL resources for the render target
	 function setupRenderTarget( renderTarget ) {

		 const texture = renderTarget.texture;

		 const renderTargetProperties = properties.get( renderTarget );
		 const textureProperties = properties.get( texture );

		 renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		 if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

			 textureProperties.__webglTexture = _gl.createTexture();
			 textureProperties.__version = texture.version;
			 info.memory.textures ++;

		 }

		 const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		 const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
		 const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		 const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
		 const supportsMips = isPowerOfTwo$1$1( renderTarget ) || isWebGL2;

		 // Handles WebGL2 RGBFormat fallback - #18858

		 if ( isWebGL2 && texture.format === RGBFormat$1 && ( texture.type === FloatType$1 || texture.type === HalfFloatType$1 ) ) {

			 texture.format = RGBAFormat$1;

			 console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		 }

		 // Setup framebuffer

		 if ( isCube ) {

			 renderTargetProperties.__webglFramebuffer = [];

			 for ( let i = 0; i < 6; i ++ ) {

				 renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			 }

		 } else {

			 renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			 if ( isMultipleRenderTargets ) {

				 if ( capabilities.drawBuffers ) {

					 const textures = renderTarget.texture;

					 for ( let i = 0, il = textures.length; i < il; i ++ ) {

						 const attachmentProperties = properties.get( textures[ i ] );

						 if ( attachmentProperties.__webglTexture === undefined ) {

							 attachmentProperties.__webglTexture = _gl.createTexture();

							 info.memory.textures ++;

						 }

					 }

				 } else {

					 console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

				 }

			 } else if ( isMultisample ) {

				 if ( isWebGL2 ) {

					 renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					 renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					 _gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					 const glFormat = utils.convert( texture.format );
					 const glType = utils.convert( texture.type );
					 const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
					 const samples = getRenderTargetSamples( renderTarget );
					 _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					 state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					 _gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					 _gl.bindRenderbuffer( 36161, null );

					 if ( renderTarget.depthBuffer ) {

						 renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						 setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					 }

					 state.bindFramebuffer( 36160, null );


				 } else {

					 console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				 }

			 }

		 }

		 // Setup color buffer

		 if ( isCube ) {

			 state.bindTexture( 34067, textureProperties.__webglTexture );
			 setTextureParameters( 34067, texture, supportsMips );

			 for ( let i = 0; i < 6; i ++ ) {

				 setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

			 }

			 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				 generateMipmap( 34067, texture, renderTarget.width, renderTarget.height );

			 }

			 state.bindTexture( 34067, null );

		 } else if ( isMultipleRenderTargets ) {

			 const textures = renderTarget.texture;

			 for ( let i = 0, il = textures.length; i < il; i ++ ) {

				 const attachment = textures[ i ];
				 const attachmentProperties = properties.get( attachment );

				 state.bindTexture( 3553, attachmentProperties.__webglTexture );
				 setTextureParameters( 3553, attachment, supportsMips );
				 setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

				 if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

					 generateMipmap( 3553, attachment, renderTarget.width, renderTarget.height );

				 }

			 }

			 state.bindTexture( 3553, null );

		 } else {

			 let glTextureType = 3553;

			 if ( isRenderTarget3D ) {

				 // Render targets containing layers, i.e: Texture 3D and 2d arrays

				 if ( isWebGL2 ) {

					 const isTexture3D = texture.isDataTexture3D;
					 glTextureType = isTexture3D ? 32879 : 35866;

				 } else {

					 console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

				 }

			 }

			 state.bindTexture( glTextureType, textureProperties.__webglTexture );
			 setTextureParameters( glTextureType, texture, supportsMips );
			 setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

			 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				 generateMipmap( glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth );

			 }

			 state.bindTexture( glTextureType, null );

		 }

		 // Setup depth and stencil buffers

		 if ( renderTarget.depthBuffer ) {

			 setupDepthRenderbuffer( renderTarget );

		 }

	 }

	 function updateRenderTargetMipmap( renderTarget ) {

		 const supportsMips = isPowerOfTwo$1$1( renderTarget ) || isWebGL2;

		 const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

		 for ( let i = 0, il = textures.length; i < il; i ++ ) {

			 const texture = textures[ i ];

			 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				 const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
				 const webglTexture = properties.get( texture ).__webglTexture;

				 state.bindTexture( target, webglTexture );
				 generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				 state.bindTexture( target, null );

			 }

		 }

	 }

	 function updateMultisampleRenderTarget( renderTarget ) {

		 if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			 if ( isWebGL2 ) {

				 const width = renderTarget.width;
				 const height = renderTarget.height;
				 let mask = 16384;

				 if ( renderTarget.depthBuffer ) mask |= 256;
				 if ( renderTarget.stencilBuffer ) mask |= 1024;

				 const renderTargetProperties = properties.get( renderTarget );

				 state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				 state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				 _gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				 state.bindFramebuffer( 36008, null );
				 state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

			 } else {

				 console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			 }

		 }

	 }

	 function getRenderTargetSamples( renderTarget ) {

		 return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			 Math.min( maxSamples, renderTarget.samples ) : 0;

	 }

	 function updateVideoTexture( texture ) {

		 const frame = info.render.frame;

		 // Check the last frame we updated the VideoTexture

		 if ( _videoTextures.get( texture ) !== frame ) {

			 _videoTextures.set( texture, frame );
			 texture.update();

		 }

	 }

	 // backwards compatibility

	 let warnedTexture2D = false;
	 let warnedTextureCube = false;

	 function safeSetTexture2D( texture, slot ) {

		 if ( texture && texture.isWebGLRenderTarget ) {

			 if ( warnedTexture2D === false ) {

				 console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
				 warnedTexture2D = true;

			 }

			 texture = texture.texture;

		 }

		 setTexture2D( texture, slot );

	 }

	 function safeSetTextureCube( texture, slot ) {

		 if ( texture && texture.isWebGLCubeRenderTarget ) {

			 if ( warnedTextureCube === false ) {

				 console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
				 warnedTextureCube = true;

			 }

			 texture = texture.texture;

		 }


		 setTextureCube( texture, slot );

	 }

	 //

	 this.allocateTextureUnit = allocateTextureUnit;
	 this.resetTextureUnits = resetTextureUnits;

	 this.setTexture2D = setTexture2D;
	 this.setTexture2DArray = setTexture2DArray;
	 this.setTexture3D = setTexture3D;
	 this.setTextureCube = setTextureCube;
	 this.setupRenderTarget = setupRenderTarget;
	 this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	 this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	 this.safeSetTexture2D = safeSetTexture2D;
	 this.safeSetTextureCube = safeSetTextureCube;

 }

 function WebGLUtils$1( gl, extensions, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 function convert( p ) {

		 let extension;

		 if ( p === UnsignedByteType$1 ) return 5121;
		 if ( p === UnsignedShort4444Type$1 ) return 32819;
		 if ( p === UnsignedShort5551Type$1 ) return 32820;
		 if ( p === UnsignedShort565Type$1 ) return 33635;

		 if ( p === ByteType$1 ) return 5120;
		 if ( p === ShortType$1 ) return 5122;
		 if ( p === UnsignedShortType$1 ) return 5123;
		 if ( p === IntType$1 ) return 5124;
		 if ( p === UnsignedIntType$1 ) return 5125;
		 if ( p === FloatType$1 ) return 5126;

		 if ( p === HalfFloatType$1 ) {

			 if ( isWebGL2 ) return 5131;

			 extension = extensions.get( 'OES_texture_half_float' );

			 if ( extension !== null ) {

				 return extension.HALF_FLOAT_OES;

			 } else {

				 return null;

			 }

		 }

		 if ( p === AlphaFormat$1 ) return 6406;
		 if ( p === RGBFormat$1 ) return 6407;
		 if ( p === RGBAFormat$1 ) return 6408;
		 if ( p === LuminanceFormat$1 ) return 6409;
		 if ( p === LuminanceAlphaFormat$1 ) return 6410;
		 if ( p === DepthFormat$1 ) return 6402;
		 if ( p === DepthStencilFormat$1 ) return 34041;
		 if ( p === RedFormat$1 ) return 6403;

		 // WebGL2 formats.

		 if ( p === RedIntegerFormat$1 ) return 36244;
		 if ( p === RGFormat$1 ) return 33319;
		 if ( p === RGIntegerFormat$1 ) return 33320;
		 if ( p === RGBIntegerFormat$1 ) return 36248;
		 if ( p === RGBAIntegerFormat$1 ) return 36249;

		 if ( p === RGB_S3TC_DXT1_Format$1 || p === RGBA_S3TC_DXT1_Format$1 ||
			 p === RGBA_S3TC_DXT3_Format$1 || p === RGBA_S3TC_DXT5_Format$1 ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			 if ( extension !== null ) {

				 if ( p === RGB_S3TC_DXT1_Format$1 ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				 if ( p === RGBA_S3TC_DXT1_Format$1 ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				 if ( p === RGBA_S3TC_DXT3_Format$1 ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				 if ( p === RGBA_S3TC_DXT5_Format$1 ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGB_PVRTC_4BPPV1_Format$1 || p === RGB_PVRTC_2BPPV1_Format$1 ||
			 p === RGBA_PVRTC_4BPPV1_Format$1 || p === RGBA_PVRTC_2BPPV1_Format$1 ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			 if ( extension !== null ) {

				 if ( p === RGB_PVRTC_4BPPV1_Format$1 ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				 if ( p === RGB_PVRTC_2BPPV1_Format$1 ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				 if ( p === RGBA_PVRTC_4BPPV1_Format$1 ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				 if ( p === RGBA_PVRTC_2BPPV1_Format$1 ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGB_ETC1_Format$1 ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			 if ( extension !== null ) {

				 return extension.COMPRESSED_RGB_ETC1_WEBGL;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGB_ETC2_Format$1 || p === RGBA_ETC2_EAC_Format$1 ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			 if ( extension !== null ) {

				 if ( p === RGB_ETC2_Format$1 ) return extension.COMPRESSED_RGB8_ETC2;
				 if ( p === RGBA_ETC2_EAC_Format$1 ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			 }

		 }

		 if ( p === RGBA_ASTC_4x4_Format$1 || p === RGBA_ASTC_5x4_Format$1 || p === RGBA_ASTC_5x5_Format$1 ||
			 p === RGBA_ASTC_6x5_Format$1 || p === RGBA_ASTC_6x6_Format$1 || p === RGBA_ASTC_8x5_Format$1 ||
			 p === RGBA_ASTC_8x6_Format$1 || p === RGBA_ASTC_8x8_Format$1 || p === RGBA_ASTC_10x5_Format$1 ||
			 p === RGBA_ASTC_10x6_Format$1 || p === RGBA_ASTC_10x8_Format$1 || p === RGBA_ASTC_10x10_Format$1 ||
			 p === RGBA_ASTC_12x10_Format$1 || p === RGBA_ASTC_12x12_Format$1 ||
			 p === SRGB8_ALPHA8_ASTC_4x4_Format$1 || p === SRGB8_ALPHA8_ASTC_5x4_Format$1 || p === SRGB8_ALPHA8_ASTC_5x5_Format$1 ||
			 p === SRGB8_ALPHA8_ASTC_6x5_Format$1 || p === SRGB8_ALPHA8_ASTC_6x6_Format$1 || p === SRGB8_ALPHA8_ASTC_8x5_Format$1 ||
			 p === SRGB8_ALPHA8_ASTC_8x6_Format$1 || p === SRGB8_ALPHA8_ASTC_8x8_Format$1 || p === SRGB8_ALPHA8_ASTC_10x5_Format$1 ||
			 p === SRGB8_ALPHA8_ASTC_10x6_Format$1 || p === SRGB8_ALPHA8_ASTC_10x8_Format$1 || p === SRGB8_ALPHA8_ASTC_10x10_Format$1 ||
			 p === SRGB8_ALPHA8_ASTC_12x10_Format$1 || p === SRGB8_ALPHA8_ASTC_12x12_Format$1 ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			 if ( extension !== null ) {

				 // TODO Complete?

				 return p;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGBA_BPTC_Format$1 ) {

			 extension = extensions.get( 'EXT_texture_compression_bptc' );

			 if ( extension !== null ) {

				 // TODO Complete?

				 return p;

			 } else {

				 return null;

			 }

		 }

		 if ( p === UnsignedInt248Type$1 ) {

			 if ( isWebGL2 ) return 34042;

			 extension = extensions.get( 'WEBGL_depth_texture' );

			 if ( extension !== null ) {

				 return extension.UNSIGNED_INT_24_8_WEBGL;

			 } else {

				 return null;

			 }

		 }

	 }

	 return { convert: convert };

 }

 class ArrayCamera$1 extends PerspectiveCamera$1 {

	 constructor( array = [] ) {

		 super();

		 this.cameras = array;

	 }

 }

 ArrayCamera$1.prototype.isArrayCamera = true;

 class Group$1 extends Object3D$1 {

	 constructor() {

		 super();

		 this.type = 'Group';

	 }

 }

 Group$1.prototype.isGroup = true;

 const _moveEvent$1 = { type: 'move' };

 class WebXRController$1 {

	 constructor() {

		 this._targetRay = null;
		 this._grip = null;
		 this._hand = null;

	 }

	 getHandSpace() {

		 if ( this._hand === null ) {

			 this._hand = new Group$1();
			 this._hand.matrixAutoUpdate = false;
			 this._hand.visible = false;

			 this._hand.joints = {};
			 this._hand.inputState = { pinching: false };

		 }

		 return this._hand;

	 }

	 getTargetRaySpace() {

		 if ( this._targetRay === null ) {

			 this._targetRay = new Group$1();
			 this._targetRay.matrixAutoUpdate = false;
			 this._targetRay.visible = false;
			 this._targetRay.hasLinearVelocity = false;
			 this._targetRay.linearVelocity = new Vector3$1();
			 this._targetRay.hasAngularVelocity = false;
			 this._targetRay.angularVelocity = new Vector3$1();

		 }

		 return this._targetRay;

	 }

	 getGripSpace() {

		 if ( this._grip === null ) {

			 this._grip = new Group$1();
			 this._grip.matrixAutoUpdate = false;
			 this._grip.visible = false;
			 this._grip.hasLinearVelocity = false;
			 this._grip.linearVelocity = new Vector3$1();
			 this._grip.hasAngularVelocity = false;
			 this._grip.angularVelocity = new Vector3$1();

		 }

		 return this._grip;

	 }

	 dispatchEvent( event ) {

		 if ( this._targetRay !== null ) {

			 this._targetRay.dispatchEvent( event );

		 }

		 if ( this._grip !== null ) {

			 this._grip.dispatchEvent( event );

		 }

		 if ( this._hand !== null ) {

			 this._hand.dispatchEvent( event );

		 }

		 return this;

	 }

	 disconnect( inputSource ) {

		 this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		 if ( this._targetRay !== null ) {

			 this._targetRay.visible = false;

		 }

		 if ( this._grip !== null ) {

			 this._grip.visible = false;

		 }

		 if ( this._hand !== null ) {

			 this._hand.visible = false;

		 }

		 return this;

	 }

	 update( inputSource, frame, referenceSpace ) {

		 let inputPose = null;
		 let gripPose = null;
		 let handPose = null;

		 const targetRay = this._targetRay;
		 const grip = this._grip;
		 const hand = this._hand;

		 if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			 if ( targetRay !== null ) {

				 inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				 if ( inputPose !== null ) {

					 targetRay.matrix.fromArray( inputPose.transform.matrix );
					 targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					 if ( inputPose.linearVelocity ) {

						 targetRay.hasLinearVelocity = true;
						 targetRay.linearVelocity.copy( inputPose.linearVelocity );

					 } else {

						 targetRay.hasLinearVelocity = false;

					 }

					 if ( inputPose.angularVelocity ) {

						 targetRay.hasAngularVelocity = true;
						 targetRay.angularVelocity.copy( inputPose.angularVelocity );

					 } else {

						 targetRay.hasAngularVelocity = false;

					 }

					 this.dispatchEvent( _moveEvent$1 );

				 }

			 }

			 if ( hand && inputSource.hand ) {

				 handPose = true;

				 for ( const inputjoint of inputSource.hand.values() ) {

					 // Update the joints groups with the XRJoint poses
					 const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					 if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						 // The transform of this joint will be updated with the joint pose on each frame
						 const joint = new Group$1();
						 joint.matrixAutoUpdate = false;
						 joint.visible = false;
						 hand.joints[ inputjoint.jointName ] = joint;
						 // ??
						 hand.add( joint );

					 }

					 const joint = hand.joints[ inputjoint.jointName ];

					 if ( jointPose !== null ) {

						 joint.matrix.fromArray( jointPose.transform.matrix );
						 joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						 joint.jointRadius = jointPose.radius;

					 }

					 joint.visible = jointPose !== null;

				 }

				 // Custom events

				 // Check pinchz
				 const indexTip = hand.joints[ 'index-finger-tip' ];
				 const thumbTip = hand.joints[ 'thumb-tip' ];
				 const distance = indexTip.position.distanceTo( thumbTip.position );

				 const distanceToPinch = 0.02;
				 const threshold = 0.005;

				 if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					 hand.inputState.pinching = false;
					 this.dispatchEvent( {
						 type: 'pinchend',
						 handedness: inputSource.handedness,
						 target: this
					 } );

				 } else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					 hand.inputState.pinching = true;
					 this.dispatchEvent( {
						 type: 'pinchstart',
						 handedness: inputSource.handedness,
						 target: this
					 } );

				 }

			 } else {

				 if ( grip !== null && inputSource.gripSpace ) {

					 gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					 if ( gripPose !== null ) {

						 grip.matrix.fromArray( gripPose.transform.matrix );
						 grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						 if ( gripPose.linearVelocity ) {

							 grip.hasLinearVelocity = true;
							 grip.linearVelocity.copy( gripPose.linearVelocity );

						 } else {

							 grip.hasLinearVelocity = false;

						 }

						 if ( gripPose.angularVelocity ) {

							 grip.hasAngularVelocity = true;
							 grip.angularVelocity.copy( gripPose.angularVelocity );

						 } else {

							 grip.hasAngularVelocity = false;

						 }

					 }

				 }

			 }

		 }

		 if ( targetRay !== null ) {

			 targetRay.visible = ( inputPose !== null );

		 }

		 if ( grip !== null ) {

			 grip.visible = ( gripPose !== null );

		 }

		 if ( hand !== null ) {

			 hand.visible = ( handPose !== null );

		 }

		 return this;

	 }

 }

 class WebXRManager$1 extends EventDispatcher$1 {

	 constructor( renderer, gl ) {

		 super();

		 const scope = this;
		 const state = renderer.state;

		 let session = null;
		 let framebufferScaleFactor = 1.0;

		 let referenceSpace = null;
		 let referenceSpaceType = 'local-floor';

		 let pose = null;
		 let glBinding = null;
		 let glFramebuffer = null;
		 let glProjLayer = null;

		 const controllers = [];
		 const inputSourcesMap = new Map();

		 //

		 const cameraL = new PerspectiveCamera$1();
		 cameraL.layers.enable( 1 );
		 cameraL.viewport = new Vector4$1();

		 const cameraR = new PerspectiveCamera$1();
		 cameraR.layers.enable( 2 );
		 cameraR.viewport = new Vector4$1();

		 const cameras = [ cameraL, cameraR ];

		 const cameraVR = new ArrayCamera$1();
		 cameraVR.layers.enable( 1 );
		 cameraVR.layers.enable( 2 );

		 let _currentDepthNear = null;
		 let _currentDepthFar = null;

		 //

		 this.cameraAutoUpdate = true;
		 this.enabled = false;

		 this.isPresenting = false;

		 this.getController = function ( index ) {

			 let controller = controllers[ index ];

			 if ( controller === undefined ) {

				 controller = new WebXRController$1();
				 controllers[ index ] = controller;

			 }

			 return controller.getTargetRaySpace();

		 };

		 this.getControllerGrip = function ( index ) {

			 let controller = controllers[ index ];

			 if ( controller === undefined ) {

				 controller = new WebXRController$1();
				 controllers[ index ] = controller;

			 }

			 return controller.getGripSpace();

		 };

		 this.getHand = function ( index ) {

			 let controller = controllers[ index ];

			 if ( controller === undefined ) {

				 controller = new WebXRController$1();
				 controllers[ index ] = controller;

			 }

			 return controller.getHandSpace();

		 };

		 //

		 function onSessionEvent( event ) {

			 const controller = inputSourcesMap.get( event.inputSource );

			 if ( controller ) {

				 controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			 }

		 }

		 function onSessionEnd() {

			 inputSourcesMap.forEach( function ( controller, inputSource ) {

				 controller.disconnect( inputSource );

			 } );

			 inputSourcesMap.clear();

			 _currentDepthNear = null;
			 _currentDepthFar = null;

			 // restore framebuffer/rendering state

			 state.bindXRFramebuffer( null );
			 renderer.setRenderTarget( renderer.getRenderTarget() );

			 //

			 animation.stop();

			 scope.isPresenting = false;

			 scope.dispatchEvent( { type: 'sessionend' } );

		 }

		 this.setFramebufferScaleFactor = function ( value ) {

			 framebufferScaleFactor = value;

			 if ( scope.isPresenting === true ) {

				 console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			 }

		 };

		 this.setReferenceSpaceType = function ( value ) {

			 referenceSpaceType = value;

			 if ( scope.isPresenting === true ) {

				 console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			 }

		 };

		 this.getReferenceSpace = function () {

			 return referenceSpace;

		 };

		 this.getSession = function () {

			 return session;

		 };

		 this.setSession = async function ( value ) {

			 session = value;

			 if ( session !== null ) {

				 session.addEventListener( 'select', onSessionEvent );
				 session.addEventListener( 'selectstart', onSessionEvent );
				 session.addEventListener( 'selectend', onSessionEvent );
				 session.addEventListener( 'squeeze', onSessionEvent );
				 session.addEventListener( 'squeezestart', onSessionEvent );
				 session.addEventListener( 'squeezeend', onSessionEvent );
				 session.addEventListener( 'end', onSessionEnd );
				 session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				 const attributes = gl.getContextAttributes();

				 if ( attributes.xrCompatible !== true ) {

					 await gl.makeXRCompatible();

				 }

				 if ( session.renderState.layers === undefined ) {

					 const layerInit = {
						 antialias: attributes.antialias,
						 alpha: attributes.alpha,
						 depth: attributes.depth,
						 stencil: attributes.stencil,
						 framebufferScaleFactor: framebufferScaleFactor
					 };

					 // eslint-disable-next-line no-undef
					 const baseLayer = new XRWebGLLayer( session, gl, layerInit );

					 session.updateRenderState( { baseLayer: baseLayer } );

				 } else {

					 let depthFormat = 0;

					 if ( attributes.depth ) {

						 depthFormat = attributes.stencil ? 34041 : 6402;

					 }

					 const projectionlayerInit = {
						 colorFormat: attributes.alpha ? 6408 : 6407,
						 depthFormat: depthFormat,
						 scaleFactor: framebufferScaleFactor
					 };

					 // eslint-disable-next-line no-undef
					 glBinding = new XRWebGLBinding( session, gl );

					 glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					 glFramebuffer = gl.createFramebuffer();

					 session.updateRenderState( { layers: [ glProjLayer ] } );

				 }

				 referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				 animation.setContext( session );
				 animation.start();

				 scope.isPresenting = true;

				 scope.dispatchEvent( { type: 'sessionstart' } );

			 }

		 };

		 function onInputSourcesChange( event ) {

			 const inputSources = session.inputSources;

			 // Assign inputSources to available controllers

			 for ( let i = 0; i < controllers.length; i ++ ) {

				 inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

			 }

			 // Notify disconnected

			 for ( let i = 0; i < event.removed.length; i ++ ) {

				 const inputSource = event.removed[ i ];
				 const controller = inputSourcesMap.get( inputSource );

				 if ( controller ) {

					 controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					 inputSourcesMap.delete( inputSource );

				 }

			 }

			 // Notify connected

			 for ( let i = 0; i < event.added.length; i ++ ) {

				 const inputSource = event.added[ i ];
				 const controller = inputSourcesMap.get( inputSource );

				 if ( controller ) {

					 controller.dispatchEvent( { type: 'connected', data: inputSource } );

				 }

			 }

		 }

		 //

		 const cameraLPos = new Vector3$1();
		 const cameraRPos = new Vector3$1();

		 /**
			* Assumes 2 cameras that are parallel and share an X-axis, and that
			* the cameras' projection and world matrices have already been set.
			* And that near and far planes are identical for both cameras.
			* Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			*/
		 function setProjectionFromUnion( camera, cameraL, cameraR ) {

			 cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			 cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			 const ipd = cameraLPos.distanceTo( cameraRPos );

			 const projL = cameraL.projectionMatrix.elements;
			 const projR = cameraR.projectionMatrix.elements;

			 // VR systems will have identical far and near planes, and
			 // most likely identical top and bottom frustum extents.
			 // Use the left camera for these values.
			 const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			 const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			 const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			 const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			 const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			 const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			 const left = near * leftFov;
			 const right = near * rightFov;

			 // Calculate the new camera's position offset from the
			 // left camera. xOffset should be roughly half `ipd`.
			 const zOffset = ipd / ( - leftFov + rightFov );
			 const xOffset = zOffset * - leftFov;

			 // TODO: Better way to apply this offset?
			 cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			 camera.translateX( xOffset );
			 camera.translateZ( zOffset );
			 camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			 camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			 // Find the union of the frustum values of the cameras and scale
			 // the values so that the near plane's position does not change in world space,
			 // although must now be relative to the new union camera.
			 const near2 = near + zOffset;
			 const far2 = far + zOffset;
			 const left2 = left - xOffset;
			 const right2 = right + ( ipd - xOffset );
			 const top2 = topFov * far / far2 * near2;
			 const bottom2 = bottomFov * far / far2 * near2;

			 camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		 }

		 function updateCamera( camera, parent ) {

			 if ( parent === null ) {

				 camera.matrixWorld.copy( camera.matrix );

			 } else {

				 camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			 }

			 camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		 }

		 this.updateCamera = function ( camera ) {

			 if ( session === null ) return;

			 cameraVR.near = cameraR.near = cameraL.near = camera.near;
			 cameraVR.far = cameraR.far = cameraL.far = camera.far;

			 if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				 // Note that the new renderState won't apply until the next frame. See #18320

				 session.updateRenderState( {
					 depthNear: cameraVR.near,
					 depthFar: cameraVR.far
				 } );

				 _currentDepthNear = cameraVR.near;
				 _currentDepthFar = cameraVR.far;

			 }

			 const parent = camera.parent;
			 const cameras = cameraVR.cameras;

			 updateCamera( cameraVR, parent );

			 for ( let i = 0; i < cameras.length; i ++ ) {

				 updateCamera( cameras[ i ], parent );

			 }

			 cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

			 // update user camera and its children

			 camera.position.copy( cameraVR.position );
			 camera.quaternion.copy( cameraVR.quaternion );
			 camera.scale.copy( cameraVR.scale );
			 camera.matrix.copy( cameraVR.matrix );
			 camera.matrixWorld.copy( cameraVR.matrixWorld );

			 const children = camera.children;

			 for ( let i = 0, l = children.length; i < l; i ++ ) {

				 children[ i ].updateMatrixWorld( true );

			 }

			 // update projection matrix for proper view frustum culling

			 if ( cameras.length === 2 ) {

				 setProjectionFromUnion( cameraVR, cameraL, cameraR );

			 } else {

				 // assume single camera setup (AR)

				 cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			 }

		 };

		 this.getCamera = function () {

			 return cameraVR;

		 };

		 // Animation Loop

		 let onAnimationFrameCallback = null;

		 function onAnimationFrame( time, frame ) {

			 pose = frame.getViewerPose( referenceSpace );

			 if ( pose !== null ) {

				 const views = pose.views;

				 const baseLayer = session.renderState.baseLayer;

				 if ( session.renderState.layers === undefined ) {

					 state.bindXRFramebuffer( baseLayer.framebuffer );

				 }

				 let cameraVRNeedsUpdate = false;

				 // check if it's necessary to rebuild cameraVR's camera list

				 if ( views.length !== cameraVR.cameras.length ) {

					 cameraVR.cameras.length = 0;

					 cameraVRNeedsUpdate = true;


				 }

				 for ( let i = 0; i < views.length; i ++ ) {

					 const view = views[ i ];

					 let viewport = null;

					 if ( session.renderState.layers === undefined ) {

						 viewport = baseLayer.getViewport( view );

					 } else {

						 const glSubImage = glBinding.getViewSubImage( glProjLayer, view );

						 state.bindXRFramebuffer( glFramebuffer );

						 gl.framebufferTexture2D( 36160, 36064, 3553, glSubImage.colorTexture, 0 );

						 if ( glSubImage.depthStencilTexture !== undefined ) {

							 gl.framebufferTexture2D( 36160, 36096, 3553, glSubImage.depthStencilTexture, 0 );

						 }

						 viewport = glSubImage.viewport;

					 }

					 const camera = cameras[ i ];

					 camera.matrix.fromArray( view.transform.matrix );

					 camera.projectionMatrix.fromArray( view.projectionMatrix );

					 camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					 if ( i === 0 ) {

						 cameraVR.matrix.copy( camera.matrix );

					 }

					 if ( cameraVRNeedsUpdate === true ) {

						 cameraVR.cameras.push( camera );

					 }

				 }

			 }

			 //

			 const inputSources = session.inputSources;

			 for ( let i = 0; i < controllers.length; i ++ ) {

				 const controller = controllers[ i ];
				 const inputSource = inputSources[ i ];

				 controller.update( inputSource, frame, referenceSpace );

			 }

			 if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

		 }

		 const animation = new WebGLAnimation$1();
		 animation.setAnimationLoop( onAnimationFrame );

		 this.setAnimationLoop = function ( callback ) {

			 onAnimationFrameCallback = callback;

		 };

		 this.dispose = function () {};

	 }

 }

 function WebGLMaterials$1( properties ) {

	 function refreshFogUniforms( uniforms, fog ) {

		 uniforms.fogColor.value.copy( fog.color );

		 if ( fog.isFog ) {

			 uniforms.fogNear.value = fog.near;
			 uniforms.fogFar.value = fog.far;

		 } else if ( fog.isFogExp2 ) {

			 uniforms.fogDensity.value = fog.density;

		 }

	 }

	 function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		 if ( material.isMeshBasicMaterial ) {

			 refreshUniformsCommon( uniforms, material );

		 } else if ( material.isMeshLambertMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsLambert( uniforms, material );

		 } else if ( material.isMeshToonMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsToon( uniforms, material );

		 } else if ( material.isMeshPhongMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsPhong( uniforms, material );

		 } else if ( material.isMeshStandardMaterial ) {

			 refreshUniformsCommon( uniforms, material );

			 if ( material.isMeshPhysicalMaterial ) {

				 refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			 } else {

				 refreshUniformsStandard( uniforms, material );

			 }

		 } else if ( material.isMeshMatcapMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsMatcap( uniforms, material );

		 } else if ( material.isMeshDepthMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsDepth( uniforms, material );

		 } else if ( material.isMeshDistanceMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsDistance( uniforms, material );

		 } else if ( material.isMeshNormalMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsNormal( uniforms, material );

		 } else if ( material.isLineBasicMaterial ) {

			 refreshUniformsLine( uniforms, material );

			 if ( material.isLineDashedMaterial ) {

				 refreshUniformsDash( uniforms, material );

			 }

		 } else if ( material.isPointsMaterial ) {

			 refreshUniformsPoints( uniforms, material, pixelRatio, height );

		 } else if ( material.isSpriteMaterial ) {

			 refreshUniformsSprites( uniforms, material );

		 } else if ( material.isShadowMaterial ) {

			 uniforms.color.value.copy( material.color );
			 uniforms.opacity.value = material.opacity;

		 } else if ( material.isShaderMaterial ) {

			 material.uniformsNeedUpdate = false; // #15581

		 }

	 }

	 function refreshUniformsCommon( uniforms, material ) {

		 uniforms.opacity.value = material.opacity;

		 if ( material.color ) {

			 uniforms.diffuse.value.copy( material.color );

		 }

		 if ( material.emissive ) {

			 uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		 }

		 if ( material.map ) {

			 uniforms.map.value = material.map;

		 }

		 if ( material.alphaMap ) {

			 uniforms.alphaMap.value = material.alphaMap;

		 }

		 if ( material.specularMap ) {

			 uniforms.specularMap.value = material.specularMap;

		 }

		 const envMap = properties.get( material ).envMap;

		 if ( envMap ) {

			 uniforms.envMap.value = envMap;

			 uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

			 uniforms.reflectivity.value = material.reflectivity;
			 uniforms.refractionRatio.value = material.refractionRatio;

			 const maxMipLevel = properties.get( envMap ).__maxMipLevel;

			 if ( maxMipLevel !== undefined ) {

				 uniforms.maxMipLevel.value = maxMipLevel;

			 }

		 }

		 if ( material.lightMap ) {

			 uniforms.lightMap.value = material.lightMap;
			 uniforms.lightMapIntensity.value = material.lightMapIntensity;

		 }

		 if ( material.aoMap ) {

			 uniforms.aoMap.value = material.aoMap;
			 uniforms.aoMapIntensity.value = material.aoMapIntensity;

		 }

		 // uv repeat and offset setting priorities
		 // 1. color map
		 // 2. specular map
		 // 3. displacementMap map
		 // 4. normal map
		 // 5. bump map
		 // 6. roughnessMap map
		 // 7. metalnessMap map
		 // 8. alphaMap map
		 // 9. emissiveMap map
		 // 10. clearcoat map
		 // 11. clearcoat normal map
		 // 12. clearcoat roughnessMap map

		 let uvScaleMap;

		 if ( material.map ) {

			 uvScaleMap = material.map;

		 } else if ( material.specularMap ) {

			 uvScaleMap = material.specularMap;

		 } else if ( material.displacementMap ) {

			 uvScaleMap = material.displacementMap;

		 } else if ( material.normalMap ) {

			 uvScaleMap = material.normalMap;

		 } else if ( material.bumpMap ) {

			 uvScaleMap = material.bumpMap;

		 } else if ( material.roughnessMap ) {

			 uvScaleMap = material.roughnessMap;

		 } else if ( material.metalnessMap ) {

			 uvScaleMap = material.metalnessMap;

		 } else if ( material.alphaMap ) {

			 uvScaleMap = material.alphaMap;

		 } else if ( material.emissiveMap ) {

			 uvScaleMap = material.emissiveMap;

		 } else if ( material.clearcoatMap ) {

			 uvScaleMap = material.clearcoatMap;

		 } else if ( material.clearcoatNormalMap ) {

			 uvScaleMap = material.clearcoatNormalMap;

		 } else if ( material.clearcoatRoughnessMap ) {

			 uvScaleMap = material.clearcoatRoughnessMap;

		 }

		 if ( uvScaleMap !== undefined ) {

			 // backwards compatibility
			 if ( uvScaleMap.isWebGLRenderTarget ) {

				 uvScaleMap = uvScaleMap.texture;

			 }

			 if ( uvScaleMap.matrixAutoUpdate === true ) {

				 uvScaleMap.updateMatrix();

			 }

			 uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		 }

		 // uv repeat and offset setting priorities for uv2
		 // 1. ao map
		 // 2. light map

		 let uv2ScaleMap;

		 if ( material.aoMap ) {

			 uv2ScaleMap = material.aoMap;

		 } else if ( material.lightMap ) {

			 uv2ScaleMap = material.lightMap;

		 }

		 if ( uv2ScaleMap !== undefined ) {

			 // backwards compatibility
			 if ( uv2ScaleMap.isWebGLRenderTarget ) {

				 uv2ScaleMap = uv2ScaleMap.texture;

			 }

			 if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				 uv2ScaleMap.updateMatrix();

			 }

			 uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		 }

	 }

	 function refreshUniformsLine( uniforms, material ) {

		 uniforms.diffuse.value.copy( material.color );
		 uniforms.opacity.value = material.opacity;

	 }

	 function refreshUniformsDash( uniforms, material ) {

		 uniforms.dashSize.value = material.dashSize;
		 uniforms.totalSize.value = material.dashSize + material.gapSize;
		 uniforms.scale.value = material.scale;

	 }

	 function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		 uniforms.diffuse.value.copy( material.color );
		 uniforms.opacity.value = material.opacity;
		 uniforms.size.value = material.size * pixelRatio;
		 uniforms.scale.value = height * 0.5;

		 if ( material.map ) {

			 uniforms.map.value = material.map;

		 }

		 if ( material.alphaMap ) {

			 uniforms.alphaMap.value = material.alphaMap;

		 }

		 // uv repeat and offset setting priorities
		 // 1. color map
		 // 2. alpha map

		 let uvScaleMap;

		 if ( material.map ) {

			 uvScaleMap = material.map;

		 } else if ( material.alphaMap ) {

			 uvScaleMap = material.alphaMap;

		 }

		 if ( uvScaleMap !== undefined ) {

			 if ( uvScaleMap.matrixAutoUpdate === true ) {

				 uvScaleMap.updateMatrix();

			 }

			 uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		 }

	 }

	 function refreshUniformsSprites( uniforms, material ) {

		 uniforms.diffuse.value.copy( material.color );
		 uniforms.opacity.value = material.opacity;
		 uniforms.rotation.value = material.rotation;

		 if ( material.map ) {

			 uniforms.map.value = material.map;

		 }

		 if ( material.alphaMap ) {

			 uniforms.alphaMap.value = material.alphaMap;

		 }

		 // uv repeat and offset setting priorities
		 // 1. color map
		 // 2. alpha map

		 let uvScaleMap;

		 if ( material.map ) {

			 uvScaleMap = material.map;

		 } else if ( material.alphaMap ) {

			 uvScaleMap = material.alphaMap;

		 }

		 if ( uvScaleMap !== undefined ) {

			 if ( uvScaleMap.matrixAutoUpdate === true ) {

				 uvScaleMap.updateMatrix();

			 }

			 uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		 }

	 }

	 function refreshUniformsLambert( uniforms, material ) {

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

	 }

	 function refreshUniformsPhong( uniforms, material ) {

		 uniforms.specular.value.copy( material.specular );
		 uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide$1 ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide$1 ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsToon( uniforms, material ) {

		 if ( material.gradientMap ) {

			 uniforms.gradientMap.value = material.gradientMap;

		 }

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide$1 ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide$1 ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsStandard( uniforms, material ) {

		 uniforms.roughness.value = material.roughness;
		 uniforms.metalness.value = material.metalness;

		 if ( material.roughnessMap ) {

			 uniforms.roughnessMap.value = material.roughnessMap;

		 }

		 if ( material.metalnessMap ) {

			 uniforms.metalnessMap.value = material.metalnessMap;

		 }

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide$1 ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide$1 ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

		 const envMap = properties.get( material ).envMap;

		 if ( envMap ) {

			 //uniforms.envMap.value = material.envMap; // part of uniforms common
			 uniforms.envMapIntensity.value = material.envMapIntensity;

		 }

	 }

	 function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		 refreshUniformsStandard( uniforms, material );

		 uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		 uniforms.clearcoat.value = material.clearcoat;
		 uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

		 if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		 if ( material.clearcoatMap ) {

			 uniforms.clearcoatMap.value = material.clearcoatMap;

		 }

		 if ( material.clearcoatRoughnessMap ) {

			 uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		 }

		 if ( material.clearcoatNormalMap ) {

			 uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			 uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			 if ( material.side === BackSide$1 ) {

				 uniforms.clearcoatNormalScale.value.negate();

			 }

		 }

		 uniforms.transmission.value = material.transmission;

		 if ( material.transmissionMap ) {

			 uniforms.transmissionMap.value = material.transmissionMap;

		 }

		 if ( material.transmission > 0.0 ) {

			 uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			 uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

		 }

		 uniforms.thickness.value = material.thickness;

		 if ( material.thicknessMap ) {

			 uniforms.thicknessMap.value = material.thicknessMap;

		 }

		 uniforms.attenuationDistance.value = material.attenuationDistance;
		 uniforms.attenuationColor.value.copy( material.attenuationColor );

	 }

	 function refreshUniformsMatcap( uniforms, material ) {

		 if ( material.matcap ) {

			 uniforms.matcap.value = material.matcap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide$1 ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide$1 ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsDepth( uniforms, material ) {

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsDistance( uniforms, material ) {

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

		 uniforms.referencePosition.value.copy( material.referencePosition );
		 uniforms.nearDistance.value = material.nearDistance;
		 uniforms.farDistance.value = material.farDistance;

	 }

	 function refreshUniformsNormal( uniforms, material ) {

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide$1 ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide$1 ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 return {
		 refreshFogUniforms: refreshFogUniforms,
		 refreshMaterialUniforms: refreshMaterialUniforms
	 };

 }

 function createCanvasElement$1() {

	 const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	 canvas.style.display = 'block';
	 return canvas;

 }

 function WebGLRenderer$1( parameters = {} ) {

	 const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement$1(),
		 _context = parameters.context !== undefined ? parameters.context : null,

		 _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		 _depth = parameters.depth !== undefined ? parameters.depth : true,
		 _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		 _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		 _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		 _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		 _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		 _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	 let currentRenderList = null;
	 let currentRenderState = null;

	 // render() can be called from within a callback triggered by another render.
	 // We track this so that the nested render call gets its list and state isolated from the parent render call.

	 const renderListStack = [];
	 const renderStateStack = [];

	 // public properties

	 this.domElement = _canvas;

	 // Debug configuration container
	 this.debug = {

		 /**
			* Enables error checking and reporting when shader programs are being compiled
			* @type {boolean}
			*/
		 checkShaderErrors: true
	 };

	 // clearing

	 this.autoClear = true;
	 this.autoClearColor = true;
	 this.autoClearDepth = true;
	 this.autoClearStencil = true;

	 // scene graph

	 this.sortObjects = true;

	 // user-defined clipping

	 this.clippingPlanes = [];
	 this.localClippingEnabled = false;

	 // physically based shading

	 this.gammaFactor = 2.0;	// for backwards compatibility
	 this.outputEncoding = LinearEncoding$1;

	 // physical lights

	 this.physicallyCorrectLights = false;

	 // tone mapping

	 this.toneMapping = NoToneMapping$1;
	 this.toneMappingExposure = 1.0;

	 // internal properties

	 const _this = this;

	 let _isContextLost = false;

	 // internal state cache

	 let _currentActiveCubeFace = 0;
	 let _currentActiveMipmapLevel = 0;
	 let _currentRenderTarget = null;
	 let _currentMaterialId = - 1;

	 let _currentCamera = null;

	 const _currentViewport = new Vector4$1();
	 const _currentScissor = new Vector4$1();
	 let _currentScissorTest = null;

	 //

	 let _width = _canvas.width;
	 let _height = _canvas.height;

	 let _pixelRatio = 1;
	 let _opaqueSort = null;
	 let _transparentSort = null;

	 const _viewport = new Vector4$1( 0, 0, _width, _height );
	 const _scissor = new Vector4$1( 0, 0, _width, _height );
	 let _scissorTest = false;

	 //

	 const _currentDrawBuffers = [];

	 // frustum

	 const _frustum = new Frustum$1();

	 // clipping

	 let _clippingEnabled = false;
	 let _localClippingEnabled = false;

	 // transmission

	 let _transmissionRenderTarget = null;

	 // camera matrices cache

	 const _projScreenMatrix = new Matrix4$1();

	 const _vector3 = new Vector3$1();

	 const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	 function getTargetPixelRatio() {

		 return _currentRenderTarget === null ? _pixelRatio : 1;

	 }

	 // initialize

	 let _gl = _context;

	 function getContext( contextNames, contextAttributes ) {

		 for ( let i = 0; i < contextNames.length; i ++ ) {

			 const contextName = contextNames[ i ];
			 const context = _canvas.getContext( contextName, contextAttributes );
			 if ( context !== null ) return context;

		 }

		 return null;

	 }

	 try {

		 const contextAttributes = {
			 alpha: _alpha,
			 depth: _depth,
			 stencil: _stencil,
			 antialias: _antialias,
			 premultipliedAlpha: _premultipliedAlpha,
			 preserveDrawingBuffer: _preserveDrawingBuffer,
			 powerPreference: _powerPreference,
			 failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		 };

		 // event listeners must be registered before WebGL context is created, see #12753

		 _canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		 _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		 if ( _gl === null ) {

			 const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			 if ( _this.isWebGL1Renderer === true ) {

				 contextNames.shift();

			 }

			 _gl = getContext( contextNames, contextAttributes );

			 if ( _gl === null ) {

				 if ( getContext( contextNames ) ) {

					 throw new Error( 'Error creating WebGL context with your selected attributes.' );

				 } else {

					 throw new Error( 'Error creating WebGL context.' );

				 }

			 }

		 }

		 // Some experimental-webgl implementations do not have getShaderPrecisionFormat

		 if ( _gl.getShaderPrecisionFormat === undefined ) {

			 _gl.getShaderPrecisionFormat = function () {

				 return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			 };

		 }

	 } catch ( error ) {

		 console.error( 'THREE.WebGLRenderer: ' + error.message );
		 throw error;

	 }

	 let extensions, capabilities, state, info;
	 let properties, textures, cubemaps, attributes, geometries, objects;
	 let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	 let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	 let utils, bindingStates;

	 function initGLContext() {

		 extensions = new WebGLExtensions$1( _gl );

		 capabilities = new WebGLCapabilities$1( _gl, extensions, parameters );

		 extensions.init( capabilities );

		 utils = new WebGLUtils$1( _gl, extensions, capabilities );

		 state = new WebGLState$1( _gl, extensions, capabilities );

		 _currentDrawBuffers[ 0 ] = 1029;

		 info = new WebGLInfo$1( _gl );
		 properties = new WebGLProperties$1();
		 textures = new WebGLTextures$1( _gl, extensions, state, properties, capabilities, utils, info );
		 cubemaps = new WebGLCubeMaps$1( _this );
		 attributes = new WebGLAttributes$1( _gl, capabilities );
		 bindingStates = new WebGLBindingStates$1( _gl, extensions, attributes, capabilities );
		 geometries = new WebGLGeometries$1( _gl, attributes, info, bindingStates );
		 objects = new WebGLObjects$1( _gl, geometries, attributes, info );
		 morphtargets = new WebGLMorphtargets$1( _gl );
		 clipping = new WebGLClipping$1( properties );
		 programCache = new WebGLPrograms$1( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
		 materials = new WebGLMaterials$1( properties );
		 renderLists = new WebGLRenderLists$1( properties );
		 renderStates = new WebGLRenderStates$1( extensions, capabilities );
		 background = new WebGLBackground$1( _this, cubemaps, state, objects, _premultipliedAlpha );
		 shadowMap = new WebGLShadowMap$1( _this, objects, capabilities );

		 bufferRenderer = new WebGLBufferRenderer$1( _gl, extensions, info, capabilities );
		 indexedBufferRenderer = new WebGLIndexedBufferRenderer$1( _gl, extensions, info, capabilities );

		 info.programs = programCache.programs;

		 _this.capabilities = capabilities;
		 _this.extensions = extensions;
		 _this.properties = properties;
		 _this.renderLists = renderLists;
		 _this.shadowMap = shadowMap;
		 _this.state = state;
		 _this.info = info;

	 }

	 initGLContext();

	 // xr

	 const xr = new WebXRManager$1( _this, _gl );

	 this.xr = xr;

	 // API

	 this.getContext = function () {

		 return _gl;

	 };

	 this.getContextAttributes = function () {

		 return _gl.getContextAttributes();

	 };

	 this.forceContextLoss = function () {

		 const extension = extensions.get( 'WEBGL_lose_context' );
		 if ( extension ) extension.loseContext();

	 };

	 this.forceContextRestore = function () {

		 const extension = extensions.get( 'WEBGL_lose_context' );
		 if ( extension ) extension.restoreContext();

	 };

	 this.getPixelRatio = function () {

		 return _pixelRatio;

	 };

	 this.setPixelRatio = function ( value ) {

		 if ( value === undefined ) return;

		 _pixelRatio = value;

		 this.setSize( _width, _height, false );

	 };

	 this.getSize = function ( target ) {

		 return target.set( _width, _height );

	 };

	 this.setSize = function ( width, height, updateStyle ) {

		 if ( xr.isPresenting ) {

			 console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			 return;

		 }

		 _width = width;
		 _height = height;

		 _canvas.width = Math.floor( width * _pixelRatio );
		 _canvas.height = Math.floor( height * _pixelRatio );

		 if ( updateStyle !== false ) {

			 _canvas.style.width = width + 'px';
			 _canvas.style.height = height + 'px';

		 }

		 this.setViewport( 0, 0, width, height );

	 };

	 this.getDrawingBufferSize = function ( target ) {

		 return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	 };

	 this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		 _width = width;
		 _height = height;

		 _pixelRatio = pixelRatio;

		 _canvas.width = Math.floor( width * pixelRatio );
		 _canvas.height = Math.floor( height * pixelRatio );

		 this.setViewport( 0, 0, width, height );

	 };

	 this.getCurrentViewport = function ( target ) {

		 return target.copy( _currentViewport );

	 };

	 this.getViewport = function ( target ) {

		 return target.copy( _viewport );

	 };

	 this.setViewport = function ( x, y, width, height ) {

		 if ( x.isVector4 ) {

			 _viewport.set( x.x, x.y, x.z, x.w );

		 } else {

			 _viewport.set( x, y, width, height );

		 }

		 state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	 };

	 this.getScissor = function ( target ) {

		 return target.copy( _scissor );

	 };

	 this.setScissor = function ( x, y, width, height ) {

		 if ( x.isVector4 ) {

			 _scissor.set( x.x, x.y, x.z, x.w );

		 } else {

			 _scissor.set( x, y, width, height );

		 }

		 state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	 };

	 this.getScissorTest = function () {

		 return _scissorTest;

	 };

	 this.setScissorTest = function ( boolean ) {

		 state.setScissorTest( _scissorTest = boolean );

	 };

	 this.setOpaqueSort = function ( method ) {

		 _opaqueSort = method;

	 };

	 this.setTransparentSort = function ( method ) {

		 _transparentSort = method;

	 };

	 // Clearing

	 this.getClearColor = function ( target ) {

		 return target.copy( background.getClearColor() );

	 };

	 this.setClearColor = function () {

		 background.setClearColor.apply( background, arguments );

	 };

	 this.getClearAlpha = function () {

		 return background.getClearAlpha();

	 };

	 this.setClearAlpha = function () {

		 background.setClearAlpha.apply( background, arguments );

	 };

	 this.clear = function ( color, depth, stencil ) {

		 let bits = 0;

		 if ( color === undefined || color ) bits |= 16384;
		 if ( depth === undefined || depth ) bits |= 256;
		 if ( stencil === undefined || stencil ) bits |= 1024;

		 _gl.clear( bits );

	 };

	 this.clearColor = function () {

		 this.clear( true, false, false );

	 };

	 this.clearDepth = function () {

		 this.clear( false, true, false );

	 };

	 this.clearStencil = function () {

		 this.clear( false, false, true );

	 };

	 //

	 this.dispose = function () {

		 _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		 _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		 renderLists.dispose();
		 renderStates.dispose();
		 properties.dispose();
		 cubemaps.dispose();
		 objects.dispose();
		 bindingStates.dispose();

		 xr.dispose();

		 xr.removeEventListener( 'sessionstart', onXRSessionStart );
		 xr.removeEventListener( 'sessionend', onXRSessionEnd );

		 if ( _transmissionRenderTarget ) {

			 _transmissionRenderTarget.dispose();
			 _transmissionRenderTarget = null;

		 }

		 animation.stop();

	 };

	 // Events

	 function onContextLost( event ) {

		 event.preventDefault();

		 console.log( 'THREE.WebGLRenderer: Context Lost.' );

		 _isContextLost = true;

	 }

	 function onContextRestore( /* event */ ) {

		 console.log( 'THREE.WebGLRenderer: Context Restored.' );

		 _isContextLost = false;

		 const infoAutoReset = info.autoReset;
		 const shadowMapEnabled = shadowMap.enabled;
		 const shadowMapAutoUpdate = shadowMap.autoUpdate;
		 const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		 const shadowMapType = shadowMap.type;

		 initGLContext();

		 info.autoReset = infoAutoReset;
		 shadowMap.enabled = shadowMapEnabled;
		 shadowMap.autoUpdate = shadowMapAutoUpdate;
		 shadowMap.needsUpdate = shadowMapNeedsUpdate;
		 shadowMap.type = shadowMapType;

	 }

	 function onMaterialDispose( event ) {

		 const material = event.target;

		 material.removeEventListener( 'dispose', onMaterialDispose );

		 deallocateMaterial( material );

	 }

	 // Buffer deallocation

	 function deallocateMaterial( material ) {

		 releaseMaterialProgramReferences( material );

		 properties.remove( material );

	 }


	 function releaseMaterialProgramReferences( material ) {

		 const programs = properties.get( material ).programs;

		 if ( programs !== undefined ) {

			 programs.forEach( function ( program ) {

				 programCache.releaseProgram( program );

			 } );

		 }

	 }

	 // Buffer rendering

	 function renderObjectImmediate( object, program ) {

		 object.render( function ( object ) {

			 _this.renderBufferImmediate( object, program );

		 } );

	 }

	 this.renderBufferImmediate = function ( object, program ) {

		 bindingStates.initAttributes();

		 const buffers = properties.get( object );

		 if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		 if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		 if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		 if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		 const programAttributes = program.getAttributes();

		 if ( object.hasPositions ) {

			 _gl.bindBuffer( 34962, buffers.position );
			 _gl.bufferData( 34962, object.positionArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.position );
			 _gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

		 }

		 if ( object.hasNormals ) {

			 _gl.bindBuffer( 34962, buffers.normal );
			 _gl.bufferData( 34962, object.normalArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.normal );
			 _gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

		 }

		 if ( object.hasUvs ) {

			 _gl.bindBuffer( 34962, buffers.uv );
			 _gl.bufferData( 34962, object.uvArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.uv );
			 _gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

		 }

		 if ( object.hasColors ) {

			 _gl.bindBuffer( 34962, buffers.color );
			 _gl.bufferData( 34962, object.colorArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.color );
			 _gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

		 }

		 bindingStates.disableUnusedAttributes();

		 _gl.drawArrays( 4, 0, object.count );

		 object.count = 0;

	 };

	 this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		 if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		 const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		 const program = setProgram( camera, scene, material, object );

		 state.setMaterial( material, frontFaceCW );

		 //

		 let index = geometry.index;
		 const position = geometry.attributes.position;

		 //

		 if ( index === null ) {

			 if ( position === undefined || position.count === 0 ) return;

		 } else if ( index.count === 0 ) {

			 return;

		 }

		 //

		 let rangeFactor = 1;

		 if ( material.wireframe === true ) {

			 index = geometries.getWireframeAttribute( geometry );
			 rangeFactor = 2;

		 }

		 if ( material.morphTargets || material.morphNormals ) {

			 morphtargets.update( object, geometry, material, program );

		 }

		 bindingStates.setup( object, material, program, geometry, index );

		 let attribute;
		 let renderer = bufferRenderer;

		 if ( index !== null ) {

			 attribute = attributes.get( index );

			 renderer = indexedBufferRenderer;
			 renderer.setIndex( attribute );

		 }

		 //

		 const dataCount = ( index !== null ) ? index.count : position.count;

		 const rangeStart = geometry.drawRange.start * rangeFactor;
		 const rangeCount = geometry.drawRange.count * rangeFactor;

		 const groupStart = group !== null ? group.start * rangeFactor : 0;
		 const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		 const drawStart = Math.max( rangeStart, groupStart );
		 const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		 const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		 if ( drawCount === 0 ) return;

		 //

		 if ( object.isMesh ) {

			 if ( material.wireframe === true ) {

				 state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				 renderer.setMode( 1 );

			 } else {

				 renderer.setMode( 4 );

			 }

		 } else if ( object.isLine ) {

			 let lineWidth = material.linewidth;

			 if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			 state.setLineWidth( lineWidth * getTargetPixelRatio() );

			 if ( object.isLineSegments ) {

				 renderer.setMode( 1 );

			 } else if ( object.isLineLoop ) {

				 renderer.setMode( 2 );

			 } else {

				 renderer.setMode( 3 );

			 }

		 } else if ( object.isPoints ) {

			 renderer.setMode( 0 );

		 } else if ( object.isSprite ) {

			 renderer.setMode( 4 );

		 }

		 if ( object.isInstancedMesh ) {

			 renderer.renderInstances( drawStart, drawCount, object.count );

		 } else if ( geometry.isInstancedBufferGeometry ) {

			 const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			 renderer.renderInstances( drawStart, drawCount, instanceCount );

		 } else {

			 renderer.render( drawStart, drawCount );

		 }

	 };

	 // Compile

	 this.compile = function ( scene, camera ) {

		 currentRenderState = renderStates.get( scene );
		 currentRenderState.init();

		 scene.traverseVisible( function ( object ) {

			 if ( object.isLight && object.layers.test( camera.layers ) ) {

				 currentRenderState.pushLight( object );

				 if ( object.castShadow ) {

					 currentRenderState.pushShadow( object );

				 }

			 }

		 } );

		 currentRenderState.setupLights();

		 scene.traverse( function ( object ) {

			 const material = object.material;

			 if ( material ) {

				 if ( Array.isArray( material ) ) {

					 for ( let i = 0; i < material.length; i ++ ) {

						 const material2 = material[ i ];

						 getProgram( material2, scene, object );

					 }

				 } else {

					 getProgram( material, scene, object );

				 }

			 }

		 } );

	 };

	 // Animation Loop

	 let onAnimationFrameCallback = null;

	 function onAnimationFrame( time ) {

		 if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	 }

	 function onXRSessionStart() {

		 animation.stop();

	 }

	 function onXRSessionEnd() {

		 animation.start();

	 }

	 const animation = new WebGLAnimation$1();
	 animation.setAnimationLoop( onAnimationFrame );

	 if ( typeof window !== 'undefined' ) animation.setContext( window );

	 this.setAnimationLoop = function ( callback ) {

		 onAnimationFrameCallback = callback;
		 xr.setAnimationLoop( callback );

		 ( callback === null ) ? animation.stop() : animation.start();

	 };

	 xr.addEventListener( 'sessionstart', onXRSessionStart );
	 xr.addEventListener( 'sessionend', onXRSessionEnd );

	 // Rendering

	 this.render = function ( scene, camera ) {

		 if ( camera !== undefined && camera.isCamera !== true ) {

			 console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			 return;

		 }

		 if ( _isContextLost === true ) return;

		 // update scene graph

		 if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		 // update camera matrices and frustum

		 if ( camera.parent === null ) camera.updateMatrixWorld();

		 if ( xr.enabled === true && xr.isPresenting === true ) {

			 if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

			 camera = xr.getCamera(); // use XR camera for rendering

		 }

		 //
		 if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

		 currentRenderState = renderStates.get( scene, renderStateStack.length );
		 currentRenderState.init();

		 renderStateStack.push( currentRenderState );

		 _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		 _frustum.setFromProjectionMatrix( _projScreenMatrix );

		 _localClippingEnabled = this.localClippingEnabled;
		 _clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		 currentRenderList = renderLists.get( scene, renderListStack.length );
		 currentRenderList.init();

		 renderListStack.push( currentRenderList );

		 projectObject( scene, camera, 0, _this.sortObjects );

		 currentRenderList.finish();

		 if ( _this.sortObjects === true ) {

			 currentRenderList.sort( _opaqueSort, _transparentSort );

		 }

		 //

		 if ( _clippingEnabled === true ) clipping.beginShadows();

		 const shadowsArray = currentRenderState.state.shadowsArray;

		 shadowMap.render( shadowsArray, scene, camera );

		 currentRenderState.setupLights();
		 currentRenderState.setupLightsView( camera );

		 if ( _clippingEnabled === true ) clipping.endShadows();

		 //

		 if ( this.info.autoReset === true ) this.info.reset();

		 //

		 background.render( currentRenderList, scene );

		 // render scene

		 const opaqueObjects = currentRenderList.opaque;
		 const transmissiveObjects = currentRenderList.transmissive;
		 const transparentObjects = currentRenderList.transparent;

		 if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		 if ( transmissiveObjects.length > 0 ) renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera );
		 if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		 //

		 if ( _currentRenderTarget !== null ) {

			 // resolve multisample renderbuffers to a single-sample texture if necessary

			 textures.updateMultisampleRenderTarget( _currentRenderTarget );

			 // Generate mipmap if we're using any kind of mipmap filtering

			 textures.updateRenderTargetMipmap( _currentRenderTarget );

		 }

		 //

		 if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		 // Ensure depth buffer writing is enabled so it can be cleared on next render

		 state.buffers.depth.setTest( true );
		 state.buffers.depth.setMask( true );
		 state.buffers.color.setMask( true );

		 state.setPolygonOffset( false );

		 // _gl.finish();

		 bindingStates.resetDefaultState();
		 _currentMaterialId = - 1;
		 _currentCamera = null;

		 renderStateStack.pop();

		 if ( renderStateStack.length > 0 ) {

			 currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		 } else {

			 currentRenderState = null;

		 }

		 renderListStack.pop();

		 if ( renderListStack.length > 0 ) {

			 currentRenderList = renderListStack[ renderListStack.length - 1 ];

		 } else {

			 currentRenderList = null;

		 }

	 };

	 function projectObject( object, camera, groupOrder, sortObjects ) {

		 if ( object.visible === false ) return;

		 const visible = object.layers.test( camera.layers );

		 if ( visible ) {

			 if ( object.isGroup ) {

				 groupOrder = object.renderOrder;

			 } else if ( object.isLOD ) {

				 if ( object.autoUpdate === true ) object.update( camera );

			 } else if ( object.isLight ) {

				 currentRenderState.pushLight( object );

				 if ( object.castShadow ) {

					 currentRenderState.pushShadow( object );

				 }

			 } else if ( object.isSprite ) {

				 if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					 if ( sortObjects ) {

						 _vector3.setFromMatrixPosition( object.matrixWorld )
							 .applyMatrix4( _projScreenMatrix );

					 }

					 const geometry = objects.update( object );
					 const material = object.material;

					 if ( material.visible ) {

						 currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					 }

				 }

			 } else if ( object.isImmediateRenderObject ) {

				 if ( sortObjects ) {

					 _vector3.setFromMatrixPosition( object.matrixWorld )
						 .applyMatrix4( _projScreenMatrix );

				 }

				 currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			 } else if ( object.isMesh || object.isLine || object.isPoints ) {

				 if ( object.isSkinnedMesh ) {

					 // update skeleton only once in a frame

					 if ( object.skeleton.frame !== info.render.frame ) {

						 object.skeleton.update();
						 object.skeleton.frame = info.render.frame;

					 }

				 }

				 if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					 if ( sortObjects ) {

						 _vector3.setFromMatrixPosition( object.matrixWorld )
							 .applyMatrix4( _projScreenMatrix );

					 }

					 const geometry = objects.update( object );
					 const material = object.material;

					 if ( Array.isArray( material ) ) {

						 const groups = geometry.groups;

						 for ( let i = 0, l = groups.length; i < l; i ++ ) {

							 const group = groups[ i ];
							 const groupMaterial = material[ group.materialIndex ];

							 if ( groupMaterial && groupMaterial.visible ) {

								 currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							 }

						 }

					 } else if ( material.visible ) {

						 currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					 }

				 }

			 }

		 }

		 const children = object.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 projectObject( children[ i ], camera, groupOrder, sortObjects );

		 }

	 }

	 function renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera ) {

		 if ( _transmissionRenderTarget === null ) {

			 const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
			 const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget$1 : WebGLRenderTarget$1;

			 _transmissionRenderTarget = new renderTargetType( 1024, 1024, {
				 generateMipmaps: true,
				 type: utils.convert( HalfFloatType$1 ) !== null ? HalfFloatType$1 : UnsignedByteType$1,
				 minFilter: LinearMipmapLinearFilter$1,
				 magFilter: NearestFilter$1,
				 wrapS: ClampToEdgeWrapping$1,
				 wrapT: ClampToEdgeWrapping$1
			 } );

		 }

		 const currentRenderTarget = _this.getRenderTarget();
		 _this.setRenderTarget( _transmissionRenderTarget );
		 _this.clear();

		 // Turn off the features which can affect the frag color for opaque objects pass.
		 // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		 const currentToneMapping = _this.toneMapping;
		 _this.toneMapping = NoToneMapping$1;

		 renderObjects( opaqueObjects, scene, camera );

		 _this.toneMapping = currentToneMapping;

		 textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
		 textures.updateRenderTargetMipmap( _transmissionRenderTarget );

		 _this.setRenderTarget( currentRenderTarget );

		 renderObjects( transmissiveObjects, scene, camera );

	 }

	 function renderObjects( renderList, scene, camera ) {

		 const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		 for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			 const renderItem = renderList[ i ];

			 const object = renderItem.object;
			 const geometry = renderItem.geometry;
			 const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			 const group = renderItem.group;

			 if ( camera.isArrayCamera ) {

				 const cameras = camera.cameras;

				 for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					 const camera2 = cameras[ j ];

					 if ( object.layers.test( camera2.layers ) ) {

						 state.viewport( _currentViewport.copy( camera2.viewport ) );

						 currentRenderState.setupLightsView( camera2 );

						 renderObject( object, scene, camera2, geometry, material, group );

					 }

				 }

			 } else {

				 renderObject( object, scene, camera, geometry, material, group );

			 }

		 }

	 }

	 function renderObject( object, scene, camera, geometry, material, group ) {

		 object.onBeforeRender( _this, scene, camera, geometry, material, group );

		 object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		 object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		 if ( object.isImmediateRenderObject ) {

			 const program = setProgram( camera, scene, material, object );

			 state.setMaterial( material );

			 bindingStates.reset();

			 renderObjectImmediate( object, program );

		 } else {

			 if ( material.transparent === true && material.side === DoubleSide$1 ) {

				 material.side = BackSide$1;
				 material.needsUpdate = true;
				 _this.renderBufferDirect( camera, scene, geometry, material, object, group );

				 material.side = FrontSide$1;
				 material.needsUpdate = true;
				 _this.renderBufferDirect( camera, scene, geometry, material, object, group );

				 material.side = DoubleSide$1;

			 } else {

				 _this.renderBufferDirect( camera, scene, geometry, material, object, group );

			 }

		 }

		 object.onAfterRender( _this, scene, camera, geometry, material, group );

	 }

	 function getProgram( material, scene, object ) {

		 if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		 const materialProperties = properties.get( material );

		 const lights = currentRenderState.state.lights;
		 const shadowsArray = currentRenderState.state.shadowsArray;

		 const lightsStateVersion = lights.state.version;

		 const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		 const programCacheKey = programCache.getProgramCacheKey( parameters );

		 let programs = materialProperties.programs;

		 // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		 materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		 materialProperties.fog = scene.fog;
		 materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

		 if ( programs === undefined ) {

			 // new material

			 material.addEventListener( 'dispose', onMaterialDispose );

			 programs = new Map();
			 materialProperties.programs = programs;

		 }

		 let program = programs.get( programCacheKey );

		 if ( program !== undefined ) {

			 // early out if program and light state is identical

			 if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				 updateCommonMaterialProperties( material, parameters );

				 return program;

			 }

		 } else {

			 parameters.uniforms = programCache.getUniforms( material );

			 material.onBuild( parameters, _this );

			 material.onBeforeCompile( parameters, _this );

			 program = programCache.acquireProgram( parameters, programCacheKey );
			 programs.set( programCacheKey, program );

			 materialProperties.uniforms = parameters.uniforms;

		 }

		 const uniforms = materialProperties.uniforms;

		 if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			 uniforms.clippingPlanes = clipping.uniform;

		 }

		 updateCommonMaterialProperties( material, parameters );

		 // store the light setup it was created for

		 materialProperties.needsLights = materialNeedsLights( material );
		 materialProperties.lightsStateVersion = lightsStateVersion;

		 if ( materialProperties.needsLights ) {

			 // wire up the material to this renderer's lighting state

			 uniforms.ambientLightColor.value = lights.state.ambient;
			 uniforms.lightProbe.value = lights.state.probe;
			 uniforms.directionalLights.value = lights.state.directional;
			 uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			 uniforms.spotLights.value = lights.state.spot;
			 uniforms.spotLightShadows.value = lights.state.spotShadow;
			 uniforms.rectAreaLights.value = lights.state.rectArea;
			 uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			 uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			 uniforms.pointLights.value = lights.state.point;
			 uniforms.pointLightShadows.value = lights.state.pointShadow;
			 uniforms.hemisphereLights.value = lights.state.hemi;

			 uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			 uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			 uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			 uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			 uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			 uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			 // TODO (abelnation): add area lights shadow info to uniforms

		 }

		 const progUniforms = program.getUniforms();
		 const uniformsList = WebGLUniforms$1.seqWithValue( progUniforms.seq, uniforms );

		 materialProperties.currentProgram = program;
		 materialProperties.uniformsList = uniformsList;

		 return program;

	 }

	 function updateCommonMaterialProperties( material, parameters ) {

		 const materialProperties = properties.get( material );

		 materialProperties.outputEncoding = parameters.outputEncoding;
		 materialProperties.instancing = parameters.instancing;
		 materialProperties.skinning = parameters.skinning;
		 materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		 materialProperties.numIntersection = parameters.numClipIntersection;
		 materialProperties.vertexAlphas = parameters.vertexAlphas;

	 }

	 function setProgram( camera, scene, material, object ) {

		 if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		 textures.resetTextureUnits();

		 const fog = scene.fog;
		 const environment = material.isMeshStandardMaterial ? scene.environment : null;
		 const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
		 const envMap = cubemaps.get( material.envMap || environment );
		 const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;

		 const materialProperties = properties.get( material );
		 const lights = currentRenderState.state.lights;

		 if ( _clippingEnabled === true ) {

			 if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				 const useCache =
					 camera === _currentCamera &&
					 material.id === _currentMaterialId;

				 // we might want to call this function with some ClippingGroup
				 // object instead of the material, once it becomes feasible
				 // (#8465, #8379)
				 clipping.setState( material, camera, useCache );

			 }

		 }

		 //

		 let needsProgramChange = false;

		 if ( material.version === materialProperties.__version ) {

			 if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.outputEncoding !== encoding ) {

				 needsProgramChange = true;

			 } else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				 needsProgramChange = true;

			 } else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				 needsProgramChange = true;

			 } else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

				 needsProgramChange = true;

			 } else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.envMap !== envMap ) {

				 needsProgramChange = true;

			 } else if ( material.fog && materialProperties.fog !== fog ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.numClippingPlanes !== undefined &&
				 ( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				 materialProperties.numIntersection !== clipping.numIntersection ) ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				 needsProgramChange = true;

			 }

		 } else {

			 needsProgramChange = true;
			 materialProperties.__version = material.version;

		 }

		 //

		 let program = materialProperties.currentProgram;

		 if ( needsProgramChange === true ) {

			 program = getProgram( material, scene, object );

		 }

		 let refreshProgram = false;
		 let refreshMaterial = false;
		 let refreshLights = false;

		 const p_uniforms = program.getUniforms(),
			 m_uniforms = materialProperties.uniforms;

		 if ( state.useProgram( program.program ) ) {

			 refreshProgram = true;
			 refreshMaterial = true;
			 refreshLights = true;

		 }

		 if ( material.id !== _currentMaterialId ) {

			 _currentMaterialId = material.id;

			 refreshMaterial = true;

		 }

		 if ( refreshProgram || _currentCamera !== camera ) {

			 p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			 if ( capabilities.logarithmicDepthBuffer ) {

				 p_uniforms.setValue( _gl, 'logDepthBufFC',
					 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			 }

			 if ( _currentCamera !== camera ) {

				 _currentCamera = camera;

				 // lighting uniforms depend on the camera so enforce an update
				 // now, in case this material supports lights - or later, when
				 // the next material that does gets activated:

				 refreshMaterial = true;		// set to true on material change
				 refreshLights = true;		// remains set until update done

			 }

			 // load material specific uniforms
			 // (shader material also gets them for the sake of genericity)

			 if ( material.isShaderMaterial ||
				 material.isMeshPhongMaterial ||
				 material.isMeshToonMaterial ||
				 material.isMeshStandardMaterial ||
				 material.envMap ) {

				 const uCamPos = p_uniforms.map.cameraPosition;

				 if ( uCamPos !== undefined ) {

					 uCamPos.setValue( _gl,
						 _vector3.setFromMatrixPosition( camera.matrixWorld ) );

				 }

			 }

			 if ( material.isMeshPhongMaterial ||
				 material.isMeshToonMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isMeshBasicMaterial ||
				 material.isMeshStandardMaterial ||
				 material.isShaderMaterial ) {

				 p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			 }

			 if ( material.isMeshPhongMaterial ||
				 material.isMeshToonMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isMeshBasicMaterial ||
				 material.isMeshStandardMaterial ||
				 material.isShaderMaterial ||
				 material.isShadowMaterial ||
				 object.isSkinnedMesh ) {

				 p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			 }

		 }

		 // skinning uniforms must be set even if material didn't change
		 // auto-setting of texture unit for bone texture must go before other textures
		 // otherwise textures used for skinning can take over texture units reserved for other material textures

		 if ( object.isSkinnedMesh ) {

			 p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			 p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			 const skeleton = object.skeleton;

			 if ( skeleton ) {

				 if ( capabilities.floatVertexTextures ) {

					 if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					 p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					 p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				 } else {

					 p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				 }

			 }

		 }

		 if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			 materialProperties.receiveShadow = object.receiveShadow;
			 p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		 }

		 if ( refreshMaterial ) {

			 p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			 if ( materialProperties.needsLights ) {

				 // the current material requires lighting info

				 // note: all lighting uniforms are always set correctly
				 // they simply reference the renderer's state for their
				 // values
				 //
				 // use the current material's .needsUpdate flags to set
				 // the GL state when required

				 markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			 }

			 // refresh uniforms common to several materials

			 if ( fog && material.fog ) {

				 materials.refreshFogUniforms( m_uniforms, fog );

			 }

			 materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

			 WebGLUniforms$1.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		 }

		 if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			 WebGLUniforms$1.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			 material.uniformsNeedUpdate = false;

		 }

		 if ( material.isSpriteMaterial ) {

			 p_uniforms.setValue( _gl, 'center', object.center );

		 }

		 // common matrices

		 p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		 p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		 p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		 return program;

	 }

	 // If uniforms are marked as clean, they don't need to be loaded to the GPU.

	 function markUniformsLightsNeedsUpdate( uniforms, value ) {

		 uniforms.ambientLightColor.needsUpdate = value;
		 uniforms.lightProbe.needsUpdate = value;

		 uniforms.directionalLights.needsUpdate = value;
		 uniforms.directionalLightShadows.needsUpdate = value;
		 uniforms.pointLights.needsUpdate = value;
		 uniforms.pointLightShadows.needsUpdate = value;
		 uniforms.spotLights.needsUpdate = value;
		 uniforms.spotLightShadows.needsUpdate = value;
		 uniforms.rectAreaLights.needsUpdate = value;
		 uniforms.hemisphereLights.needsUpdate = value;

	 }

	 function materialNeedsLights( material ) {

		 return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			 material.isMeshStandardMaterial || material.isShadowMaterial ||
			 ( material.isShaderMaterial && material.lights === true );

	 }

	 this.getActiveCubeFace = function () {

		 return _currentActiveCubeFace;

	 };

	 this.getActiveMipmapLevel = function () {

		 return _currentActiveMipmapLevel;

	 };

	 this.getRenderTarget = function () {

		 return _currentRenderTarget;

	 };

	 this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		 _currentRenderTarget = renderTarget;
		 _currentActiveCubeFace = activeCubeFace;
		 _currentActiveMipmapLevel = activeMipmapLevel;

		 if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			 textures.setupRenderTarget( renderTarget );

		 }

		 let framebuffer = null;
		 let isCube = false;
		 let isRenderTarget3D = false;

		 if ( renderTarget ) {

			 const texture = renderTarget.texture;

			 if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

				 isRenderTarget3D = true;

			 }

			 const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			 if ( renderTarget.isWebGLCubeRenderTarget ) {

				 framebuffer = __webglFramebuffer[ activeCubeFace ];
				 isCube = true;

			 } else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				 framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			 } else {

				 framebuffer = __webglFramebuffer;

			 }

			 _currentViewport.copy( renderTarget.viewport );
			 _currentScissor.copy( renderTarget.scissor );
			 _currentScissorTest = renderTarget.scissorTest;

		 } else {

			 _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			 _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			 _currentScissorTest = _scissorTest;

		 }

		 const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

		 if ( framebufferBound && capabilities.drawBuffers ) {

			 let needsUpdate = false;

			 if ( renderTarget ) {

				 if ( renderTarget.isWebGLMultipleRenderTargets ) {

					 const textures = renderTarget.texture;

					 if ( _currentDrawBuffers.length !== textures.length || _currentDrawBuffers[ 0 ] !== 36064 ) {

						 for ( let i = 0, il = textures.length; i < il; i ++ ) {

							 _currentDrawBuffers[ i ] = 36064 + i;

						 }

						 _currentDrawBuffers.length = textures.length;

						 needsUpdate = true;

					 }

				 } else {

					 if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 36064 ) {

						 _currentDrawBuffers[ 0 ] = 36064;
						 _currentDrawBuffers.length = 1;

						 needsUpdate = true;

					 }

				 }

			 } else {

				 if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 1029 ) {

					 _currentDrawBuffers[ 0 ] = 1029;
					 _currentDrawBuffers.length = 1;

					 needsUpdate = true;

				 }

			 }

			 if ( needsUpdate ) {

				 if ( capabilities.isWebGL2 ) {

					 _gl.drawBuffers( _currentDrawBuffers );

				 } else {

					 extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( _currentDrawBuffers );

				 }

			 }

		 }

		 state.viewport( _currentViewport );
		 state.scissor( _currentScissor );
		 state.setScissorTest( _currentScissorTest );

		 if ( isCube ) {

			 const textureProperties = properties.get( renderTarget.texture );
			 _gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		 } else if ( isRenderTarget3D ) {

			 const textureProperties = properties.get( renderTarget.texture );
			 const layer = activeCubeFace || 0;
			 _gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		 }

	 };

	 this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		 if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			 return;

		 }

		 let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		 if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			 framebuffer = framebuffer[ activeCubeFaceIndex ];

		 }

		 if ( framebuffer ) {

			 state.bindFramebuffer( 36160, framebuffer );

			 try {

				 const texture = renderTarget.texture;
				 const textureFormat = texture.format;
				 const textureType = texture.type;

				 if ( textureFormat !== RGBAFormat$1 && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					 return;

				 }

				 const halfFloatSupportedByExt = ( textureType === HalfFloatType$1 ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				 if ( textureType !== UnsignedByteType$1 && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					 ! ( textureType === FloatType$1 && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					 ! halfFloatSupportedByExt ) {

					 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					 return;

				 }

				 if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					 // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					 if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						 _gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					 }

				 } else {

					 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				 }

			 } finally {

				 // restore framebuffer of current render target if necessary

				 const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				 state.bindFramebuffer( 36160, framebuffer );

			 }

		 }

	 };

	 this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		 const levelScale = Math.pow( 2, - level );
		 const width = Math.floor( texture.image.width * levelScale );
		 const height = Math.floor( texture.image.height * levelScale );

		 let glFormat = utils.convert( texture.format );

		 if ( capabilities.isWebGL2 ) {

			 // Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
			 // Not needed in Chrome 93+

			 if ( glFormat === 6407 ) glFormat = 32849;
			 if ( glFormat === 6408 ) glFormat = 32856;

		 }

		 textures.setTexture2D( texture, 0 );

		 _gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		 state.unbindTexture();

	 };

	 this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		 const width = srcTexture.image.width;
		 const height = srcTexture.image.height;
		 const glFormat = utils.convert( dstTexture.format );
		 const glType = utils.convert( dstTexture.type );

		 textures.setTexture2D( dstTexture, 0 );

		 // As another texture upload may have changed pixelStorei
		 // parameters, make sure they are correct for the dstTexture
		 _gl.pixelStorei( 37440, dstTexture.flipY );
		 _gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		 if ( srcTexture.isDataTexture ) {

			 _gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		 } else {

			 if ( srcTexture.isCompressedTexture ) {

				 _gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			 } else {

				 _gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			 }

		 }

		 // Generate mipmaps only when copying level 0
		 if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		 state.unbindTexture();

	 };

	 this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		 if ( _this.isWebGL1Renderer ) {

			 console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			 return;

		 }

		 const width = sourceBox.max.x - sourceBox.min.x + 1;
		 const height = sourceBox.max.y - sourceBox.min.y + 1;
		 const depth = sourceBox.max.z - sourceBox.min.z + 1;
		 const glFormat = utils.convert( dstTexture.format );
		 const glType = utils.convert( dstTexture.type );
		 let glTarget;

		 if ( dstTexture.isDataTexture3D ) {

			 textures.setTexture3D( dstTexture, 0 );
			 glTarget = 32879;

		 } else if ( dstTexture.isDataTexture2DArray ) {

			 textures.setTexture2DArray( dstTexture, 0 );
			 glTarget = 35866;

		 } else {

			 console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			 return;

		 }

		 _gl.pixelStorei( 37440, dstTexture.flipY );
		 _gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		 const unpackRowLen = _gl.getParameter( 3314 );
		 const unpackImageHeight = _gl.getParameter( 32878 );
		 const unpackSkipPixels = _gl.getParameter( 3316 );
		 const unpackSkipRows = _gl.getParameter( 3315 );
		 const unpackSkipImages = _gl.getParameter( 32877 );

		 const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

		 _gl.pixelStorei( 3314, image.width );
		 _gl.pixelStorei( 32878, image.height );
		 _gl.pixelStorei( 3316, sourceBox.min.x );
		 _gl.pixelStorei( 3315, sourceBox.min.y );
		 _gl.pixelStorei( 32877, sourceBox.min.z );

		 if ( srcTexture.isDataTexture || srcTexture.isDataTexture3D ) {

			 _gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

		 } else {

			 if ( srcTexture.isCompressedTexture ) {

				 console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
				 _gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

			 } else {

				 _gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

			 }

		 }

		 _gl.pixelStorei( 3314, unpackRowLen );
		 _gl.pixelStorei( 32878, unpackImageHeight );
		 _gl.pixelStorei( 3316, unpackSkipPixels );
		 _gl.pixelStorei( 3315, unpackSkipRows );
		 _gl.pixelStorei( 32877, unpackSkipImages );

		 // Generate mipmaps only when copying level 0
		 if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		 state.unbindTexture();

	 };

	 this.initTexture = function ( texture ) {

		 textures.setTexture2D( texture, 0 );

		 state.unbindTexture();

	 };

	 this.resetState = function () {

		 _currentActiveCubeFace = 0;
		 _currentActiveMipmapLevel = 0;
		 _currentRenderTarget = null;

		 state.reset();
		 bindingStates.reset();

	 };

	 if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		 __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	 }

 }

 class WebGL1Renderer$1 extends WebGLRenderer$1 {}

 WebGL1Renderer$1.prototype.isWebGL1Renderer = true;

 class Scene$1 extends Object3D$1 {

	 constructor() {

		 super();

		 this.type = 'Scene';

		 this.background = null;
		 this.environment = null;
		 this.fog = null;

		 this.overrideMaterial = null;

		 this.autoUpdate = true; // checked by the renderer

		 if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			 __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		 }

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 if ( source.background !== null ) this.background = source.background.clone();
		 if ( source.environment !== null ) this.environment = source.environment.clone();
		 if ( source.fog !== null ) this.fog = source.fog.clone();

		 if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		 this.autoUpdate = source.autoUpdate;
		 this.matrixAutoUpdate = source.matrixAutoUpdate;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		 return data;

	 }

 }

 Scene$1.prototype.isScene = true;

 class InterleavedBuffer$1 {

	 constructor( array, stride ) {

		 this.array = array;
		 this.stride = stride;
		 this.count = array !== undefined ? array.length / stride : 0;

		 this.usage = StaticDrawUsage$1;
		 this.updateRange = { offset: 0, count: - 1 };

		 this.version = 0;

		 this.uuid = generateUUID$1();

	 }

	 onUploadCallback() {}

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

	 setUsage( value ) {

		 this.usage = value;

		 return this;

	 }

	 copy( source ) {

		 this.array = new source.array.constructor( source.array );
		 this.count = source.count;
		 this.stride = source.stride;
		 this.usage = source.usage;

		 return this;

	 }

	 copyAt( index1, attribute, index2 ) {

		 index1 *= this.stride;
		 index2 *= attribute.stride;

		 for ( let i = 0, l = this.stride; i < l; i ++ ) {

			 this.array[ index1 + i ] = attribute.array[ index2 + i ];

		 }

		 return this;

	 }

	 set( value, offset = 0 ) {

		 this.array.set( value, offset );

		 return this;

	 }

	 clone( data ) {

		 if ( data.arrayBuffers === undefined ) {

			 data.arrayBuffers = {};

		 }

		 if ( this.array.buffer._uuid === undefined ) {

			 this.array.buffer._uuid = generateUUID$1();

		 }

		 if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			 data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		 }

		 const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		 const ib = new this.constructor( array, this.stride );
		 ib.setUsage( this.usage );

		 return ib;

	 }

	 onUpload( callback ) {

		 this.onUploadCallback = callback;

		 return this;

	 }

	 toJSON( data ) {

		 if ( data.arrayBuffers === undefined ) {

			 data.arrayBuffers = {};

		 }

		 // generate UUID for array buffer if necessary

		 if ( this.array.buffer._uuid === undefined ) {

			 this.array.buffer._uuid = generateUUID$1();

		 }

		 if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			 data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		 }

		 //

		 return {
			 uuid: this.uuid,
			 buffer: this.array.buffer._uuid,
			 type: this.array.constructor.name,
			 stride: this.stride
		 };

	 }

 }

 InterleavedBuffer$1.prototype.isInterleavedBuffer = true;

 const _vector$6$1 = /*@__PURE__*/ new Vector3$1();

 class InterleavedBufferAttribute$1 {

	 constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		 this.name = '';

		 this.data = interleavedBuffer;
		 this.itemSize = itemSize;
		 this.offset = offset;

		 this.normalized = normalized === true;

	 }

	 get count() {

		 return this.data.count;

	 }

	 get array() {

		 return this.data.array;

	 }

	 set needsUpdate( value ) {

		 this.data.needsUpdate = value;

	 }

	 applyMatrix4( m ) {

		 for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			 _vector$6$1.x = this.getX( i );
			 _vector$6$1.y = this.getY( i );
			 _vector$6$1.z = this.getZ( i );

			 _vector$6$1.applyMatrix4( m );

			 this.setXYZ( i, _vector$6$1.x, _vector$6$1.y, _vector$6$1.z );

		 }

		 return this;

	 }

	 applyNormalMatrix( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$6$1.x = this.getX( i );
			 _vector$6$1.y = this.getY( i );
			 _vector$6$1.z = this.getZ( i );

			 _vector$6$1.applyNormalMatrix( m );

			 this.setXYZ( i, _vector$6$1.x, _vector$6$1.y, _vector$6$1.z );

		 }

		 return this;

	 }

	 transformDirection( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$6$1.x = this.getX( i );
			 _vector$6$1.y = this.getY( i );
			 _vector$6$1.z = this.getZ( i );

			 _vector$6$1.transformDirection( m );

			 this.setXYZ( i, _vector$6$1.x, _vector$6$1.y, _vector$6$1.z );

		 }

		 return this;

	 }

	 setX( index, x ) {

		 this.data.array[ index * this.data.stride + this.offset ] = x;

		 return this;

	 }

	 setY( index, y ) {

		 this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		 return this;

	 }

	 setZ( index, z ) {

		 this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		 return this;

	 }

	 setW( index, w ) {

		 this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		 return this;

	 }

	 getX( index ) {

		 return this.data.array[ index * this.data.stride + this.offset ];

	 }

	 getY( index ) {

		 return this.data.array[ index * this.data.stride + this.offset + 1 ];

	 }

	 getZ( index ) {

		 return this.data.array[ index * this.data.stride + this.offset + 2 ];

	 }

	 getW( index ) {

		 return this.data.array[ index * this.data.stride + this.offset + 3 ];

	 }

	 setXY( index, x, y ) {

		 index = index * this.data.stride + this.offset;

		 this.data.array[ index + 0 ] = x;
		 this.data.array[ index + 1 ] = y;

		 return this;

	 }

	 setXYZ( index, x, y, z ) {

		 index = index * this.data.stride + this.offset;

		 this.data.array[ index + 0 ] = x;
		 this.data.array[ index + 1 ] = y;
		 this.data.array[ index + 2 ] = z;

		 return this;

	 }

	 setXYZW( index, x, y, z, w ) {

		 index = index * this.data.stride + this.offset;

		 this.data.array[ index + 0 ] = x;
		 this.data.array[ index + 1 ] = y;
		 this.data.array[ index + 2 ] = z;
		 this.data.array[ index + 3 ] = w;

		 return this;

	 }

	 clone( data ) {

		 if ( data === undefined ) {

			 console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			 const array = [];

			 for ( let i = 0; i < this.count; i ++ ) {

				 const index = i * this.data.stride + this.offset;

				 for ( let j = 0; j < this.itemSize; j ++ ) {

					 array.push( this.data.array[ index + j ] );

				 }

			 }

			 return new BufferAttribute$1( new this.array.constructor( array ), this.itemSize, this.normalized );

		 } else {

			 if ( data.interleavedBuffers === undefined ) {

				 data.interleavedBuffers = {};

			 }

			 if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				 data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			 }

			 return new InterleavedBufferAttribute$1( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		 }

	 }

	 toJSON( data ) {

		 if ( data === undefined ) {

			 console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			 const array = [];

			 for ( let i = 0; i < this.count; i ++ ) {

				 const index = i * this.data.stride + this.offset;

				 for ( let j = 0; j < this.itemSize; j ++ ) {

					 array.push( this.data.array[ index + j ] );

				 }

			 }

			 // deinterleave data and save it as an ordinary buffer attribute for now

			 return {
				 itemSize: this.itemSize,
				 type: this.array.constructor.name,
				 array: array,
				 normalized: this.normalized
			 };

		 } else {

			 // save as true interlaved attribtue

			 if ( data.interleavedBuffers === undefined ) {

				 data.interleavedBuffers = {};

			 }

			 if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				 data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			 }

			 return {
				 isInterleavedBufferAttribute: true,
				 itemSize: this.itemSize,
				 data: this.data.uuid,
				 offset: this.offset,
				 normalized: this.normalized
			 };

		 }

	 }

 }

 InterleavedBufferAttribute$1.prototype.isInterleavedBufferAttribute = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  map: new THREE.Texture( <Image> ),
	*  alphaMap: new THREE.Texture( <Image> ),
	*  rotation: <float>,
	*  sizeAttenuation: <bool>
	* }
	*/

 class SpriteMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'SpriteMaterial';

		 this.color = new Color$2( 0xffffff );

		 this.map = null;

		 this.alphaMap = null;

		 this.rotation = 0;

		 this.sizeAttenuation = true;

		 this.transparent = true;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.rotation = source.rotation;

		 this.sizeAttenuation = source.sizeAttenuation;

		 return this;

	 }

 }

 SpriteMaterial$1.prototype.isSpriteMaterial = true;

 let _geometry$3;

 const _intersectPoint$1 = /*@__PURE__*/ new Vector3$1();
 const _worldScale$1 = /*@__PURE__*/ new Vector3$1();
 const _mvPosition$1 = /*@__PURE__*/ new Vector3$1();

 const _alignedPosition$1 = /*@__PURE__*/ new Vector2$1();
 const _rotatedPosition$1 = /*@__PURE__*/ new Vector2$1();
 const _viewWorldMatrix$1 = /*@__PURE__*/ new Matrix4$1();

 const _vA$2 = /*@__PURE__*/ new Vector3$1();
 const _vB$2 = /*@__PURE__*/ new Vector3$1();
 const _vC$2 = /*@__PURE__*/ new Vector3$1();

 const _uvA$2 = /*@__PURE__*/ new Vector2$1();
 const _uvB$2 = /*@__PURE__*/ new Vector2$1();
 const _uvC$2 = /*@__PURE__*/ new Vector2$1();

 class Sprite$1 extends Object3D$1 {

	 constructor( material ) {

		 super();

		 this.type = 'Sprite';

		 if ( _geometry$3 === undefined ) {

			 _geometry$3 = new BufferGeometry$1();

			 const float32Array = new Float32Array( [
				 - 0.5, - 0.5, 0, 0, 0,
				 0.5, - 0.5, 0, 1, 0,
				 0.5, 0.5, 0, 1, 1,
				 - 0.5, 0.5, 0, 0, 1
			 ] );

			 const interleavedBuffer = new InterleavedBuffer$1( float32Array, 5 );

			 _geometry$3.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			 _geometry$3.setAttribute( 'position', new InterleavedBufferAttribute$1( interleavedBuffer, 3, 0, false ) );
			 _geometry$3.setAttribute( 'uv', new InterleavedBufferAttribute$1( interleavedBuffer, 2, 3, false ) );

		 }

		 this.geometry = _geometry$3;
		 this.material = ( material !== undefined ) ? material : new SpriteMaterial$1();

		 this.center = new Vector2$1( 0.5, 0.5 );

	 }

	 raycast( raycaster, intersects ) {

		 if ( raycaster.camera === null ) {

			 console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		 }

		 _worldScale$1.setFromMatrixScale( this.matrixWorld );

		 _viewWorldMatrix$1.copy( raycaster.camera.matrixWorld );
		 this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		 _mvPosition$1.setFromMatrixPosition( this.modelViewMatrix );

		 if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			 _worldScale$1.multiplyScalar( - _mvPosition$1.z );

		 }

		 const rotation = this.material.rotation;
		 let sin, cos;

		 if ( rotation !== 0 ) {

			 cos = Math.cos( rotation );
			 sin = Math.sin( rotation );

		 }

		 const center = this.center;

		 transformVertex$1( _vA$2.set( - 0.5, - 0.5, 0 ), _mvPosition$1, center, _worldScale$1, sin, cos );
		 transformVertex$1( _vB$2.set( 0.5, - 0.5, 0 ), _mvPosition$1, center, _worldScale$1, sin, cos );
		 transformVertex$1( _vC$2.set( 0.5, 0.5, 0 ), _mvPosition$1, center, _worldScale$1, sin, cos );

		 _uvA$2.set( 0, 0 );
		 _uvB$2.set( 1, 0 );
		 _uvC$2.set( 1, 1 );

		 // check first triangle
		 let intersect = raycaster.ray.intersectTriangle( _vA$2, _vB$2, _vC$2, false, _intersectPoint$1 );

		 if ( intersect === null ) {

			 // check second triangle
			 transformVertex$1( _vB$2.set( - 0.5, 0.5, 0 ), _mvPosition$1, center, _worldScale$1, sin, cos );
			 _uvB$2.set( 0, 1 );

			 intersect = raycaster.ray.intersectTriangle( _vA$2, _vC$2, _vB$2, false, _intersectPoint$1 );
			 if ( intersect === null ) {

				 return;

			 }

		 }

		 const distance = raycaster.ray.origin.distanceTo( _intersectPoint$1 );

		 if ( distance < raycaster.near || distance > raycaster.far ) return;

		 intersects.push( {

			 distance: distance,
			 point: _intersectPoint$1.clone(),
			 uv: Triangle$1.getUV( _intersectPoint$1, _vA$2, _vB$2, _vC$2, _uvA$2, _uvB$2, _uvC$2, new Vector2$1() ),
			 face: null,
			 object: this

		 } );

	 }

	 copy( source ) {

		 super.copy( source );

		 if ( source.center !== undefined ) this.center.copy( source.center );

		 this.material = source.material;

		 return this;

	 }

 }

 Sprite$1.prototype.isSprite = true;

 function transformVertex$1( vertexPosition, mvPosition, center, scale, sin, cos ) {

	 // compute position in camera space
	 _alignedPosition$1.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	 // to check if rotation is not zero
	 if ( sin !== undefined ) {

		 _rotatedPosition$1.x = ( cos * _alignedPosition$1.x ) - ( sin * _alignedPosition$1.y );
		 _rotatedPosition$1.y = ( sin * _alignedPosition$1.x ) + ( cos * _alignedPosition$1.y );

	 } else {

		 _rotatedPosition$1.copy( _alignedPosition$1 );

	 }


	 vertexPosition.copy( mvPosition );
	 vertexPosition.x += _rotatedPosition$1.x;
	 vertexPosition.y += _rotatedPosition$1.y;

	 // transform to world space
	 vertexPosition.applyMatrix4( _viewWorldMatrix$1 );

 }

 const _basePosition$1 = /*@__PURE__*/ new Vector3$1();

 const _skinIndex$1 = /*@__PURE__*/ new Vector4$1();
 const _skinWeight$1 = /*@__PURE__*/ new Vector4$1();

 const _vector$5$1 = /*@__PURE__*/ new Vector3$1();
 const _matrix$2 = /*@__PURE__*/ new Matrix4$1();

 class SkinnedMesh$1 extends Mesh$1 {

	 constructor( geometry, material ) {

		 super( geometry, material );

		 this.type = 'SkinnedMesh';

		 this.bindMode = 'attached';
		 this.bindMatrix = new Matrix4$1();
		 this.bindMatrixInverse = new Matrix4$1();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.bindMode = source.bindMode;
		 this.bindMatrix.copy( source.bindMatrix );
		 this.bindMatrixInverse.copy( source.bindMatrixInverse );

		 this.skeleton = source.skeleton;

		 return this;

	 }

	 bind( skeleton, bindMatrix ) {

		 this.skeleton = skeleton;

		 if ( bindMatrix === undefined ) {

			 this.updateMatrixWorld( true );

			 this.skeleton.calculateInverses();

			 bindMatrix = this.matrixWorld;

		 }

		 this.bindMatrix.copy( bindMatrix );
		 this.bindMatrixInverse.copy( bindMatrix ).invert();

	 }

	 pose() {

		 this.skeleton.pose();

	 }

	 normalizeSkinWeights() {

		 const vector = new Vector4$1();

		 const skinWeight = this.geometry.attributes.skinWeight;

		 for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			 vector.x = skinWeight.getX( i );
			 vector.y = skinWeight.getY( i );
			 vector.z = skinWeight.getZ( i );
			 vector.w = skinWeight.getW( i );

			 const scale = 1.0 / vector.manhattanLength();

			 if ( scale !== Infinity ) {

				 vector.multiplyScalar( scale );

			 } else {

				 vector.set( 1, 0, 0, 0 ); // do something reasonable

			 }

			 skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		 }

	 }

	 updateMatrixWorld( force ) {

		 super.updateMatrixWorld( force );

		 if ( this.bindMode === 'attached' ) {

			 this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		 } else if ( this.bindMode === 'detached' ) {

			 this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		 } else {

			 console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		 }

	 }

	 boneTransform( index, target ) {

		 const skeleton = this.skeleton;
		 const geometry = this.geometry;

		 _skinIndex$1.fromBufferAttribute( geometry.attributes.skinIndex, index );
		 _skinWeight$1.fromBufferAttribute( geometry.attributes.skinWeight, index );

		 _basePosition$1.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

		 target.set( 0, 0, 0 );

		 for ( let i = 0; i < 4; i ++ ) {

			 const weight = _skinWeight$1.getComponent( i );

			 if ( weight !== 0 ) {

				 const boneIndex = _skinIndex$1.getComponent( i );

				 _matrix$2.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				 target.addScaledVector( _vector$5$1.copy( _basePosition$1 ).applyMatrix4( _matrix$2 ), weight );

			 }

		 }

		 return target.applyMatrix4( this.bindMatrixInverse );

	 }

 }

 SkinnedMesh$1.prototype.isSkinnedMesh = true;

 class Bone$1 extends Object3D$1 {

	 constructor() {

		 super();

		 this.type = 'Bone';

	 }

 }

 Bone$1.prototype.isBone = true;

 class DataTexture$1 extends Texture$1 {

	 constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter$1, minFilter = NearestFilter$1, anisotropy, encoding ) {

		 super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		 this.image = { data: data, width: width, height: height };

		 this.magFilter = magFilter;
		 this.minFilter = minFilter;

		 this.generateMipmaps = false;
		 this.flipY = false;
		 this.unpackAlignment = 1;

		 this.needsUpdate = true;

	 }

 }

 DataTexture$1.prototype.isDataTexture = true;

 const _offsetMatrix = /*@__PURE__*/ new Matrix4$1();
 const _identityMatrix = /*@__PURE__*/ new Matrix4$1();

 class Skeleton {

	 constructor( bones = [], boneInverses = [] ) {

		 this.uuid = generateUUID$1();

		 this.bones = bones.slice( 0 );
		 this.boneInverses = boneInverses;
		 this.boneMatrices = null;

		 this.boneTexture = null;
		 this.boneTextureSize = 0;

		 this.frame = - 1;

		 this.init();

	 }

	 init() {

		 const bones = this.bones;
		 const boneInverses = this.boneInverses;

		 this.boneMatrices = new Float32Array( bones.length * 16 );

		 // calculate inverse bone matrices if necessary

		 if ( boneInverses.length === 0 ) {

			 this.calculateInverses();

		 } else {

			 // handle special case

			 if ( bones.length !== boneInverses.length ) {

				 console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				 this.boneInverses = [];

				 for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					 this.boneInverses.push( new Matrix4$1() );

				 }

			 }

		 }

	 }

	 calculateInverses() {

		 this.boneInverses.length = 0;

		 for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			 const inverse = new Matrix4$1();

			 if ( this.bones[ i ] ) {

				 inverse.copy( this.bones[ i ].matrixWorld ).invert();

			 }

			 this.boneInverses.push( inverse );

		 }

	 }

	 pose() {

		 // recover the bind-time world matrices

		 for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			 const bone = this.bones[ i ];

			 if ( bone ) {

				 bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			 }

		 }

		 // compute the local matrices, positions, rotations and scales

		 for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			 const bone = this.bones[ i ];

			 if ( bone ) {

				 if ( bone.parent && bone.parent.isBone ) {

					 bone.matrix.copy( bone.parent.matrixWorld ).invert();
					 bone.matrix.multiply( bone.matrixWorld );

				 } else {

					 bone.matrix.copy( bone.matrixWorld );

				 }

				 bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			 }

		 }

	 }

	 update() {

		 const bones = this.bones;
		 const boneInverses = this.boneInverses;
		 const boneMatrices = this.boneMatrices;
		 const boneTexture = this.boneTexture;

		 // flatten bone matrices to array

		 for ( let i = 0, il = bones.length; i < il; i ++ ) {

			 // compute the offset between the current and the original transform

			 const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			 _offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			 _offsetMatrix.toArray( boneMatrices, i * 16 );

		 }

		 if ( boneTexture !== null ) {

			 boneTexture.needsUpdate = true;

		 }

	 }

	 clone() {

		 return new Skeleton( this.bones, this.boneInverses );

	 }

	 computeBoneTexture() {

		 // layout (1 matrix = 4 pixels)
		 //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		 //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		 //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		 //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		 //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		 let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		 size = ceilPowerOfTwo( size );
		 size = Math.max( size, 4 );

		 const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		 boneMatrices.set( this.boneMatrices ); // copy current values

		 const boneTexture = new DataTexture$1( boneMatrices, size, size, RGBAFormat$1, FloatType$1 );

		 this.boneMatrices = boneMatrices;
		 this.boneTexture = boneTexture;
		 this.boneTextureSize = size;

		 return this;

	 }

	 getBoneByName( name ) {

		 for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			 const bone = this.bones[ i ];

			 if ( bone.name === name ) {

				 return bone;

			 }

		 }

		 return undefined;

	 }

	 dispose( ) {

		 if ( this.boneTexture !== null ) {

			 this.boneTexture.dispose();

			 this.boneTexture = null;

		 }

	 }

	 fromJSON( json, bones ) {

		 this.uuid = json.uuid;

		 for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			 const uuid = json.bones[ i ];
			 let bone = bones[ uuid ];

			 if ( bone === undefined ) {

				 console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				 bone = new Bone$1();

			 }

			 this.bones.push( bone );
			 this.boneInverses.push( new Matrix4$1().fromArray( json.boneInverses[ i ] ) );

		 }

		 this.init();

		 return this;

	 }

	 toJSON() {

		 const data = {
			 metadata: {
				 version: 4.5,
				 type: 'Skeleton',
				 generator: 'Skeleton.toJSON'
			 },
			 bones: [],
			 boneInverses: []
		 };

		 data.uuid = this.uuid;

		 const bones = this.bones;
		 const boneInverses = this.boneInverses;

		 for ( let i = 0, l = bones.length; i < l; i ++ ) {

			 const bone = bones[ i ];
			 data.bones.push( bone.uuid );

			 const boneInverse = boneInverses[ i ];
			 data.boneInverses.push( boneInverse.toArray() );

		 }

		 return data;

	 }

 }

 const _instanceLocalMatrix$1 = /*@__PURE__*/ new Matrix4$1();
 const _instanceWorldMatrix$1 = /*@__PURE__*/ new Matrix4$1();

 const _instanceIntersects$1 = [];

 const _mesh$1 = /*@__PURE__*/ new Mesh$1();

 class InstancedMesh$1 extends Mesh$1 {

	 constructor( geometry, material, count ) {

		 super( geometry, material );

		 this.instanceMatrix = new BufferAttribute$1( new Float32Array( count * 16 ), 16 );
		 this.instanceColor = null;

		 this.count = count;

		 this.frustumCulled = false;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.instanceMatrix.copy( source.instanceMatrix );

		 if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		 this.count = source.count;

		 return this;

	 }

	 getColorAt( index, color ) {

		 color.fromArray( this.instanceColor.array, index * 3 );

	 }

	 getMatrixAt( index, matrix ) {

		 matrix.fromArray( this.instanceMatrix.array, index * 16 );

	 }

	 raycast( raycaster, intersects ) {

		 const matrixWorld = this.matrixWorld;
		 const raycastTimes = this.count;

		 _mesh$1.geometry = this.geometry;
		 _mesh$1.material = this.material;

		 if ( _mesh$1.material === undefined ) return;

		 for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			 // calculate the world matrix for each instance

			 this.getMatrixAt( instanceId, _instanceLocalMatrix$1 );

			 _instanceWorldMatrix$1.multiplyMatrices( matrixWorld, _instanceLocalMatrix$1 );

			 // the mesh represents this single instance

			 _mesh$1.matrixWorld = _instanceWorldMatrix$1;

			 _mesh$1.raycast( raycaster, _instanceIntersects$1 );

			 // process the result of raycast

			 for ( let i = 0, l = _instanceIntersects$1.length; i < l; i ++ ) {

				 const intersect = _instanceIntersects$1[ i ];
				 intersect.instanceId = instanceId;
				 intersect.object = this;
				 intersects.push( intersect );

			 }

			 _instanceIntersects$1.length = 0;

		 }

	 }

	 setColorAt( index, color ) {

		 if ( this.instanceColor === null ) {

			 this.instanceColor = new BufferAttribute$1( new Float32Array( this.count * 3 ), 3 );

		 }

		 color.toArray( this.instanceColor.array, index * 3 );

	 }

	 setMatrixAt( index, matrix ) {

		 matrix.toArray( this.instanceMatrix.array, index * 16 );

	 }

	 updateMorphTargets() {

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

 }

 InstancedMesh$1.prototype.isInstancedMesh = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  linewidth: <float>,
	*  linecap: "round",
	*  linejoin: "round"
	* }
	*/

 class LineBasicMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'LineBasicMaterial';

		 this.color = new Color$2( 0xffffff );

		 this.linewidth = 1;
		 this.linecap = 'round';
		 this.linejoin = 'round';

		 this.morphTargets = false;

		 this.setValues( parameters );

	 }


	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.linewidth = source.linewidth;
		 this.linecap = source.linecap;
		 this.linejoin = source.linejoin;

		 this.morphTargets = source.morphTargets;

		 return this;

	 }

 }

 LineBasicMaterial$1.prototype.isLineBasicMaterial = true;

 const _start$1$1 = /*@__PURE__*/ new Vector3$1();
 const _end$1$1 = /*@__PURE__*/ new Vector3$1();
 const _inverseMatrix$1$1 = /*@__PURE__*/ new Matrix4$1();
 const _ray$1$1 = /*@__PURE__*/ new Ray$1();
 const _sphere$1$1 = /*@__PURE__*/ new Sphere$1();

 class Line$1 extends Object3D$1 {

	 constructor( geometry = new BufferGeometry$1(), material = new LineBasicMaterial$1() ) {

		 super();

		 this.type = 'Line';

		 this.geometry = geometry;
		 this.material = material;

		 this.updateMorphTargets();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.material = source.material;
		 this.geometry = source.geometry;

		 return this;

	 }

	 computeLineDistances() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 // we assume non-indexed geometry

			 if ( geometry.index === null ) {

				 const positionAttribute = geometry.attributes.position;
				 const lineDistances = [ 0 ];

				 for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					 _start$1$1.fromBufferAttribute( positionAttribute, i - 1 );
					 _end$1$1.fromBufferAttribute( positionAttribute, i );

					 lineDistances[ i ] = lineDistances[ i - 1 ];
					 lineDistances[ i ] += _start$1$1.distanceTo( _end$1$1 );

				 }

				 geometry.setAttribute( 'lineDistance', new Float32BufferAttribute$1( lineDistances, 1 ) );

			 } else {

				 console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

		 return this;

	 }

	 raycast( raycaster, intersects ) {

		 const geometry = this.geometry;
		 const matrixWorld = this.matrixWorld;
		 const threshold = raycaster.params.Line.threshold;
		 const drawRange = geometry.drawRange;

		 // Checking boundingSphere distance to ray

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere$1$1.copy( geometry.boundingSphere );
		 _sphere$1$1.applyMatrix4( matrixWorld );
		 _sphere$1$1.radius += threshold;

		 if ( raycaster.ray.intersectsSphere( _sphere$1$1 ) === false ) return;

		 //

		 _inverseMatrix$1$1.copy( matrixWorld ).invert();
		 _ray$1$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1$1 );

		 const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		 const localThresholdSq = localThreshold * localThreshold;

		 const vStart = new Vector3$1();
		 const vEnd = new Vector3$1();
		 const interSegment = new Vector3$1();
		 const interRay = new Vector3$1();
		 const step = this.isLineSegments ? 2 : 1;

		 if ( geometry.isBufferGeometry ) {

			 const index = geometry.index;
			 const attributes = geometry.attributes;
			 const positionAttribute = attributes.position;

			 if ( index !== null ) {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, l = end - 1; i < l; i += step ) {

					 const a = index.getX( i );
					 const b = index.getX( i + 1 );

					 vStart.fromBufferAttribute( positionAttribute, a );
					 vEnd.fromBufferAttribute( positionAttribute, b );

					 const distSq = _ray$1$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					 if ( distSq > localThresholdSq ) continue;

					 interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					 const distance = raycaster.ray.origin.distanceTo( interRay );

					 if ( distance < raycaster.near || distance > raycaster.far ) continue;

					 intersects.push( {

						 distance: distance,
						 // What do we want? intersection point on the ray or on the segment??
						 // point: raycaster.ray.at( distance ),
						 point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						 index: i,
						 face: null,
						 faceIndex: null,
						 object: this

					 } );

				 }

			 } else {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, l = end - 1; i < l; i += step ) {

					 vStart.fromBufferAttribute( positionAttribute, i );
					 vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					 const distSq = _ray$1$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					 if ( distSq > localThresholdSq ) continue;

					 interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					 const distance = raycaster.ray.origin.distanceTo( interRay );

					 if ( distance < raycaster.near || distance > raycaster.far ) continue;

					 intersects.push( {

						 distance: distance,
						 // What do we want? intersection point on the ray or on the segment??
						 // point: raycaster.ray.at( distance ),
						 point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						 index: i,
						 face: null,
						 faceIndex: null,
						 object: this

					 } );

				 }

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

	 }

	 updateMorphTargets() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 const morphAttributes = geometry.morphAttributes;
			 const keys = Object.keys( morphAttributes );

			 if ( keys.length > 0 ) {

				 const morphAttribute = morphAttributes[ keys[ 0 ] ];

				 if ( morphAttribute !== undefined ) {

					 this.morphTargetInfluences = [];
					 this.morphTargetDictionary = {};

					 for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						 const name = morphAttribute[ m ].name || String( m );

						 this.morphTargetInfluences.push( 0 );
						 this.morphTargetDictionary[ name ] = m;

					 }

				 }

			 }

		 } else {

			 const morphTargets = geometry.morphTargets;

			 if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				 console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			 }

		 }

	 }

 }

 Line$1.prototype.isLine = true;

 const _start$2 = /*@__PURE__*/ new Vector3$1();
 const _end$2 = /*@__PURE__*/ new Vector3$1();

 class LineSegments$1 extends Line$1 {

	 constructor( geometry, material ) {

		 super( geometry, material );

		 this.type = 'LineSegments';

	 }

	 computeLineDistances() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 // we assume non-indexed geometry

			 if ( geometry.index === null ) {

				 const positionAttribute = geometry.attributes.position;
				 const lineDistances = [];

				 for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					 _start$2.fromBufferAttribute( positionAttribute, i );
					 _end$2.fromBufferAttribute( positionAttribute, i + 1 );

					 lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					 lineDistances[ i + 1 ] = lineDistances[ i ] + _start$2.distanceTo( _end$2 );

				 }

				 geometry.setAttribute( 'lineDistance', new Float32BufferAttribute$1( lineDistances, 1 ) );

			 } else {

				 console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

		 return this;

	 }

 }

 LineSegments$1.prototype.isLineSegments = true;

 class LineLoop$1 extends Line$1 {

	 constructor( geometry, material ) {

		 super( geometry, material );

		 this.type = 'LineLoop';

	 }

 }

 LineLoop$1.prototype.isLineLoop = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*  map: new THREE.Texture( <Image> ),
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  size: <float>,
	*  sizeAttenuation: <bool>
	*
	*  morphTargets: <bool>
	* }
	*/

 class PointsMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'PointsMaterial';

		 this.color = new Color$2( 0xffffff );

		 this.map = null;

		 this.alphaMap = null;

		 this.size = 1;
		 this.sizeAttenuation = true;

		 this.morphTargets = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.size = source.size;
		 this.sizeAttenuation = source.sizeAttenuation;

		 this.morphTargets = source.morphTargets;

		 return this;

	 }

 }

 PointsMaterial$1.prototype.isPointsMaterial = true;

 const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4$1();
 const _ray$3 = /*@__PURE__*/ new Ray$1();
 const _sphere$4 = /*@__PURE__*/ new Sphere$1();
 const _position$2$1 = /*@__PURE__*/ new Vector3$1();

 class Points$1 extends Object3D$1 {

	 constructor( geometry = new BufferGeometry$1(), material = new PointsMaterial$1() ) {

		 super();

		 this.type = 'Points';

		 this.geometry = geometry;
		 this.material = material;

		 this.updateMorphTargets();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.material = source.material;
		 this.geometry = source.geometry;

		 return this;

	 }

	 raycast( raycaster, intersects ) {

		 const geometry = this.geometry;
		 const matrixWorld = this.matrixWorld;
		 const threshold = raycaster.params.Points.threshold;
		 const drawRange = geometry.drawRange;

		 // Checking boundingSphere distance to ray

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere$4.copy( geometry.boundingSphere );
		 _sphere$4.applyMatrix4( matrixWorld );
		 _sphere$4.radius += threshold;

		 if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

		 //

		 _inverseMatrix$3.copy( matrixWorld ).invert();
		 _ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

		 const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		 const localThresholdSq = localThreshold * localThreshold;

		 if ( geometry.isBufferGeometry ) {

			 const index = geometry.index;
			 const attributes = geometry.attributes;
			 const positionAttribute = attributes.position;

			 if ( index !== null ) {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, il = end; i < il; i ++ ) {

					 const a = index.getX( i );

					 _position$2$1.fromBufferAttribute( positionAttribute, a );

					 testPoint$1( _position$2$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				 }

			 } else {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, l = end; i < l; i ++ ) {

					 _position$2$1.fromBufferAttribute( positionAttribute, i );

					 testPoint$1( _position$2$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				 }

			 }

		 } else {

			 console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

	 }

	 updateMorphTargets() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 const morphAttributes = geometry.morphAttributes;
			 const keys = Object.keys( morphAttributes );

			 if ( keys.length > 0 ) {

				 const morphAttribute = morphAttributes[ keys[ 0 ] ];

				 if ( morphAttribute !== undefined ) {

					 this.morphTargetInfluences = [];
					 this.morphTargetDictionary = {};

					 for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						 const name = morphAttribute[ m ].name || String( m );

						 this.morphTargetInfluences.push( 0 );
						 this.morphTargetDictionary[ name ] = m;

					 }

				 }

			 }

		 } else {

			 const morphTargets = geometry.morphTargets;

			 if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				 console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			 }

		 }

	 }

 }

 Points$1.prototype.isPoints = true;

 function testPoint$1( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	 const rayPointDistanceSq = _ray$3.distanceSqToPoint( point );

	 if ( rayPointDistanceSq < localThresholdSq ) {

		 const intersectPoint = new Vector3$1();

		 _ray$3.closestPointToPoint( point, intersectPoint );
		 intersectPoint.applyMatrix4( matrixWorld );

		 const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		 if ( distance < raycaster.near || distance > raycaster.far ) return;

		 intersects.push( {

			 distance: distance,
			 distanceToRay: Math.sqrt( rayPointDistanceSq ),
			 point: intersectPoint,
			 index: index,
			 face: null,
			 object: object

		 } );

	 }

 }

 class VideoTexture$1 extends Texture$1 {

	 constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		 super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		 this.format = format !== undefined ? format : RGBFormat$1;

		 this.minFilter = minFilter !== undefined ? minFilter : LinearFilter$1;
		 this.magFilter = magFilter !== undefined ? magFilter : LinearFilter$1;

		 this.generateMipmaps = false;

		 const scope = this;

		 function updateVideo() {

			 scope.needsUpdate = true;
			 video.requestVideoFrameCallback( updateVideo );

		 }

		 if ( 'requestVideoFrameCallback' in video ) {

			 video.requestVideoFrameCallback( updateVideo );

		 }

	 }

	 clone() {

		 return new this.constructor( this.image ).copy( this );

	 }

	 update() {

		 const video = this.image;
		 const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		 if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			 this.needsUpdate = true;

		 }

	 }

 }

 VideoTexture$1.prototype.isVideoTexture = true;

 class CompressedTexture$1 extends Texture$1 {

	 constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		 super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		 this.image = { width: width, height: height };
		 this.mipmaps = mipmaps;

		 // no flipping for cube textures
		 // (also flipping doesn't work for compressed textures )

		 this.flipY = false;

		 // can't generate mipmaps for compressed textures
		 // mips must be embedded in DDS files

		 this.generateMipmaps = false;

	 }

 }

 CompressedTexture$1.prototype.isCompressedTexture = true;

 class CanvasTexture$1 extends Texture$1 {

	 constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		 super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		 this.needsUpdate = true;

	 }

 }

 CanvasTexture$1.prototype.isCanvasTexture = true;

 class DepthTexture$1 extends Texture$1 {

	 constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		 format = format !== undefined ? format : DepthFormat$1;

		 if ( format !== DepthFormat$1 && format !== DepthStencilFormat$1 ) {

			 throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		 }

		 if ( type === undefined && format === DepthFormat$1 ) type = UnsignedShortType$1;
		 if ( type === undefined && format === DepthStencilFormat$1 ) type = UnsignedInt248Type$1;

		 super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		 this.image = { width: width, height: height };

		 this.magFilter = magFilter !== undefined ? magFilter : NearestFilter$1;
		 this.minFilter = minFilter !== undefined ? minFilter : NearestFilter$1;

		 this.flipY = false;
		 this.generateMipmaps	= false;

	 }


 }

 DepthTexture$1.prototype.isDepthTexture = true;

 new Vector3$1();
 new Vector3$1();
 new Vector3$1();
 new Triangle$1();

 /**
	* Extensible curve object.
	*
	* Some common of curve methods:
	* .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	* .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	* .getPoints(), .getSpacedPoints()
	* .getLength()
	* .updateArcLengths()
	*
	* This following curves inherit from THREE.Curve:
	*
	* -- 2D curves --
	* THREE.ArcCurve
	* THREE.CubicBezierCurve
	* THREE.EllipseCurve
	* THREE.LineCurve
	* THREE.QuadraticBezierCurve
	* THREE.SplineCurve
	*
	* -- 3D curves --
	* THREE.CatmullRomCurve3
	* THREE.CubicBezierCurve3
	* THREE.LineCurve3
	* THREE.QuadraticBezierCurve3
	*
	* A series of curves can be represented as a THREE.CurvePath.
	*
	**/

 class Curve$1 {

	 constructor() {

		 this.type = 'Curve';

		 this.arcLengthDivisions = 200;

	 }

	 // Virtual base class method to overwrite and implement in subclasses
	 //	- t [0 .. 1]

	 getPoint( /* t, optionalTarget */ ) {

		 console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		 return null;

	 }

	 // Get point at relative position in curve according to arc length
	 // - u [0 .. 1]

	 getPointAt( u, optionalTarget ) {

		 const t = this.getUtoTmapping( u );
		 return this.getPoint( t, optionalTarget );

	 }

	 // Get sequence of points using getPoint( t )

	 getPoints( divisions = 5 ) {

		 const points = [];

		 for ( let d = 0; d <= divisions; d ++ ) {

			 points.push( this.getPoint( d / divisions ) );

		 }

		 return points;

	 }

	 // Get sequence of points using getPointAt( u )

	 getSpacedPoints( divisions = 5 ) {

		 const points = [];

		 for ( let d = 0; d <= divisions; d ++ ) {

			 points.push( this.getPointAt( d / divisions ) );

		 }

		 return points;

	 }

	 // Get total curve arc length

	 getLength() {

		 const lengths = this.getLengths();
		 return lengths[ lengths.length - 1 ];

	 }

	 // Get list of cumulative segment lengths

	 getLengths( divisions = this.arcLengthDivisions ) {

		 if ( this.cacheArcLengths &&
			 ( this.cacheArcLengths.length === divisions + 1 ) &&
			 ! this.needsUpdate ) {

			 return this.cacheArcLengths;

		 }

		 this.needsUpdate = false;

		 const cache = [];
		 let current, last = this.getPoint( 0 );
		 let sum = 0;

		 cache.push( 0 );

		 for ( let p = 1; p <= divisions; p ++ ) {

			 current = this.getPoint( p / divisions );
			 sum += current.distanceTo( last );
			 cache.push( sum );
			 last = current;

		 }

		 this.cacheArcLengths = cache;

		 return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	 }

	 updateArcLengths() {

		 this.needsUpdate = true;
		 this.getLengths();

	 }

	 // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	 getUtoTmapping( u, distance ) {

		 const arcLengths = this.getLengths();

		 let i = 0;
		 const il = arcLengths.length;

		 let targetArcLength; // The targeted u distance value to get

		 if ( distance ) {

			 targetArcLength = distance;

		 } else {

			 targetArcLength = u * arcLengths[ il - 1 ];

		 }

		 // binary search for the index with largest value smaller than target u distance

		 let low = 0, high = il - 1, comparison;

		 while ( low <= high ) {

			 i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			 comparison = arcLengths[ i ] - targetArcLength;

			 if ( comparison < 0 ) {

				 low = i + 1;

			 } else if ( comparison > 0 ) {

				 high = i - 1;

			 } else {

				 high = i;
				 break;

				 // DONE

			 }

		 }

		 i = high;

		 if ( arcLengths[ i ] === targetArcLength ) {

			 return i / ( il - 1 );

		 }

		 // we could get finer grain at lengths, or use simple interpolation between two points

		 const lengthBefore = arcLengths[ i ];
		 const lengthAfter = arcLengths[ i + 1 ];

		 const segmentLength = lengthAfter - lengthBefore;

		 // determine where we are between the 'before' and 'after' points

		 const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		 // add that fractional amount to t

		 const t = ( i + segmentFraction ) / ( il - 1 );

		 return t;

	 }

	 // Returns a unit vector tangent at t
	 // In case any sub curve does not implement its tangent derivation,
	 // 2 points a small delta apart will be used to find its gradient
	 // which seems to give a reasonable approximation

	 getTangent( t, optionalTarget ) {

		 const delta = 0.0001;
		 let t1 = t - delta;
		 let t2 = t + delta;

		 // Capping in case of danger

		 if ( t1 < 0 ) t1 = 0;
		 if ( t2 > 1 ) t2 = 1;

		 const pt1 = this.getPoint( t1 );
		 const pt2 = this.getPoint( t2 );

		 const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2$1() : new Vector3$1() );

		 tangent.copy( pt2 ).sub( pt1 ).normalize();

		 return tangent;

	 }

	 getTangentAt( u, optionalTarget ) {

		 const t = this.getUtoTmapping( u );
		 return this.getTangent( t, optionalTarget );

	 }

	 computeFrenetFrames( segments, closed ) {

		 // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		 const normal = new Vector3$1();

		 const tangents = [];
		 const normals = [];
		 const binormals = [];

		 const vec = new Vector3$1();
		 const mat = new Matrix4$1();

		 // compute the tangent vectors for each segment on the curve

		 for ( let i = 0; i <= segments; i ++ ) {

			 const u = i / segments;

			 tangents[ i ] = this.getTangentAt( u, new Vector3$1() );
			 tangents[ i ].normalize();

		 }

		 // select an initial normal vector perpendicular to the first tangent vector,
		 // and in the direction of the minimum tangent xyz component

		 normals[ 0 ] = new Vector3$1();
		 binormals[ 0 ] = new Vector3$1();
		 let min = Number.MAX_VALUE;
		 const tx = Math.abs( tangents[ 0 ].x );
		 const ty = Math.abs( tangents[ 0 ].y );
		 const tz = Math.abs( tangents[ 0 ].z );

		 if ( tx <= min ) {

			 min = tx;
			 normal.set( 1, 0, 0 );

		 }

		 if ( ty <= min ) {

			 min = ty;
			 normal.set( 0, 1, 0 );

		 }

		 if ( tz <= min ) {

			 normal.set( 0, 0, 1 );

		 }

		 vec.crossVectors( tangents[ 0 ], normal ).normalize();

		 normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		 binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		 // compute the slowly-varying normal and binormal vectors for each segment on the curve

		 for ( let i = 1; i <= segments; i ++ ) {

			 normals[ i ] = normals[ i - 1 ].clone();

			 binormals[ i ] = binormals[ i - 1 ].clone();

			 vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			 if ( vec.length() > Number.EPSILON ) {

				 vec.normalize();

				 const theta = Math.acos( clamp$1( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				 normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			 }

			 binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		 }

		 // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		 if ( closed === true ) {

			 let theta = Math.acos( clamp$1( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			 theta /= segments;

			 if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				 theta = - theta;

			 }

			 for ( let i = 1; i <= segments; i ++ ) {

				 // twist a little...
				 normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				 binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			 }

		 }

		 return {
			 tangents: tangents,
			 normals: normals,
			 binormals: binormals
		 };

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.arcLengthDivisions = source.arcLengthDivisions;

		 return this;

	 }

	 toJSON() {

		 const data = {
			 metadata: {
				 version: 4.5,
				 type: 'Curve',
				 generator: 'Curve.toJSON'
			 }
		 };

		 data.arcLengthDivisions = this.arcLengthDivisions;
		 data.type = this.type;

		 return data;

	 }

	 fromJSON( json ) {

		 this.arcLengthDivisions = json.arcLengthDivisions;

		 return this;

	 }

 }

 class EllipseCurve$1 extends Curve$1 {

	 constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		 super();

		 this.type = 'EllipseCurve';

		 this.aX = aX;
		 this.aY = aY;

		 this.xRadius = xRadius;
		 this.yRadius = yRadius;

		 this.aStartAngle = aStartAngle;
		 this.aEndAngle = aEndAngle;

		 this.aClockwise = aClockwise;

		 this.aRotation = aRotation;

	 }

	 getPoint( t, optionalTarget ) {

		 const point = optionalTarget || new Vector2$1();

		 const twoPi = Math.PI * 2;
		 let deltaAngle = this.aEndAngle - this.aStartAngle;
		 const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		 // ensures that deltaAngle is 0 .. 2 PI
		 while ( deltaAngle < 0 ) deltaAngle += twoPi;
		 while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		 if ( deltaAngle < Number.EPSILON ) {

			 if ( samePoints ) {

				 deltaAngle = 0;

			 } else {

				 deltaAngle = twoPi;

			 }

		 }

		 if ( this.aClockwise === true && ! samePoints ) {

			 if ( deltaAngle === twoPi ) {

				 deltaAngle = - twoPi;

			 } else {

				 deltaAngle = deltaAngle - twoPi;

			 }

		 }

		 const angle = this.aStartAngle + t * deltaAngle;
		 let x = this.aX + this.xRadius * Math.cos( angle );
		 let y = this.aY + this.yRadius * Math.sin( angle );

		 if ( this.aRotation !== 0 ) {

			 const cos = Math.cos( this.aRotation );
			 const sin = Math.sin( this.aRotation );

			 const tx = x - this.aX;
			 const ty = y - this.aY;

			 // Rotate the point about the center of the ellipse.
			 x = tx * cos - ty * sin + this.aX;
			 y = tx * sin + ty * cos + this.aY;

		 }

		 return point.set( x, y );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.aX = source.aX;
		 this.aY = source.aY;

		 this.xRadius = source.xRadius;
		 this.yRadius = source.yRadius;

		 this.aStartAngle = source.aStartAngle;
		 this.aEndAngle = source.aEndAngle;

		 this.aClockwise = source.aClockwise;

		 this.aRotation = source.aRotation;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.aX = this.aX;
		 data.aY = this.aY;

		 data.xRadius = this.xRadius;
		 data.yRadius = this.yRadius;

		 data.aStartAngle = this.aStartAngle;
		 data.aEndAngle = this.aEndAngle;

		 data.aClockwise = this.aClockwise;

		 data.aRotation = this.aRotation;

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.aX = json.aX;
		 this.aY = json.aY;

		 this.xRadius = json.xRadius;
		 this.yRadius = json.yRadius;

		 this.aStartAngle = json.aStartAngle;
		 this.aEndAngle = json.aEndAngle;

		 this.aClockwise = json.aClockwise;

		 this.aRotation = json.aRotation;

		 return this;

	 }

 }

 EllipseCurve$1.prototype.isEllipseCurve = true;

 class ArcCurve$1 extends EllipseCurve$1 {

	 constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		 super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		 this.type = 'ArcCurve';

	 }

 }

 ArcCurve$1.prototype.isArcCurve = true;

 /**
	* Centripetal CatmullRom Curve - which is useful for avoiding
	* cusps and self-intersections in non-uniform catmull rom curves.
	* http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	*
	* curve.type accepts centripetal(default), chordal and catmullrom
	* curve.tension is used for catmullrom which defaults to 0.5
	*/


 /*
 Based on an optimized c++ solution in
	- http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	- http://ideone.com/NoEbVM

 This CubicPoly class could be used for reusing some variables and calculations,
 but for three.js curve use, it could be possible inlined and flatten into a single function call
 which can be placed in CurveUtils.
 */

 function CubicPoly$1() {

	 let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	 /*
		* Compute coefficients for a cubic polynomial
		*   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		* such that
		*   p(0) = x0, p(1) = x1
		*  and
		*   p'(0) = t0, p'(1) = t1.
		*/
	 function init( x0, x1, t0, t1 ) {

		 c0 = x0;
		 c1 = t0;
		 c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		 c3 = 2 * x0 - 2 * x1 + t0 + t1;

	 }

	 return {

		 initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			 init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		 },

		 initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			 // compute tangents when parameterized in [t1,t2]
			 let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			 let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			 // rescale tangents for parametrization in [0,1]
			 t1 *= dt1;
			 t2 *= dt1;

			 init( x1, x2, t1, t2 );

		 },

		 calc: function ( t ) {

			 const t2 = t * t;
			 const t3 = t2 * t;
			 return c0 + c1 * t + c2 * t2 + c3 * t3;

		 }

	 };

 }

 //

 const tmp$1 = new Vector3$1();
 const px$1 = new CubicPoly$1(), py$1 = new CubicPoly$1(), pz$1 = new CubicPoly$1();

 class CatmullRomCurve3$1 extends Curve$1 {

	 constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		 super();

		 this.type = 'CatmullRomCurve3';

		 this.points = points;
		 this.closed = closed;
		 this.curveType = curveType;
		 this.tension = tension;

	 }

	 getPoint( t, optionalTarget = new Vector3$1() ) {

		 const point = optionalTarget;

		 const points = this.points;
		 const l = points.length;

		 const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		 let intPoint = Math.floor( p );
		 let weight = p - intPoint;

		 if ( this.closed ) {

			 intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		 } else if ( weight === 0 && intPoint === l - 1 ) {

			 intPoint = l - 2;
			 weight = 1;

		 }

		 let p0, p3; // 4 points (p1 & p2 defined below)

		 if ( this.closed || intPoint > 0 ) {

			 p0 = points[ ( intPoint - 1 ) % l ];

		 } else {

			 // extrapolate first point
			 tmp$1.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			 p0 = tmp$1;

		 }

		 const p1 = points[ intPoint % l ];
		 const p2 = points[ ( intPoint + 1 ) % l ];

		 if ( this.closed || intPoint + 2 < l ) {

			 p3 = points[ ( intPoint + 2 ) % l ];

		 } else {

			 // extrapolate last point
			 tmp$1.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			 p3 = tmp$1;

		 }

		 if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			 // init Centripetal / Chordal Catmull-Rom
			 const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			 let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			 let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			 let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			 // safety check for repeated points
			 if ( dt1 < 1e-4 ) dt1 = 1.0;
			 if ( dt0 < 1e-4 ) dt0 = dt1;
			 if ( dt2 < 1e-4 ) dt2 = dt1;

			 px$1.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			 py$1.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			 pz$1.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		 } else if ( this.curveType === 'catmullrom' ) {

			 px$1.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			 py$1.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			 pz$1.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		 }

		 point.set(
			 px$1.calc( weight ),
			 py$1.calc( weight ),
			 pz$1.calc( weight )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.points = [];

		 for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			 const point = source.points[ i ];

			 this.points.push( point.clone() );

		 }

		 this.closed = source.closed;
		 this.curveType = source.curveType;
		 this.tension = source.tension;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.points = [];

		 for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			 const point = this.points[ i ];
			 data.points.push( point.toArray() );

		 }

		 data.closed = this.closed;
		 data.curveType = this.curveType;
		 data.tension = this.tension;

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.points = [];

		 for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			 const point = json.points[ i ];
			 this.points.push( new Vector3$1().fromArray( point ) );

		 }

		 this.closed = json.closed;
		 this.curveType = json.curveType;
		 this.tension = json.tension;

		 return this;

	 }

 }

 CatmullRomCurve3$1.prototype.isCatmullRomCurve3 = true;

 /**
	* Bezier Curves formulas obtained from
	* http://en.wikipedia.org/wiki/Bézier_curve
	*/

 function CatmullRom$1( t, p0, p1, p2, p3 ) {

	 const v0 = ( p2 - p0 ) * 0.5;
	 const v1 = ( p3 - p1 ) * 0.5;
	 const t2 = t * t;
	 const t3 = t * t2;
	 return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

 }

 //

 function QuadraticBezierP0$1( t, p ) {

	 const k = 1 - t;
	 return k * k * p;

 }

 function QuadraticBezierP1$1( t, p ) {

	 return 2 * ( 1 - t ) * t * p;

 }

 function QuadraticBezierP2$1( t, p ) {

	 return t * t * p;

 }

 function QuadraticBezier$1( t, p0, p1, p2 ) {

	 return QuadraticBezierP0$1( t, p0 ) + QuadraticBezierP1$1( t, p1 ) +
		 QuadraticBezierP2$1( t, p2 );

 }

 //

 function CubicBezierP0$1( t, p ) {

	 const k = 1 - t;
	 return k * k * k * p;

 }

 function CubicBezierP1$1( t, p ) {

	 const k = 1 - t;
	 return 3 * k * k * t * p;

 }

 function CubicBezierP2$1( t, p ) {

	 return 3 * ( 1 - t ) * t * t * p;

 }

 function CubicBezierP3$1( t, p ) {

	 return t * t * t * p;

 }

 function CubicBezier$1( t, p0, p1, p2, p3 ) {

	 return CubicBezierP0$1( t, p0 ) + CubicBezierP1$1( t, p1 ) + CubicBezierP2$1( t, p2 ) +
		 CubicBezierP3$1( t, p3 );

 }

 class CubicBezierCurve$1 extends Curve$1 {

	 constructor( v0 = new Vector2$1(), v1 = new Vector2$1(), v2 = new Vector2$1(), v3 = new Vector2$1() ) {

		 super();

		 this.type = 'CubicBezierCurve';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;
		 this.v3 = v3;

	 }

	 getPoint( t, optionalTarget = new Vector2$1() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		 point.set(
			 CubicBezier$1( t, v0.x, v1.x, v2.x, v3.x ),
			 CubicBezier$1( t, v0.y, v1.y, v2.y, v3.y )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );
		 this.v3.copy( source.v3 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();
		 data.v3 = this.v3.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );
		 this.v3.fromArray( json.v3 );

		 return this;

	 }

 }

 CubicBezierCurve$1.prototype.isCubicBezierCurve = true;

 class CubicBezierCurve3$1 extends Curve$1 {

	 constructor( v0 = new Vector3$1(), v1 = new Vector3$1(), v2 = new Vector3$1(), v3 = new Vector3$1() ) {

		 super();

		 this.type = 'CubicBezierCurve3';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;
		 this.v3 = v3;

	 }

	 getPoint( t, optionalTarget = new Vector3$1() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		 point.set(
			 CubicBezier$1( t, v0.x, v1.x, v2.x, v3.x ),
			 CubicBezier$1( t, v0.y, v1.y, v2.y, v3.y ),
			 CubicBezier$1( t, v0.z, v1.z, v2.z, v3.z )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );
		 this.v3.copy( source.v3 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();
		 data.v3 = this.v3.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );
		 this.v3.fromArray( json.v3 );

		 return this;

	 }

 }

 CubicBezierCurve3$1.prototype.isCubicBezierCurve3 = true;

 class LineCurve$1 extends Curve$1 {

	 constructor( v1 = new Vector2$1(), v2 = new Vector2$1() ) {

		 super();

		 this.type = 'LineCurve';

		 this.v1 = v1;
		 this.v2 = v2;

	 }

	 getPoint( t, optionalTarget = new Vector2$1() ) {

		 const point = optionalTarget;

		 if ( t === 1 ) {

			 point.copy( this.v2 );

		 } else {

			 point.copy( this.v2 ).sub( this.v1 );
			 point.multiplyScalar( t ).add( this.v1 );

		 }

		 return point;

	 }

	 // Line curve is linear, so we can overwrite default getPointAt
	 getPointAt( u, optionalTarget ) {

		 return this.getPoint( u, optionalTarget );

	 }

	 getTangent( t, optionalTarget ) {

		 const tangent = optionalTarget || new Vector2$1();

		 tangent.copy( this.v2 ).sub( this.v1 ).normalize();

		 return tangent;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 LineCurve$1.prototype.isLineCurve = true;

 class LineCurve3$1 extends Curve$1 {

	 constructor( v1 = new Vector3$1(), v2 = new Vector3$1() ) {

		 super();

		 this.type = 'LineCurve3';
		 this.isLineCurve3 = true;

		 this.v1 = v1;
		 this.v2 = v2;

	 }
	 getPoint( t, optionalTarget = new Vector3$1() ) {

		 const point = optionalTarget;

		 if ( t === 1 ) {

			 point.copy( this.v2 );

		 } else {

			 point.copy( this.v2 ).sub( this.v1 );
			 point.multiplyScalar( t ).add( this.v1 );

		 }

		 return point;

	 }
	 // Line curve is linear, so we can overwrite default getPointAt
	 getPointAt( u, optionalTarget ) {

		 return this.getPoint( u, optionalTarget );

	 }
	 copy( source ) {

		 super.copy( source );

		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }
	 toJSON() {

		 const data = super.toJSON();

		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }
	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 class QuadraticBezierCurve$1 extends Curve$1 {

	 constructor( v0 = new Vector2$1(), v1 = new Vector2$1(), v2 = new Vector2$1() ) {

		 super();

		 this.type = 'QuadraticBezierCurve';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;

	 }

	 getPoint( t, optionalTarget = new Vector2$1() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		 point.set(
			 QuadraticBezier$1( t, v0.x, v1.x, v2.x ),
			 QuadraticBezier$1( t, v0.y, v1.y, v2.y )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 QuadraticBezierCurve$1.prototype.isQuadraticBezierCurve = true;

 class QuadraticBezierCurve3$1 extends Curve$1 {

	 constructor( v0 = new Vector3$1(), v1 = new Vector3$1(), v2 = new Vector3$1() ) {

		 super();

		 this.type = 'QuadraticBezierCurve3';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;

	 }

	 getPoint( t, optionalTarget = new Vector3$1() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		 point.set(
			 QuadraticBezier$1( t, v0.x, v1.x, v2.x ),
			 QuadraticBezier$1( t, v0.y, v1.y, v2.y ),
			 QuadraticBezier$1( t, v0.z, v1.z, v2.z )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 QuadraticBezierCurve3$1.prototype.isQuadraticBezierCurve3 = true;

 class SplineCurve$1 extends Curve$1 {

	 constructor( points = [] ) {

		 super();

		 this.type = 'SplineCurve';

		 this.points = points;

	 }

	 getPoint( t, optionalTarget = new Vector2$1() ) {

		 const point = optionalTarget;

		 const points = this.points;
		 const p = ( points.length - 1 ) * t;

		 const intPoint = Math.floor( p );
		 const weight = p - intPoint;

		 const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		 const p1 = points[ intPoint ];
		 const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		 const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		 point.set(
			 CatmullRom$1( weight, p0.x, p1.x, p2.x, p3.x ),
			 CatmullRom$1( weight, p0.y, p1.y, p2.y, p3.y )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.points = [];

		 for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			 const point = source.points[ i ];

			 this.points.push( point.clone() );

		 }

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.points = [];

		 for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			 const point = this.points[ i ];
			 data.points.push( point.toArray() );

		 }

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.points = [];

		 for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			 const point = json.points[ i ];
			 this.points.push( new Vector2$1().fromArray( point ) );

		 }

		 return this;

	 }

 }

 SplineCurve$1.prototype.isSplineCurve = true;

 var Curves$1 = /*#__PURE__*/Object.freeze({
	 __proto__: null,
	 ArcCurve: ArcCurve$1,
	 CatmullRomCurve3: CatmullRomCurve3$1,
	 CubicBezierCurve: CubicBezierCurve$1,
	 CubicBezierCurve3: CubicBezierCurve3$1,
	 EllipseCurve: EllipseCurve$1,
	 LineCurve: LineCurve$1,
	 LineCurve3: LineCurve3$1,
	 QuadraticBezierCurve: QuadraticBezierCurve$1,
	 QuadraticBezierCurve3: QuadraticBezierCurve3$1,
	 SplineCurve: SplineCurve$1
 });

 /**
	* Port from https://github.com/mapbox/earcut (v2.2.2)
	*/

 const Earcut$1 = {

	 triangulate: function ( data, holeIndices, dim = 2 ) {

		 const hasHoles = holeIndices && holeIndices.length;
		 const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		 let outerNode = linkedList$1( data, 0, outerLen, dim, true );
		 const triangles = [];

		 if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		 let minX, minY, maxX, maxY, x, y, invSize;

		 if ( hasHoles ) outerNode = eliminateHoles$1( data, holeIndices, outerNode, dim );

		 // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		 if ( data.length > 80 * dim ) {

			 minX = maxX = data[ 0 ];
			 minY = maxY = data[ 1 ];

			 for ( let i = dim; i < outerLen; i += dim ) {

				 x = data[ i ];
				 y = data[ i + 1 ];
				 if ( x < minX ) minX = x;
				 if ( y < minY ) minY = y;
				 if ( x > maxX ) maxX = x;
				 if ( y > maxY ) maxY = y;

			 }

			 // minX, minY and invSize are later used to transform coords into integers for z-order calculation
			 invSize = Math.max( maxX - minX, maxY - minY );
			 invSize = invSize !== 0 ? 1 / invSize : 0;

		 }

		 earcutLinked$1( outerNode, triangles, dim, minX, minY, invSize );

		 return triangles;

	 }

 };

 // create a circular doubly linked list from polygon points in the specified winding order
 function linkedList$1( data, start, end, dim, clockwise ) {

	 let i, last;

	 if ( clockwise === ( signedArea$1( data, start, end, dim ) > 0 ) ) {

		 for ( i = start; i < end; i += dim ) last = insertNode$1( i, data[ i ], data[ i + 1 ], last );

	 } else {

		 for ( i = end - dim; i >= start; i -= dim ) last = insertNode$1( i, data[ i ], data[ i + 1 ], last );

	 }

	 if ( last && equals$1( last, last.next ) ) {

		 removeNode$1( last );
		 last = last.next;

	 }

	 return last;

 }

 // eliminate colinear or duplicate points
 function filterPoints$1( start, end ) {

	 if ( ! start ) return start;
	 if ( ! end ) end = start;

	 let p = start,
		 again;
	 do {

		 again = false;

		 if ( ! p.steiner && ( equals$1( p, p.next ) || area$1( p.prev, p, p.next ) === 0 ) ) {

			 removeNode$1( p );
			 p = end = p.prev;
			 if ( p === p.next ) break;
			 again = true;

		 } else {

			 p = p.next;

		 }

	 } while ( again || p !== end );

	 return end;

 }

 // main ear slicing loop which triangulates a polygon (given as a linked list)
 function earcutLinked$1( ear, triangles, dim, minX, minY, invSize, pass ) {

	 if ( ! ear ) return;

	 // interlink polygon nodes in z-order
	 if ( ! pass && invSize ) indexCurve$1( ear, minX, minY, invSize );

	 let stop = ear,
		 prev, next;

	 // iterate through ears, slicing them one by one
	 while ( ear.prev !== ear.next ) {

		 prev = ear.prev;
		 next = ear.next;

		 if ( invSize ? isEarHashed$1( ear, minX, minY, invSize ) : isEar$1( ear ) ) {

			 // cut off the triangle
			 triangles.push( prev.i / dim );
			 triangles.push( ear.i / dim );
			 triangles.push( next.i / dim );

			 removeNode$1( ear );

			 // skipping the next vertex leads to less sliver triangles
			 ear = next.next;
			 stop = next.next;

			 continue;

		 }

		 ear = next;

		 // if we looped through the whole remaining polygon and can't find any more ears
		 if ( ear === stop ) {

			 // try filtering points and slicing again
			 if ( ! pass ) {

				 earcutLinked$1( filterPoints$1( ear ), triangles, dim, minX, minY, invSize, 1 );

				 // if this didn't work, try curing all small self-intersections locally

			 } else if ( pass === 1 ) {

				 ear = cureLocalIntersections$1( filterPoints$1( ear ), triangles, dim );
				 earcutLinked$1( ear, triangles, dim, minX, minY, invSize, 2 );

				 // as a last resort, try splitting the remaining polygon into two

			 } else if ( pass === 2 ) {

				 splitEarcut$1( ear, triangles, dim, minX, minY, invSize );

			 }

			 break;

		 }

	 }

 }

 // check whether a polygon node forms a valid ear with adjacent nodes
 function isEar$1( ear ) {

	 const a = ear.prev,
		 b = ear,
		 c = ear.next;

	 if ( area$1( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	 // now make sure we don't have other points inside the potential ear
	 let p = ear.next.next;

	 while ( p !== ear.prev ) {

		 if ( pointInTriangle$1( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			 area$1( p.prev, p, p.next ) >= 0 ) return false;
		 p = p.next;

	 }

	 return true;

 }

 function isEarHashed$1( ear, minX, minY, invSize ) {

	 const a = ear.prev,
		 b = ear,
		 c = ear.next;

	 if ( area$1( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	 // triangle bbox; min & max are calculated like this for speed
	 const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		 minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		 maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		 maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	 // z-order range for the current triangle bbox;
	 const minZ = zOrder$1( minTX, minTY, minX, minY, invSize ),
		 maxZ = zOrder$1( maxTX, maxTY, minX, minY, invSize );

	 let p = ear.prevZ,
		 n = ear.nextZ;

	 // look for points inside the triangle in both directions
	 while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		 if ( p !== ear.prev && p !== ear.next &&
			 pointInTriangle$1( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			 area$1( p.prev, p, p.next ) >= 0 ) return false;
		 p = p.prevZ;

		 if ( n !== ear.prev && n !== ear.next &&
			 pointInTriangle$1( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			 area$1( n.prev, n, n.next ) >= 0 ) return false;
		 n = n.nextZ;

	 }

	 // look for remaining points in decreasing z-order
	 while ( p && p.z >= minZ ) {

		 if ( p !== ear.prev && p !== ear.next &&
			 pointInTriangle$1( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			 area$1( p.prev, p, p.next ) >= 0 ) return false;
		 p = p.prevZ;

	 }

	 // look for remaining points in increasing z-order
	 while ( n && n.z <= maxZ ) {

		 if ( n !== ear.prev && n !== ear.next &&
			 pointInTriangle$1( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			 area$1( n.prev, n, n.next ) >= 0 ) return false;
		 n = n.nextZ;

	 }

	 return true;

 }

 // go through all polygon nodes and cure small local self-intersections
 function cureLocalIntersections$1( start, triangles, dim ) {

	 let p = start;
	 do {

		 const a = p.prev,
			 b = p.next.next;

		 if ( ! equals$1( a, b ) && intersects$1( a, p, p.next, b ) && locallyInside$1( a, b ) && locallyInside$1( b, a ) ) {

			 triangles.push( a.i / dim );
			 triangles.push( p.i / dim );
			 triangles.push( b.i / dim );

			 // remove two nodes involved
			 removeNode$1( p );
			 removeNode$1( p.next );

			 p = start = b;

		 }

		 p = p.next;

	 } while ( p !== start );

	 return filterPoints$1( p );

 }

 // try splitting polygon into two and triangulate them independently
 function splitEarcut$1( start, triangles, dim, minX, minY, invSize ) {

	 // look for a valid diagonal that divides the polygon into two
	 let a = start;
	 do {

		 let b = a.next.next;
		 while ( b !== a.prev ) {

			 if ( a.i !== b.i && isValidDiagonal$1( a, b ) ) {

				 // split the polygon in two by the diagonal
				 let c = splitPolygon$1( a, b );

				 // filter colinear points around the cuts
				 a = filterPoints$1( a, a.next );
				 c = filterPoints$1( c, c.next );

				 // run earcut on each half
				 earcutLinked$1( a, triangles, dim, minX, minY, invSize );
				 earcutLinked$1( c, triangles, dim, minX, minY, invSize );
				 return;

			 }

			 b = b.next;

		 }

		 a = a.next;

	 } while ( a !== start );

 }

 // link every hole into the outer loop, producing a single-ring polygon without holes
 function eliminateHoles$1( data, holeIndices, outerNode, dim ) {

	 const queue = [];
	 let i, len, start, end, list;

	 for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		 start = holeIndices[ i ] * dim;
		 end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		 list = linkedList$1( data, start, end, dim, false );
		 if ( list === list.next ) list.steiner = true;
		 queue.push( getLeftmost$1( list ) );

	 }

	 queue.sort( compareX$1 );

	 // process holes from left to right
	 for ( i = 0; i < queue.length; i ++ ) {

		 eliminateHole$1( queue[ i ], outerNode );
		 outerNode = filterPoints$1( outerNode, outerNode.next );

	 }

	 return outerNode;

 }

 function compareX$1( a, b ) {

	 return a.x - b.x;

 }

 // find a bridge between vertices that connects hole with an outer ring and and link it
 function eliminateHole$1( hole, outerNode ) {

	 outerNode = findHoleBridge$1( hole, outerNode );
	 if ( outerNode ) {

		 const b = splitPolygon$1( outerNode, hole );

		 // filter collinear points around the cuts
		 filterPoints$1( outerNode, outerNode.next );
		 filterPoints$1( b, b.next );

	 }

 }

 // David Eberly's algorithm for finding a bridge between hole and outer polygon
 function findHoleBridge$1( hole, outerNode ) {

	 let p = outerNode;
	 const hx = hole.x;
	 const hy = hole.y;
	 let qx = - Infinity, m;

	 // find a segment intersected by a ray from the hole's leftmost point to the left;
	 // segment's endpoint with lesser x will be potential connection point
	 do {

		 if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			 const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			 if ( x <= hx && x > qx ) {

				 qx = x;
				 if ( x === hx ) {

					 if ( hy === p.y ) return p;
					 if ( hy === p.next.y ) return p.next;

				 }

				 m = p.x < p.next.x ? p : p.next;

			 }

		 }

		 p = p.next;

	 } while ( p !== outerNode );

	 if ( ! m ) return null;

	 if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	 // look for points inside the triangle of hole point, segment intersection and endpoint;
	 // if there are no points found, we have a valid connection;
	 // otherwise choose the point of the minimum angle with the ray as connection point

	 const stop = m,
		 mx = m.x,
		 my = m.y;
	 let tanMin = Infinity, tan;

	 p = m;

	 do {

		 if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				 pointInTriangle$1( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			 tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			 if ( locallyInside$1( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector$1( m, p ) ) ) ) ) ) {

				 m = p;
				 tanMin = tan;

			 }

		 }

		 p = p.next;

	 } while ( p !== stop );

	 return m;

 }

 // whether sector in vertex m contains sector in vertex p in the same coordinates
 function sectorContainsSector$1( m, p ) {

	 return area$1( m.prev, m, p.prev ) < 0 && area$1( p.next, m, m.next ) < 0;

 }

 // interlink polygon nodes in z-order
 function indexCurve$1( start, minX, minY, invSize ) {

	 let p = start;
	 do {

		 if ( p.z === null ) p.z = zOrder$1( p.x, p.y, minX, minY, invSize );
		 p.prevZ = p.prev;
		 p.nextZ = p.next;
		 p = p.next;

	 } while ( p !== start );

	 p.prevZ.nextZ = null;
	 p.prevZ = null;

	 sortLinked$1( p );

 }

 // Simon Tatham's linked list merge sort algorithm
 // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
 function sortLinked$1( list ) {

	 let i, p, q, e, tail, numMerges, pSize, qSize,
		 inSize = 1;

	 do {

		 p = list;
		 list = null;
		 tail = null;
		 numMerges = 0;

		 while ( p ) {

			 numMerges ++;
			 q = p;
			 pSize = 0;
			 for ( i = 0; i < inSize; i ++ ) {

				 pSize ++;
				 q = q.nextZ;
				 if ( ! q ) break;

			 }

			 qSize = inSize;

			 while ( pSize > 0 || ( qSize > 0 && q ) ) {

				 if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					 e = p;
					 p = p.nextZ;
					 pSize --;

				 } else {

					 e = q;
					 q = q.nextZ;
					 qSize --;

				 }

				 if ( tail ) tail.nextZ = e;
				 else list = e;

				 e.prevZ = tail;
				 tail = e;

			 }

			 p = q;

		 }

		 tail.nextZ = null;
		 inSize *= 2;

	 } while ( numMerges > 1 );

	 return list;

 }

 // z-order of a point given coords and inverse of the longer side of data bbox
 function zOrder$1( x, y, minX, minY, invSize ) {

	 // coords are transformed into non-negative 15-bit integer range
	 x = 32767 * ( x - minX ) * invSize;
	 y = 32767 * ( y - minY ) * invSize;

	 x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	 x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	 x = ( x | ( x << 2 ) ) & 0x33333333;
	 x = ( x | ( x << 1 ) ) & 0x55555555;

	 y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	 y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	 y = ( y | ( y << 2 ) ) & 0x33333333;
	 y = ( y | ( y << 1 ) ) & 0x55555555;

	 return x | ( y << 1 );

 }

 // find the leftmost node of a polygon ring
 function getLeftmost$1( start ) {

	 let p = start,
		 leftmost = start;
	 do {

		 if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		 p = p.next;

	 } while ( p !== start );

	 return leftmost;

 }

 // check if a point lies within a convex triangle
 function pointInTriangle$1( ax, ay, bx, by, cx, cy, px, py ) {

	 return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

 }

 // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
 function isValidDiagonal$1( a, b ) {

	 return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon$1( a, b ) && // dones't intersect other edges
		 ( locallyInside$1( a, b ) && locallyInside$1( b, a ) && middleInside$1( a, b ) && // locally visible
		 ( area$1( a.prev, a, b.prev ) || area$1( a, b.prev, b ) ) || // does not create opposite-facing sectors
		 equals$1( a, b ) && area$1( a.prev, a, a.next ) > 0 && area$1( b.prev, b, b.next ) > 0 ); // special zero-length case

 }

 // signed area of a triangle
 function area$1( p, q, r ) {

	 return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

 }

 // check if two points are equal
 function equals$1( p1, p2 ) {

	 return p1.x === p2.x && p1.y === p2.y;

 }

 // check if two segments intersect
 function intersects$1( p1, q1, p2, q2 ) {

	 const o1 = sign$1( area$1( p1, q1, p2 ) );
	 const o2 = sign$1( area$1( p1, q1, q2 ) );
	 const o3 = sign$1( area$1( p2, q2, p1 ) );
	 const o4 = sign$1( area$1( p2, q2, q1 ) );

	 if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	 if ( o1 === 0 && onSegment$1( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	 if ( o2 === 0 && onSegment$1( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	 if ( o3 === 0 && onSegment$1( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	 if ( o4 === 0 && onSegment$1( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	 return false;

 }

 // for collinear points p, q, r, check if point q lies on segment pr
 function onSegment$1( p, q, r ) {

	 return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

 }

 function sign$1( num ) {

	 return num > 0 ? 1 : num < 0 ? - 1 : 0;

 }

 // check if a polygon diagonal intersects any polygon segments
 function intersectsPolygon$1( a, b ) {

	 let p = a;
	 do {

		 if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				 intersects$1( p, p.next, a, b ) ) return true;
		 p = p.next;

	 } while ( p !== a );

	 return false;

 }

 // check if a polygon diagonal is locally inside the polygon
 function locallyInside$1( a, b ) {

	 return area$1( a.prev, a, a.next ) < 0 ?
		 area$1( a, b, a.next ) >= 0 && area$1( a, a.prev, b ) >= 0 :
		 area$1( a, b, a.prev ) < 0 || area$1( a, a.next, b ) < 0;

 }

 // check if the middle point of a polygon diagonal is inside the polygon
 function middleInside$1( a, b ) {

	 let p = a,
		 inside = false;
	 const px = ( a.x + b.x ) / 2,
		 py = ( a.y + b.y ) / 2;
	 do {

		 if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				 ( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			 inside = ! inside;
		 p = p.next;

	 } while ( p !== a );

	 return inside;

 }

 // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
 // if one belongs to the outer ring and another to a hole, it merges it into a single ring
 function splitPolygon$1( a, b ) {

	 const a2 = new Node$1( a.i, a.x, a.y ),
		 b2 = new Node$1( b.i, b.x, b.y ),
		 an = a.next,
		 bp = b.prev;

	 a.next = b;
	 b.prev = a;

	 a2.next = an;
	 an.prev = a2;

	 b2.next = a2;
	 a2.prev = b2;

	 bp.next = b2;
	 b2.prev = bp;

	 return b2;

 }

 // create a node and optionally link it with previous one (in a circular doubly linked list)
 function insertNode$1( i, x, y, last ) {

	 const p = new Node$1( i, x, y );

	 if ( ! last ) {

		 p.prev = p;
		 p.next = p;

	 } else {

		 p.next = last.next;
		 p.prev = last;
		 last.next.prev = p;
		 last.next = p;

	 }

	 return p;

 }

 function removeNode$1( p ) {

	 p.next.prev = p.prev;
	 p.prev.next = p.next;

	 if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	 if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

 }

 function Node$1( i, x, y ) {

	 // vertex index in coordinates array
	 this.i = i;

	 // vertex coordinates
	 this.x = x;
	 this.y = y;

	 // previous and next vertex nodes in a polygon ring
	 this.prev = null;
	 this.next = null;

	 // z-order curve value
	 this.z = null;

	 // previous and next nodes in z-order
	 this.prevZ = null;
	 this.nextZ = null;

	 // indicates whether this is a steiner point
	 this.steiner = false;

 }

 function signedArea$1( data, start, end, dim ) {

	 let sum = 0;
	 for ( let i = start, j = end - dim; i < end; i += dim ) {

		 sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		 j = i;

	 }

	 return sum;

 }

 class ShapeUtils$1 {

	 // calculate area of the contour polygon

	 static area( contour ) {

		 const n = contour.length;
		 let a = 0.0;

		 for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			 a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		 }

		 return a * 0.5;

	 }

	 static isClockWise( pts ) {

		 return ShapeUtils$1.area( pts ) < 0;

	 }

	 static triangulateShape( contour, holes ) {

		 const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		 const holeIndices = []; // array of hole indices
		 const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		 removeDupEndPts$1( contour );
		 addContour$1( vertices, contour );

		 //

		 let holeIndex = contour.length;

		 holes.forEach( removeDupEndPts$1 );

		 for ( let i = 0; i < holes.length; i ++ ) {

			 holeIndices.push( holeIndex );
			 holeIndex += holes[ i ].length;
			 addContour$1( vertices, holes[ i ] );

		 }

		 //

		 const triangles = Earcut$1.triangulate( vertices, holeIndices );

		 //

		 for ( let i = 0; i < triangles.length; i += 3 ) {

			 faces.push( triangles.slice( i, i + 3 ) );

		 }

		 return faces;

	 }

 }

 function removeDupEndPts$1( points ) {

	 const l = points.length;

	 if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		 points.pop();

	 }

 }

 function addContour$1( vertices, contour ) {

	 for ( let i = 0; i < contour.length; i ++ ) {

		 vertices.push( contour[ i ].x );
		 vertices.push( contour[ i ].y );

	 }

 }

 /**
	* Creates extruded geometry from a path shape.
	*
	* parameters = {
	*
	*  curveSegments: <int>, // number of points on the curves
	*  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	*  depth: <float>, // Depth to extrude the shape
	*
	*  bevelEnabled: <bool>, // turn on bevel
	*  bevelThickness: <float>, // how deep into the original shape bevel goes
	*  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	*  bevelOffset: <float>, // how far from shape outline does bevel start
	*  bevelSegments: <int>, // number of bevel layers
	*
	*  extrudePath: <THREE.Curve> // curve to extrude shape along
	*
	*  UVGenerator: <Object> // object that provides UV generator functions
	*
	* }
	*/

 class ExtrudeGeometry$1 extends BufferGeometry$1 {

	 constructor( shapes, options ) {

		 super();

		 this.type = 'ExtrudeGeometry';

		 this.parameters = {
			 shapes: shapes,
			 options: options
		 };

		 shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		 const scope = this;

		 const verticesArray = [];
		 const uvArray = [];

		 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			 const shape = shapes[ i ];
			 addShape( shape );

		 }

		 // build geometry

		 this.setAttribute( 'position', new Float32BufferAttribute$1( verticesArray, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute$1( uvArray, 2 ) );

		 this.computeVertexNormals();

		 // functions

		 function addShape( shape ) {

			 const placeholder = [];

			 // options

			 const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			 const steps = options.steps !== undefined ? options.steps : 1;
			 let depth = options.depth !== undefined ? options.depth : 100;

			 let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			 let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			 let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			 let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			 let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			 const extrudePath = options.extrudePath;

			 const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator$1;

			 // deprecated options

			 if ( options.amount !== undefined ) {

				 console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				 depth = options.amount;

			 }

			 //

			 let extrudePts, extrudeByPath = false;
			 let splineTube, binormal, normal, position2;

			 if ( extrudePath ) {

				 extrudePts = extrudePath.getSpacedPoints( steps );

				 extrudeByPath = true;
				 bevelEnabled = false; // bevels not supported for path extrusion

				 // SETUP TNB variables

				 // TODO1 - have a .isClosed in spline?

				 splineTube = extrudePath.computeFrenetFrames( steps, false );

				 // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				 binormal = new Vector3$1();
				 normal = new Vector3$1();
				 position2 = new Vector3$1();

			 }

			 // Safeguards if bevels are not enabled

			 if ( ! bevelEnabled ) {

				 bevelSegments = 0;
				 bevelThickness = 0;
				 bevelSize = 0;
				 bevelOffset = 0;

			 }

			 // Variables initialization

			 const shapePoints = shape.extractPoints( curveSegments );

			 let vertices = shapePoints.shape;
			 const holes = shapePoints.holes;

			 const reverse = ! ShapeUtils$1.isClockWise( vertices );

			 if ( reverse ) {

				 vertices = vertices.reverse();

				 // Maybe we should also check if holes are in the opposite direction, just to be safe ...

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];

					 if ( ShapeUtils$1.isClockWise( ahole ) ) {

						 holes[ h ] = ahole.reverse();

					 }

				 }

			 }


			 const faces = ShapeUtils$1.triangulateShape( vertices, holes );

			 /* Vertices */

			 const contour = vertices; // vertices has all points but contour has only points of circumference

			 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				 const ahole = holes[ h ];

				 vertices = vertices.concat( ahole );

			 }


			 function scalePt2( pt, vec, size ) {

				 if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				 return vec.clone().multiplyScalar( size ).add( pt );

			 }

			 const vlen = vertices.length, flen = faces.length;


			 // Find directions for point movement


			 function getBevelVec( inPt, inPrev, inNext ) {

				 // computes for inPt the corresponding point inPt' on a new contour
				 //   shifted by 1 unit (length of normalized vector) to the left
				 // if we walk along contour clockwise, this new contour is outside the old one
				 //
				 // inPt' is the intersection of the two lines parallel to the two
				 //  adjacent edges of inPt at a distance of 1 unit on the left side.

				 let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				 // good reading for geometry algorithms (here: line-line intersection)
				 // http://geomalgorithms.com/a05-_intersect-1.html

				 const v_prev_x = inPt.x - inPrev.x,
					 v_prev_y = inPt.y - inPrev.y;
				 const v_next_x = inNext.x - inPt.x,
					 v_next_y = inNext.y - inPt.y;

				 const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				 // check for collinear edges
				 const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				 if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					 // not collinear

					 // length of vectors for normalizing

					 const v_prev_len = Math.sqrt( v_prev_lensq );
					 const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					 // shift adjacent points by unit vectors to the left

					 const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					 const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					 const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					 const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					 // scaling factor for v_prev to intersection point

					 const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							 ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						 ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					 // vector from inPt to intersection point

					 v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					 v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					 // Don't normalize!, otherwise sharp corners become ugly
					 //  but prevent crazy spikes
					 const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					 if ( v_trans_lensq <= 2 ) {

						 return new Vector2$1( v_trans_x, v_trans_y );

					 } else {

						 shrink_by = Math.sqrt( v_trans_lensq / 2 );

					 }

				 } else {

					 // handle special case of collinear edges

					 let direction_eq = false; // assumes: opposite

					 if ( v_prev_x > Number.EPSILON ) {

						 if ( v_next_x > Number.EPSILON ) {

							 direction_eq = true;

						 }

					 } else {

						 if ( v_prev_x < - Number.EPSILON ) {

							 if ( v_next_x < - Number.EPSILON ) {

								 direction_eq = true;

							 }

						 } else {

							 if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								 direction_eq = true;

							 }

						 }

					 }

					 if ( direction_eq ) {

						 // console.log("Warning: lines are a straight sequence");
						 v_trans_x = - v_prev_y;
						 v_trans_y = v_prev_x;
						 shrink_by = Math.sqrt( v_prev_lensq );

					 } else {

						 // console.log("Warning: lines are a straight spike");
						 v_trans_x = v_prev_x;
						 v_trans_y = v_prev_y;
						 shrink_by = Math.sqrt( v_prev_lensq / 2 );

					 }

				 }

				 return new Vector2$1( v_trans_x / shrink_by, v_trans_y / shrink_by );

			 }


			 const contourMovements = [];

			 for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				 if ( j === il ) j = 0;
				 if ( k === il ) k = 0;

				 //  (j)---(i)---(k)
				 // console.log('i,j,k', i, j , k)

				 contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			 }

			 const holesMovements = [];
			 let oneHoleMovements, verticesMovements = contourMovements.concat();

			 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				 const ahole = holes[ h ];

				 oneHoleMovements = [];

				 for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					 if ( j === il ) j = 0;
					 if ( k === il ) k = 0;

					 //  (j)---(i)---(k)
					 oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				 }

				 holesMovements.push( oneHoleMovements );
				 verticesMovements = verticesMovements.concat( oneHoleMovements );

			 }


			 // Loop bevelSegments, 1 for the front, 1 for the back

			 for ( let b = 0; b < bevelSegments; b ++ ) {

				 //for ( b = bevelSegments; b > 0; b -- ) {

				 const t = b / bevelSegments;
				 const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				 const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				 // contract shape

				 for ( let i = 0, il = contour.length; i < il; i ++ ) {

					 const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					 v( vert.x, vert.y, - z );

				 }

				 // expand holes

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];
					 oneHoleMovements = holesMovements[ h ];

					 for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						 const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						 v( vert.x, vert.y, - z );

					 }

				 }

			 }

			 const bs = bevelSize + bevelOffset;

			 // Back facing vertices

			 for ( let i = 0; i < vlen; i ++ ) {

				 const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				 if ( ! extrudeByPath ) {

					 v( vert.x, vert.y, 0 );

				 } else {

					 // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					 normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					 binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					 position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					 v( position2.x, position2.y, position2.z );

				 }

			 }

			 // Add stepped vertices...
			 // Including front facing vertices

			 for ( let s = 1; s <= steps; s ++ ) {

				 for ( let i = 0; i < vlen; i ++ ) {

					 const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					 if ( ! extrudeByPath ) {

						 v( vert.x, vert.y, depth / steps * s );

					 } else {

						 // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						 normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						 binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						 position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						 v( position2.x, position2.y, position2.z );

					 }

				 }

			 }


			 // Add bevel segments planes

			 //for ( b = 1; b <= bevelSegments; b ++ ) {
			 for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				 const t = b / bevelSegments;
				 const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				 const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				 // contract shape

				 for ( let i = 0, il = contour.length; i < il; i ++ ) {

					 const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					 v( vert.x, vert.y, depth + z );

				 }

				 // expand holes

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];
					 oneHoleMovements = holesMovements[ h ];

					 for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						 const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						 if ( ! extrudeByPath ) {

							 v( vert.x, vert.y, depth + z );

						 } else {

							 v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						 }

					 }

				 }

			 }

			 /* Faces */

			 // Top and bottom faces

			 buildLidFaces();

			 // Sides faces

			 buildSideFaces();


			 /////  Internal functions

			 function buildLidFaces() {

				 const start = verticesArray.length / 3;

				 if ( bevelEnabled ) {

					 let layer = 0; // steps + 1
					 let offset = vlen * layer;

					 // Bottom faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					 }

					 layer = steps + bevelSegments * 2;
					 offset = vlen * layer;

					 // Top faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					 }

				 } else {

					 // Bottom faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					 }

					 // Top faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					 }

				 }

				 scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			 }

			 // Create faces for the z-sides of the shape

			 function buildSideFaces() {

				 const start = verticesArray.length / 3;
				 let layeroffset = 0;
				 sidewalls( contour, layeroffset );
				 layeroffset += contour.length;

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];
					 sidewalls( ahole, layeroffset );

					 //, true
					 layeroffset += ahole.length;

				 }


				 scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			 }

			 function sidewalls( contour, layeroffset ) {

				 let i = contour.length;

				 while ( -- i >= 0 ) {

					 const j = i;
					 let k = i - 1;
					 if ( k < 0 ) k = contour.length - 1;

					 //console.log('b', i,j, i-1, k,vertices.length);

					 for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						 const slen1 = vlen * s;
						 const slen2 = vlen * ( s + 1 );

						 const a = layeroffset + j + slen1,
							 b = layeroffset + k + slen1,
							 c = layeroffset + k + slen2,
							 d = layeroffset + j + slen2;

						 f4( a, b, c, d );

					 }

				 }

			 }

			 function v( x, y, z ) {

				 placeholder.push( x );
				 placeholder.push( y );
				 placeholder.push( z );

			 }


			 function f3( a, b, c ) {

				 addVertex( a );
				 addVertex( b );
				 addVertex( c );

				 const nextIndex = verticesArray.length / 3;
				 const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				 addUV( uvs[ 0 ] );
				 addUV( uvs[ 1 ] );
				 addUV( uvs[ 2 ] );

			 }

			 function f4( a, b, c, d ) {

				 addVertex( a );
				 addVertex( b );
				 addVertex( d );

				 addVertex( b );
				 addVertex( c );
				 addVertex( d );


				 const nextIndex = verticesArray.length / 3;
				 const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				 addUV( uvs[ 0 ] );
				 addUV( uvs[ 1 ] );
				 addUV( uvs[ 3 ] );

				 addUV( uvs[ 1 ] );
				 addUV( uvs[ 2 ] );
				 addUV( uvs[ 3 ] );

			 }

			 function addVertex( index ) {

				 verticesArray.push( placeholder[ index * 3 + 0 ] );
				 verticesArray.push( placeholder[ index * 3 + 1 ] );
				 verticesArray.push( placeholder[ index * 3 + 2 ] );

			 }


			 function addUV( vector2 ) {

				 uvArray.push( vector2.x );
				 uvArray.push( vector2.y );

			 }

		 }

	 }

	 toJSON() {

		 const data = super.toJSON();

		 const shapes = this.parameters.shapes;
		 const options = this.parameters.options;

		 return toJSON$1$1( shapes, options, data );

	 }

	 static fromJSON( data, shapes ) {

		 const geometryShapes = [];

		 for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			 const shape = shapes[ data.shapes[ j ] ];

			 geometryShapes.push( shape );

		 }

		 const extrudePath = data.options.extrudePath;

		 if ( extrudePath !== undefined ) {

			 data.options.extrudePath = new Curves$1[ extrudePath.type ]().fromJSON( extrudePath );

		 }

		 return new ExtrudeGeometry$1( geometryShapes, data.options );

	 }

 }

 const WorldUVGenerator$1 = {

	 generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		 const a_x = vertices[ indexA * 3 ];
		 const a_y = vertices[ indexA * 3 + 1 ];
		 const b_x = vertices[ indexB * 3 ];
		 const b_y = vertices[ indexB * 3 + 1 ];
		 const c_x = vertices[ indexC * 3 ];
		 const c_y = vertices[ indexC * 3 + 1 ];

		 return [
			 new Vector2$1( a_x, a_y ),
			 new Vector2$1( b_x, b_y ),
			 new Vector2$1( c_x, c_y )
		 ];

	 },

	 generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		 const a_x = vertices[ indexA * 3 ];
		 const a_y = vertices[ indexA * 3 + 1 ];
		 const a_z = vertices[ indexA * 3 + 2 ];
		 const b_x = vertices[ indexB * 3 ];
		 const b_y = vertices[ indexB * 3 + 1 ];
		 const b_z = vertices[ indexB * 3 + 2 ];
		 const c_x = vertices[ indexC * 3 ];
		 const c_y = vertices[ indexC * 3 + 1 ];
		 const c_z = vertices[ indexC * 3 + 2 ];
		 const d_x = vertices[ indexD * 3 ];
		 const d_y = vertices[ indexD * 3 + 1 ];
		 const d_z = vertices[ indexD * 3 + 2 ];

		 if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			 return [
				 new Vector2$1( a_x, 1 - a_z ),
				 new Vector2$1( b_x, 1 - b_z ),
				 new Vector2$1( c_x, 1 - c_z ),
				 new Vector2$1( d_x, 1 - d_z )
			 ];

		 } else {

			 return [
				 new Vector2$1( a_y, 1 - a_z ),
				 new Vector2$1( b_y, 1 - b_z ),
				 new Vector2$1( c_y, 1 - c_z ),
				 new Vector2$1( d_y, 1 - d_z )
			 ];

		 }

	 }

 };

 function toJSON$1$1( shapes, options, data ) {

	 data.shapes = [];

	 if ( Array.isArray( shapes ) ) {

		 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			 const shape = shapes[ i ];

			 data.shapes.push( shape.uuid );

		 }

	 } else {

		 data.shapes.push( shapes.uuid );

	 }

	 if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	 return data;

 }

 class ShapeGeometry$1 extends BufferGeometry$1 {

	 constructor( shapes, curveSegments = 12 ) {

		 super();
		 this.type = 'ShapeGeometry';

		 this.parameters = {
			 shapes: shapes,
			 curveSegments: curveSegments
		 };

		 // buffers

		 const indices = [];
		 const vertices = [];
		 const normals = [];
		 const uvs = [];

		 // helper variables

		 let groupStart = 0;
		 let groupCount = 0;

		 // allow single and array values for "shapes" parameter

		 if ( Array.isArray( shapes ) === false ) {

			 addShape( shapes );

		 } else {

			 for ( let i = 0; i < shapes.length; i ++ ) {

				 addShape( shapes[ i ] );

				 this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				 groupStart += groupCount;
				 groupCount = 0;

			 }

		 }

		 // build geometry

		 this.setIndex( indices );
		 this.setAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
		 this.setAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );


		 // helper functions

		 function addShape( shape ) {

			 const indexOffset = vertices.length / 3;
			 const points = shape.extractPoints( curveSegments );

			 let shapeVertices = points.shape;
			 const shapeHoles = points.holes;

			 // check direction of vertices

			 if ( ShapeUtils$1.isClockWise( shapeVertices ) === false ) {

				 shapeVertices = shapeVertices.reverse();

			 }

			 for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				 const shapeHole = shapeHoles[ i ];

				 if ( ShapeUtils$1.isClockWise( shapeHole ) === true ) {

					 shapeHoles[ i ] = shapeHole.reverse();

				 }

			 }

			 const faces = ShapeUtils$1.triangulateShape( shapeVertices, shapeHoles );

			 // join vertices of inner and outer paths to a single array

			 for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				 const shapeHole = shapeHoles[ i ];
				 shapeVertices = shapeVertices.concat( shapeHole );

			 }

			 // vertices, normals, uvs

			 for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				 const vertex = shapeVertices[ i ];

				 vertices.push( vertex.x, vertex.y, 0 );
				 normals.push( 0, 0, 1 );
				 uvs.push( vertex.x, vertex.y ); // world uvs

			 }

			 // incides

			 for ( let i = 0, l = faces.length; i < l; i ++ ) {

				 const face = faces[ i ];

				 const a = face[ 0 ] + indexOffset;
				 const b = face[ 1 ] + indexOffset;
				 const c = face[ 2 ] + indexOffset;

				 indices.push( a, b, c );
				 groupCount += 3;

			 }

		 }

	 }

	 toJSON() {

		 const data = super.toJSON();

		 const shapes = this.parameters.shapes;

		 return toJSON$2( shapes, data );

	 }

	 static fromJSON( data, shapes ) {

		 const geometryShapes = [];

		 for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			 const shape = shapes[ data.shapes[ j ] ];

			 geometryShapes.push( shape );

		 }

		 return new ShapeGeometry$1( geometryShapes, data.curveSegments );

	 }

 }

 function toJSON$2( shapes, data ) {

	 data.shapes = [];

	 if ( Array.isArray( shapes ) ) {

		 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			 const shape = shapes[ i ];

			 data.shapes.push( shape.uuid );

		 }

	 } else {

		 data.shapes.push( shapes.uuid );

	 }

	 return data;

 }

 class SphereGeometry extends BufferGeometry$1 {

	 constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		 super();
		 this.type = 'SphereGeometry';

		 this.parameters = {
			 radius: radius,
			 widthSegments: widthSegments,
			 heightSegments: heightSegments,
			 phiStart: phiStart,
			 phiLength: phiLength,
			 thetaStart: thetaStart,
			 thetaLength: thetaLength
		 };

		 widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		 heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		 const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		 let index = 0;
		 const grid = [];

		 const vertex = new Vector3$1();
		 const normal = new Vector3$1();

		 // buffers

		 const indices = [];
		 const vertices = [];
		 const normals = [];
		 const uvs = [];

		 // generate vertices, normals and uvs

		 for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			 const verticesRow = [];

			 const v = iy / heightSegments;

			 // special case for the poles

			 let uOffset = 0;

			 if ( iy == 0 && thetaStart == 0 ) {

				 uOffset = 0.5 / widthSegments;

			 } else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				 uOffset = - 0.5 / widthSegments;

			 }

			 for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				 const u = ix / widthSegments;

				 // vertex

				 vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				 vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				 vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				 vertices.push( vertex.x, vertex.y, vertex.z );

				 // normal

				 normal.copy( vertex ).normalize();
				 normals.push( normal.x, normal.y, normal.z );

				 // uv

				 uvs.push( u + uOffset, 1 - v );

				 verticesRow.push( index ++ );

			 }

			 grid.push( verticesRow );

		 }

		 // indices

		 for ( let iy = 0; iy < heightSegments; iy ++ ) {

			 for ( let ix = 0; ix < widthSegments; ix ++ ) {

				 const a = grid[ iy ][ ix + 1 ];
				 const b = grid[ iy ][ ix ];
				 const c = grid[ iy + 1 ][ ix ];
				 const d = grid[ iy + 1 ][ ix + 1 ];

				 if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				 if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			 }

		 }

		 // build geometry

		 this.setIndex( indices );
		 this.setAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
		 this.setAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

	 }

	 static fromJSON( data ) {

		 return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	 }

 }

 /**
	* parameters = {
	*  color: <THREE.Color>
	* }
	*/

 class ShadowMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'ShadowMaterial';

		 this.color = new Color$2( 0x000000 );
		 this.transparent = true;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 return this;

	 }

 }

 ShadowMaterial$1.prototype.isShadowMaterial = true;

 class RawShaderMaterial$1 extends ShaderMaterial$1 {

	 constructor( parameters ) {

		 super( parameters );

		 this.type = 'RawShaderMaterial';

	 }

 }

 RawShaderMaterial$1.prototype.isRawShaderMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  roughness: <float>,
	*  metalness: <float>,
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  roughnessMap: new THREE.Texture( <Image> ),
	*
	*  metalnessMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  envMapIntensity: <float>
	*
	*  refractionRatio: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>,
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshStandardMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.defines = { 'STANDARD': '' };

		 this.type = 'MeshStandardMaterial';

		 this.color = new Color$2( 0xffffff ); // diffuse
		 this.roughness = 1.0;
		 this.metalness = 0.0;

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$2( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap$1;
		 this.normalScale = new Vector2$1( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.roughnessMap = null;

		 this.metalnessMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.envMapIntensity = 1.0;

		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.vertexTangents = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.defines = { 'STANDARD': '' };

		 this.color.copy( source.color );
		 this.roughness = source.roughness;
		 this.metalness = source.metalness;

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.roughnessMap = source.roughnessMap;

		 this.metalnessMap = source.metalnessMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.envMapIntensity = source.envMapIntensity;

		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 this.vertexTangents = source.vertexTangents;

		 return this;

	 }

 }

 MeshStandardMaterial$1.prototype.isMeshStandardMaterial = true;

 /**
	* parameters = {
	*  clearcoat: <float>,
	*  clearcoatMap: new THREE.Texture( <Image> ),
	*  clearcoatRoughness: <float>,
	*  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	*  clearcoatNormalScale: <Vector2>,
	*  clearcoatNormalMap: new THREE.Texture( <Image> ),
	*
	*  reflectivity: <float>,
	*  ior: <float>,
	*
	*  sheen: <Color>,
	*
	*  transmission: <float>,
	*  transmissionMap: new THREE.Texture( <Image> ),
	*
	*  thickness: <float>,
	*  thicknessMap: new THREE.Texture( <Image> ),
	*  attenuationDistance: <float>,
	*  attenuationColor: <Color>
	* }
	*/

 class MeshPhysicalMaterial$1 extends MeshStandardMaterial$1 {

	 constructor( parameters ) {

		 super();

		 this.defines = {

			 'STANDARD': '',
			 'PHYSICAL': ''

		 };

		 this.type = 'MeshPhysicalMaterial';

		 this.clearcoat = 0.0;
		 this.clearcoatMap = null;
		 this.clearcoatRoughness = 0.0;
		 this.clearcoatRoughnessMap = null;
		 this.clearcoatNormalScale = new Vector2$1( 1, 1 );
		 this.clearcoatNormalMap = null;

		 this.reflectivity = 0.5; // maps to F0 = 0.04

		 Object.defineProperty( this, 'ior', {
			 get: function () {

				 return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

			 },
			 set: function ( ior ) {

				 this.reflectivity = clamp$1( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

			 }
		 } );

		 this.sheen = null; // null will disable sheen bsdf

		 this.transmission = 0.0;
		 this.transmissionMap = null;

		 this.thickness = 0.01;
		 this.thicknessMap = null;
		 this.attenuationDistance = 0.0;
		 this.attenuationColor = new Color$2( 1, 1, 1 );

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.defines = {

			 'STANDARD': '',
			 'PHYSICAL': ''

		 };

		 this.clearcoat = source.clearcoat;
		 this.clearcoatMap = source.clearcoatMap;
		 this.clearcoatRoughness = source.clearcoatRoughness;
		 this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		 this.clearcoatNormalMap = source.clearcoatNormalMap;
		 this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		 this.reflectivity = source.reflectivity;

		 if ( source.sheen ) {

			 this.sheen = ( this.sheen || new Color$2() ).copy( source.sheen );

		 } else {

			 this.sheen = null;

		 }

		 this.transmission = source.transmission;
		 this.transmissionMap = source.transmissionMap;

		 this.thickness = source.thickness;
		 this.thicknessMap = source.thicknessMap;
		 this.attenuationDistance = source.attenuationDistance;
		 this.attenuationColor.copy( source.attenuationColor );

		 return this;

	 }

 }

 MeshPhysicalMaterial$1.prototype.isMeshPhysicalMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  specular: <hex>,
	*  shininess: <float>,
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  specularMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  combine: THREE.MultiplyOperation,
	*  reflectivity: <float>,
	*  refractionRatio: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>,
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshPhongMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshPhongMaterial';

		 this.color = new Color$2( 0xffffff ); // diffuse
		 this.specular = new Color$2( 0x111111 );
		 this.shininess = 30;

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$2( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap$1;
		 this.normalScale = new Vector2$1( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.specularMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.combine = MultiplyOperation$1;
		 this.reflectivity = 1;
		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );
		 this.specular.copy( source.specular );
		 this.shininess = source.shininess;

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.specularMap = source.specularMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.combine = source.combine;
		 this.reflectivity = source.reflectivity;
		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 return this;

	 }

 }

 MeshPhongMaterial$1.prototype.isMeshPhongMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*
	*  map: new THREE.Texture( <Image> ),
	*  gradientMap: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	* }
	*/

 class MeshToonMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.defines = { 'TOON': '' };

		 this.type = 'MeshToonMaterial';

		 this.color = new Color$2( 0xffffff );

		 this.map = null;
		 this.gradientMap = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$2( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap$1;
		 this.normalScale = new Vector2$1( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.alphaMap = null;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;
		 this.gradientMap = source.gradientMap;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.alphaMap = source.alphaMap;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 return this;

	 }

 }

 MeshToonMaterial$1.prototype.isMeshToonMaterial = true;

 /**
	* parameters = {
	*  opacity: <float>,
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>,
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshNormalMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshNormalMaterial';

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap$1;
		 this.normalScale = new Vector2$1( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;

		 this.fog = false;

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 return this;

	 }

 }

 MeshNormalMaterial$1.prototype.isMeshNormalMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  specularMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  combine: THREE.Multiply,
	*  reflectivity: <float>,
	*  refractionRatio: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	* }
	*/

 class MeshLambertMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshLambertMaterial';

		 this.color = new Color$2( 0xffffff ); // diffuse

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$2( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.specularMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.combine = MultiplyOperation$1;
		 this.reflectivity = 1;
		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.specularMap = source.specularMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.combine = source.combine;
		 this.reflectivity = source.reflectivity;
		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 return this;

	 }

 }

 MeshLambertMaterial$1.prototype.isMeshLambertMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  matcap: new THREE.Texture( <Image> ),
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshMatcapMaterial$1 extends Material$1 {

	 constructor( parameters ) {

		 super();

		 this.defines = { 'MATCAP': '' };

		 this.type = 'MeshMatcapMaterial';

		 this.color = new Color$2( 0xffffff ); // diffuse

		 this.matcap = null;

		 this.map = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap$1;
		 this.normalScale = new Vector2$1( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.alphaMap = null;

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.setValues( parameters );

	 }


	 copy( source ) {

		 super.copy( source );

		 this.defines = { 'MATCAP': '' };

		 this.color.copy( source.color );

		 this.matcap = source.matcap;

		 this.map = source.map;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.alphaMap = source.alphaMap;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 return this;

	 }

 }

 MeshMatcapMaterial$1.prototype.isMeshMatcapMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  linewidth: <float>,
	*
	*  scale: <float>,
	*  dashSize: <float>,
	*  gapSize: <float>
	* }
	*/

 class LineDashedMaterial$1 extends LineBasicMaterial$1 {

	 constructor( parameters ) {

		 super();

		 this.type = 'LineDashedMaterial';

		 this.scale = 1;
		 this.dashSize = 3;
		 this.gapSize = 1;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.scale = source.scale;
		 this.dashSize = source.dashSize;
		 this.gapSize = source.gapSize;

		 return this;

	 }

 }

 LineDashedMaterial$1.prototype.isLineDashedMaterial = true;

 const AnimationUtils$1 = {

	 // same as Array.prototype.slice, but also works on typed arrays
	 arraySlice: function ( array, from, to ) {

		 if ( AnimationUtils$1.isTypedArray( array ) ) {

			 // in ios9 array.subarray(from, undefined) will return empty array
			 // but array.subarray(from) or array.subarray(from, len) is correct
			 return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		 }

		 return array.slice( from, to );

	 },

	 // converts an array to a specific type
	 convertArray: function ( array, type, forceClone ) {

		 if ( ! array || // let 'undefined' and 'null' pass
			 ! forceClone && array.constructor === type ) return array;

		 if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			 return new type( array ); // create typed array

		 }

		 return Array.prototype.slice.call( array ); // create Array

	 },

	 isTypedArray: function ( object ) {

		 return ArrayBuffer.isView( object ) &&
			 ! ( object instanceof DataView );

	 },

	 // returns an array by which times and values can be sorted
	 getKeyframeOrder: function ( times ) {

		 function compareTime( i, j ) {

			 return times[ i ] - times[ j ];

		 }

		 const n = times.length;
		 const result = new Array( n );
		 for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		 result.sort( compareTime );

		 return result;

	 },

	 // uses the array previously returned by 'getKeyframeOrder' to sort data
	 sortedArray: function ( values, stride, order ) {

		 const nValues = values.length;
		 const result = new values.constructor( nValues );

		 for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			 const srcOffset = order[ i ] * stride;

			 for ( let j = 0; j !== stride; ++ j ) {

				 result[ dstOffset ++ ] = values[ srcOffset + j ];

			 }

		 }

		 return result;

	 },

	 // function for parsing AOS keyframe formats
	 flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		 let i = 1, key = jsonKeys[ 0 ];

		 while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			 key = jsonKeys[ i ++ ];

		 }

		 if ( key === undefined ) return; // no data

		 let value = key[ valuePropertyName ];
		 if ( value === undefined ) return; // no data

		 if ( Array.isArray( value ) ) {

			 do {

				 value = key[ valuePropertyName ];

				 if ( value !== undefined ) {

					 times.push( key.time );
					 values.push.apply( values, value ); // push all elements

				 }

				 key = jsonKeys[ i ++ ];

			 } while ( key !== undefined );

		 } else if ( value.toArray !== undefined ) {

			 // ...assume THREE.Math-ish

			 do {

				 value = key[ valuePropertyName ];

				 if ( value !== undefined ) {

					 times.push( key.time );
					 value.toArray( values, values.length );

				 }

				 key = jsonKeys[ i ++ ];

			 } while ( key !== undefined );

		 } else {

			 // otherwise push as-is

			 do {

				 value = key[ valuePropertyName ];

				 if ( value !== undefined ) {

					 times.push( key.time );
					 values.push( value );

				 }

				 key = jsonKeys[ i ++ ];

			 } while ( key !== undefined );

		 }

	 },

	 subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		 const clip = sourceClip.clone();

		 clip.name = name;

		 const tracks = [];

		 for ( let i = 0; i < clip.tracks.length; ++ i ) {

			 const track = clip.tracks[ i ];
			 const valueSize = track.getValueSize();

			 const times = [];
			 const values = [];

			 for ( let j = 0; j < track.times.length; ++ j ) {

				 const frame = track.times[ j ] * fps;

				 if ( frame < startFrame || frame >= endFrame ) continue;

				 times.push( track.times[ j ] );

				 for ( let k = 0; k < valueSize; ++ k ) {

					 values.push( track.values[ j * valueSize + k ] );

				 }

			 }

			 if ( times.length === 0 ) continue;

			 track.times = AnimationUtils$1.convertArray( times, track.times.constructor );
			 track.values = AnimationUtils$1.convertArray( values, track.values.constructor );

			 tracks.push( track );

		 }

		 clip.tracks = tracks;

		 // find minimum .times value across all tracks in the trimmed clip

		 let minStartTime = Infinity;

		 for ( let i = 0; i < clip.tracks.length; ++ i ) {

			 if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				 minStartTime = clip.tracks[ i ].times[ 0 ];

			 }

		 }

		 // shift all tracks such that clip begins at t=0

		 for ( let i = 0; i < clip.tracks.length; ++ i ) {

			 clip.tracks[ i ].shift( - 1 * minStartTime );

		 }

		 clip.resetDuration();

		 return clip;

	 },

	 makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		 if ( fps <= 0 ) fps = 30;

		 const numTracks = referenceClip.tracks.length;
		 const referenceTime = referenceFrame / fps;

		 // Make each track's values relative to the values at the reference frame
		 for ( let i = 0; i < numTracks; ++ i ) {

			 const referenceTrack = referenceClip.tracks[ i ];
			 const referenceTrackType = referenceTrack.ValueTypeName;

			 // Skip this track if it's non-numeric
			 if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			 // Find the track in the target clip whose name and type matches the reference track
			 const targetTrack = targetClip.tracks.find( function ( track ) {

				 return track.name === referenceTrack.name
					 && track.ValueTypeName === referenceTrackType;

			 } );

			 if ( targetTrack === undefined ) continue;

			 let referenceOffset = 0;
			 const referenceValueSize = referenceTrack.getValueSize();

			 if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				 referenceOffset = referenceValueSize / 3;

			 }

			 let targetOffset = 0;
			 const targetValueSize = targetTrack.getValueSize();

			 if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				 targetOffset = targetValueSize / 3;

			 }

			 const lastIndex = referenceTrack.times.length - 1;
			 let referenceValue;

			 // Find the value to subtract out of the track
			 if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				 // Reference frame is earlier than the first keyframe, so just use the first keyframe
				 const startIndex = referenceOffset;
				 const endIndex = referenceValueSize - referenceOffset;
				 referenceValue = AnimationUtils$1.arraySlice( referenceTrack.values, startIndex, endIndex );

			 } else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				 // Reference frame is after the last keyframe, so just use the last keyframe
				 const startIndex = lastIndex * referenceValueSize + referenceOffset;
				 const endIndex = startIndex + referenceValueSize - referenceOffset;
				 referenceValue = AnimationUtils$1.arraySlice( referenceTrack.values, startIndex, endIndex );

			 } else {

				 // Interpolate to the reference value
				 const interpolant = referenceTrack.createInterpolant();
				 const startIndex = referenceOffset;
				 const endIndex = referenceValueSize - referenceOffset;
				 interpolant.evaluate( referenceTime );
				 referenceValue = AnimationUtils$1.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			 }

			 // Conjugate the quaternion
			 if ( referenceTrackType === 'quaternion' ) {

				 const referenceQuat = new Quaternion$1().fromArray( referenceValue ).normalize().conjugate();
				 referenceQuat.toArray( referenceValue );

			 }

			 // Subtract the reference value from all of the track values

			 const numTimes = targetTrack.times.length;
			 for ( let j = 0; j < numTimes; ++ j ) {

				 const valueStart = j * targetValueSize + targetOffset;

				 if ( referenceTrackType === 'quaternion' ) {

					 // Multiply the conjugate for quaternion track types
					 Quaternion$1.multiplyQuaternionsFlat(
						 targetTrack.values,
						 valueStart,
						 referenceValue,
						 0,
						 targetTrack.values,
						 valueStart
					 );

				 } else {

					 const valueEnd = targetValueSize - targetOffset * 2;

					 // Subtract each value for all other numeric track types
					 for ( let k = 0; k < valueEnd; ++ k ) {

						 targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					 }

				 }

			 }

		 }

		 targetClip.blendMode = AdditiveAnimationBlendMode$1;

		 return targetClip;

	 }

 };

 /**
	* Abstract base class of interpolants over parametric samples.
	*
	* The parameter domain is one dimensional, typically the time or a path
	* along a curve defined by the data.
	*
	* The sample values can have any dimensionality and derived classes may
	* apply special interpretations to the data.
	*
	* This class provides the interval seek in a Template Method, deferring
	* the actual interpolation to derived classes.
	*
	* Time complexity is O(1) for linear access crossing at most two points
	* and O(log N) for random access, where N is the number of positions.
	*
	* References:
	*
	* 		http://www.oodesign.com/template-method-pattern.html
	*
	*/

 class Interpolant$1 {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 this.parameterPositions = parameterPositions;
		 this._cachedIndex = 0;

		 this.resultBuffer = resultBuffer !== undefined ?
			 resultBuffer : new sampleValues.constructor( sampleSize );
		 this.sampleValues = sampleValues;
		 this.valueSize = sampleSize;

		 this.settings = null;
		 this.DefaultSettings_ = {};

	 }

	 evaluate( t ) {

		 const pp = this.parameterPositions;
		 let i1 = this._cachedIndex,
			 t1 = pp[ i1 ],
			 t0 = pp[ i1 - 1 ];

		 validate_interval: {

			 seek: {

				 let right;

				 linear_scan: {

					 //- See http://jsperf.com/comparison-to-undefined/3
					 //- slower code:
					 //-
					 //- 				if ( t >= t1 || t1 === undefined ) {
					 forward_scan: if ( ! ( t < t1 ) ) {

						 for ( let giveUpAt = i1 + 2; ; ) {

							 if ( t1 === undefined ) {

								 if ( t < t0 ) break forward_scan;

								 // after end

								 i1 = pp.length;
								 this._cachedIndex = i1;
								 return this.afterEnd_( i1 - 1, t, t0 );

							 }

							 if ( i1 === giveUpAt ) break; // this loop

							 t0 = t1;
							 t1 = pp[ ++ i1 ];

							 if ( t < t1 ) {

								 // we have arrived at the sought interval
								 break seek;

							 }

						 }

						 // prepare binary search on the right side of the index
						 right = pp.length;
						 break linear_scan;

					 }

					 //- slower code:
					 //-					if ( t < t0 || t0 === undefined ) {
					 if ( ! ( t >= t0 ) ) {

						 // looping?

						 const t1global = pp[ 1 ];

						 if ( t < t1global ) {

							 i1 = 2; // + 1, using the scan for the details
							 t0 = t1global;

						 }

						 // linear reverse scan

						 for ( let giveUpAt = i1 - 2; ; ) {

							 if ( t0 === undefined ) {

								 // before start

								 this._cachedIndex = 0;
								 return this.beforeStart_( 0, t, t1 );

							 }

							 if ( i1 === giveUpAt ) break; // this loop

							 t1 = t0;
							 t0 = pp[ -- i1 - 1 ];

							 if ( t >= t0 ) {

								 // we have arrived at the sought interval
								 break seek;

							 }

						 }

						 // prepare binary search on the left side of the index
						 right = i1;
						 i1 = 0;
						 break linear_scan;

					 }

					 // the interval is valid

					 break validate_interval;

				 } // linear scan

				 // binary search

				 while ( i1 < right ) {

					 const mid = ( i1 + right ) >>> 1;

					 if ( t < pp[ mid ] ) {

						 right = mid;

					 } else {

						 i1 = mid + 1;

					 }

				 }

				 t1 = pp[ i1 ];
				 t0 = pp[ i1 - 1 ];

				 // check boundary cases, again

				 if ( t0 === undefined ) {

					 this._cachedIndex = 0;
					 return this.beforeStart_( 0, t, t1 );

				 }

				 if ( t1 === undefined ) {

					 i1 = pp.length;
					 this._cachedIndex = i1;
					 return this.afterEnd_( i1 - 1, t0, t );

				 }

			 } // seek

			 this._cachedIndex = i1;

			 this.intervalChanged_( i1, t0, t1 );

		 } // validate_interval

		 return this.interpolate_( i1, t0, t, t1 );

	 }

	 getSettings_() {

		 return this.settings || this.DefaultSettings_;

	 }

	 copySampleValue_( index ) {

		 // copies a sample value to the result buffer

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,
			 offset = index * stride;

		 for ( let i = 0; i !== stride; ++ i ) {

			 result[ i ] = values[ offset + i ];

		 }

		 return result;

	 }

	 // Template methods for derived classes:

	 interpolate_( /* i1, t0, t, t1 */ ) {

		 throw new Error( 'call to abstract method' );
		 // implementations shall return this.resultBuffer

	 }

	 intervalChanged_( /* i1, t0, t1 */ ) {

		 // empty

	 }

 }

 // ALIAS DEFINITIONS

 Interpolant$1.prototype.beforeStart_ = Interpolant$1.prototype.copySampleValue_;
 Interpolant$1.prototype.afterEnd_ = Interpolant$1.prototype.copySampleValue_;

 /**
	* Fast and simple cubic spline interpolant.
	*
	* It was derived from a Hermitian construction setting the first derivative
	* at each sample position to the linear slope between neighboring positions
	* over their parameter interval.
	*/

 class CubicInterpolant$1 extends Interpolant$1 {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		 this._weightPrev = - 0;
		 this._offsetPrev = - 0;
		 this._weightNext = - 0;
		 this._offsetNext = - 0;

		 this.DefaultSettings_ = {

			 endingStart: ZeroCurvatureEnding$1,
			 endingEnd: ZeroCurvatureEnding$1

		 };

	 }

	 intervalChanged_( i1, t0, t1 ) {

		 const pp = this.parameterPositions;
		 let iPrev = i1 - 2,
			 iNext = i1 + 1,

			 tPrev = pp[ iPrev ],
			 tNext = pp[ iNext ];

		 if ( tPrev === undefined ) {

			 switch ( this.getSettings_().endingStart ) {

				 case ZeroSlopeEnding$1:

					 // f'(t0) = 0
					 iPrev = i1;
					 tPrev = 2 * t0 - t1;

					 break;

				 case WrapAroundEnding$1:

					 // use the other end of the curve
					 iPrev = pp.length - 2;
					 tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					 break;

				 default: // ZeroCurvatureEnding

					 // f''(t0) = 0 a.k.a. Natural Spline
					 iPrev = i1;
					 tPrev = t1;

			 }

		 }

		 if ( tNext === undefined ) {

			 switch ( this.getSettings_().endingEnd ) {

				 case ZeroSlopeEnding$1:

					 // f'(tN) = 0
					 iNext = i1;
					 tNext = 2 * t1 - t0;

					 break;

				 case WrapAroundEnding$1:

					 // use the other end of the curve
					 iNext = 1;
					 tNext = t1 + pp[ 1 ] - pp[ 0 ];

					 break;

				 default: // ZeroCurvatureEnding

					 // f''(tN) = 0, a.k.a. Natural Spline
					 iNext = i1 - 1;
					 tNext = t0;

			 }

		 }

		 const halfDt = ( t1 - t0 ) * 0.5,
			 stride = this.valueSize;

		 this._weightPrev = halfDt / ( t0 - tPrev );
		 this._weightNext = halfDt / ( tNext - t1 );
		 this._offsetPrev = iPrev * stride;
		 this._offsetNext = iNext * stride;

	 }

	 interpolate_( i1, t0, t, t1 ) {

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,

			 o1 = i1 * stride,		o0 = o1 - stride,
			 oP = this._offsetPrev, 	oN = this._offsetNext,
			 wP = this._weightPrev,	wN = this._weightNext,

			 p = ( t - t0 ) / ( t1 - t0 ),
			 pp = p * p,
			 ppp = pp * p;

		 // evaluate polynomials

		 const sP = - wP * ppp + 2 * wP * pp - wP * p;
		 const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		 const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		 const sN = wN * ppp - wN * pp;

		 // combine data linearly

		 for ( let i = 0; i !== stride; ++ i ) {

			 result[ i ] =
					 sP * values[ oP + i ] +
					 s0 * values[ o0 + i ] +
					 s1 * values[ o1 + i ] +
					 sN * values[ oN + i ];

		 }

		 return result;

	 }

 }

 class LinearInterpolant$1 extends Interpolant$1 {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	 }

	 interpolate_( i1, t0, t, t1 ) {

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,

			 offset1 = i1 * stride,
			 offset0 = offset1 - stride,

			 weight1 = ( t - t0 ) / ( t1 - t0 ),
			 weight0 = 1 - weight1;

		 for ( let i = 0; i !== stride; ++ i ) {

			 result[ i ] =
					 values[ offset0 + i ] * weight0 +
					 values[ offset1 + i ] * weight1;

		 }

		 return result;

	 }

 }

 /**
	*
	* Interpolant that evaluates to the sample value at the position preceeding
	* the parameter.
	*/

 class DiscreteInterpolant$1 extends Interpolant$1 {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	 }

	 interpolate_( i1 /*, t0, t, t1 */ ) {

		 return this.copySampleValue_( i1 - 1 );

	 }

 }

 class KeyframeTrack$1 {

	 constructor( name, times, values, interpolation ) {

		 if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		 if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		 this.name = name;

		 this.times = AnimationUtils$1.convertArray( times, this.TimeBufferType );
		 this.values = AnimationUtils$1.convertArray( values, this.ValueBufferType );

		 this.setInterpolation( interpolation || this.DefaultInterpolation );

	 }

	 // Serialization (in static context, because of constructor invocation
	 // and automatic invocation of .toJSON):

	 static toJSON( track ) {

		 const trackType = track.constructor;

		 let json;

		 // derived classes can define a static toJSON method
		 if ( trackType.toJSON !== this.toJSON ) {

			 json = trackType.toJSON( track );

		 } else {

			 // by default, we assume the data can be serialized as-is
			 json = {

				 'name': track.name,
				 'times': AnimationUtils$1.convertArray( track.times, Array ),
				 'values': AnimationUtils$1.convertArray( track.values, Array )

			 };

			 const interpolation = track.getInterpolation();

			 if ( interpolation !== track.DefaultInterpolation ) {

				 json.interpolation = interpolation;

			 }

		 }

		 json.type = track.ValueTypeName; // mandatory

		 return json;

	 }

	 InterpolantFactoryMethodDiscrete( result ) {

		 return new DiscreteInterpolant$1( this.times, this.values, this.getValueSize(), result );

	 }

	 InterpolantFactoryMethodLinear( result ) {

		 return new LinearInterpolant$1( this.times, this.values, this.getValueSize(), result );

	 }

	 InterpolantFactoryMethodSmooth( result ) {

		 return new CubicInterpolant$1( this.times, this.values, this.getValueSize(), result );

	 }

	 setInterpolation( interpolation ) {

		 let factoryMethod;

		 switch ( interpolation ) {

			 case InterpolateDiscrete$1:

				 factoryMethod = this.InterpolantFactoryMethodDiscrete;

				 break;

			 case InterpolateLinear$1:

				 factoryMethod = this.InterpolantFactoryMethodLinear;

				 break;

			 case InterpolateSmooth$1:

				 factoryMethod = this.InterpolantFactoryMethodSmooth;

				 break;

		 }

		 if ( factoryMethod === undefined ) {

			 const message = 'unsupported interpolation for ' +
				 this.ValueTypeName + ' keyframe track named ' + this.name;

			 if ( this.createInterpolant === undefined ) {

				 // fall back to default, unless the default itself is messed up
				 if ( interpolation !== this.DefaultInterpolation ) {

					 this.setInterpolation( this.DefaultInterpolation );

				 } else {

					 throw new Error( message ); // fatal, in this case

				 }

			 }

			 console.warn( 'THREE.KeyframeTrack:', message );
			 return this;

		 }

		 this.createInterpolant = factoryMethod;

		 return this;

	 }

	 getInterpolation() {

		 switch ( this.createInterpolant ) {

			 case this.InterpolantFactoryMethodDiscrete:

				 return InterpolateDiscrete$1;

			 case this.InterpolantFactoryMethodLinear:

				 return InterpolateLinear$1;

			 case this.InterpolantFactoryMethodSmooth:

				 return InterpolateSmooth$1;

		 }

	 }

	 getValueSize() {

		 return this.values.length / this.times.length;

	 }

	 // move all keyframes either forwards or backwards in time
	 shift( timeOffset ) {

		 if ( timeOffset !== 0.0 ) {

			 const times = this.times;

			 for ( let i = 0, n = times.length; i !== n; ++ i ) {

				 times[ i ] += timeOffset;

			 }

		 }

		 return this;

	 }

	 // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	 scale( timeScale ) {

		 if ( timeScale !== 1.0 ) {

			 const times = this.times;

			 for ( let i = 0, n = times.length; i !== n; ++ i ) {

				 times[ i ] *= timeScale;

			 }

		 }

		 return this;

	 }

	 // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	 // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	 trim( startTime, endTime ) {

		 const times = this.times,
			 nKeys = times.length;

		 let from = 0,
			 to = nKeys - 1;

		 while ( from !== nKeys && times[ from ] < startTime ) {

			 ++ from;

		 }

		 while ( to !== - 1 && times[ to ] > endTime ) {

			 -- to;

		 }

		 ++ to; // inclusive -> exclusive bound

		 if ( from !== 0 || to !== nKeys ) {

			 // empty tracks are forbidden, so keep at least one keyframe
			 if ( from >= to ) {

				 to = Math.max( to, 1 );
				 from = to - 1;

			 }

			 const stride = this.getValueSize();
			 this.times = AnimationUtils$1.arraySlice( times, from, to );
			 this.values = AnimationUtils$1.arraySlice( this.values, from * stride, to * stride );

		 }

		 return this;

	 }

	 // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	 validate() {

		 let valid = true;

		 const valueSize = this.getValueSize();
		 if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			 console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			 valid = false;

		 }

		 const times = this.times,
			 values = this.values,

			 nKeys = times.length;

		 if ( nKeys === 0 ) {

			 console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			 valid = false;

		 }

		 let prevTime = null;

		 for ( let i = 0; i !== nKeys; i ++ ) {

			 const currTime = times[ i ];

			 if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				 console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				 valid = false;
				 break;

			 }

			 if ( prevTime !== null && prevTime > currTime ) {

				 console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				 valid = false;
				 break;

			 }

			 prevTime = currTime;

		 }

		 if ( values !== undefined ) {

			 if ( AnimationUtils$1.isTypedArray( values ) ) {

				 for ( let i = 0, n = values.length; i !== n; ++ i ) {

					 const value = values[ i ];

					 if ( isNaN( value ) ) {

						 console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						 valid = false;
						 break;

					 }

				 }

			 }

		 }

		 return valid;

	 }

	 // removes equivalent sequential keys as common in morph target sequences
	 // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	 optimize() {

		 // times or values may be shared with other tracks, so overwriting is unsafe
		 const times = AnimationUtils$1.arraySlice( this.times ),
			 values = AnimationUtils$1.arraySlice( this.values ),
			 stride = this.getValueSize(),

			 smoothInterpolation = this.getInterpolation() === InterpolateSmooth$1,

			 lastIndex = times.length - 1;

		 let writeIndex = 1;

		 for ( let i = 1; i < lastIndex; ++ i ) {

			 let keep = false;

			 const time = times[ i ];
			 const timeNext = times[ i + 1 ];

			 // remove adjacent keyframes scheduled at the same time

			 if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				 if ( ! smoothInterpolation ) {

					 // remove unnecessary keyframes same as their neighbors

					 const offset = i * stride,
						 offsetP = offset - stride,
						 offsetN = offset + stride;

					 for ( let j = 0; j !== stride; ++ j ) {

						 const value = values[ offset + j ];

						 if ( value !== values[ offsetP + j ] ||
							 value !== values[ offsetN + j ] ) {

							 keep = true;
							 break;

						 }

					 }

				 } else {

					 keep = true;

				 }

			 }

			 // in-place compaction

			 if ( keep ) {

				 if ( i !== writeIndex ) {

					 times[ writeIndex ] = times[ i ];

					 const readOffset = i * stride,
						 writeOffset = writeIndex * stride;

					 for ( let j = 0; j !== stride; ++ j ) {

						 values[ writeOffset + j ] = values[ readOffset + j ];

					 }

				 }

				 ++ writeIndex;

			 }

		 }

		 // flush last keyframe (compaction looks ahead)

		 if ( lastIndex > 0 ) {

			 times[ writeIndex ] = times[ lastIndex ];

			 for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				 values[ writeOffset + j ] = values[ readOffset + j ];

			 }

			 ++ writeIndex;

		 }

		 if ( writeIndex !== times.length ) {

			 this.times = AnimationUtils$1.arraySlice( times, 0, writeIndex );
			 this.values = AnimationUtils$1.arraySlice( values, 0, writeIndex * stride );

		 } else {

			 this.times = times;
			 this.values = values;

		 }

		 return this;

	 }

	 clone() {

		 const times = AnimationUtils$1.arraySlice( this.times, 0 );
		 const values = AnimationUtils$1.arraySlice( this.values, 0 );

		 const TypedKeyframeTrack = this.constructor;
		 const track = new TypedKeyframeTrack( this.name, times, values );

		 // Interpolant argument to constructor is not saved, so copy the factory method directly.
		 track.createInterpolant = this.createInterpolant;

		 return track;

	 }

 }

 KeyframeTrack$1.prototype.TimeBufferType = Float32Array;
 KeyframeTrack$1.prototype.ValueBufferType = Float32Array;
 KeyframeTrack$1.prototype.DefaultInterpolation = InterpolateLinear$1;

 /**
	* A Track of Boolean keyframe values.
	*/
 class BooleanKeyframeTrack$1 extends KeyframeTrack$1 {}

 BooleanKeyframeTrack$1.prototype.ValueTypeName = 'bool';
 BooleanKeyframeTrack$1.prototype.ValueBufferType = Array;
 BooleanKeyframeTrack$1.prototype.DefaultInterpolation = InterpolateDiscrete$1;
 BooleanKeyframeTrack$1.prototype.InterpolantFactoryMethodLinear = undefined;
 BooleanKeyframeTrack$1.prototype.InterpolantFactoryMethodSmooth = undefined;

 /**
	* A Track of keyframe values that represent color.
	*/
 class ColorKeyframeTrack$1 extends KeyframeTrack$1 {}

 ColorKeyframeTrack$1.prototype.ValueTypeName = 'color';

 /**
	* A Track of numeric keyframe values.
	*/
 class NumberKeyframeTrack$1 extends KeyframeTrack$1 {}

 NumberKeyframeTrack$1.prototype.ValueTypeName = 'number';

 /**
	* Spherical linear unit quaternion interpolant.
	*/

 class QuaternionLinearInterpolant$1 extends Interpolant$1 {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	 }

	 interpolate_( i1, t0, t, t1 ) {

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,

			 alpha = ( t - t0 ) / ( t1 - t0 );

		 let offset = i1 * stride;

		 for ( let end = offset + stride; offset !== end; offset += 4 ) {

			 Quaternion$1.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		 }

		 return result;

	 }

 }

 /**
	* A Track of quaternion keyframe values.
	*/
 class QuaternionKeyframeTrack$1 extends KeyframeTrack$1 {

	 InterpolantFactoryMethodLinear( result ) {

		 return new QuaternionLinearInterpolant$1( this.times, this.values, this.getValueSize(), result );

	 }

 }

 QuaternionKeyframeTrack$1.prototype.ValueTypeName = 'quaternion';
 // ValueBufferType is inherited
 QuaternionKeyframeTrack$1.prototype.DefaultInterpolation = InterpolateLinear$1;
 QuaternionKeyframeTrack$1.prototype.InterpolantFactoryMethodSmooth = undefined;

 /**
	* A Track that interpolates Strings
	*/
 class StringKeyframeTrack$1 extends KeyframeTrack$1 {}

 StringKeyframeTrack$1.prototype.ValueTypeName = 'string';
 StringKeyframeTrack$1.prototype.ValueBufferType = Array;
 StringKeyframeTrack$1.prototype.DefaultInterpolation = InterpolateDiscrete$1;
 StringKeyframeTrack$1.prototype.InterpolantFactoryMethodLinear = undefined;
 StringKeyframeTrack$1.prototype.InterpolantFactoryMethodSmooth = undefined;

 /**
	* A Track of vectored keyframe values.
	*/
 class VectorKeyframeTrack$1 extends KeyframeTrack$1 {}

 VectorKeyframeTrack$1.prototype.ValueTypeName = 'vector';

 class AnimationClip$1 {

	 constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode$1 ) {

		 this.name = name;
		 this.tracks = tracks;
		 this.duration = duration;
		 this.blendMode = blendMode;

		 this.uuid = generateUUID$1();

		 // this means it should figure out its duration by scanning the tracks
		 if ( this.duration < 0 ) {

			 this.resetDuration();

		 }

	 }


	 static parse( json ) {

		 const tracks = [],
			 jsonTracks = json.tracks,
			 frameTime = 1.0 / ( json.fps || 1.0 );

		 for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			 tracks.push( parseKeyframeTrack$1( jsonTracks[ i ] ).scale( frameTime ) );

		 }

		 const clip = new this( json.name, json.duration, tracks, json.blendMode );
		 clip.uuid = json.uuid;

		 return clip;

	 }

	 static toJSON( clip ) {

		 const tracks = [],
			 clipTracks = clip.tracks;

		 const json = {

			 'name': clip.name,
			 'duration': clip.duration,
			 'tracks': tracks,
			 'uuid': clip.uuid,
			 'blendMode': clip.blendMode

		 };

		 for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			 tracks.push( KeyframeTrack$1.toJSON( clipTracks[ i ] ) );

		 }

		 return json;

	 }

	 static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		 const numMorphTargets = morphTargetSequence.length;
		 const tracks = [];

		 for ( let i = 0; i < numMorphTargets; i ++ ) {

			 let times = [];
			 let values = [];

			 times.push(
				 ( i + numMorphTargets - 1 ) % numMorphTargets,
				 i,
				 ( i + 1 ) % numMorphTargets );

			 values.push( 0, 1, 0 );

			 const order = AnimationUtils$1.getKeyframeOrder( times );
			 times = AnimationUtils$1.sortedArray( times, 1, order );
			 values = AnimationUtils$1.sortedArray( values, 1, order );

			 // if there is a key at the first frame, duplicate it as the
			 // last frame as well for perfect loop.
			 if ( ! noLoop && times[ 0 ] === 0 ) {

				 times.push( numMorphTargets );
				 values.push( values[ 0 ] );

			 }

			 tracks.push(
				 new NumberKeyframeTrack$1(
					 '.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					 times, values
				 ).scale( 1.0 / fps ) );

		 }

		 return new this( name, - 1, tracks );

	 }

	 static findByName( objectOrClipArray, name ) {

		 let clipArray = objectOrClipArray;

		 if ( ! Array.isArray( objectOrClipArray ) ) {

			 const o = objectOrClipArray;
			 clipArray = o.geometry && o.geometry.animations || o.animations;

		 }

		 for ( let i = 0; i < clipArray.length; i ++ ) {

			 if ( clipArray[ i ].name === name ) {

				 return clipArray[ i ];

			 }

		 }

		 return null;

	 }

	 static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		 const animationToMorphTargets = {};

		 // tested with https://regex101.com/ on trick sequences
		 // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		 const pattern = /^([\w-]*?)([\d]+)$/;

		 // sort morph target names into animation groups based
		 // patterns like Walk_001, Walk_002, Run_001, Run_002
		 for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			 const morphTarget = morphTargets[ i ];
			 const parts = morphTarget.name.match( pattern );

			 if ( parts && parts.length > 1 ) {

				 const name = parts[ 1 ];

				 let animationMorphTargets = animationToMorphTargets[ name ];

				 if ( ! animationMorphTargets ) {

					 animationToMorphTargets[ name ] = animationMorphTargets = [];

				 }

				 animationMorphTargets.push( morphTarget );

			 }

		 }

		 const clips = [];

		 for ( const name in animationToMorphTargets ) {

			 clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		 }

		 return clips;

	 }

	 // parse the animation.hierarchy format
	 static parseAnimation( animation, bones ) {

		 if ( ! animation ) {

			 console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			 return null;

		 }

		 const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			 // only return track if there are actually keys.
			 if ( animationKeys.length !== 0 ) {

				 const times = [];
				 const values = [];

				 AnimationUtils$1.flattenJSON( animationKeys, times, values, propertyName );

				 // empty keys are filtered out, so check again
				 if ( times.length !== 0 ) {

					 destTracks.push( new trackType( trackName, times, values ) );

				 }

			 }

		 };

		 const tracks = [];

		 const clipName = animation.name || 'default';
		 const fps = animation.fps || 30;
		 const blendMode = animation.blendMode;

		 // automatic length determination in AnimationClip.
		 let duration = animation.length || - 1;

		 const hierarchyTracks = animation.hierarchy || [];

		 for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			 const animationKeys = hierarchyTracks[ h ].keys;

			 // skip empty tracks
			 if ( ! animationKeys || animationKeys.length === 0 ) continue;

			 // process morph targets
			 if ( animationKeys[ 0 ].morphTargets ) {

				 // figure out all morph targets used in this track
				 const morphTargetNames = {};

				 let k;

				 for ( k = 0; k < animationKeys.length; k ++ ) {

					 if ( animationKeys[ k ].morphTargets ) {

						 for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							 morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						 }

					 }

				 }

				 // create a track for each morph target with all zero
				 // morphTargetInfluences except for the keys in which
				 // the morphTarget is named.
				 for ( const morphTargetName in morphTargetNames ) {

					 const times = [];
					 const values = [];

					 for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						 const animationKey = animationKeys[ k ];

						 times.push( animationKey.time );
						 values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					 }

					 tracks.push( new NumberKeyframeTrack$1( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				 }

				 duration = morphTargetNames.length * ( fps || 1.0 );

			 } else {

				 // ...assume skeletal animation

				 const boneName = '.bones[' + bones[ h ].name + ']';

				 addNonemptyTrack(
					 VectorKeyframeTrack$1, boneName + '.position',
					 animationKeys, 'pos', tracks );

				 addNonemptyTrack(
					 QuaternionKeyframeTrack$1, boneName + '.quaternion',
					 animationKeys, 'rot', tracks );

				 addNonemptyTrack(
					 VectorKeyframeTrack$1, boneName + '.scale',
					 animationKeys, 'scl', tracks );

			 }

		 }

		 if ( tracks.length === 0 ) {

			 return null;

		 }

		 const clip = new this( clipName, duration, tracks, blendMode );

		 return clip;

	 }

	 resetDuration() {

		 const tracks = this.tracks;
		 let duration = 0;

		 for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			 const track = this.tracks[ i ];

			 duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		 }

		 this.duration = duration;

		 return this;

	 }

	 trim() {

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 this.tracks[ i ].trim( 0, this.duration );

		 }

		 return this;

	 }

	 validate() {

		 let valid = true;

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 valid = valid && this.tracks[ i ].validate();

		 }

		 return valid;

	 }

	 optimize() {

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 this.tracks[ i ].optimize();

		 }

		 return this;

	 }

	 clone() {

		 const tracks = [];

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 tracks.push( this.tracks[ i ].clone() );

		 }

		 return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	 }

	 toJSON() {

		 return this.constructor.toJSON( this );

	 }

 }

 function getTrackTypeForValueTypeName$1( typeName ) {

	 switch ( typeName.toLowerCase() ) {

		 case 'scalar':
		 case 'double':
		 case 'float':
		 case 'number':
		 case 'integer':

			 return NumberKeyframeTrack$1;

		 case 'vector':
		 case 'vector2':
		 case 'vector3':
		 case 'vector4':

			 return VectorKeyframeTrack$1;

		 case 'color':

			 return ColorKeyframeTrack$1;

		 case 'quaternion':

			 return QuaternionKeyframeTrack$1;

		 case 'bool':
		 case 'boolean':

			 return BooleanKeyframeTrack$1;

		 case 'string':

			 return StringKeyframeTrack$1;

	 }

	 throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

 }

 function parseKeyframeTrack$1( json ) {

	 if ( json.type === undefined ) {

		 throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	 }

	 const trackType = getTrackTypeForValueTypeName$1( json.type );

	 if ( json.times === undefined ) {

		 const times = [], values = [];

		 AnimationUtils$1.flattenJSON( json.keys, times, values, 'value' );

		 json.times = times;
		 json.values = values;

	 }

	 // derived classes can define a static parse method
	 if ( trackType.parse !== undefined ) {

		 return trackType.parse( json );

	 } else {

		 // by default, we assume a constructor compatible with the base
		 return new trackType( json.name, json.times, json.values, json.interpolation );

	 }

 }

 const Cache$1 = {

	 enabled: false,

	 files: {},

	 add: function ( key, file ) {

		 if ( this.enabled === false ) return;

		 // console.log( 'THREE.Cache', 'Adding key:', key );

		 this.files[ key ] = file;

	 },

	 get: function ( key ) {

		 if ( this.enabled === false ) return;

		 // console.log( 'THREE.Cache', 'Checking key:', key );

		 return this.files[ key ];

	 },

	 remove: function ( key ) {

		 delete this.files[ key ];

	 },

	 clear: function () {

		 this.files = {};

	 }

 };

 class LoadingManager$1 {

	 constructor( onLoad, onProgress, onError ) {

		 const scope = this;

		 let isLoading = false;
		 let itemsLoaded = 0;
		 let itemsTotal = 0;
		 let urlModifier = undefined;
		 const handlers = [];

		 // Refer to #5689 for the reason why we don't set .onStart
		 // in the constructor

		 this.onStart = undefined;
		 this.onLoad = onLoad;
		 this.onProgress = onProgress;
		 this.onError = onError;

		 this.itemStart = function ( url ) {

			 itemsTotal ++;

			 if ( isLoading === false ) {

				 if ( scope.onStart !== undefined ) {

					 scope.onStart( url, itemsLoaded, itemsTotal );

				 }

			 }

			 isLoading = true;

		 };

		 this.itemEnd = function ( url ) {

			 itemsLoaded ++;

			 if ( scope.onProgress !== undefined ) {

				 scope.onProgress( url, itemsLoaded, itemsTotal );

			 }

			 if ( itemsLoaded === itemsTotal ) {

				 isLoading = false;

				 if ( scope.onLoad !== undefined ) {

					 scope.onLoad();

				 }

			 }

		 };

		 this.itemError = function ( url ) {

			 if ( scope.onError !== undefined ) {

				 scope.onError( url );

			 }

		 };

		 this.resolveURL = function ( url ) {

			 if ( urlModifier ) {

				 return urlModifier( url );

			 }

			 return url;

		 };

		 this.setURLModifier = function ( transform ) {

			 urlModifier = transform;

			 return this;

		 };

		 this.addHandler = function ( regex, loader ) {

			 handlers.push( regex, loader );

			 return this;

		 };

		 this.removeHandler = function ( regex ) {

			 const index = handlers.indexOf( regex );

			 if ( index !== - 1 ) {

				 handlers.splice( index, 2 );

			 }

			 return this;

		 };

		 this.getHandler = function ( file ) {

			 for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				 const regex = handlers[ i ];
				 const loader = handlers[ i + 1 ];

				 if ( regex.global ) regex.lastIndex = 0; // see #17920

				 if ( regex.test( file ) ) {

					 return loader;

				 }

			 }

			 return null;

		 };

	 }

 }

 const DefaultLoadingManager$1 = new LoadingManager$1();

 class Loader$1 {

	 constructor( manager ) {

		 this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

		 this.crossOrigin = 'anonymous';
		 this.withCredentials = false;
		 this.path = '';
		 this.resourcePath = '';
		 this.requestHeader = {};

	 }

	 load( /* url, onLoad, onProgress, onError */ ) {}

	 loadAsync( url, onProgress ) {

		 const scope = this;

		 return new Promise( function ( resolve, reject ) {

			 scope.load( url, resolve, onProgress, reject );

		 } );

	 }

	 parse( /* data */ ) {}

	 setCrossOrigin( crossOrigin ) {

		 this.crossOrigin = crossOrigin;
		 return this;

	 }

	 setWithCredentials( value ) {

		 this.withCredentials = value;
		 return this;

	 }

	 setPath( path ) {

		 this.path = path;
		 return this;

	 }

	 setResourcePath( resourcePath ) {

		 this.resourcePath = resourcePath;
		 return this;

	 }

	 setRequestHeader( requestHeader ) {

		 this.requestHeader = requestHeader;
		 return this;

	 }

 }

 const loading$1 = {};

 class FileLoader$1 extends Loader$1 {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 if ( url === undefined ) url = '';

		 if ( this.path !== undefined ) url = this.path + url;

		 url = this.manager.resolveURL( url );

		 const scope = this;

		 const cached = Cache$1.get( url );

		 if ( cached !== undefined ) {

			 scope.manager.itemStart( url );

			 setTimeout( function () {

				 if ( onLoad ) onLoad( cached );

				 scope.manager.itemEnd( url );

			 }, 0 );

			 return cached;

		 }

		 // Check if request is duplicate

		 if ( loading$1[ url ] !== undefined ) {

			 loading$1[ url ].push( {

				 onLoad: onLoad,
				 onProgress: onProgress,
				 onError: onError

			 } );

			 return;

		 }

		 // Check for data: URI
		 const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		 const dataUriRegexResult = url.match( dataUriRegex );
		 let request;

		 // Safari can not handle Data URIs through XMLHttpRequest so process manually
		 if ( dataUriRegexResult ) {

			 const mimeType = dataUriRegexResult[ 1 ];
			 const isBase64 = !! dataUriRegexResult[ 2 ];

			 let data = dataUriRegexResult[ 3 ];
			 data = decodeURIComponent( data );

			 if ( isBase64 ) data = atob( data );

			 try {

				 let response;
				 const responseType = ( this.responseType || '' ).toLowerCase();

				 switch ( responseType ) {

					 case 'arraybuffer':
					 case 'blob':

						 const view = new Uint8Array( data.length );

						 for ( let i = 0; i < data.length; i ++ ) {

							 view[ i ] = data.charCodeAt( i );

						 }

						 if ( responseType === 'blob' ) {

							 response = new Blob( [ view.buffer ], { type: mimeType } );

						 } else {

							 response = view.buffer;

						 }

						 break;

					 case 'document':

						 const parser = new DOMParser();
						 response = parser.parseFromString( data, mimeType );

						 break;

					 case 'json':

						 response = JSON.parse( data );

						 break;

					 default: // 'text' or other

						 response = data;

						 break;

				 }

				 // Wait for next browser tick like standard XMLHttpRequest event dispatching does
				 setTimeout( function () {

					 if ( onLoad ) onLoad( response );

					 scope.manager.itemEnd( url );

				 }, 0 );

			 } catch ( error ) {

				 // Wait for next browser tick like standard XMLHttpRequest event dispatching does
				 setTimeout( function () {

					 if ( onError ) onError( error );

					 scope.manager.itemError( url );
					 scope.manager.itemEnd( url );

				 }, 0 );

			 }

		 } else {

			 // Initialise array for duplicate requests

			 loading$1[ url ] = [];

			 loading$1[ url ].push( {

				 onLoad: onLoad,
				 onProgress: onProgress,
				 onError: onError

			 } );

			 request = new XMLHttpRequest();

			 request.open( 'GET', url, true );

			 request.addEventListener( 'load', function ( event ) {

				 const response = this.response;

				 const callbacks = loading$1[ url ];

				 delete loading$1[ url ];

				 if ( this.status === 200 || this.status === 0 ) {

					 // Some browsers return HTTP Status 0 when using non-http protocol
					 // e.g. 'file://' or 'data://'. Handle as success.

					 if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					 // Add to cache only on HTTP success, so that we do not cache
					 // error response bodies as proper responses to requests.
					 Cache$1.add( url, response );

					 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						 const callback = callbacks[ i ];
						 if ( callback.onLoad ) callback.onLoad( response );

					 }

					 scope.manager.itemEnd( url );

				 } else {

					 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						 const callback = callbacks[ i ];
						 if ( callback.onError ) callback.onError( event );

					 }

					 scope.manager.itemError( url );
					 scope.manager.itemEnd( url );

				 }

			 }, false );

			 request.addEventListener( 'progress', function ( event ) {

				 const callbacks = loading$1[ url ];

				 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					 const callback = callbacks[ i ];
					 if ( callback.onProgress ) callback.onProgress( event );

				 }

			 }, false );

			 request.addEventListener( 'error', function ( event ) {

				 const callbacks = loading$1[ url ];

				 delete loading$1[ url ];

				 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					 const callback = callbacks[ i ];
					 if ( callback.onError ) callback.onError( event );

				 }

				 scope.manager.itemError( url );
				 scope.manager.itemEnd( url );

			 }, false );

			 request.addEventListener( 'abort', function ( event ) {

				 const callbacks = loading$1[ url ];

				 delete loading$1[ url ];

				 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					 const callback = callbacks[ i ];
					 if ( callback.onError ) callback.onError( event );

				 }

				 scope.manager.itemError( url );
				 scope.manager.itemEnd( url );

			 }, false );

			 if ( this.responseType !== undefined ) request.responseType = this.responseType;
			 if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			 if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			 for ( const header in this.requestHeader ) {

				 request.setRequestHeader( header, this.requestHeader[ header ] );

			 }

			 request.send( null );

		 }

		 scope.manager.itemStart( url );

		 return request;

	 }

	 setResponseType( value ) {

		 this.responseType = value;
		 return this;

	 }

	 setMimeType( value ) {

		 this.mimeType = value;
		 return this;

	 }

 }

 class ImageLoader$1 extends Loader$1 {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 if ( this.path !== undefined ) url = this.path + url;

		 url = this.manager.resolveURL( url );

		 const scope = this;

		 const cached = Cache$1.get( url );

		 if ( cached !== undefined ) {

			 scope.manager.itemStart( url );

			 setTimeout( function () {

				 if ( onLoad ) onLoad( cached );

				 scope.manager.itemEnd( url );

			 }, 0 );

			 return cached;

		 }

		 const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		 function onImageLoad() {

			 image.removeEventListener( 'load', onImageLoad, false );
			 image.removeEventListener( 'error', onImageError, false );

			 Cache$1.add( url, this );

			 if ( onLoad ) onLoad( this );

			 scope.manager.itemEnd( url );

		 }

		 function onImageError( event ) {

			 image.removeEventListener( 'load', onImageLoad, false );
			 image.removeEventListener( 'error', onImageError, false );

			 if ( onError ) onError( event );

			 scope.manager.itemError( url );
			 scope.manager.itemEnd( url );

		 }

		 image.addEventListener( 'load', onImageLoad, false );
		 image.addEventListener( 'error', onImageError, false );

		 if ( url.substr( 0, 5 ) !== 'data:' ) {

			 if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		 }

		 scope.manager.itemStart( url );

		 image.src = url;

		 return image;

	 }

 }

 class CubeTextureLoader$1 extends Loader$1 {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( urls, onLoad, onProgress, onError ) {

		 const texture = new CubeTexture$1();

		 const loader = new ImageLoader$1( this.manager );
		 loader.setCrossOrigin( this.crossOrigin );
		 loader.setPath( this.path );

		 let loaded = 0;

		 function loadTexture( i ) {

			 loader.load( urls[ i ], function ( image ) {

				 texture.images[ i ] = image;

				 loaded ++;

				 if ( loaded === 6 ) {

					 texture.needsUpdate = true;

					 if ( onLoad ) onLoad( texture );

				 }

			 }, undefined, onError );

		 }

		 for ( let i = 0; i < urls.length; ++ i ) {

			 loadTexture( i );

		 }

		 return texture;

	 }

 }

 class TextureLoader$1 extends Loader$1 {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 const texture = new Texture$1();

		 const loader = new ImageLoader$1( this.manager );
		 loader.setCrossOrigin( this.crossOrigin );
		 loader.setPath( this.path );

		 loader.load( url, function ( image ) {

			 texture.image = image;

			 // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			 const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			 texture.format = isJPEG ? RGBFormat$1 : RGBAFormat$1;
			 texture.needsUpdate = true;

			 if ( onLoad !== undefined ) {

				 onLoad( texture );

			 }

		 }, onProgress, onError );

		 return texture;

	 }

 }

 /**************************************************************
	*	Curved Path - a curve path is simply a array of connected
	*  curves, but retains the api of a curve
	**************************************************************/

 class CurvePath$1 extends Curve$1 {

	 constructor() {

		 super();

		 this.type = 'CurvePath';

		 this.curves = [];
		 this.autoClose = false; // Automatically closes the path

	 }

	 add( curve ) {

		 this.curves.push( curve );

	 }

	 closePath() {

		 // Add a line curve if start and end of lines are not connected
		 const startPoint = this.curves[ 0 ].getPoint( 0 );
		 const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		 if ( ! startPoint.equals( endPoint ) ) {

			 this.curves.push( new LineCurve$1( endPoint, startPoint ) );

		 }

	 }

	 // To get accurate point with reference to
	 // entire path distance at time t,
	 // following has to be done:

	 // 1. Length of each sub path have to be known
	 // 2. Locate and identify type of curve
	 // 3. Get t for the curve
	 // 4. Return curve.getPointAt(t')

	 getPoint( t ) {

		 const d = t * this.getLength();
		 const curveLengths = this.getCurveLengths();
		 let i = 0;

		 // To think about boundaries points.

		 while ( i < curveLengths.length ) {

			 if ( curveLengths[ i ] >= d ) {

				 const diff = curveLengths[ i ] - d;
				 const curve = this.curves[ i ];

				 const segmentLength = curve.getLength();
				 const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				 return curve.getPointAt( u );

			 }

			 i ++;

		 }

		 return null;

		 // loop where sum != 0, sum > d , sum+1 <d

	 }

	 // We cannot use the default THREE.Curve getPoint() with getLength() because in
	 // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	 // getPoint() depends on getLength

	 getLength() {

		 const lens = this.getCurveLengths();
		 return lens[ lens.length - 1 ];

	 }

	 // cacheLengths must be recalculated.
	 updateArcLengths() {

		 this.needsUpdate = true;
		 this.cacheLengths = null;
		 this.getCurveLengths();

	 }

	 // Compute lengths and cache them
	 // We cannot overwrite getLengths() because UtoT mapping uses it.

	 getCurveLengths() {

		 // We use cache values if curves and cache array are same length

		 if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			 return this.cacheLengths;

		 }

		 // Get length of sub-curve
		 // Push sums into cached array

		 const lengths = [];
		 let sums = 0;

		 for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			 sums += this.curves[ i ].getLength();
			 lengths.push( sums );

		 }

		 this.cacheLengths = lengths;

		 return lengths;

	 }

	 getSpacedPoints( divisions = 40 ) {

		 const points = [];

		 for ( let i = 0; i <= divisions; i ++ ) {

			 points.push( this.getPoint( i / divisions ) );

		 }

		 if ( this.autoClose ) {

			 points.push( points[ 0 ] );

		 }

		 return points;

	 }

	 getPoints( divisions = 12 ) {

		 const points = [];
		 let last;

		 for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			 const curve = curves[ i ];
			 const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				 : ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					 : ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						 : divisions;

			 const pts = curve.getPoints( resolution );

			 for ( let j = 0; j < pts.length; j ++ ) {

				 const point = pts[ j ];

				 if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				 points.push( point );
				 last = point;

			 }

		 }

		 if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			 points.push( points[ 0 ] );

		 }

		 return points;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.curves = [];

		 for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			 const curve = source.curves[ i ];

			 this.curves.push( curve.clone() );

		 }

		 this.autoClose = source.autoClose;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.autoClose = this.autoClose;
		 data.curves = [];

		 for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			 const curve = this.curves[ i ];
			 data.curves.push( curve.toJSON() );

		 }

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.autoClose = json.autoClose;
		 this.curves = [];

		 for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			 const curve = json.curves[ i ];
			 this.curves.push( new Curves$1[ curve.type ]().fromJSON( curve ) );

		 }

		 return this;

	 }

 }

 class Path$1 extends CurvePath$1 {

	 constructor( points ) {

		 super();
		 this.type = 'Path';

		 this.currentPoint = new Vector2$1();

		 if ( points ) {

			 this.setFromPoints( points );

		 }

	 }

	 setFromPoints( points ) {

		 this.moveTo( points[ 0 ].x, points[ 0 ].y );

		 for ( let i = 1, l = points.length; i < l; i ++ ) {

			 this.lineTo( points[ i ].x, points[ i ].y );

		 }

		 return this;

	 }

	 moveTo( x, y ) {

		 this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		 return this;

	 }

	 lineTo( x, y ) {

		 const curve = new LineCurve$1( this.currentPoint.clone(), new Vector2$1( x, y ) );
		 this.curves.push( curve );

		 this.currentPoint.set( x, y );

		 return this;

	 }

	 quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		 const curve = new QuadraticBezierCurve$1(
			 this.currentPoint.clone(),
			 new Vector2$1( aCPx, aCPy ),
			 new Vector2$1( aX, aY )
		 );

		 this.curves.push( curve );

		 this.currentPoint.set( aX, aY );

		 return this;

	 }

	 bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		 const curve = new CubicBezierCurve$1(
			 this.currentPoint.clone(),
			 new Vector2$1( aCP1x, aCP1y ),
			 new Vector2$1( aCP2x, aCP2y ),
			 new Vector2$1( aX, aY )
		 );

		 this.curves.push( curve );

		 this.currentPoint.set( aX, aY );

		 return this;

	 }

	 splineThru( pts /*Array of Vector*/ ) {

		 const npts = [ this.currentPoint.clone() ].concat( pts );

		 const curve = new SplineCurve$1( npts );
		 this.curves.push( curve );

		 this.currentPoint.copy( pts[ pts.length - 1 ] );

		 return this;

	 }

	 arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		 const x0 = this.currentPoint.x;
		 const y0 = this.currentPoint.y;

		 this.absarc( aX + x0, aY + y0, aRadius,
			 aStartAngle, aEndAngle, aClockwise );

		 return this;

	 }

	 absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		 this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		 return this;

	 }

	 ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		 const x0 = this.currentPoint.x;
		 const y0 = this.currentPoint.y;

		 this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		 return this;

	 }

	 absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		 const curve = new EllipseCurve$1( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		 if ( this.curves.length > 0 ) {

			 // if a previous curve is present, attempt to join
			 const firstPoint = curve.getPoint( 0 );

			 if ( ! firstPoint.equals( this.currentPoint ) ) {

				 this.lineTo( firstPoint.x, firstPoint.y );

			 }

		 }

		 this.curves.push( curve );

		 const lastPoint = curve.getPoint( 1 );
		 this.currentPoint.copy( lastPoint );

		 return this;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.currentPoint.copy( source.currentPoint );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.currentPoint = this.currentPoint.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.currentPoint.fromArray( json.currentPoint );

		 return this;

	 }

 }

 class Shape$1 extends Path$1 {

	 constructor( points ) {

		 super( points );

		 this.uuid = generateUUID$1();

		 this.type = 'Shape';

		 this.holes = [];

	 }

	 getPointsHoles( divisions ) {

		 const holesPts = [];

		 for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			 holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		 }

		 return holesPts;

	 }

	 // get points of shape and holes (keypoints based on segments parameter)

	 extractPoints( divisions ) {

		 return {

			 shape: this.getPoints( divisions ),
			 holes: this.getPointsHoles( divisions )

		 };

	 }

	 copy( source ) {

		 super.copy( source );

		 this.holes = [];

		 for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			 const hole = source.holes[ i ];

			 this.holes.push( hole.clone() );

		 }

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.uuid = this.uuid;
		 data.holes = [];

		 for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			 const hole = this.holes[ i ];
			 data.holes.push( hole.toJSON() );

		 }

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.uuid = json.uuid;
		 this.holes = [];

		 for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			 const hole = json.holes[ i ];
			 this.holes.push( new Path$1().fromJSON( hole ) );

		 }

		 return this;

	 }

 }

 class Light$1 extends Object3D$1 {

	 constructor( color, intensity = 1 ) {

		 super();

		 this.type = 'Light';

		 this.color = new Color$2( color );
		 this.intensity = intensity;

	 }

	 dispose() {

		 // Empty here in base class; some subclasses override.

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );
		 this.intensity = source.intensity;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.color = this.color.getHex();
		 data.object.intensity = this.intensity;

		 if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		 if ( this.distance !== undefined ) data.object.distance = this.distance;
		 if ( this.angle !== undefined ) data.object.angle = this.angle;
		 if ( this.decay !== undefined ) data.object.decay = this.decay;
		 if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		 if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		 return data;

	 }

 }

 Light$1.prototype.isLight = true;

 class HemisphereLight$1 extends Light$1 {

	 constructor( skyColor, groundColor, intensity ) {

		 super( skyColor, intensity );

		 this.type = 'HemisphereLight';

		 this.position.copy( Object3D$1.DefaultUp );
		 this.updateMatrix();

		 this.groundColor = new Color$2( groundColor );

	 }

	 copy( source ) {

		 Light$1.prototype.copy.call( this, source );

		 this.groundColor.copy( source.groundColor );

		 return this;

	 }

 }

 HemisphereLight$1.prototype.isHemisphereLight = true;

 const _projScreenMatrix$1$1 = /*@__PURE__*/ new Matrix4$1();
 const _lightPositionWorld$1$1 = /*@__PURE__*/ new Vector3$1();
 const _lookTarget$1$1 = /*@__PURE__*/ new Vector3$1();

 class LightShadow$1 {

	 constructor( camera ) {

		 this.camera = camera;

		 this.bias = 0;
		 this.normalBias = 0;
		 this.radius = 1;

		 this.mapSize = new Vector2$1( 512, 512 );

		 this.map = null;
		 this.mapPass = null;
		 this.matrix = new Matrix4$1();

		 this.autoUpdate = true;
		 this.needsUpdate = false;

		 this._frustum = new Frustum$1();
		 this._frameExtents = new Vector2$1( 1, 1 );

		 this._viewportCount = 1;

		 this._viewports = [

			 new Vector4$1( 0, 0, 1, 1 )

		 ];

	 }

	 getViewportCount() {

		 return this._viewportCount;

	 }

	 getFrustum() {

		 return this._frustum;

	 }

	 updateMatrices( light ) {

		 const shadowCamera = this.camera;
		 const shadowMatrix = this.matrix;

		 _lightPositionWorld$1$1.setFromMatrixPosition( light.matrixWorld );
		 shadowCamera.position.copy( _lightPositionWorld$1$1 );

		 _lookTarget$1$1.setFromMatrixPosition( light.target.matrixWorld );
		 shadowCamera.lookAt( _lookTarget$1$1 );
		 shadowCamera.updateMatrixWorld();

		 _projScreenMatrix$1$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		 this._frustum.setFromProjectionMatrix( _projScreenMatrix$1$1 );

		 shadowMatrix.set(
			 0.5, 0.0, 0.0, 0.5,
			 0.0, 0.5, 0.0, 0.5,
			 0.0, 0.0, 0.5, 0.5,
			 0.0, 0.0, 0.0, 1.0
		 );

		 shadowMatrix.multiply( shadowCamera.projectionMatrix );
		 shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	 }

	 getViewport( viewportIndex ) {

		 return this._viewports[ viewportIndex ];

	 }

	 getFrameExtents() {

		 return this._frameExtents;

	 }

	 dispose() {

		 if ( this.map ) {

			 this.map.dispose();

		 }

		 if ( this.mapPass ) {

			 this.mapPass.dispose();

		 }

	 }

	 copy( source ) {

		 this.camera = source.camera.clone();

		 this.bias = source.bias;
		 this.radius = source.radius;

		 this.mapSize.copy( source.mapSize );

		 return this;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 toJSON() {

		 const object = {};

		 if ( this.bias !== 0 ) object.bias = this.bias;
		 if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		 if ( this.radius !== 1 ) object.radius = this.radius;
		 if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		 object.camera = this.camera.toJSON( false ).object;
		 delete object.camera.matrix;

		 return object;

	 }

 }

 class SpotLightShadow$1 extends LightShadow$1 {

	 constructor() {

		 super( new PerspectiveCamera$1( 50, 1, 0.5, 500 ) );

		 this.focus = 1;

	 }

	 updateMatrices( light ) {

		 const camera = this.camera;

		 const fov = RAD2DEG$1 * 2 * light.angle * this.focus;
		 const aspect = this.mapSize.width / this.mapSize.height;
		 const far = light.distance || camera.far;

		 if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			 camera.fov = fov;
			 camera.aspect = aspect;
			 camera.far = far;
			 camera.updateProjectionMatrix();

		 }

		 super.updateMatrices( light );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.focus = source.focus;

		 return this;

	 }

 }

 SpotLightShadow$1.prototype.isSpotLightShadow = true;

 class SpotLight$1 extends Light$1 {

	 constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		 super( color, intensity );

		 this.type = 'SpotLight';

		 this.position.copy( Object3D$1.DefaultUp );
		 this.updateMatrix();

		 this.target = new Object3D$1();

		 this.distance = distance;
		 this.angle = angle;
		 this.penumbra = penumbra;
		 this.decay = decay; // for physically correct lights, should be 2.

		 this.shadow = new SpotLightShadow$1();

	 }

	 get power() {

		 // intensity = power per solid angle.
		 // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 return this.intensity * Math.PI;

	 }

	 set power( power ) {

		 // intensity = power per solid angle.
		 // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 this.intensity = power / Math.PI;

	 }

	 dispose() {

		 this.shadow.dispose();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.distance = source.distance;
		 this.angle = source.angle;
		 this.penumbra = source.penumbra;
		 this.decay = source.decay;

		 this.target = source.target.clone();

		 this.shadow = source.shadow.clone();

		 return this;

	 }

 }

 SpotLight$1.prototype.isSpotLight = true;

 const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4$1();
 const _lightPositionWorld$2 = /*@__PURE__*/ new Vector3$1();
 const _lookTarget$2 = /*@__PURE__*/ new Vector3$1();

 class PointLightShadow$1 extends LightShadow$1 {

	 constructor() {

		 super( new PerspectiveCamera$1( 90, 1, 0.5, 500 ) );

		 this._frameExtents = new Vector2$1( 4, 2 );

		 this._viewportCount = 6;

		 this._viewports = [
			 // These viewports map a cube-map onto a 2D texture with the
			 // following orientation:
			 //
			 //  xzXZ
			 //   y Y
			 //
			 // X - Positive x direction
			 // x - Negative x direction
			 // Y - Positive y direction
			 // y - Negative y direction
			 // Z - Positive z direction
			 // z - Negative z direction

			 // positive X
			 new Vector4$1( 2, 1, 1, 1 ),
			 // negative X
			 new Vector4$1( 0, 1, 1, 1 ),
			 // positive Z
			 new Vector4$1( 3, 1, 1, 1 ),
			 // negative Z
			 new Vector4$1( 1, 1, 1, 1 ),
			 // positive Y
			 new Vector4$1( 3, 0, 1, 1 ),
			 // negative Y
			 new Vector4$1( 1, 0, 1, 1 )
		 ];

		 this._cubeDirections = [
			 new Vector3$1( 1, 0, 0 ), new Vector3$1( - 1, 0, 0 ), new Vector3$1( 0, 0, 1 ),
			 new Vector3$1( 0, 0, - 1 ), new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, - 1, 0 )
		 ];

		 this._cubeUps = [
			 new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 1, 0 ),
			 new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 0, 1 ),	new Vector3$1( 0, 0, - 1 )
		 ];

	 }

	 updateMatrices( light, viewportIndex = 0 ) {

		 const camera = this.camera;
		 const shadowMatrix = this.matrix;

		 const far = light.distance || camera.far;

		 if ( far !== camera.far ) {

			 camera.far = far;
			 camera.updateProjectionMatrix();

		 }

		 _lightPositionWorld$2.setFromMatrixPosition( light.matrixWorld );
		 camera.position.copy( _lightPositionWorld$2 );

		 _lookTarget$2.copy( camera.position );
		 _lookTarget$2.add( this._cubeDirections[ viewportIndex ] );
		 camera.up.copy( this._cubeUps[ viewportIndex ] );
		 camera.lookAt( _lookTarget$2 );
		 camera.updateMatrixWorld();

		 shadowMatrix.makeTranslation( - _lightPositionWorld$2.x, - _lightPositionWorld$2.y, - _lightPositionWorld$2.z );

		 _projScreenMatrix$2.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		 this._frustum.setFromProjectionMatrix( _projScreenMatrix$2 );

	 }

 }

 PointLightShadow$1.prototype.isPointLightShadow = true;

 class PointLight$1 extends Light$1 {

	 constructor( color, intensity, distance = 0, decay = 1 ) {

		 super( color, intensity );

		 this.type = 'PointLight';

		 this.distance = distance;
		 this.decay = decay; // for physically correct lights, should be 2.

		 this.shadow = new PointLightShadow$1();

	 }

	 get power() {

		 // intensity = power per solid angle.
		 // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 return this.intensity * 4 * Math.PI;

	 }

	 set power( power ) {

		 // intensity = power per solid angle.
		 // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 this.intensity = power / ( 4 * Math.PI );

	 }

	 dispose() {

		 this.shadow.dispose();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.distance = source.distance;
		 this.decay = source.decay;

		 this.shadow = source.shadow.clone();

		 return this;

	 }

 }

 PointLight$1.prototype.isPointLight = true;

 class OrthographicCamera$1 extends Camera$1 {

	 constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		 super();

		 this.type = 'OrthographicCamera';

		 this.zoom = 1;
		 this.view = null;

		 this.left = left;
		 this.right = right;
		 this.top = top;
		 this.bottom = bottom;

		 this.near = near;
		 this.far = far;

		 this.updateProjectionMatrix();

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 this.left = source.left;
		 this.right = source.right;
		 this.top = source.top;
		 this.bottom = source.bottom;
		 this.near = source.near;
		 this.far = source.far;

		 this.zoom = source.zoom;
		 this.view = source.view === null ? null : Object.assign( {}, source.view );

		 return this;

	 }

	 setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		 if ( this.view === null ) {

			 this.view = {
				 enabled: true,
				 fullWidth: 1,
				 fullHeight: 1,
				 offsetX: 0,
				 offsetY: 0,
				 width: 1,
				 height: 1
			 };

		 }

		 this.view.enabled = true;
		 this.view.fullWidth = fullWidth;
		 this.view.fullHeight = fullHeight;
		 this.view.offsetX = x;
		 this.view.offsetY = y;
		 this.view.width = width;
		 this.view.height = height;

		 this.updateProjectionMatrix();

	 }

	 clearViewOffset() {

		 if ( this.view !== null ) {

			 this.view.enabled = false;

		 }

		 this.updateProjectionMatrix();

	 }

	 updateProjectionMatrix() {

		 const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		 const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		 const cx = ( this.right + this.left ) / 2;
		 const cy = ( this.top + this.bottom ) / 2;

		 let left = cx - dx;
		 let right = cx + dx;
		 let top = cy + dy;
		 let bottom = cy - dy;

		 if ( this.view !== null && this.view.enabled ) {

			 const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			 const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			 left += scaleW * this.view.offsetX;
			 right = left + scaleW * this.view.width;
			 top -= scaleH * this.view.offsetY;
			 bottom = top - scaleH * this.view.height;

		 }

		 this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		 this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.zoom = this.zoom;
		 data.object.left = this.left;
		 data.object.right = this.right;
		 data.object.top = this.top;
		 data.object.bottom = this.bottom;
		 data.object.near = this.near;
		 data.object.far = this.far;

		 if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		 return data;

	 }

 }

 OrthographicCamera$1.prototype.isOrthographicCamera = true;

 class DirectionalLightShadow$1 extends LightShadow$1 {

	 constructor() {

		 super( new OrthographicCamera$1( - 5, 5, 5, - 5, 0.5, 500 ) );

	 }

 }

 DirectionalLightShadow$1.prototype.isDirectionalLightShadow = true;

 class DirectionalLight$1 extends Light$1 {

	 constructor( color, intensity ) {

		 super( color, intensity );

		 this.type = 'DirectionalLight';

		 this.position.copy( Object3D$1.DefaultUp );
		 this.updateMatrix();

		 this.target = new Object3D$1();

		 this.shadow = new DirectionalLightShadow$1();

	 }

	 dispose() {

		 this.shadow.dispose();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.target = source.target.clone();
		 this.shadow = source.shadow.clone();

		 return this;

	 }

 }

 DirectionalLight$1.prototype.isDirectionalLight = true;

 class AmbientLight$1 extends Light$1 {

	 constructor( color, intensity ) {

		 super( color, intensity );

		 this.type = 'AmbientLight';

	 }

 }

 AmbientLight$1.prototype.isAmbientLight = true;

 class RectAreaLight$1 extends Light$1 {

	 constructor( color, intensity, width = 10, height = 10 ) {

		 super( color, intensity );

		 this.type = 'RectAreaLight';

		 this.width = width;
		 this.height = height;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.width = source.width;
		 this.height = source.height;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.width = this.width;
		 data.object.height = this.height;

		 return data;

	 }

 }

 RectAreaLight$1.prototype.isRectAreaLight = true;

 /**
	* Primary reference:
	*   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	*
	* Secondary reference:
	*   https://www.ppsloan.org/publications/StupidSH36.pdf
	*/

 // 3-band SH defined by 9 coefficients

 class SphericalHarmonics3$1 {

	 constructor() {

		 this.coefficients = [];

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients.push( new Vector3$1() );

		 }

	 }

	 set( coefficients ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].copy( coefficients[ i ] );

		 }

		 return this;

	 }

	 zero() {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].set( 0, 0, 0 );

		 }

		 return this;

	 }

	 // get the radiance in the direction of the normal
	 // target is a Vector3
	 getAt( normal, target ) {

		 // normal is assumed to be unit length

		 const x = normal.x, y = normal.y, z = normal.z;

		 const coeff = this.coefficients;

		 // band 0
		 target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		 // band 1
		 target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		 target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		 target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		 // band 2
		 target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		 target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		 target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		 target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		 target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		 return target;

	 }

	 // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	 // target is a Vector3
	 // https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 getIrradianceAt( normal, target ) {

		 // normal is assumed to be unit length

		 const x = normal.x, y = normal.y, z = normal.z;

		 const coeff = this.coefficients;

		 // band 0
		 target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		 // band 1
		 target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		 target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		 target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		 // band 2
		 target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		 target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		 target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		 target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		 target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		 return target;

	 }

	 add( sh ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].add( sh.coefficients[ i ] );

		 }

		 return this;

	 }

	 addScaledSH( sh, s ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		 }

		 return this;

	 }

	 scale( s ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].multiplyScalar( s );

		 }

		 return this;

	 }

	 lerp( sh, alpha ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		 }

		 return this;

	 }

	 equals( sh ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 copy( sh ) {

		 return this.set( sh.coefficients );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 fromArray( array, offset = 0 ) {

		 const coefficients = this.coefficients;

		 for ( let i = 0; i < 9; i ++ ) {

			 coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		 }

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 const coefficients = this.coefficients;

		 for ( let i = 0; i < 9; i ++ ) {

			 coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		 }

		 return array;

	 }

	 // evaluate the basis functions
	 // shBasis is an Array[ 9 ]
	 static getBasisAt( normal, shBasis ) {

		 // normal is assumed to be unit length

		 const x = normal.x, y = normal.y, z = normal.z;

		 // band 0
		 shBasis[ 0 ] = 0.282095;

		 // band 1
		 shBasis[ 1 ] = 0.488603 * y;
		 shBasis[ 2 ] = 0.488603 * z;
		 shBasis[ 3 ] = 0.488603 * x;

		 // band 2
		 shBasis[ 4 ] = 1.092548 * x * y;
		 shBasis[ 5 ] = 1.092548 * y * z;
		 shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		 shBasis[ 7 ] = 1.092548 * x * z;
		 shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	 }

 }

 SphericalHarmonics3$1.prototype.isSphericalHarmonics3 = true;

 class LightProbe$1 extends Light$1 {

	 constructor( sh = new SphericalHarmonics3$1(), intensity = 1 ) {

		 super( undefined, intensity );

		 this.sh = sh;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.sh.copy( source.sh );

		 return this;

	 }

	 fromJSON( json ) {

		 this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		 this.sh.fromArray( json.sh );

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.sh = this.sh.toArray();

		 return data;

	 }

 }

 LightProbe$1.prototype.isLightProbe = true;

 class LoaderUtils$1 {

	 static decodeText( array ) {

		 if ( typeof TextDecoder !== 'undefined' ) {

			 return new TextDecoder().decode( array );

		 }

		 // Avoid the String.fromCharCode.apply(null, array) shortcut, which
		 // throws a "maximum call stack size exceeded" error for large arrays.

		 let s = '';

		 for ( let i = 0, il = array.length; i < il; i ++ ) {

			 // Implicitly assumes little-endian.
			 s += String.fromCharCode( array[ i ] );

		 }

		 try {

			 // merges multi-byte utf-8 characters.

			 return decodeURIComponent( escape( s ) );

		 } catch ( e ) { // see #16358

			 return s;

		 }

	 }

	 static extractUrlBase( url ) {

		 const index = url.lastIndexOf( '/' );

		 if ( index === - 1 ) return './';

		 return url.substr( 0, index + 1 );

	 }

 }

 class InstancedBufferGeometry$1 extends BufferGeometry$1 {

	 constructor() {

		 super();

		 this.type = 'InstancedBufferGeometry';
		 this.instanceCount = Infinity;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.instanceCount = source.instanceCount;

		 return this;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 toJSON() {

		 const data = super.toJSON( this );

		 data.instanceCount = this.instanceCount;

		 data.isInstancedBufferGeometry = true;

		 return data;

	 }

 }

 InstancedBufferGeometry$1.prototype.isInstancedBufferGeometry = true;

 class InstancedBufferAttribute$1 extends BufferAttribute$1 {

	 constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		 if ( typeof normalized === 'number' ) {

			 meshPerAttribute = normalized;

			 normalized = false;

			 console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		 }

		 super( array, itemSize, normalized );

		 this.meshPerAttribute = meshPerAttribute;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.meshPerAttribute = source.meshPerAttribute;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.meshPerAttribute = this.meshPerAttribute;

		 data.isInstancedBufferAttribute = true;

		 return data;

	 }

 }

 InstancedBufferAttribute$1.prototype.isInstancedBufferAttribute = true;

 class ImageBitmapLoader$1 extends Loader$1 {

	 constructor( manager ) {

		 super( manager );

		 if ( typeof createImageBitmap === 'undefined' ) {

			 console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		 }

		 if ( typeof fetch === 'undefined' ) {

			 console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		 }

		 this.options = { premultiplyAlpha: 'none' };

	 }

	 setOptions( options ) {

		 this.options = options;

		 return this;

	 }

	 load( url, onLoad, onProgress, onError ) {

		 if ( url === undefined ) url = '';

		 if ( this.path !== undefined ) url = this.path + url;

		 url = this.manager.resolveURL( url );

		 const scope = this;

		 const cached = Cache$1.get( url );

		 if ( cached !== undefined ) {

			 scope.manager.itemStart( url );

			 setTimeout( function () {

				 if ( onLoad ) onLoad( cached );

				 scope.manager.itemEnd( url );

			 }, 0 );

			 return cached;

		 }

		 const fetchOptions = {};
		 fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		 fetchOptions.headers = this.requestHeader;

		 fetch( url, fetchOptions ).then( function ( res ) {

			 return res.blob();

		 } ).then( function ( blob ) {

			 return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		 } ).then( function ( imageBitmap ) {

			 Cache$1.add( url, imageBitmap );

			 if ( onLoad ) onLoad( imageBitmap );

			 scope.manager.itemEnd( url );

		 } ).catch( function ( e ) {

			 if ( onError ) onError( e );

			 scope.manager.itemError( url );
			 scope.manager.itemEnd( url );

		 } );

		 scope.manager.itemStart( url );

	 }

 }

 ImageBitmapLoader$1.prototype.isImageBitmapLoader = true;

 let _context$1;

 const AudioContext$1 = {

	 getContext: function () {

		 if ( _context$1 === undefined ) {

			 _context$1 = new ( window.AudioContext || window.webkitAudioContext )();

		 }

		 return _context$1;

	 },

	 setContext: function ( value ) {

		 _context$1 = value;

	 }

 };

 class AudioLoader$1 extends Loader$1 {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 const scope = this;

		 const loader = new FileLoader$1( this.manager );
		 loader.setResponseType( 'arraybuffer' );
		 loader.setPath( this.path );
		 loader.setRequestHeader( this.requestHeader );
		 loader.setWithCredentials( this.withCredentials );
		 loader.load( url, function ( buffer ) {

			 try {

				 // Create a copy of the buffer. The `decodeAudioData` method
				 // detaches the buffer when complete, preventing reuse.
				 const bufferCopy = buffer.slice( 0 );

				 const context = AudioContext$1.getContext();
				 context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					 onLoad( audioBuffer );

				 } );

			 } catch ( e ) {

				 if ( onError ) {

					 onError( e );

				 } else {

					 console.error( e );

				 }

				 scope.manager.itemError( url );

			 }

		 }, onProgress, onError );

	 }

 }

 class HemisphereLightProbe$1 extends LightProbe$1 {

	 constructor( skyColor, groundColor, intensity = 1 ) {

		 super( undefined, intensity );

		 const color1 = new Color$2().set( skyColor );
		 const color2 = new Color$2().set( groundColor );

		 const sky = new Vector3$1( color1.r, color1.g, color1.b );
		 const ground = new Vector3$1( color2.r, color2.g, color2.b );

		 // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		 const c0 = Math.sqrt( Math.PI );
		 const c1 = c0 * Math.sqrt( 0.75 );

		 this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		 this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	 }

 }

 HemisphereLightProbe$1.prototype.isHemisphereLightProbe = true;

 class AmbientLightProbe$1 extends LightProbe$1 {

	 constructor( color, intensity = 1 ) {

		 super( undefined, intensity );

		 const color1 = new Color$2().set( color );

		 // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		 this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	 }

 }

 AmbientLightProbe$1.prototype.isAmbientLightProbe = true;

 class Clock {

	 constructor( autoStart = true ) {

		 this.autoStart = autoStart;

		 this.startTime = 0;
		 this.oldTime = 0;
		 this.elapsedTime = 0;

		 this.running = false;

	 }

	 start() {

		 this.startTime = now();

		 this.oldTime = this.startTime;
		 this.elapsedTime = 0;
		 this.running = true;

	 }

	 stop() {

		 this.getElapsedTime();
		 this.running = false;
		 this.autoStart = false;

	 }

	 getElapsedTime() {

		 this.getDelta();
		 return this.elapsedTime;

	 }

	 getDelta() {

		 let diff = 0;

		 if ( this.autoStart && ! this.running ) {

			 this.start();
			 return 0;

		 }

		 if ( this.running ) {

			 const newTime = now();

			 diff = ( newTime - this.oldTime ) / 1000;
			 this.oldTime = newTime;

			 this.elapsedTime += diff;

		 }

		 return diff;

	 }

 }

 function now() {

	 return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

 }

 class Audio$1 extends Object3D$1 {

	 constructor( listener ) {

		 super();

		 this.type = 'Audio';

		 this.listener = listener;
		 this.context = listener.context;

		 this.gain = this.context.createGain();
		 this.gain.connect( listener.getInput() );

		 this.autoplay = false;

		 this.buffer = null;
		 this.detune = 0;
		 this.loop = false;
		 this.loopStart = 0;
		 this.loopEnd = 0;
		 this.offset = 0;
		 this.duration = undefined;
		 this.playbackRate = 1;
		 this.isPlaying = false;
		 this.hasPlaybackControl = true;
		 this.source = null;
		 this.sourceType = 'empty';

		 this._startedAt = 0;
		 this._progress = 0;
		 this._connected = false;

		 this.filters = [];

	 }

	 getOutput() {

		 return this.gain;

	 }

	 setNodeSource( audioNode ) {

		 this.hasPlaybackControl = false;
		 this.sourceType = 'audioNode';
		 this.source = audioNode;
		 this.connect();

		 return this;

	 }

	 setMediaElementSource( mediaElement ) {

		 this.hasPlaybackControl = false;
		 this.sourceType = 'mediaNode';
		 this.source = this.context.createMediaElementSource( mediaElement );
		 this.connect();

		 return this;

	 }

	 setMediaStreamSource( mediaStream ) {

		 this.hasPlaybackControl = false;
		 this.sourceType = 'mediaStreamNode';
		 this.source = this.context.createMediaStreamSource( mediaStream );
		 this.connect();

		 return this;

	 }

	 setBuffer( audioBuffer ) {

		 this.buffer = audioBuffer;
		 this.sourceType = 'buffer';

		 if ( this.autoplay ) this.play();

		 return this;

	 }

	 play( delay = 0 ) {

		 if ( this.isPlaying === true ) {

			 console.warn( 'THREE.Audio: Audio is already playing.' );
			 return;

		 }

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this._startedAt = this.context.currentTime + delay;

		 const source = this.context.createBufferSource();
		 source.buffer = this.buffer;
		 source.loop = this.loop;
		 source.loopStart = this.loopStart;
		 source.loopEnd = this.loopEnd;
		 source.onended = this.onEnded.bind( this );
		 source.start( this._startedAt, this._progress + this.offset, this.duration );

		 this.isPlaying = true;

		 this.source = source;

		 this.setDetune( this.detune );
		 this.setPlaybackRate( this.playbackRate );

		 return this.connect();

	 }

	 pause() {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 if ( this.isPlaying === true ) {

			 // update current progress

			 this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			 if ( this.loop === true ) {

				 // ensure _progress does not exceed duration with looped audios

				 this._progress = this._progress % ( this.duration || this.buffer.duration );

			 }

			 this.source.stop();
			 this.source.onended = null;

			 this.isPlaying = false;

		 }

		 return this;

	 }

	 stop() {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this._progress = 0;

		 this.source.stop();
		 this.source.onended = null;
		 this.isPlaying = false;

		 return this;

	 }

	 connect() {

		 if ( this.filters.length > 0 ) {

			 this.source.connect( this.filters[ 0 ] );

			 for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				 this.filters[ i - 1 ].connect( this.filters[ i ] );

			 }

			 this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		 } else {

			 this.source.connect( this.getOutput() );

		 }

		 this._connected = true;

		 return this;

	 }

	 disconnect() {

		 if ( this.filters.length > 0 ) {

			 this.source.disconnect( this.filters[ 0 ] );

			 for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				 this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			 }

			 this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		 } else {

			 this.source.disconnect( this.getOutput() );

		 }

		 this._connected = false;

		 return this;

	 }

	 getFilters() {

		 return this.filters;

	 }

	 setFilters( value ) {

		 if ( ! value ) value = [];

		 if ( this._connected === true ) {

			 this.disconnect();
			 this.filters = value.slice();
			 this.connect();

		 } else {

			 this.filters = value.slice();

		 }

		 return this;

	 }

	 setDetune( value ) {

		 this.detune = value;

		 if ( this.source.detune === undefined ) return; // only set detune when available

		 if ( this.isPlaying === true ) {

			 this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		 }

		 return this;

	 }

	 getDetune() {

		 return this.detune;

	 }

	 getFilter() {

		 return this.getFilters()[ 0 ];

	 }

	 setFilter( filter ) {

		 return this.setFilters( filter ? [ filter ] : [] );

	 }

	 setPlaybackRate( value ) {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this.playbackRate = value;

		 if ( this.isPlaying === true ) {

			 this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		 }

		 return this;

	 }

	 getPlaybackRate() {

		 return this.playbackRate;

	 }

	 onEnded() {

		 this.isPlaying = false;

	 }

	 getLoop() {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return false;

		 }

		 return this.loop;

	 }

	 setLoop( value ) {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this.loop = value;

		 if ( this.isPlaying === true ) {

			 this.source.loop = this.loop;

		 }

		 return this;

	 }

	 setLoopStart( value ) {

		 this.loopStart = value;

		 return this;

	 }

	 setLoopEnd( value ) {

		 this.loopEnd = value;

		 return this;

	 }

	 getVolume() {

		 return this.gain.gain.value;

	 }

	 setVolume( value ) {

		 this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		 return this;

	 }

 }

 class PropertyMixer$1 {

	 constructor( binding, typeName, valueSize ) {

		 this.binding = binding;
		 this.valueSize = valueSize;

		 let mixFunction,
			 mixFunctionAdditive,
			 setIdentity;

		 // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		 //
		 // interpolators can use .buffer as their .result
		 // the data then goes to 'incoming'
		 //
		 // 'accu0' and 'accu1' are used frame-interleaved for
		 // the cumulative result and are compared to detect
		 // changes
		 //
		 // 'orig' stores the original state of the property
		 //
		 // 'add' is used for additive cumulative results
		 //
		 // 'work' is optional and is only present for quaternion types. It is used
		 // to store intermediate quaternion multiplication results

		 switch ( typeName ) {

			 case 'quaternion':
				 mixFunction = this._slerp;
				 mixFunctionAdditive = this._slerpAdditive;
				 setIdentity = this._setAdditiveIdentityQuaternion;

				 this.buffer = new Float64Array( valueSize * 6 );
				 this._workIndex = 5;
				 break;

			 case 'string':
			 case 'bool':
				 mixFunction = this._select;

				 // Use the regular mix function and for additive on these types,
				 // additive is not relevant for non-numeric types
				 mixFunctionAdditive = this._select;

				 setIdentity = this._setAdditiveIdentityOther;

				 this.buffer = new Array( valueSize * 5 );
				 break;

			 default:
				 mixFunction = this._lerp;
				 mixFunctionAdditive = this._lerpAdditive;
				 setIdentity = this._setAdditiveIdentityNumeric;

				 this.buffer = new Float64Array( valueSize * 5 );

		 }

		 this._mixBufferRegion = mixFunction;
		 this._mixBufferRegionAdditive = mixFunctionAdditive;
		 this._setIdentity = setIdentity;
		 this._origIndex = 3;
		 this._addIndex = 4;

		 this.cumulativeWeight = 0;
		 this.cumulativeWeightAdditive = 0;

		 this.useCount = 0;
		 this.referenceCount = 0;

	 }

	 // accumulate data in the 'incoming' region into 'accu<i>'
	 accumulate( accuIndex, weight ) {

		 // note: happily accumulating nothing when weight = 0, the caller knows
		 // the weight and shouldn't have made the call in the first place

		 const buffer = this.buffer,
			 stride = this.valueSize,
			 offset = accuIndex * stride + stride;

		 let currentWeight = this.cumulativeWeight;

		 if ( currentWeight === 0 ) {

			 // accuN := incoming * weight

			 for ( let i = 0; i !== stride; ++ i ) {

				 buffer[ offset + i ] = buffer[ i ];

			 }

			 currentWeight = weight;

		 } else {

			 // accuN := accuN + incoming * weight

			 currentWeight += weight;
			 const mix = weight / currentWeight;
			 this._mixBufferRegion( buffer, offset, 0, mix, stride );

		 }

		 this.cumulativeWeight = currentWeight;

	 }

	 // accumulate data in the 'incoming' region into 'add'
	 accumulateAdditive( weight ) {

		 const buffer = this.buffer,
			 stride = this.valueSize,
			 offset = stride * this._addIndex;

		 if ( this.cumulativeWeightAdditive === 0 ) {

			 // add = identity

			 this._setIdentity();

		 }

		 // add := add + incoming * weight

		 this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		 this.cumulativeWeightAdditive += weight;

	 }

	 // apply the state of 'accu<i>' to the binding when accus differ
	 apply( accuIndex ) {

		 const stride = this.valueSize,
			 buffer = this.buffer,
			 offset = accuIndex * stride + stride,

			 weight = this.cumulativeWeight,
			 weightAdditive = this.cumulativeWeightAdditive,

			 binding = this.binding;

		 this.cumulativeWeight = 0;
		 this.cumulativeWeightAdditive = 0;

		 if ( weight < 1 ) {

			 // accuN := accuN + original * ( 1 - cumulativeWeight )

			 const originalValueOffset = stride * this._origIndex;

			 this._mixBufferRegion(
				 buffer, offset, originalValueOffset, 1 - weight, stride );

		 }

		 if ( weightAdditive > 0 ) {

			 // accuN := accuN + additive accuN

			 this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		 }

		 for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			 if ( buffer[ i ] !== buffer[ i + stride ] ) {

				 // value has changed -> update scene graph

				 binding.setValue( buffer, offset );
				 break;

			 }

		 }

	 }

	 // remember the state of the bound property and copy it to both accus
	 saveOriginalState() {

		 const binding = this.binding;

		 const buffer = this.buffer,
			 stride = this.valueSize,

			 originalValueOffset = stride * this._origIndex;

		 binding.getValue( buffer, originalValueOffset );

		 // accu[0..1] := orig -- initially detect changes against the original
		 for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			 buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		 }

		 // Add to identity for additive
		 this._setIdentity();

		 this.cumulativeWeight = 0;
		 this.cumulativeWeightAdditive = 0;

	 }

	 // apply the state previously taken via 'saveOriginalState' to the binding
	 restoreOriginalState() {

		 const originalValueOffset = this.valueSize * 3;
		 this.binding.setValue( this.buffer, originalValueOffset );

	 }

	 _setAdditiveIdentityNumeric() {

		 const startIndex = this._addIndex * this.valueSize;
		 const endIndex = startIndex + this.valueSize;

		 for ( let i = startIndex; i < endIndex; i ++ ) {

			 this.buffer[ i ] = 0;

		 }

	 }

	 _setAdditiveIdentityQuaternion() {

		 this._setAdditiveIdentityNumeric();
		 this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	 }

	 _setAdditiveIdentityOther() {

		 const startIndex = this._origIndex * this.valueSize;
		 const targetIndex = this._addIndex * this.valueSize;

		 for ( let i = 0; i < this.valueSize; i ++ ) {

			 this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		 }

	 }


	 // mix functions

	 _select( buffer, dstOffset, srcOffset, t, stride ) {

		 if ( t >= 0.5 ) {

			 for ( let i = 0; i !== stride; ++ i ) {

				 buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			 }

		 }

	 }

	 _slerp( buffer, dstOffset, srcOffset, t ) {

		 Quaternion$1.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	 }

	 _slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		 const workOffset = this._workIndex * stride;

		 // Store result in intermediate buffer offset
		 Quaternion$1.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		 // Slerp to the intermediate result
		 Quaternion$1.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	 }

	 _lerp( buffer, dstOffset, srcOffset, t, stride ) {

		 const s = 1 - t;

		 for ( let i = 0; i !== stride; ++ i ) {

			 const j = dstOffset + i;

			 buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		 }

	 }

	 _lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		 for ( let i = 0; i !== stride; ++ i ) {

			 const j = dstOffset + i;

			 buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		 }

	 }

 }

 // Characters [].:/ are reserved for track binding syntax.
 const _RESERVED_CHARS_RE$1 = '\\[\\]\\.:\\/';
 const _reservedRe$1 = new RegExp( '[' + _RESERVED_CHARS_RE$1 + ']', 'g' );

 // Attempts to allow node names from any language. ES5's `\w` regexp matches
 // only latin characters, and the unicode \p{L} is not yet supported. So
 // instead, we exclude reserved characters and match everything else.
 const _wordChar$1 = '[^' + _RESERVED_CHARS_RE$1 + ']';
 const _wordCharOrDot$1 = '[^' + _RESERVED_CHARS_RE$1.replace( '\\.', '' ) + ']';

 // Parent directories, delimited by '/' or ':'. Currently unused, but must
 // be matched to parse the rest of the track name.
 const _directoryRe$1 = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar$1 );

 // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
 const _nodeRe$1 = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot$1 );

 // Object on target node, and accessor. May not contain reserved
 // characters. Accessor may contain any character except closing bracket.
 const _objectRe$1 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar$1 );

 // Property and accessor. May not contain reserved characters. Accessor may
 // contain any non-bracket characters.
 const _propertyRe$1 = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar$1 );

 const _trackRe$1 = new RegExp( ''
	 + '^'
	 + _directoryRe$1
	 + _nodeRe$1
	 + _objectRe$1
	 + _propertyRe$1
	 + '$'
 );

 const _supportedObjectNames$1 = [ 'material', 'materials', 'bones' ];

 class Composite$1 {

	 constructor( targetGroup, path, optionalParsedPath ) {

		 const parsedPath = optionalParsedPath || PropertyBinding$1.parseTrackName( path );

		 this._targetGroup = targetGroup;
		 this._bindings = targetGroup.subscribe_( path, parsedPath );

	 }

	 getValue( array, offset ) {

		 this.bind(); // bind all binding

		 const firstValidIndex = this._targetGroup.nCachedObjects_,
			 binding = this._bindings[ firstValidIndex ];

		 // and only call .getValue on the first
		 if ( binding !== undefined ) binding.getValue( array, offset );

	 }

	 setValue( array, offset ) {

		 const bindings = this._bindings;

		 for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			 bindings[ i ].setValue( array, offset );

		 }

	 }

	 bind() {

		 const bindings = this._bindings;

		 for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			 bindings[ i ].bind();

		 }

	 }

	 unbind() {

		 const bindings = this._bindings;

		 for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			 bindings[ i ].unbind();

		 }

	 }

 }

 // Note: This class uses a State pattern on a per-method basis:
 // 'bind' sets 'this.getValue' / 'setValue' and shadows the
 // prototype version of these methods with one that represents
 // the bound state. When the property is not found, the methods
 // become no-ops.
 class PropertyBinding$1 {

	 constructor( rootNode, path, parsedPath ) {

		 this.path = path;
		 this.parsedPath = parsedPath || PropertyBinding$1.parseTrackName( path );

		 this.node = PropertyBinding$1.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		 this.rootNode = rootNode;

		 // initial state of these methods that calls 'bind'
		 this.getValue = this._getValue_unbound;
		 this.setValue = this._setValue_unbound;

	 }


	 static create( root, path, parsedPath ) {

		 if ( ! ( root && root.isAnimationObjectGroup ) ) {

			 return new PropertyBinding$1( root, path, parsedPath );

		 } else {

			 return new PropertyBinding$1.Composite( root, path, parsedPath );

		 }

	 }

	 /**
		* Replaces spaces with underscores and removes unsupported characters from
		* node names, to ensure compatibility with parseTrackName().
		*
		* @param {string} name Node name to be sanitized.
		* @return {string}
		*/
	 static sanitizeNodeName( name ) {

		 return name.replace( /\s/g, '_' ).replace( _reservedRe$1, '' );

	 }

	 static parseTrackName( trackName ) {

		 const matches = _trackRe$1.exec( trackName );

		 if ( ! matches ) {

			 throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		 }

		 const results = {
			 // directoryName: matches[ 1 ], // (tschw) currently unused
			 nodeName: matches[ 2 ],
			 objectName: matches[ 3 ],
			 objectIndex: matches[ 4 ],
			 propertyName: matches[ 5 ], // required
			 propertyIndex: matches[ 6 ]
		 };

		 const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		 if ( lastDot !== undefined && lastDot !== - 1 ) {

			 const objectName = results.nodeName.substring( lastDot + 1 );

			 // Object names must be checked against an allowlist. Otherwise, there
			 // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			 // 'bar' could be the objectName, or part of a nodeName (which can
			 // include '.' characters).
			 if ( _supportedObjectNames$1.indexOf( objectName ) !== - 1 ) {

				 results.nodeName = results.nodeName.substring( 0, lastDot );
				 results.objectName = objectName;

			 }

		 }

		 if ( results.propertyName === null || results.propertyName.length === 0 ) {

			 throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		 }

		 return results;

	 }

	 static findNode( root, nodeName ) {

		 if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			 return root;

		 }

		 // search into skeleton bones.
		 if ( root.skeleton ) {

			 const bone = root.skeleton.getBoneByName( nodeName );

			 if ( bone !== undefined ) {

				 return bone;

			 }

		 }

		 // search into node subtree.
		 if ( root.children ) {

			 const searchNodeSubtree = function ( children ) {

				 for ( let i = 0; i < children.length; i ++ ) {

					 const childNode = children[ i ];

					 if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						 return childNode;

					 }

					 const result = searchNodeSubtree( childNode.children );

					 if ( result ) return result;

				 }

				 return null;

			 };

			 const subTreeNode = searchNodeSubtree( root.children );

			 if ( subTreeNode ) {

				 return subTreeNode;

			 }

		 }

		 return null;

	 }

	 // these are used to "bind" a nonexistent property
	 _getValue_unavailable() {}
	 _setValue_unavailable() {}

	 // Getters

	 _getValue_direct( buffer, offset ) {

		 buffer[ offset ] = this.node[ this.propertyName ];

	 }

	 _getValue_array( buffer, offset ) {

		 const source = this.resolvedProperty;

		 for ( let i = 0, n = source.length; i !== n; ++ i ) {

			 buffer[ offset ++ ] = source[ i ];

		 }

	 }

	 _getValue_arrayElement( buffer, offset ) {

		 buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	 }

	 _getValue_toArray( buffer, offset ) {

		 this.resolvedProperty.toArray( buffer, offset );

	 }

	 // Direct

	 _setValue_direct( buffer, offset ) {

		 this.targetObject[ this.propertyName ] = buffer[ offset ];

	 }

	 _setValue_direct_setNeedsUpdate( buffer, offset ) {

		 this.targetObject[ this.propertyName ] = buffer[ offset ];
		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 this.targetObject[ this.propertyName ] = buffer[ offset ];
		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 // EntireArray

	 _setValue_array( buffer, offset ) {

		 const dest = this.resolvedProperty;

		 for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			 dest[ i ] = buffer[ offset ++ ];

		 }

	 }

	 _setValue_array_setNeedsUpdate( buffer, offset ) {

		 const dest = this.resolvedProperty;

		 for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			 dest[ i ] = buffer[ offset ++ ];

		 }

		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 const dest = this.resolvedProperty;

		 for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			 dest[ i ] = buffer[ offset ++ ];

		 }

		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 // ArrayElement

	 _setValue_arrayElement( buffer, offset ) {

		 this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	 }

	 _setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 // HasToFromArray

	 _setValue_fromArray( buffer, offset ) {

		 this.resolvedProperty.fromArray( buffer, offset );

	 }

	 _setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty.fromArray( buffer, offset );
		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty.fromArray( buffer, offset );
		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 _getValue_unbound( targetArray, offset ) {

		 this.bind();
		 this.getValue( targetArray, offset );

	 }

	 _setValue_unbound( sourceArray, offset ) {

		 this.bind();
		 this.setValue( sourceArray, offset );

	 }

	 // create getter / setter pair for a property in the scene graph
	 bind() {

		 let targetObject = this.node;
		 const parsedPath = this.parsedPath;

		 const objectName = parsedPath.objectName;
		 const propertyName = parsedPath.propertyName;
		 let propertyIndex = parsedPath.propertyIndex;

		 if ( ! targetObject ) {

			 targetObject = PropertyBinding$1.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			 this.node = targetObject;

		 }

		 // set fail state so we can just 'return' on error
		 this.getValue = this._getValue_unavailable;
		 this.setValue = this._setValue_unavailable;

		 // ensure there is a value node
		 if ( ! targetObject ) {

			 console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			 return;

		 }

		 if ( objectName ) {

			 let objectIndex = parsedPath.objectIndex;

			 // special cases were we need to reach deeper into the hierarchy to get the face materials....
			 switch ( objectName ) {

				 case 'materials':

					 if ( ! targetObject.material ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						 return;

					 }

					 if ( ! targetObject.material.materials ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						 return;

					 }

					 targetObject = targetObject.material.materials;

					 break;

				 case 'bones':

					 if ( ! targetObject.skeleton ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						 return;

					 }

					 // potential future optimization: skip this if propertyIndex is already an integer
					 // and convert the integer string to a true integer.

					 targetObject = targetObject.skeleton.bones;

					 // support resolving morphTarget names into indices.
					 for ( let i = 0; i < targetObject.length; i ++ ) {

						 if ( targetObject[ i ].name === objectIndex ) {

							 objectIndex = i;
							 break;

						 }

					 }

					 break;

				 default:

					 if ( targetObject[ objectName ] === undefined ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						 return;

					 }

					 targetObject = targetObject[ objectName ];

			 }


			 if ( objectIndex !== undefined ) {

				 if ( targetObject[ objectIndex ] === undefined ) {

					 console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					 return;

				 }

				 targetObject = targetObject[ objectIndex ];

			 }

		 }

		 // resolve property
		 const nodeProperty = targetObject[ propertyName ];

		 if ( nodeProperty === undefined ) {

			 const nodeName = parsedPath.nodeName;

			 console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				 '.' + propertyName + ' but it wasn\'t found.', targetObject );
			 return;

		 }

		 // determine versioning scheme
		 let versioning = this.Versioning.None;

		 this.targetObject = targetObject;

		 if ( targetObject.needsUpdate !== undefined ) { // material

			 versioning = this.Versioning.NeedsUpdate;

		 } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			 versioning = this.Versioning.MatrixWorldNeedsUpdate;

		 }

		 // determine how the property gets bound
		 let bindingType = this.BindingType.Direct;

		 if ( propertyIndex !== undefined ) {

			 // access a sub element of the property array (only primitives are supported right now)

			 if ( propertyName === 'morphTargetInfluences' ) {

				 // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				 // support resolving morphTarget names into indices.
				 if ( ! targetObject.geometry ) {

					 console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					 return;

				 }

				 if ( targetObject.geometry.isBufferGeometry ) {

					 if ( ! targetObject.geometry.morphAttributes ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						 return;

					 }

					 if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						 propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					 }


				 } else {

					 console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					 return;

				 }

			 }

			 bindingType = this.BindingType.ArrayElement;

			 this.resolvedProperty = nodeProperty;
			 this.propertyIndex = propertyIndex;

		 } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			 // must use copy for Object3D.Euler/Quaternion

			 bindingType = this.BindingType.HasFromToArray;

			 this.resolvedProperty = nodeProperty;

		 } else if ( Array.isArray( nodeProperty ) ) {

			 bindingType = this.BindingType.EntireArray;

			 this.resolvedProperty = nodeProperty;

		 } else {

			 this.propertyName = propertyName;

		 }

		 // select getter / setter
		 this.getValue = this.GetterByBindingType[ bindingType ];
		 this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	 }

	 unbind() {

		 this.node = null;

		 // back to the prototype version of getValue / setValue
		 // note: avoiding to mutate the shape of 'this' via 'delete'
		 this.getValue = this._getValue_unbound;
		 this.setValue = this._setValue_unbound;

	 }

 }

 PropertyBinding$1.Composite = Composite$1;

 PropertyBinding$1.prototype.BindingType = {
	 Direct: 0,
	 EntireArray: 1,
	 ArrayElement: 2,
	 HasFromToArray: 3
 };

 PropertyBinding$1.prototype.Versioning = {
	 None: 0,
	 NeedsUpdate: 1,
	 MatrixWorldNeedsUpdate: 2
 };

 PropertyBinding$1.prototype.GetterByBindingType = [

	 PropertyBinding$1.prototype._getValue_direct,
	 PropertyBinding$1.prototype._getValue_array,
	 PropertyBinding$1.prototype._getValue_arrayElement,
	 PropertyBinding$1.prototype._getValue_toArray,

 ];

 PropertyBinding$1.prototype.SetterByBindingTypeAndVersioning = [

	 [
		 // Direct
		 PropertyBinding$1.prototype._setValue_direct,
		 PropertyBinding$1.prototype._setValue_direct_setNeedsUpdate,
		 PropertyBinding$1.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	 ], [

		 // EntireArray

		 PropertyBinding$1.prototype._setValue_array,
		 PropertyBinding$1.prototype._setValue_array_setNeedsUpdate,
		 PropertyBinding$1.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	 ], [

		 // ArrayElement
		 PropertyBinding$1.prototype._setValue_arrayElement,
		 PropertyBinding$1.prototype._setValue_arrayElement_setNeedsUpdate,
		 PropertyBinding$1.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	 ], [

		 // HasToFromArray
		 PropertyBinding$1.prototype._setValue_fromArray,
		 PropertyBinding$1.prototype._setValue_fromArray_setNeedsUpdate,
		 PropertyBinding$1.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	 ]

 ];

 class AnimationAction$1 {

	 constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		 this._mixer = mixer;
		 this._clip = clip;
		 this._localRoot = localRoot;
		 this.blendMode = blendMode;

		 const tracks = clip.tracks,
			 nTracks = tracks.length,
			 interpolants = new Array( nTracks );

		 const interpolantSettings = {
			 endingStart: ZeroCurvatureEnding$1,
			 endingEnd: ZeroCurvatureEnding$1
		 };

		 for ( let i = 0; i !== nTracks; ++ i ) {

			 const interpolant = tracks[ i ].createInterpolant( null );
			 interpolants[ i ] = interpolant;
			 interpolant.settings = interpolantSettings;

		 }

		 this._interpolantSettings = interpolantSettings;

		 this._interpolants = interpolants; // bound by the mixer

		 // inside: PropertyMixer (managed by the mixer)
		 this._propertyBindings = new Array( nTracks );

		 this._cacheIndex = null; // for the memory manager
		 this._byClipCacheIndex = null; // for the memory manager

		 this._timeScaleInterpolant = null;
		 this._weightInterpolant = null;

		 this.loop = LoopRepeat$1;
		 this._loopCount = - 1;

		 // global mixer time when the action is to be started
		 // it's set back to 'null' upon start of the action
		 this._startTime = null;

		 // scaled local time of the action
		 // gets clamped or wrapped to 0..clip.duration according to loop
		 this.time = 0;

		 this.timeScale = 1;
		 this._effectiveTimeScale = 1;

		 this.weight = 1;
		 this._effectiveWeight = 1;

		 this.repetitions = Infinity; // no. of repetitions when looping

		 this.paused = false; // true -> zero effective time scale
		 this.enabled = true; // false -> zero effective weight

		 this.clampWhenFinished = false;// keep feeding the last frame?

		 this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		 this.zeroSlopeAtEnd = true;// clips for start, loop and end

	 }

	 // State & Scheduling

	 play() {

		 this._mixer._activateAction( this );

		 return this;

	 }

	 stop() {

		 this._mixer._deactivateAction( this );

		 return this.reset();

	 }

	 reset() {

		 this.paused = false;
		 this.enabled = true;

		 this.time = 0; // restart clip
		 this._loopCount = - 1;// forget previous loops
		 this._startTime = null;// forget scheduling

		 return this.stopFading().stopWarping();

	 }

	 isRunning() {

		 return this.enabled && ! this.paused && this.timeScale !== 0 &&
			 this._startTime === null && this._mixer._isActiveAction( this );

	 }

	 // return true when play has been called
	 isScheduled() {

		 return this._mixer._isActiveAction( this );

	 }

	 startAt( time ) {

		 this._startTime = time;

		 return this;

	 }

	 setLoop( mode, repetitions ) {

		 this.loop = mode;
		 this.repetitions = repetitions;

		 return this;

	 }

	 // Weight

	 // set the weight stopping any scheduled fading
	 // although .enabled = false yields an effective weight of zero, this
	 // method does *not* change .enabled, because it would be confusing
	 setEffectiveWeight( weight ) {

		 this.weight = weight;

		 // note: same logic as when updated at runtime
		 this._effectiveWeight = this.enabled ? weight : 0;

		 return this.stopFading();

	 }

	 // return the weight considering fading and .enabled
	 getEffectiveWeight() {

		 return this._effectiveWeight;

	 }

	 fadeIn( duration ) {

		 return this._scheduleFading( duration, 0, 1 );

	 }

	 fadeOut( duration ) {

		 return this._scheduleFading( duration, 1, 0 );

	 }

	 crossFadeFrom( fadeOutAction, duration, warp ) {

		 fadeOutAction.fadeOut( duration );
		 this.fadeIn( duration );

		 if ( warp ) {

			 const fadeInDuration = this._clip.duration,
				 fadeOutDuration = fadeOutAction._clip.duration,

				 startEndRatio = fadeOutDuration / fadeInDuration,
				 endStartRatio = fadeInDuration / fadeOutDuration;

			 fadeOutAction.warp( 1.0, startEndRatio, duration );
			 this.warp( endStartRatio, 1.0, duration );

		 }

		 return this;

	 }

	 crossFadeTo( fadeInAction, duration, warp ) {

		 return fadeInAction.crossFadeFrom( this, duration, warp );

	 }

	 stopFading() {

		 const weightInterpolant = this._weightInterpolant;

		 if ( weightInterpolant !== null ) {

			 this._weightInterpolant = null;
			 this._mixer._takeBackControlInterpolant( weightInterpolant );

		 }

		 return this;

	 }

	 // Time Scale Control

	 // set the time scale stopping any scheduled warping
	 // although .paused = true yields an effective time scale of zero, this
	 // method does *not* change .paused, because it would be confusing
	 setEffectiveTimeScale( timeScale ) {

		 this.timeScale = timeScale;
		 this._effectiveTimeScale = this.paused ? 0 : timeScale;

		 return this.stopWarping();

	 }

	 // return the time scale considering warping and .paused
	 getEffectiveTimeScale() {

		 return this._effectiveTimeScale;

	 }

	 setDuration( duration ) {

		 this.timeScale = this._clip.duration / duration;

		 return this.stopWarping();

	 }

	 syncWith( action ) {

		 this.time = action.time;
		 this.timeScale = action.timeScale;

		 return this.stopWarping();

	 }

	 halt( duration ) {

		 return this.warp( this._effectiveTimeScale, 0, duration );

	 }

	 warp( startTimeScale, endTimeScale, duration ) {

		 const mixer = this._mixer,
			 now = mixer.time,
			 timeScale = this.timeScale;

		 let interpolant = this._timeScaleInterpolant;

		 if ( interpolant === null ) {

			 interpolant = mixer._lendControlInterpolant();
			 this._timeScaleInterpolant = interpolant;

		 }

		 const times = interpolant.parameterPositions,
			 values = interpolant.sampleValues;

		 times[ 0 ] = now;
		 times[ 1 ] = now + duration;

		 values[ 0 ] = startTimeScale / timeScale;
		 values[ 1 ] = endTimeScale / timeScale;

		 return this;

	 }

	 stopWarping() {

		 const timeScaleInterpolant = this._timeScaleInterpolant;

		 if ( timeScaleInterpolant !== null ) {

			 this._timeScaleInterpolant = null;
			 this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		 }

		 return this;

	 }

	 // Object Accessors

	 getMixer() {

		 return this._mixer;

	 }

	 getClip() {

		 return this._clip;

	 }

	 getRoot() {

		 return this._localRoot || this._mixer._root;

	 }

	 // Interna

	 _update( time, deltaTime, timeDirection, accuIndex ) {

		 // called by the mixer

		 if ( ! this.enabled ) {

			 // call ._updateWeight() to update ._effectiveWeight

			 this._updateWeight( time );
			 return;

		 }

		 const startTime = this._startTime;

		 if ( startTime !== null ) {

			 // check for scheduled start of action

			 const timeRunning = ( time - startTime ) * timeDirection;
			 if ( timeRunning < 0 || timeDirection === 0 ) {

				 return; // yet to come / don't decide when delta = 0

			 }

			 // start

			 this._startTime = null; // unschedule
			 deltaTime = timeDirection * timeRunning;

		 }

		 // apply time scale and advance time

		 deltaTime *= this._updateTimeScale( time );
		 const clipTime = this._updateTime( deltaTime );

		 // note: _updateTime may disable the action resulting in
		 // an effective weight of 0

		 const weight = this._updateWeight( time );

		 if ( weight > 0 ) {

			 const interpolants = this._interpolants;
			 const propertyMixers = this._propertyBindings;

			 switch ( this.blendMode ) {

				 case AdditiveAnimationBlendMode$1:

					 for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						 interpolants[ j ].evaluate( clipTime );
						 propertyMixers[ j ].accumulateAdditive( weight );

					 }

					 break;

				 case NormalAnimationBlendMode$1:
				 default:

					 for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						 interpolants[ j ].evaluate( clipTime );
						 propertyMixers[ j ].accumulate( accuIndex, weight );

					 }

			 }

		 }

	 }

	 _updateWeight( time ) {

		 let weight = 0;

		 if ( this.enabled ) {

			 weight = this.weight;
			 const interpolant = this._weightInterpolant;

			 if ( interpolant !== null ) {

				 const interpolantValue = interpolant.evaluate( time )[ 0 ];

				 weight *= interpolantValue;

				 if ( time > interpolant.parameterPositions[ 1 ] ) {

					 this.stopFading();

					 if ( interpolantValue === 0 ) {

						 // faded out, disable
						 this.enabled = false;

					 }

				 }

			 }

		 }

		 this._effectiveWeight = weight;
		 return weight;

	 }

	 _updateTimeScale( time ) {

		 let timeScale = 0;

		 if ( ! this.paused ) {

			 timeScale = this.timeScale;

			 const interpolant = this._timeScaleInterpolant;

			 if ( interpolant !== null ) {

				 const interpolantValue = interpolant.evaluate( time )[ 0 ];

				 timeScale *= interpolantValue;

				 if ( time > interpolant.parameterPositions[ 1 ] ) {

					 this.stopWarping();

					 if ( timeScale === 0 ) {

						 // motion has halted, pause
						 this.paused = true;

					 } else {

						 // warp done - apply final time scale
						 this.timeScale = timeScale;

					 }

				 }

			 }

		 }

		 this._effectiveTimeScale = timeScale;
		 return timeScale;

	 }

	 _updateTime( deltaTime ) {

		 const duration = this._clip.duration;
		 const loop = this.loop;

		 let time = this.time + deltaTime;
		 let loopCount = this._loopCount;

		 const pingPong = ( loop === LoopPingPong$1 );

		 if ( deltaTime === 0 ) {

			 if ( loopCount === - 1 ) return time;

			 return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		 }

		 if ( loop === LoopOnce$1 ) {

			 if ( loopCount === - 1 ) {

				 // just started

				 this._loopCount = 0;
				 this._setEndings( true, true, false );

			 }

			 handle_stop: {

				 if ( time >= duration ) {

					 time = duration;

				 } else if ( time < 0 ) {

					 time = 0;

				 } else {

					 this.time = time;

					 break handle_stop;

				 }

				 if ( this.clampWhenFinished ) this.paused = true;
				 else this.enabled = false;

				 this.time = time;

				 this._mixer.dispatchEvent( {
					 type: 'finished', action: this,
					 direction: deltaTime < 0 ? - 1 : 1
				 } );

			 }

		 } else { // repetitive Repeat or PingPong

			 if ( loopCount === - 1 ) {

				 // just started

				 if ( deltaTime >= 0 ) {

					 loopCount = 0;

					 this._setEndings( true, this.repetitions === 0, pingPong );

				 } else {

					 // when looping in reverse direction, the initial
					 // transition through zero counts as a repetition,
					 // so leave loopCount at -1

					 this._setEndings( this.repetitions === 0, true, pingPong );

				 }

			 }

			 if ( time >= duration || time < 0 ) {

				 // wrap around

				 const loopDelta = Math.floor( time / duration ); // signed
				 time -= duration * loopDelta;

				 loopCount += Math.abs( loopDelta );

				 const pending = this.repetitions - loopCount;

				 if ( pending <= 0 ) {

					 // have to stop (switch state, clamp time, fire event)

					 if ( this.clampWhenFinished ) this.paused = true;
					 else this.enabled = false;

					 time = deltaTime > 0 ? duration : 0;

					 this.time = time;

					 this._mixer.dispatchEvent( {
						 type: 'finished', action: this,
						 direction: deltaTime > 0 ? 1 : - 1
					 } );

				 } else {

					 // keep running

					 if ( pending === 1 ) {

						 // entering the last round

						 const atStart = deltaTime < 0;
						 this._setEndings( atStart, ! atStart, pingPong );

					 } else {

						 this._setEndings( false, false, pingPong );

					 }

					 this._loopCount = loopCount;

					 this.time = time;

					 this._mixer.dispatchEvent( {
						 type: 'loop', action: this, loopDelta: loopDelta
					 } );

				 }

			 } else {

				 this.time = time;

			 }

			 if ( pingPong && ( loopCount & 1 ) === 1 ) {

				 // invert time for the "pong round"

				 return duration - time;

			 }

		 }

		 return time;

	 }

	 _setEndings( atStart, atEnd, pingPong ) {

		 const settings = this._interpolantSettings;

		 if ( pingPong ) {

			 settings.endingStart = ZeroSlopeEnding$1;
			 settings.endingEnd = ZeroSlopeEnding$1;

		 } else {

			 // assuming for LoopOnce atStart == atEnd == true

			 if ( atStart ) {

				 settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding$1 : ZeroCurvatureEnding$1;

			 } else {

				 settings.endingStart = WrapAroundEnding$1;

			 }

			 if ( atEnd ) {

				 settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding$1 : ZeroCurvatureEnding$1;

			 } else {

				 settings.endingEnd 	 = WrapAroundEnding$1;

			 }

		 }

	 }

	 _scheduleFading( duration, weightNow, weightThen ) {

		 const mixer = this._mixer, now = mixer.time;
		 let interpolant = this._weightInterpolant;

		 if ( interpolant === null ) {

			 interpolant = mixer._lendControlInterpolant();
			 this._weightInterpolant = interpolant;

		 }

		 const times = interpolant.parameterPositions,
			 values = interpolant.sampleValues;

		 times[ 0 ] = now;
		 values[ 0 ] = weightNow;
		 times[ 1 ] = now + duration;
		 values[ 1 ] = weightThen;

		 return this;

	 }

 }

 class AnimationMixer$1 extends EventDispatcher$1 {

	 constructor( root ) {

		 super();

		 this._root = root;
		 this._initMemoryManager();
		 this._accuIndex = 0;
		 this.time = 0;
		 this.timeScale = 1.0;

	 }

	 _bindAction( action, prototypeAction ) {

		 const root = action._localRoot || this._root,
			 tracks = action._clip.tracks,
			 nTracks = tracks.length,
			 bindings = action._propertyBindings,
			 interpolants = action._interpolants,
			 rootUuid = root.uuid,
			 bindingsByRoot = this._bindingsByRootAndName;

		 let bindingsByName = bindingsByRoot[ rootUuid ];

		 if ( bindingsByName === undefined ) {

			 bindingsByName = {};
			 bindingsByRoot[ rootUuid ] = bindingsByName;

		 }

		 for ( let i = 0; i !== nTracks; ++ i ) {

			 const track = tracks[ i ],
				 trackName = track.name;

			 let binding = bindingsByName[ trackName ];

			 if ( binding !== undefined ) {

				 bindings[ i ] = binding;

			 } else {

				 binding = bindings[ i ];

				 if ( binding !== undefined ) {

					 // existing binding, make sure the cache knows

					 if ( binding._cacheIndex === null ) {

						 ++ binding.referenceCount;
						 this._addInactiveBinding( binding, rootUuid, trackName );

					 }

					 continue;

				 }

				 const path = prototypeAction && prototypeAction.
					 _propertyBindings[ i ].binding.parsedPath;

				 binding = new PropertyMixer$1(
					 PropertyBinding$1.create( root, trackName, path ),
					 track.ValueTypeName, track.getValueSize() );

				 ++ binding.referenceCount;
				 this._addInactiveBinding( binding, rootUuid, trackName );

				 bindings[ i ] = binding;

			 }

			 interpolants[ i ].resultBuffer = binding.buffer;

		 }

	 }

	 _activateAction( action ) {

		 if ( ! this._isActiveAction( action ) ) {

			 if ( action._cacheIndex === null ) {

				 // this action has been forgotten by the cache, but the user
				 // appears to be still using it -> rebind

				 const rootUuid = ( action._localRoot || this._root ).uuid,
					 clipUuid = action._clip.uuid,
					 actionsForClip = this._actionsByClip[ clipUuid ];

				 this._bindAction( action,
					 actionsForClip && actionsForClip.knownActions[ 0 ] );

				 this._addInactiveAction( action, clipUuid, rootUuid );

			 }

			 const bindings = action._propertyBindings;

			 // increment reference counts / sort out state
			 for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				 const binding = bindings[ i ];

				 if ( binding.useCount ++ === 0 ) {

					 this._lendBinding( binding );
					 binding.saveOriginalState();

				 }

			 }

			 this._lendAction( action );

		 }

	 }

	 _deactivateAction( action ) {

		 if ( this._isActiveAction( action ) ) {

			 const bindings = action._propertyBindings;

			 // decrement reference counts / sort out state
			 for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				 const binding = bindings[ i ];

				 if ( -- binding.useCount === 0 ) {

					 binding.restoreOriginalState();
					 this._takeBackBinding( binding );

				 }

			 }

			 this._takeBackAction( action );

		 }

	 }

	 // Memory manager

	 _initMemoryManager() {

		 this._actions = []; // 'nActiveActions' followed by inactive ones
		 this._nActiveActions = 0;

		 this._actionsByClip = {};
		 // inside:
		 // {
		 // 	knownActions: Array< AnimationAction > - used as prototypes
		 // 	actionByRoot: AnimationAction - lookup
		 // }


		 this._bindings = []; // 'nActiveBindings' followed by inactive ones
		 this._nActiveBindings = 0;

		 this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		 this._controlInterpolants = []; // same game as above
		 this._nActiveControlInterpolants = 0;

		 const scope = this;

		 this.stats = {

			 actions: {
				 get total() {

					 return scope._actions.length;

				 },
				 get inUse() {

					 return scope._nActiveActions;

				 }
			 },
			 bindings: {
				 get total() {

					 return scope._bindings.length;

				 },
				 get inUse() {

					 return scope._nActiveBindings;

				 }
			 },
			 controlInterpolants: {
				 get total() {

					 return scope._controlInterpolants.length;

				 },
				 get inUse() {

					 return scope._nActiveControlInterpolants;

				 }
			 }

		 };

	 }

	 // Memory management for AnimationAction objects

	 _isActiveAction( action ) {

		 const index = action._cacheIndex;
		 return index !== null && index < this._nActiveActions;

	 }

	 _addInactiveAction( action, clipUuid, rootUuid ) {

		 const actions = this._actions,
			 actionsByClip = this._actionsByClip;

		 let actionsForClip = actionsByClip[ clipUuid ];

		 if ( actionsForClip === undefined ) {

			 actionsForClip = {

				 knownActions: [ action ],
				 actionByRoot: {}

			 };

			 action._byClipCacheIndex = 0;

			 actionsByClip[ clipUuid ] = actionsForClip;

		 } else {

			 const knownActions = actionsForClip.knownActions;

			 action._byClipCacheIndex = knownActions.length;
			 knownActions.push( action );

		 }

		 action._cacheIndex = actions.length;
		 actions.push( action );

		 actionsForClip.actionByRoot[ rootUuid ] = action;

	 }

	 _removeInactiveAction( action ) {

		 const actions = this._actions,
			 lastInactiveAction = actions[ actions.length - 1 ],
			 cacheIndex = action._cacheIndex;

		 lastInactiveAction._cacheIndex = cacheIndex;
		 actions[ cacheIndex ] = lastInactiveAction;
		 actions.pop();

		 action._cacheIndex = null;


		 const clipUuid = action._clip.uuid,
			 actionsByClip = this._actionsByClip,
			 actionsForClip = actionsByClip[ clipUuid ],
			 knownActionsForClip = actionsForClip.knownActions,

			 lastKnownAction =
				 knownActionsForClip[ knownActionsForClip.length - 1 ],

			 byClipCacheIndex = action._byClipCacheIndex;

		 lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		 knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		 knownActionsForClip.pop();

		 action._byClipCacheIndex = null;


		 const actionByRoot = actionsForClip.actionByRoot,
			 rootUuid = ( action._localRoot || this._root ).uuid;

		 delete actionByRoot[ rootUuid ];

		 if ( knownActionsForClip.length === 0 ) {

			 delete actionsByClip[ clipUuid ];

		 }

		 this._removeInactiveBindingsForAction( action );

	 }

	 _removeInactiveBindingsForAction( action ) {

		 const bindings = action._propertyBindings;

		 for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			 const binding = bindings[ i ];

			 if ( -- binding.referenceCount === 0 ) {

				 this._removeInactiveBinding( binding );

			 }

		 }

	 }

	 _lendAction( action ) {

		 // [ active actions |  inactive actions  ]
		 // [  active actions >| inactive actions ]
		 //                 s        a
		 //                  <-swap->
		 //                 a        s

		 const actions = this._actions,
			 prevIndex = action._cacheIndex,

			 lastActiveIndex = this._nActiveActions ++,

			 firstInactiveAction = actions[ lastActiveIndex ];

		 action._cacheIndex = lastActiveIndex;
		 actions[ lastActiveIndex ] = action;

		 firstInactiveAction._cacheIndex = prevIndex;
		 actions[ prevIndex ] = firstInactiveAction;

	 }

	 _takeBackAction( action ) {

		 // [  active actions  | inactive actions ]
		 // [ active actions |< inactive actions  ]
		 //        a        s
		 //         <-swap->
		 //        s        a

		 const actions = this._actions,
			 prevIndex = action._cacheIndex,

			 firstInactiveIndex = -- this._nActiveActions,

			 lastActiveAction = actions[ firstInactiveIndex ];

		 action._cacheIndex = firstInactiveIndex;
		 actions[ firstInactiveIndex ] = action;

		 lastActiveAction._cacheIndex = prevIndex;
		 actions[ prevIndex ] = lastActiveAction;

	 }

	 // Memory management for PropertyMixer objects

	 _addInactiveBinding( binding, rootUuid, trackName ) {

		 const bindingsByRoot = this._bindingsByRootAndName,
			 bindings = this._bindings;

		 let bindingByName = bindingsByRoot[ rootUuid ];

		 if ( bindingByName === undefined ) {

			 bindingByName = {};
			 bindingsByRoot[ rootUuid ] = bindingByName;

		 }

		 bindingByName[ trackName ] = binding;

		 binding._cacheIndex = bindings.length;
		 bindings.push( binding );

	 }

	 _removeInactiveBinding( binding ) {

		 const bindings = this._bindings,
			 propBinding = binding.binding,
			 rootUuid = propBinding.rootNode.uuid,
			 trackName = propBinding.path,
			 bindingsByRoot = this._bindingsByRootAndName,
			 bindingByName = bindingsByRoot[ rootUuid ],

			 lastInactiveBinding = bindings[ bindings.length - 1 ],
			 cacheIndex = binding._cacheIndex;

		 lastInactiveBinding._cacheIndex = cacheIndex;
		 bindings[ cacheIndex ] = lastInactiveBinding;
		 bindings.pop();

		 delete bindingByName[ trackName ];

		 if ( Object.keys( bindingByName ).length === 0 ) {

			 delete bindingsByRoot[ rootUuid ];

		 }

	 }

	 _lendBinding( binding ) {

		 const bindings = this._bindings,
			 prevIndex = binding._cacheIndex,

			 lastActiveIndex = this._nActiveBindings ++,

			 firstInactiveBinding = bindings[ lastActiveIndex ];

		 binding._cacheIndex = lastActiveIndex;
		 bindings[ lastActiveIndex ] = binding;

		 firstInactiveBinding._cacheIndex = prevIndex;
		 bindings[ prevIndex ] = firstInactiveBinding;

	 }

	 _takeBackBinding( binding ) {

		 const bindings = this._bindings,
			 prevIndex = binding._cacheIndex,

			 firstInactiveIndex = -- this._nActiveBindings,

			 lastActiveBinding = bindings[ firstInactiveIndex ];

		 binding._cacheIndex = firstInactiveIndex;
		 bindings[ firstInactiveIndex ] = binding;

		 lastActiveBinding._cacheIndex = prevIndex;
		 bindings[ prevIndex ] = lastActiveBinding;

	 }


	 // Memory management of Interpolants for weight and time scale

	 _lendControlInterpolant() {

		 const interpolants = this._controlInterpolants,
			 lastActiveIndex = this._nActiveControlInterpolants ++;

		 let interpolant = interpolants[ lastActiveIndex ];

		 if ( interpolant === undefined ) {

			 interpolant = new LinearInterpolant$1(
				 new Float32Array( 2 ), new Float32Array( 2 ),
				 1, this._controlInterpolantsResultBuffer );

			 interpolant.__cacheIndex = lastActiveIndex;
			 interpolants[ lastActiveIndex ] = interpolant;

		 }

		 return interpolant;

	 }

	 _takeBackControlInterpolant( interpolant ) {

		 const interpolants = this._controlInterpolants,
			 prevIndex = interpolant.__cacheIndex,

			 firstInactiveIndex = -- this._nActiveControlInterpolants,

			 lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		 interpolant.__cacheIndex = firstInactiveIndex;
		 interpolants[ firstInactiveIndex ] = interpolant;

		 lastActiveInterpolant.__cacheIndex = prevIndex;
		 interpolants[ prevIndex ] = lastActiveInterpolant;

	 }

	 // return an action for a clip optionally using a custom root target
	 // object (this method allocates a lot of dynamic memory in case a
	 // previously unknown clip/root combination is specified)
	 clipAction( clip, optionalRoot, blendMode ) {

		 const root = optionalRoot || this._root,
			 rootUuid = root.uuid;

		 let clipObject = typeof clip === 'string' ? AnimationClip$1.findByName( root, clip ) : clip;

		 const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		 const actionsForClip = this._actionsByClip[ clipUuid ];
		 let prototypeAction = null;

		 if ( blendMode === undefined ) {

			 if ( clipObject !== null ) {

				 blendMode = clipObject.blendMode;

			 } else {

				 blendMode = NormalAnimationBlendMode$1;

			 }

		 }

		 if ( actionsForClip !== undefined ) {

			 const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			 if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				 return existingAction;

			 }

			 // we know the clip, so we don't have to parse all
			 // the bindings again but can just copy
			 prototypeAction = actionsForClip.knownActions[ 0 ];

			 // also, take the clip from the prototype action
			 if ( clipObject === null )
				 clipObject = prototypeAction._clip;

		 }

		 // clip must be known when specified via string
		 if ( clipObject === null ) return null;

		 // allocate all resources required to run it
		 const newAction = new AnimationAction$1( this, clipObject, optionalRoot, blendMode );

		 this._bindAction( newAction, prototypeAction );

		 // and make the action known to the memory manager
		 this._addInactiveAction( newAction, clipUuid, rootUuid );

		 return newAction;

	 }

	 // get an existing action
	 existingAction( clip, optionalRoot ) {

		 const root = optionalRoot || this._root,
			 rootUuid = root.uuid,

			 clipObject = typeof clip === 'string' ?
				 AnimationClip$1.findByName( root, clip ) : clip,

			 clipUuid = clipObject ? clipObject.uuid : clip,

			 actionsForClip = this._actionsByClip[ clipUuid ];

		 if ( actionsForClip !== undefined ) {

			 return actionsForClip.actionByRoot[ rootUuid ] || null;

		 }

		 return null;

	 }

	 // deactivates all previously scheduled actions
	 stopAllAction() {

		 const actions = this._actions,
			 nActions = this._nActiveActions;

		 for ( let i = nActions - 1; i >= 0; -- i ) {

			 actions[ i ].stop();

		 }

		 return this;

	 }

	 // advance the time and update apply the animation
	 update( deltaTime ) {

		 deltaTime *= this.timeScale;

		 const actions = this._actions,
			 nActions = this._nActiveActions,

			 time = this.time += deltaTime,
			 timeDirection = Math.sign( deltaTime ),

			 accuIndex = this._accuIndex ^= 1;

		 // run active actions

		 for ( let i = 0; i !== nActions; ++ i ) {

			 const action = actions[ i ];

			 action._update( time, deltaTime, timeDirection, accuIndex );

		 }

		 // update scene graph

		 const bindings = this._bindings,
			 nBindings = this._nActiveBindings;

		 for ( let i = 0; i !== nBindings; ++ i ) {

			 bindings[ i ].apply( accuIndex );

		 }

		 return this;

	 }

	 // Allows you to seek to a specific time in an animation.
	 setTime( timeInSeconds ) {

		 this.time = 0; // Zero out time attribute for AnimationMixer object;
		 for ( let i = 0; i < this._actions.length; i ++ ) {

			 this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		 }

		 return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	 }

	 // return this mixer's root target object
	 getRoot() {

		 return this._root;

	 }

	 // free all resources specific to a particular clip
	 uncacheClip( clip ) {

		 const actions = this._actions,
			 clipUuid = clip.uuid,
			 actionsByClip = this._actionsByClip,
			 actionsForClip = actionsByClip[ clipUuid ];

		 if ( actionsForClip !== undefined ) {

			 // note: just calling _removeInactiveAction would mess up the
			 // iteration state and also require updating the state we can
			 // just throw away

			 const actionsToRemove = actionsForClip.knownActions;

			 for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				 const action = actionsToRemove[ i ];

				 this._deactivateAction( action );

				 const cacheIndex = action._cacheIndex,
					 lastInactiveAction = actions[ actions.length - 1 ];

				 action._cacheIndex = null;
				 action._byClipCacheIndex = null;

				 lastInactiveAction._cacheIndex = cacheIndex;
				 actions[ cacheIndex ] = lastInactiveAction;
				 actions.pop();

				 this._removeInactiveBindingsForAction( action );

			 }

			 delete actionsByClip[ clipUuid ];

		 }

	 }

	 // free all resources specific to a particular root target object
	 uncacheRoot( root ) {

		 const rootUuid = root.uuid,
			 actionsByClip = this._actionsByClip;

		 for ( const clipUuid in actionsByClip ) {

			 const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				 action = actionByRoot[ rootUuid ];

			 if ( action !== undefined ) {

				 this._deactivateAction( action );
				 this._removeInactiveAction( action );

			 }

		 }

		 const bindingsByRoot = this._bindingsByRootAndName,
			 bindingByName = bindingsByRoot[ rootUuid ];

		 if ( bindingByName !== undefined ) {

			 for ( const trackName in bindingByName ) {

				 const binding = bindingByName[ trackName ];
				 binding.restoreOriginalState();
				 this._removeInactiveBinding( binding );

			 }

		 }

	 }

	 // remove a targeted clip from the cache
	 uncacheAction( clip, optionalRoot ) {

		 const action = this.existingAction( clip, optionalRoot );

		 if ( action !== null ) {

			 this._deactivateAction( action );
			 this._removeInactiveAction( action );

		 }

	 }

 }

 AnimationMixer$1.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

 class InstancedInterleavedBuffer$1 extends InterleavedBuffer$1 {

	 constructor( array, stride, meshPerAttribute = 1 ) {

		 super( array, stride );

		 this.meshPerAttribute = meshPerAttribute;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.meshPerAttribute = source.meshPerAttribute;

		 return this;

	 }

	 clone( data ) {

		 const ib = super.clone( data );

		 ib.meshPerAttribute = this.meshPerAttribute;

		 return ib;

	 }

	 toJSON( data ) {

		 const json = super.toJSON( data );

		 json.isInstancedInterleavedBuffer = true;
		 json.meshPerAttribute = this.meshPerAttribute;

		 return json;

	 }

 }

 InstancedInterleavedBuffer$1.prototype.isInstancedInterleavedBuffer = true;

 /**
	* Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	*
	* The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	* The azimuthal angle (theta) is measured from the positive z-axis.
	*/

 class Spherical {

	 constructor( radius = 1, phi = 0, theta = 0 ) {

		 this.radius = radius;
		 this.phi = phi; // polar angle
		 this.theta = theta; // azimuthal angle

		 return this;

	 }

	 set( radius, phi, theta ) {

		 this.radius = radius;
		 this.phi = phi;
		 this.theta = theta;

		 return this;

	 }

	 copy( other ) {

		 this.radius = other.radius;
		 this.phi = other.phi;
		 this.theta = other.theta;

		 return this;

	 }

	 // restrict phi to be betwee EPS and PI-EPS
	 makeSafe() {

		 const EPS = 0.000001;
		 this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		 return this;

	 }

	 setFromVector3( v ) {

		 return this.setFromCartesianCoords( v.x, v.y, v.z );

	 }

	 setFromCartesianCoords( x, y, z ) {

		 this.radius = Math.sqrt( x * x + y * y + z * z );

		 if ( this.radius === 0 ) {

			 this.theta = 0;
			 this.phi = 0;

		 } else {

			 this.theta = Math.atan2( x, z );
			 this.phi = Math.acos( clamp$1( y / this.radius, - 1, 1 ) );

		 }

		 return this;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 class ImmediateRenderObject$1 extends Object3D$1 {

	 constructor( material ) {

		 super();

		 this.material = material;
		 this.render = function ( /* renderCallback */ ) {};

		 this.hasPositions = false;
		 this.hasNormals = false;
		 this.hasColors = false;
		 this.hasUvs = false;

		 this.positionArray = null;
		 this.normalArray = null;
		 this.colorArray = null;
		 this.uvArray = null;

		 this.count = 0;

	 }

 }

 ImmediateRenderObject$1.prototype.isImmediateRenderObject = true;

 const _vector$2$1 = /*@__PURE__*/ new Vector3$1();
 const _boneMatrix$1 = /*@__PURE__*/ new Matrix4$1();
 const _matrixWorldInv$1 = /*@__PURE__*/ new Matrix4$1();


 class SkeletonHelper$1 extends LineSegments$1 {

	 constructor( object ) {

		 const bones = getBoneList$1( object );

		 const geometry = new BufferGeometry$1();

		 const vertices = [];
		 const colors = [];

		 const color1 = new Color$2( 0, 0, 1 );
		 const color2 = new Color$2( 0, 1, 0 );

		 for ( let i = 0; i < bones.length; i ++ ) {

			 const bone = bones[ i ];

			 if ( bone.parent && bone.parent.isBone ) {

				 vertices.push( 0, 0, 0 );
				 vertices.push( 0, 0, 0 );
				 colors.push( color1.r, color1.g, color1.b );
				 colors.push( color2.r, color2.g, color2.b );

			 }

		 }

		 geometry.setAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
		 geometry.setAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

		 const material = new LineBasicMaterial$1( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		 super( geometry, material );

		 this.type = 'SkeletonHelper';
		 this.isSkeletonHelper = true;

		 this.root = object;
		 this.bones = bones;

		 this.matrix = object.matrixWorld;
		 this.matrixAutoUpdate = false;

	 }

	 updateMatrixWorld( force ) {

		 const bones = this.bones;

		 const geometry = this.geometry;
		 const position = geometry.getAttribute( 'position' );

		 _matrixWorldInv$1.copy( this.root.matrixWorld ).invert();

		 for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			 const bone = bones[ i ];

			 if ( bone.parent && bone.parent.isBone ) {

				 _boneMatrix$1.multiplyMatrices( _matrixWorldInv$1, bone.matrixWorld );
				 _vector$2$1.setFromMatrixPosition( _boneMatrix$1 );
				 position.setXYZ( j, _vector$2$1.x, _vector$2$1.y, _vector$2$1.z );

				 _boneMatrix$1.multiplyMatrices( _matrixWorldInv$1, bone.parent.matrixWorld );
				 _vector$2$1.setFromMatrixPosition( _boneMatrix$1 );
				 position.setXYZ( j + 1, _vector$2$1.x, _vector$2$1.y, _vector$2$1.z );

				 j += 2;

			 }

		 }

		 geometry.getAttribute( 'position' ).needsUpdate = true;

		 super.updateMatrixWorld( force );

	 }

 }


 function getBoneList$1( object ) {

	 const boneList = [];

	 if ( object && object.isBone ) {

		 boneList.push( object );

	 }

	 for ( let i = 0; i < object.children.length; i ++ ) {

		 boneList.push.apply( boneList, getBoneList$1( object.children[ i ] ) );

	 }

	 return boneList;

 }

 class PointLightHelper extends Mesh$1 {

	 constructor( light, sphereSize, color ) {

		 const geometry = new SphereGeometry( sphereSize, 4, 2 );
		 const material = new MeshBasicMaterial$1( { wireframe: true, fog: false, toneMapped: false } );

		 super( geometry, material );

		 this.light = light;
		 this.light.updateMatrixWorld();

		 this.color = color;

		 this.type = 'PointLightHelper';

		 this.matrix = this.light.matrixWorld;
		 this.matrixAutoUpdate = false;

		 this.update();


		 /*
	 // TODO: delete this comment?
	 const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	 const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	 this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	 this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	 const d = light.distance;

	 if ( d === 0.0 ) {

		 this.lightDistance.visible = false;

	 } else {

		 this.lightDistance.scale.set( d, d, d );

	 }

	 this.add( this.lightDistance );
	 */

	 }

	 dispose() {

		 this.geometry.dispose();
		 this.material.dispose();

	 }

	 update() {

		 if ( this.color !== undefined ) {

			 this.material.color.set( this.color );

		 } else {

			 this.material.color.copy( this.light.color );

		 }

		 /*
		 const d = this.light.distance;

		 if ( d === 0.0 ) {

			 this.lightDistance.visible = false;

		 } else {

			 this.lightDistance.visible = true;
			 this.lightDistance.scale.set( d, d, d );

		 }
		 */

	 }

 }

 class GridHelper$1 extends LineSegments$1 {

	 constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		 color1 = new Color$2( color1 );
		 color2 = new Color$2( color2 );

		 const center = divisions / 2;
		 const step = size / divisions;
		 const halfSize = size / 2;

		 const vertices = [], colors = [];

		 for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			 vertices.push( - halfSize, 0, k, halfSize, 0, k );
			 vertices.push( k, 0, - halfSize, k, 0, halfSize );

			 const color = i === center ? color1 : color2;

			 color.toArray( colors, j ); j += 3;
			 color.toArray( colors, j ); j += 3;
			 color.toArray( colors, j ); j += 3;
			 color.toArray( colors, j ); j += 3;

		 }

		 const geometry = new BufferGeometry$1();
		 geometry.setAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
		 geometry.setAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

		 const material = new LineBasicMaterial$1( { vertexColors: true, toneMapped: false } );

		 super( geometry, material );

		 this.type = 'GridHelper';

	 }

 }

 class Box3Helper extends LineSegments$1 {

	 constructor( box, color = 0xffff00 ) {

		 const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		 const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		 const geometry = new BufferGeometry$1();

		 geometry.setIndex( new BufferAttribute$1( indices, 1 ) );

		 geometry.setAttribute( 'position', new Float32BufferAttribute$1( positions, 3 ) );

		 super( geometry, new LineBasicMaterial$1( { color: color, toneMapped: false } ) );

		 this.box = box;

		 this.type = 'Box3Helper';

		 this.geometry.computeBoundingSphere();

	 }

	 updateMatrixWorld( force ) {

		 const box = this.box;

		 if ( box.isEmpty() ) return;

		 box.getCenter( this.position );

		 box.getSize( this.scale );

		 this.scale.multiplyScalar( 0.5 );

		 super.updateMatrixWorld( force );

	 }

 }

 const _floatView$1 = new Float32Array( 1 );
 new Int32Array( _floatView$1.buffer );

 const backgroundMaterial$1 = new MeshBasicMaterial$1( {
	 side: BackSide$1,
	 depthWrite: false,
	 depthTest: false,
 } );
 new Mesh$1( new BoxGeometry$1(), backgroundMaterial$1 );

 //

 Curve$1.create = function ( construct, getPoint ) {

	 console.log( 'THREE.Curve.create() has been deprecated' );

	 construct.prototype = Object.create( Curve$1.prototype );
	 construct.prototype.constructor = construct;
	 construct.prototype.getPoint = getPoint;

	 return construct;

 };

 //

 Path$1.prototype.fromPoints = function ( points ) {

	 console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
	 return this.setFromPoints( points );

 };

 GridHelper$1.prototype.setColors = function () {

	 console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

 };

 SkeletonHelper$1.prototype.update = function () {

	 console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

 };

 //

 Loader$1.prototype.extractUrlBase = function ( url ) {

	 console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
	 return LoaderUtils$1.extractUrlBase( url );

 };

 Loader$1.Handlers = {

	 add: function ( /* regex, loader */ ) {

		 console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	 },

	 get: function ( /* file */ ) {

		 console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	 }

 };

 //

 Box3$1.prototype.center = function ( optionalTarget ) {

	 console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
	 return this.getCenter( optionalTarget );

 };

 Box3$1.prototype.empty = function () {

	 console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
	 return this.isEmpty();

 };

 Box3$1.prototype.isIntersectionBox = function ( box ) {

	 console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
	 return this.intersectsBox( box );

 };

 Box3$1.prototype.isIntersectionSphere = function ( sphere ) {

	 console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	 return this.intersectsSphere( sphere );

 };

 Box3$1.prototype.size = function ( optionalTarget ) {

	 console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
	 return this.getSize( optionalTarget );

 };

 //

 Sphere$1.prototype.empty = function () {

	 console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
	 return this.isEmpty();

 };

 //

 Frustum$1.prototype.setFromMatrix = function ( m ) {

	 console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	 return this.setFromProjectionMatrix( m );

 };

 //

 Matrix3$1.prototype.flattenToArrayOffset = function ( array, offset ) {

	 console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	 return this.toArray( array, offset );

 };

 Matrix3$1.prototype.multiplyVector3 = function ( vector ) {

	 console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
	 return vector.applyMatrix3( this );

 };

 Matrix3$1.prototype.multiplyVector3Array = function ( /* a */ ) {

	 console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

 };

 Matrix3$1.prototype.applyToBufferAttribute = function ( attribute ) {

	 console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
	 return attribute.applyMatrix3( this );

 };

 Matrix3$1.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	 console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

 };

 Matrix3$1.prototype.getInverse = function ( matrix ) {

	 console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	 return this.copy( matrix ).invert();

 };

 //

 Matrix4$1.prototype.extractPosition = function ( m ) {

	 console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
	 return this.copyPosition( m );

 };

 Matrix4$1.prototype.flattenToArrayOffset = function ( array, offset ) {

	 console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	 return this.toArray( array, offset );

 };

 Matrix4$1.prototype.getPosition = function () {

	 console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	 return new Vector3$1().setFromMatrixColumn( this, 3 );

 };

 Matrix4$1.prototype.setRotationFromQuaternion = function ( q ) {

	 console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	 return this.makeRotationFromQuaternion( q );

 };

 Matrix4$1.prototype.multiplyToArray = function () {

	 console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

 };

 Matrix4$1.prototype.multiplyVector3 = function ( vector ) {

	 console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	 return vector.applyMatrix4( this );

 };

 Matrix4$1.prototype.multiplyVector4 = function ( vector ) {

	 console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	 return vector.applyMatrix4( this );

 };

 Matrix4$1.prototype.multiplyVector3Array = function ( /* a */ ) {

	 console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

 };

 Matrix4$1.prototype.rotateAxis = function ( v ) {

	 console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	 v.transformDirection( this );

 };

 Matrix4$1.prototype.crossVector = function ( vector ) {

	 console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	 return vector.applyMatrix4( this );

 };

 Matrix4$1.prototype.translate = function () {

	 console.error( 'THREE.Matrix4: .translate() has been removed.' );

 };

 Matrix4$1.prototype.rotateX = function () {

	 console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

 };

 Matrix4$1.prototype.rotateY = function () {

	 console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

 };

 Matrix4$1.prototype.rotateZ = function () {

	 console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

 };

 Matrix4$1.prototype.rotateByAxis = function () {

	 console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

 };

 Matrix4$1.prototype.applyToBufferAttribute = function ( attribute ) {

	 console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
	 return attribute.applyMatrix4( this );

 };

 Matrix4$1.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	 console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

 };

 Matrix4$1.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

	 console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
	 return this.makePerspective( left, right, top, bottom, near, far );

 };

 Matrix4$1.prototype.getInverse = function ( matrix ) {

	 console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	 return this.copy( matrix ).invert();

 };

 //

 Plane$1.prototype.isIntersectionLine = function ( line ) {

	 console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	 return this.intersectsLine( line );

 };

 //

 Quaternion$1.prototype.multiplyVector3 = function ( vector ) {

	 console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	 return vector.applyQuaternion( this );

 };

 Quaternion$1.prototype.inverse = function ( ) {

	 console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
	 return this.invert();

 };

 //

 Ray$1.prototype.isIntersectionBox = function ( box ) {

	 console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
	 return this.intersectsBox( box );

 };

 Ray$1.prototype.isIntersectionPlane = function ( plane ) {

	 console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
	 return this.intersectsPlane( plane );

 };

 Ray$1.prototype.isIntersectionSphere = function ( sphere ) {

	 console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	 return this.intersectsSphere( sphere );

 };

 //

 Triangle$1.prototype.area = function () {

	 console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
	 return this.getArea();

 };

 Triangle$1.prototype.barycoordFromPoint = function ( point, target ) {

	 console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	 return this.getBarycoord( point, target );

 };

 Triangle$1.prototype.midpoint = function ( target ) {

	 console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
	 return this.getMidpoint( target );

 };

 Triangle$1.prototypenormal = function ( target ) {

	 console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	 return this.getNormal( target );

 };

 Triangle$1.prototype.plane = function ( target ) {

	 console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
	 return this.getPlane( target );

 };

 Triangle$1.barycoordFromPoint = function ( point, a, b, c, target ) {

	 console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	 return Triangle$1.getBarycoord( point, a, b, c, target );

 };

 Triangle$1.normal = function ( a, b, c, target ) {

	 console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	 return Triangle$1.getNormal( a, b, c, target );

 };

 //

 Shape$1.prototype.extractAllPoints = function ( divisions ) {

	 console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
	 return this.extractPoints( divisions );

 };

 Shape$1.prototype.extrude = function ( options ) {

	 console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
	 return new ExtrudeGeometry$1( this, options );

 };

 Shape$1.prototype.makeGeometry = function ( options ) {

	 console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
	 return new ShapeGeometry$1( this, options );

 };

 //

 Vector2$1.prototype.fromAttribute = function ( attribute, index, offset ) {

	 console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	 return this.fromBufferAttribute( attribute, index, offset );

 };

 Vector2$1.prototype.distanceToManhattan = function ( v ) {

	 console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	 return this.manhattanDistanceTo( v );

 };

 Vector2$1.prototype.lengthManhattan = function () {

	 console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
	 return this.manhattanLength();

 };

 //

 Vector3$1.prototype.setEulerFromRotationMatrix = function () {

	 console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

 };

 Vector3$1.prototype.setEulerFromQuaternion = function () {

	 console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

 };

 Vector3$1.prototype.getPositionFromMatrix = function ( m ) {

	 console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	 return this.setFromMatrixPosition( m );

 };

 Vector3$1.prototype.getScaleFromMatrix = function ( m ) {

	 console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	 return this.setFromMatrixScale( m );

 };

 Vector3$1.prototype.getColumnFromMatrix = function ( index, matrix ) {

	 console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	 return this.setFromMatrixColumn( matrix, index );

 };

 Vector3$1.prototype.applyProjection = function ( m ) {

	 console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
	 return this.applyMatrix4( m );

 };

 Vector3$1.prototype.fromAttribute = function ( attribute, index, offset ) {

	 console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	 return this.fromBufferAttribute( attribute, index, offset );

 };

 Vector3$1.prototype.distanceToManhattan = function ( v ) {

	 console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	 return this.manhattanDistanceTo( v );

 };

 Vector3$1.prototype.lengthManhattan = function () {

	 console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
	 return this.manhattanLength();

 };

 //

 Vector4$1.prototype.fromAttribute = function ( attribute, index, offset ) {

	 console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	 return this.fromBufferAttribute( attribute, index, offset );

 };

 Vector4$1.prototype.lengthManhattan = function () {

	 console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
	 return this.manhattanLength();

 };

 //

 Object3D$1.prototype.getChildByName = function ( name ) {

	 console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
	 return this.getObjectByName( name );

 };

 Object3D$1.prototype.renderDepth = function () {

	 console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

 };

 Object3D$1.prototype.translate = function ( distance, axis ) {

	 console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
	 return this.translateOnAxis( axis, distance );

 };

 Object3D$1.prototype.getWorldRotation = function () {

	 console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

 };

 Object3D$1.prototype.applyMatrix = function ( matrix ) {

	 console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
	 return this.applyMatrix4( matrix );

 };

 Object.defineProperties( Object3D$1.prototype, {

	 eulerOrder: {
		 get: function () {

			 console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			 return this.rotation.order;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			 this.rotation.order = value;

		 }
	 },
	 useQuaternion: {
		 get: function () {

			 console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		 },
		 set: function () {

			 console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		 }
	 }

 } );

 Mesh$1.prototype.setDrawMode = function () {

	 console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

 };

 Object.defineProperties( Mesh$1.prototype, {

	 drawMode: {
		 get: function () {

			 console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			 return TrianglesDrawMode$1;

		 },
		 set: function () {

			 console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		 }
	 }

 } );

 SkinnedMesh$1.prototype.initBones = function () {

	 console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

 };

 //

 PerspectiveCamera$1.prototype.setLens = function ( focalLength, filmGauge ) {

	 console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
			 'Use .setFocalLength and .filmGauge for a photographic setup.' );

	 if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	 this.setFocalLength( focalLength );

 };

 //

 Object.defineProperties( Light$1.prototype, {
	 onlyShadow: {
		 set: function () {

			 console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		 }
	 },
	 shadowCameraFov: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			 this.shadow.camera.fov = value;

		 }
	 },
	 shadowCameraLeft: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			 this.shadow.camera.left = value;

		 }
	 },
	 shadowCameraRight: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			 this.shadow.camera.right = value;

		 }
	 },
	 shadowCameraTop: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			 this.shadow.camera.top = value;

		 }
	 },
	 shadowCameraBottom: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			 this.shadow.camera.bottom = value;

		 }
	 },
	 shadowCameraNear: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			 this.shadow.camera.near = value;

		 }
	 },
	 shadowCameraFar: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			 this.shadow.camera.far = value;

		 }
	 },
	 shadowCameraVisible: {
		 set: function () {

			 console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		 }
	 },
	 shadowBias: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			 this.shadow.bias = value;

		 }
	 },
	 shadowDarkness: {
		 set: function () {

			 console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		 }
	 },
	 shadowMapWidth: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			 this.shadow.mapSize.width = value;

		 }
	 },
	 shadowMapHeight: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			 this.shadow.mapSize.height = value;

		 }
	 }
 } );

 //

 Object.defineProperties( BufferAttribute$1.prototype, {

	 length: {
		 get: function () {

			 console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			 return this.array.length;

		 }
	 },
	 dynamic: {
		 get: function () {

			 console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			 return this.usage === DynamicDrawUsage$1;

		 },
		 set: function ( /* value */ ) {

			 console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			 this.setUsage( DynamicDrawUsage$1 );

		 }
	 }

 } );

 BufferAttribute$1.prototype.setDynamic = function ( value ) {

	 console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	 this.setUsage( value === true ? DynamicDrawUsage$1 : StaticDrawUsage$1 );
	 return this;

 };

 BufferAttribute$1.prototype.copyIndicesArray = function ( /* indices */ ) {

	 console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

 },

 BufferAttribute$1.prototype.setArray = function ( /* array */ ) {

	 console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

 };

 //

 BufferGeometry$1.prototype.addIndex = function ( index ) {

	 console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
	 this.setIndex( index );

 };

 BufferGeometry$1.prototype.addAttribute = function ( name, attribute ) {

	 console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

	 if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

		 console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

		 return this.setAttribute( name, new BufferAttribute$1( arguments[ 1 ], arguments[ 2 ] ) );

	 }

	 if ( name === 'index' ) {

		 console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
		 this.setIndex( attribute );

		 return this;

	 }

	 return this.setAttribute( name, attribute );

 };

 BufferGeometry$1.prototype.addDrawCall = function ( start, count, indexOffset ) {

	 if ( indexOffset !== undefined ) {

		 console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

	 }

	 console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
	 this.addGroup( start, count );

 };

 BufferGeometry$1.prototype.clearDrawCalls = function () {

	 console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
	 this.clearGroups();

 };

 BufferGeometry$1.prototype.computeOffsets = function () {

	 console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

 };

 BufferGeometry$1.prototype.removeAttribute = function ( name ) {

	 console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

	 return this.deleteAttribute( name );

 };

 BufferGeometry$1.prototype.applyMatrix = function ( matrix ) {

	 console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
	 return this.applyMatrix4( matrix );

 };

 Object.defineProperties( BufferGeometry$1.prototype, {

	 drawcalls: {
		 get: function () {

			 console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			 return this.groups;

		 }
	 },
	 offsets: {
		 get: function () {

			 console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			 return this.groups;

		 }
	 }

 } );

 InterleavedBuffer$1.prototype.setDynamic = function ( value ) {

	 console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	 this.setUsage( value === true ? DynamicDrawUsage$1 : StaticDrawUsage$1 );
	 return this;

 };

 InterleavedBuffer$1.prototype.setArray = function ( /* array */ ) {

	 console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

 };

 //

 ExtrudeGeometry$1.prototype.getArrays = function () {

	 console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

 };

 ExtrudeGeometry$1.prototype.addShapeList = function () {

	 console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

 };

 ExtrudeGeometry$1.prototype.addShape = function () {

	 console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

 };

 //

 Scene$1.prototype.dispose = function () {

	 console.error( 'THREE.Scene: .dispose() has been removed.' );

 };

 //

 Object.defineProperties( Material$1.prototype, {

	 wrapAround: {
		 get: function () {

			 console.warn( 'THREE.Material: .wrapAround has been removed.' );

		 },
		 set: function () {

			 console.warn( 'THREE.Material: .wrapAround has been removed.' );

		 }
	 },

	 overdraw: {
		 get: function () {

			 console.warn( 'THREE.Material: .overdraw has been removed.' );

		 },
		 set: function () {

			 console.warn( 'THREE.Material: .overdraw has been removed.' );

		 }
	 },

	 wrapRGB: {
		 get: function () {

			 console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			 return new Color$2();

		 }
	 },

	 shading: {
		 get: function () {

			 console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			 this.flatShading = ( value === FlatShading$1 );

		 }
	 },

	 stencilMask: {
		 get: function () {

			 console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			 return this.stencilFuncMask;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			 this.stencilFuncMask = value;

		 }
	 }

 } );

 Object.defineProperties( ShaderMaterial$1.prototype, {

	 derivatives: {
		 get: function () {

			 console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			 return this.extensions.derivatives;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			 this.extensions.derivatives = value;

		 }
	 }

 } );

 //

 WebGLRenderer$1.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

	 console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
	 this.setRenderTarget( renderTarget );
	 this.clear( color, depth, stencil );

 };

 WebGLRenderer$1.prototype.animate = function ( callback ) {

	 console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
	 this.setAnimationLoop( callback );

 };

 WebGLRenderer$1.prototype.getCurrentRenderTarget = function () {

	 console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
	 return this.getRenderTarget();

 };

 WebGLRenderer$1.prototype.getMaxAnisotropy = function () {

	 console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
	 return this.capabilities.getMaxAnisotropy();

 };

 WebGLRenderer$1.prototype.getPrecision = function () {

	 console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
	 return this.capabilities.precision;

 };

 WebGLRenderer$1.prototype.resetGLState = function () {

	 console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
	 return this.state.reset();

 };

 WebGLRenderer$1.prototype.supportsFloatTextures = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
	 return this.extensions.get( 'OES_texture_float' );

 };

 WebGLRenderer$1.prototype.supportsHalfFloatTextures = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
	 return this.extensions.get( 'OES_texture_half_float' );

 };

 WebGLRenderer$1.prototype.supportsStandardDerivatives = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
	 return this.extensions.get( 'OES_standard_derivatives' );

 };

 WebGLRenderer$1.prototype.supportsCompressedTextureS3TC = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
	 return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

 };

 WebGLRenderer$1.prototype.supportsCompressedTexturePVRTC = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
	 return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

 };

 WebGLRenderer$1.prototype.supportsBlendMinMax = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
	 return this.extensions.get( 'EXT_blend_minmax' );

 };

 WebGLRenderer$1.prototype.supportsVertexTextures = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
	 return this.capabilities.vertexTextures;

 };

 WebGLRenderer$1.prototype.supportsInstancedArrays = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
	 return this.extensions.get( 'ANGLE_instanced_arrays' );

 };

 WebGLRenderer$1.prototype.enableScissorTest = function ( boolean ) {

	 console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
	 this.setScissorTest( boolean );

 };

 WebGLRenderer$1.prototype.initMaterial = function () {

	 console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

 };

 WebGLRenderer$1.prototype.addPrePlugin = function () {

	 console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

 };

 WebGLRenderer$1.prototype.addPostPlugin = function () {

	 console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

 };

 WebGLRenderer$1.prototype.updateShadowMap = function () {

	 console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

 };

 WebGLRenderer$1.prototype.setFaceCulling = function () {

	 console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

 };

 WebGLRenderer$1.prototype.allocTextureUnit = function () {

	 console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

 };

 WebGLRenderer$1.prototype.setTexture = function () {

	 console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

 };

 WebGLRenderer$1.prototype.setTexture2D = function () {

	 console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

 };

 WebGLRenderer$1.prototype.setTextureCube = function () {

	 console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

 };

 WebGLRenderer$1.prototype.getActiveMipMapLevel = function () {

	 console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
	 return this.getActiveMipmapLevel();

 };

 Object.defineProperties( WebGLRenderer$1.prototype, {

	 shadowMapEnabled: {
		 get: function () {

			 return this.shadowMap.enabled;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			 this.shadowMap.enabled = value;

		 }
	 },
	 shadowMapType: {
		 get: function () {

			 return this.shadowMap.type;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			 this.shadowMap.type = value;

		 }
	 },
	 shadowMapCullFace: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function ( /* value */ ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		 }
	 },
	 context: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			 return this.getContext();

		 }
	 },
	 vr: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			 return this.xr;

		 }
	 },
	 gammaInput: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			 return false;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		 }
	 },
	 gammaOutput: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			 return false;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			 this.outputEncoding = ( value === true ) ? sRGBEncoding$1 : LinearEncoding$1;

		 }
	 },
	 toneMappingWhitePoint: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			 return 1.0;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		 }
	 },

 } );

 Object.defineProperties( WebGLShadowMap$1.prototype, {

	 cullFace: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function ( /* cullFace */ ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		 }
	 },
	 renderReverseSided: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		 }
	 },
	 renderSingleSided: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		 }
	 }

 } );

 //

 Object.defineProperties( WebGLRenderTarget$1.prototype, {

	 wrapS: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			 return this.texture.wrapS;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			 this.texture.wrapS = value;

		 }
	 },
	 wrapT: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			 return this.texture.wrapT;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			 this.texture.wrapT = value;

		 }
	 },
	 magFilter: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			 return this.texture.magFilter;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			 this.texture.magFilter = value;

		 }
	 },
	 minFilter: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			 return this.texture.minFilter;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			 this.texture.minFilter = value;

		 }
	 },
	 anisotropy: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			 return this.texture.anisotropy;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			 this.texture.anisotropy = value;

		 }
	 },
	 offset: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			 return this.texture.offset;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			 this.texture.offset = value;

		 }
	 },
	 repeat: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			 return this.texture.repeat;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			 this.texture.repeat = value;

		 }
	 },
	 format: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			 return this.texture.format;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			 this.texture.format = value;

		 }
	 },
	 type: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			 return this.texture.type;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			 this.texture.type = value;

		 }
	 },
	 generateMipmaps: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			 return this.texture.generateMipmaps;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			 this.texture.generateMipmaps = value;

		 }
	 }

 } );

 //

 Audio$1.prototype.load = function ( file ) {

	 console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	 const scope = this;
	 const audioLoader = new AudioLoader$1();
	 audioLoader.load( file, function ( buffer ) {

		 scope.setBuffer( buffer );

	 } );
	 return this;

 };

 //

 CubeCamera$1.prototype.updateCubeMap = function ( renderer, scene ) {

	 console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	 return this.update( renderer, scene );

 };

 CubeCamera$1.prototype.clear = function ( renderer, color, depth, stencil ) {

	 console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	 return this.renderTarget.clear( renderer, color, depth, stencil );

 };

 ImageUtils$1.crossOrigin = undefined;

 ImageUtils$1.loadTexture = function ( url, mapping, onLoad, onError ) {

	 console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	 const loader = new TextureLoader$1();
	 loader.setCrossOrigin( this.crossOrigin );

	 const texture = loader.load( url, onLoad, undefined, onError );

	 if ( mapping ) texture.mapping = mapping;

	 return texture;

 };

 ImageUtils$1.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	 console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	 const loader = new CubeTextureLoader$1();
	 loader.setCrossOrigin( this.crossOrigin );

	 const texture = loader.load( urls, onLoad, undefined, onError );

	 if ( mapping ) texture.mapping = mapping;

	 return texture;

 };

 ImageUtils$1.loadCompressedTexture = function () {

	 console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

 };

 ImageUtils$1.loadCompressedTextureCube = function () {

	 console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

 };

 if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	 /* eslint-disable no-undef */
	 __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		 revision: REVISION$1,
	 } } ) );
	 /* eslint-enable no-undef */

 }

 if ( typeof window !== 'undefined' ) {

	 if ( window.__THREE__ ) {

		 console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	 } else {

		 window.__THREE__ = REVISION$1;

	 }

 }

var TomiFaceSVG = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 353.67 188.18\">\r\n    <defs>\r\n        <style>\r\n            .cls-1 {\r\n                fill: red;\r\n            }\r\n\r\n            .cls-2 {\r\n                fill: #ff00cf;\r\n            }\r\n\r\n            .cls-3 {\r\n                fill: red;\r\n            }\r\n        </style>\r\n    </defs>\r\n   \r\n    <path class=\"cls-3\"\r\nd=\"M65.81,1.76c28.9.3,58.2,20.4,65,51.7,6.1,28.2-7.9,56.9-35.4,70.3-32.4,15.8-69.7,3.2-85.8-22.4-3.5-5.5-6.7-11.8-7.9-18.1-6.4-33.1,4.9-62.9,39.1-75.8C48.71,4.56,57.41,3.56,65.81,1.76Z\" />\r\n    <path class=\"cls-2\"\r\n        d=\"M182.34,174.48c-15.2.2-24.8-4.4-34.3-9.2a10.48,10.48,0,0,1-4.4-3.9c-1-2.1-2-5.8-1-7a9.57,9.57,0,0,1,7.5-2.8c2.7.3,5.3,2.5,7.9,4.1q19.65,12.3,39.4,0a54.1,54.1,0,0,1,7.9-4.2c3.1-1.2,6.4-.3,7.5,2.9.7,2-.2,5-1.2,7.1-.8,1.7-2.7,3-4.4,3.9C198.14,170.08,188.64,174,182.34,174.48Z\" />\r\n   <path class=\"cls-2\" d=\"M204,160.47c-.52,2-2.5,3.8-4.4,5.1-9.5,6.8-10.1,22-22.9,21.9-12.5.2-23.74-16-34.1-23.7Z\" />\r\n    <path class=\"cls-2\"\r\n                d=\"M200.94,151.48c3.1-1.2,6.4-.3,7.5,2.9.7,2-.2,5-1.2,7.1-.8,1.7-2.7,3-4.4,3.9-9.1,4.7-18.6,8.6-24.9,9.1-15.2.2-24.8-4.4-34.3-9.2a10.48,10.48,0,0,1-4.4-3.9c-1-2.1-2-5.8-1-7a9.57,9.57,0,0,1,7.5-2.8\" />\r\n    <path class=\"cls-2\"\r\n        d=\"M203.57,164.08c-1.8,9.3-2.3,10.4-8.9,10.5-14.3.3-28.6.2-42.9.1a9.62,9.62,0,0,1-5.6-1.5c-1.6-1.3-3.5-3.8-3.2-5.5s2.8-3.3,4.6-4.3c1.3-.7,3.2-.6,4.9-.6,15,0,29.9-.1,44.9,0C199.27,162.78,201.07,163.58,203.57,164.08Z\" />\r\n    <path class=\"cls-2\"\r\n        d=\"M142.26,138.83c.1-12.7,9.9-19.5,21.6-14.9,6.1,2.4,11.2,6,13.7,12.3,2.6,6.8,5.1,13.7,7.3,20.7,2,6.4-.2,12-5.2,16.1-4.8,4-10.5,4-16,1.7a29.05,29.05,0,0,1-6.7-4.2C147.86,162.73,142.16,150.13,142.26,138.83Z\" />\r\n    <path class=\"cls-2\"\r\n        d=\"M204.23,148.41c-2.2,8.6-3.5,17.6-6.8,25.7a18.1,18.1,0,0,1-25.8,9c-6.8-3.7-12.6-8.3-16.6-15.2-3.1-5.4-7.5-10.2-10.4-15.7-5-9.4-2-13.9,8.8-14.8,5.6-.5,11.3-.8,16.7-2a99.78,99.78,0,0,0,17.8-5.7c7.1-3.1,12.2-1.1,13.9,6.6a118.57,118.57,0,0,1,1.4,11.8Z\" />\r\n    <path class=\"cls-2\"\r\n        d=\"M181.31,152.43c13,.7,24.4,9.1,33.6,21.1,2.2,2.8,2.8,6.1.1,9.1-3,3.2-6.5,3.1-9.8.6-3.1-2.4-6.6-4.8-8.8-8-6.8-10.1-27.6-11.4-37.3-.9a62.47,62.47,0,0,1-6.2,6.4c-1.7,1.5-3.8,3.4-5.8,3.5-2.7.1-6-.8-7.8-2.5-1.2-1.2-1-5.3.3-7C149.21,161.73,161.11,152.33,181.31,152.43Z\" />\r\n    \r\n    <path class=\"cls-3\"\r\n        d=\"M127.5,82.85c-1.1,3.6-1.6,6.5-2.8,9.1-12.4,26.7-42,43.5-73.8,35.4-19.6-5-35.2-17.1-43.6-36.6-3.2-7.6-1.9-10.4,5.8-10.3,36.3.2,72.5.6,108.8,1C123.3,81.45,124.5,82.05,127.5,82.85Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M65.87,3.25c22.8.6,41.2,9.5,53.4,27.7,16.6,24.7,15.5,51.6-4.3,75.7-17,20.7-50.6,25.4-74,16.2-23.9-9.3-41.1-38.6-39.5-60.4,1.6-22.3,18-45.4,38.5-52.9C48.27,6.45,57.17,5.25,65.87,3.25Zm-4,60.1h0c-.1,6-.1,12-.1,17.9,0,5.7,0,11.3.2,16.9.1,3.8,2.4,6.2,6.2,6.7s6.3-1.8,7.5-5.2a22.89,22.89,0,0,0,.8-6.9c.1-19.9.1-39.9.1-59.8,0-2.3.3-5.1-.9-6.8-1.5-2.1-4.4-4.6-6.7-4.6s-5,2.7-6.5,4.9c-1.1,1.7-.7,4.5-.7,6.8,0,10.1.1,20.1.1,30.1Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M1,63.29c-2.8-24.2,15.8-48,37.8-57.2s55.2-3.5,71.7,14.8c17.5,19.4,22,41.2,12.4,65.5a75.45,75.45,0,0,1-7.5,14c-3,4.3-7.1,6.4-13,4a210.57,210.57,0,0,0-20.8-6.8c-20-5.8-40.1-4.7-60.2-.6-9.9,2-11.2,1.7-15.7-7.3A48,48,0,0,1,1,63.29Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M65.81,1.76c28.9.3,58.2,20.4,65,51.7,6.1,28.2-7.9,56.9-35.4,70.3-32.4,15.8-69.7,3.2-85.8-22.4-3.5-5.5-6.7-11.8-7.9-18.1-6.4-33.1,4.9-62.9,39.1-75.8C48.71,4.56,57.41,3.56,65.81,1.76Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M65,1.76a79,79,0,0,1,39.5,13.6c19.9,13.2,29.7,48.4,19.3,72.8-15.9,37.4-55.8,46.5-85.7,32.7-27.5-12.7-42.6-38.6-35.8-69.5,4.6-20.9,18.1-36.1,38.6-43.7C48.58,4.66,56.88,3.66,65,1.76Zm-.2,14.3a36.85,36.85,0,0,0-4.7,0C35.78,17.86,15,40.56,14.78,65c-.2,17.3,8.4,30.1,21.3,39.7,10.5,7.8,23.2,12.2,36.7,9.8,15.8-2.8,29.2-9.6,38.3-24.2,8.4-13.4,9.2-27.2,4.3-41.1C108.48,29.76,90.08,14.56,64.78,16.06Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M6.49,92.8c-9.2-19.2-7.5-38.2,3.6-56.2,3.7-6.1,5.8-6.5,12.4-4,11.7,4.5,23.5,9.2,35.3,13.6,19.9,7.5,39.9,14.8,59.8,22.3,11.5,4.3,12.3,6.9,8.4,18.8-7.9,23.8-33.4,43.3-55.9,42.4C38.29,129.3,18.19,117.4,6.49,92.8Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M61.52,0c31.1-.2,55.2,15.5,63.9,38,7.1,18.4,6.1,36.7-3.3,54-2.9,5.4-7.9,9.7-12.1,14.4-3.3,3.7-6.7,3.5-10.5.5-13-10.3-28-16.3-44-20.2A141.69,141.69,0,0,0,15,83c-9.6.4-10.7-.5-12-10.2-2.3-17-.4-32.8,10.6-47.2C27.22,8,45,.8,61.52,0Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M29.38,94.49c33.3-9.3,64.2-23.5,92.2-43.8,5.8-4.2,9.2-2.9,9.9,4.3a114.49,114.49,0,0,1,.3,21.9c-1.5,14.1-7.7,26.8-18.4,35.6-28.9,23.8-60.4,22.2-88.4-.1-3.7-2.9-6.1-7.5-10.2-12.7C21.18,97.29,25.08,95.59,29.38,94.49Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M130.68,80.06c-5.1,20.3-16.6,34.4-34.9,42.5-19.3,8.6-39,8.1-57.7-1.7-16.2-8.5-27-22.2-31.4-40.3-.4-1.6,1.3-5.3,2.5-5.5,2.2-.5,5.7.2,7,1.7,2.7,3.3,4.5,7.3,6.3,11.2,6.6,14.2,18.4,22.4,32.6,27.5,23.4,8.3,51.2-8.8,59-26,.8-1.8,1.5-3.7,2.5-5.5C119.88,78.06,121.58,77.46,130.68,80.06Z\" />\r\n    <path class=\"cls-3\"\r\n        d=\"M49.59,72.55c-6.3-7-11.6-12.9-17-18.7C24.39,45.15,16,36.65,7.69,28c-7.5-7.9-8.4-15.4-2.6-20.9,6.9-6.7,16.5-6,23.8,1.9,11.1,12,22,24,32.9,36.2,8,8.9,8.2,9,17,.2,11-11.1,21.8-22.4,33-33.3,7.7-7.6,18.8-6.2,23.5,2.6,3,5.7,2.2,10.3-3.6,16.1-7.2,7.3-14.8,14.3-22.1,21.6-5.7,5.6-11.3,11.3-16.7,17.2-4.1,4.5-4,6.3.2,11.1,7.5,8.5,15.1,16.8,22.7,25.2,6.8,7.5,7.4,14.6,1.7,20.2-5.6,5.4-14,5.5-20.5-1-7.8-7.7-14.8-16.2-22.2-24.3-5.8-6.4-7.1-6.6-13.6-.6-5.4,5-10.5,10.2-16,15.1a90.58,90.58,0,0,1-13.4,10.4c-6.5,3.9-14.1,1.8-18.4-4.2-3.9-5.5-3.1-11.1,2.9-16.8,8-7.6,16.2-14.9,24.2-22.4C43.39,79.45,45.89,76.45,49.59,72.55Z\" />\r\n    <path class=\"cls-2\"\r\n        d=\"M182.85,157.81c-7,3.2-11.2,9.2-15.7,14.9-1.2,1.6-2,3.5-3.1,5.1-5.4,7.8-11,8-16.4.2-3.6-5.2-6.1-11.1-9.2-16.5-1.4-2.2-3-4.4-4.6-6.5-8.4,4.2-13.6,10.6-18.9,16.9-3.4,4.1-6.5,8.5-9.6,12.8-2.2,3.1-5.1,4.5-8.6,2.6-3.8-2.1-4.8-5.7-2.6-9.4a82.35,82.35,0,0,1,9.8-13.8c6.5-7.1,13.7-13.6,20.6-20.3a32,32,0,0,1,5.5-4.2c6.2-3.9,10.2-3,13.9,3.5,2.6,4.6,4.7,9.6,7.2,14.3a52.71,52.71,0,0,0,4.3,6.2c2.5-2.1,4.6-3.6,6.5-5.3,5.7-5.1,11.1-10.5,17.1-15.2,7-5.5,11.7-4.1,16,3.8,8.6,15.9,8.7,16,24.4,8a121.87,121.87,0,0,0,12-7.1c5.2-3.4,10.3-3.3,14.6.9,5.2,5.1,10,10.6,14.7,16.2,2.2,2.5,2.2,5.6-.6,8a5.83,5.83,0,0,1-8.2-.1,60.7,60.7,0,0,1-8.5-8.3c-3.4-4.3-7-4.5-11.3-2-6.6,3.8-13.4,7.3-19.6,11.7-8.2,5.8-12.3,5.4-18-3C191.15,166.41,189.25,160.41,182.85,157.81Z\" />\r\n</svg>";

const FaceBase = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352.02 352.02">
<defs><style>
.cls-1{display:none;}
.cls-2{fill:#59F4F6;}
</style></defs>
<path id="right" transform="translate(349) scale(-1 1)" class="cls-2"
d="M65.81,1.76c28.9.3,58.2,20.4,65,51.7,6.1,28.2-7.9,56.9-35.4,70.3-32.4,15.8-69.7,3.2-85.8-22.4-3.5-5.5-6.7-11.8-7.9-18.1-6.4-33.1,4.9-62.9,39.1-75.8C48.71,4.56,57.41,3.56,65.81,1.76Z" />
<path id="left" class="cls-2"
d="M65.81,1.76c28.9.3,58.2,20.4,65,51.7,6.1,28.2-7.9,56.9-35.4,70.3-32.4,15.8-69.7,3.2-85.8-22.4-3.5-5.5-6.7-11.8-7.9-18.1-6.4-33.1,4.9-62.9,39.1-75.8C48.71,4.56,57.41,3.56,65.81,1.76Z" />
<path id="mouth" class="cls-2"
d="M182.34,174.48c-15.2.2-24.8-4.4-34.3-9.2a10.48,10.48,0,0,1-4.4-3.9c-1-2.1-2-5.8-1-7a9.57,9.57,0,0,1,7.5-2.8c2.7.3,5.3,2.5,7.9,4.1q19.65,12.3,39.4,0a54.1,54.1,0,0,1,7.9-4.2c3.1-1.2,6.4-.3,7.5,2.9.7,2-.2,5-1.2,7.1-.8,1.7-2.7,3-4.4,3.9C198.14,170.08,188.64,174,182.34,174.48Z" /></svg>`;
let Cached = {};
const Facial = (w = 512, h = 512) => {

    const svgW = document.createElement('div');
    svgW.id = 'face';

    svgW.innerHTML = FaceBase;
    //svgW.style.display = 'none';
    svgW.style.background = `#000`;
    svgW.style.margin = 0;
    svgW.style.padding = 0;
    svgW.style.width = `${w}px`;
    svgW.style.height = `${h}px`;

    const svg = svgW.firstChild;
    const LeftEye = { state: 'default', path: svgW.querySelector('#left') };
    const RightEye = { state: 'default', path: svgW.querySelector('#right') };
    const Mouth = { state: 'default', path: svgW.querySelector('#mouth') };
    const ref = document.createElement('svg');
    ref.innerHTML = TomiFaceSVG;
    const lips = ref.querySelectorAll('.cls-2');
    lips.forEach(lip => {
        if (lip.id == '')
            lip.classList.add('cls-1');
    });
    const getLipPath = (id) => {
        return lips[id].getAttribute('d');
    };
    const eyes = ref.querySelectorAll('.cls-3');
    eyes.forEach(eye => {
        if (eye.id == '')
            eye.classList.add('cls-1');
    });
    console.log(lips, eyes);

    const canv = document.createElement('canvas');
    canv.width = 512;
    canv.height = 512;


    const texture = new CanvasTexture$1(canv);
    texture.flipY = false;
    const ctx = canv.getContext('2d');
    let rendering = false;
    const shield = document.createElement('img');
    shield.setAttribute('src', '/models/tomi/shield.jpg');
    const updateTexture = (ms = 0) => {
        if (!rendering && Face.needsUpdate || Face.talking) {
            rendering = true;
            ctx.clearRect(0, 0, 512, 512);
            ctx.drawImage(shield, 0, 100, 512, 470);
            const animId = `${Face._eyeLeft}_${Face._eyeRight}_${Face.talking}_${Face._lipId}`;
            // if (Face.talking && !Face.useAudio) {
            //     if (ms - Face._lastTime >= 0.15 + Face._dur) {
            //         Face.mouth.path.setAttribute('d', getLipPath(Face._lipId))
            //         Face._lipId++;
            //         Face._lipId = Face._lipId % Face._maxLip;
            //         if (Face._lipId == 0) Face._lipId = Face._minLip;
            //         Face._lastTime = ms;
            //     }
            // } else {
                Face.mouth.path.setAttribute('d', getLipPath(Face._lipId));
            //}

            const svgData = (new XMLSerializer()).serializeToString(svg);
            const img = (Cached[animId]) ? Cached[animId] : document.createElement('img');
            const scale = 2.0;
            const render = (img) => {
                let sw = img.width * scale;
                let sh = img.height * scale;
                let sx = (ctx.canvas.width - sw) / 2;
                let sy = (ctx.canvas.height - sh) / 2;
                ctx.drawImage(img, sx, sy * 1.8, sw, sh);
                Cached[animId] = img;
                texture.needsUpdate = true;
            };
            if (Cached[animId]) {
                render(img);
                rendering = false;
            } else {
                img.setAttribute("src", "data:image/svg+xml;base64," + window.btoa(unescape(encodeURIComponent(svgData))));
                img.onload = function () {
                    render(img);
                    rendering = false;
                };
            }
            Face.needsUpdate = false;
        }
    };
    svgW.appendChild(canv);

    const Face = {
        rendering: false,
        left: LeftEye, right: RightEye, mouthState: 'default', mouth: Mouth, texture: texture, state: `happy`, talking: false,
        _lastTime: 0,
        _currTime: 0,
        _dur: 0,
        _eyeLeft: 5,
        _eyeRight: 5,
        _lipId: 1,
        _minLip: 0,
        _maxLip: 4,
        needsUpdate: true,
        useAudio: true,
        lips: lips,
        eyes: eyes,
        autoAnimate: true,
        reset: () => {
            Cached = {};
            Face.setEyes(5);
            Face.setLip(0);

        },
        action(eyeLeft, eyeRight = -1, lip = -1, duration = 800) {
            const prevLeft = Face._eyeLeft;
            const prevRight = Face._eyeRight;
            const prevLip = Face._lipId;
            const talking = Face.talking;
            Face.setEyes(eyeLeft, eyeRight);
            if (lip > -1) {
                Face.talking = false;
                Face.setLip(lip);
            }
            if (duration > 0) {
                setTimeout(_ => {
                    Face.setEyes(prevLeft, prevRight);
                    if (lip > -1) {
                        Face.setLip(prevLip);
                        Face.talking = talking;
                    }
                }, duration);
            }

        },
        setLip: (index) => {
            Face._lipId = index;
            const l = Face.lips[index].getAttribute('d');
            Face.mouth.path.setAttribute('d', l);
            Face.needsUpdate = true;
        },
        setEyes: (index, index2 = -1) => {
            index2 = (index2 > -1) ? index2 : index;
            Face._eyeLeft = index;
            Face._eyeRight = index2;
            const l = Face.eyes[index].getAttribute('d');
            const r = Face.eyes[index2].getAttribute('d');
            Face.left.path.setAttribute('d', l);
            Face.right.path.setAttribute('d', r);
            Face.needsUpdate = true;
        },
        update: updateTexture,
        setState: (s, duration = 0) => {
            let e;
            if (duration) {
                e = Face.state;
            }
            // Face._dur = duration;
            Face.state = s;
            UpdatePath('left', s, false);
            if (s == 'wink') s = 'default';
            UpdatePath('right', s, true);

            if (e) {
                setTimeout(() => {
                    Face.setState(e);
                }, duration);
            }
        },
        states: [],
    };

    const faceTexture = new MeshBasicMaterial$1({
        map: texture,
        metalness: 0.4,
        roughness: 0.4,
        reflectivity: 0.5,
    });
    return {
        svg,
        Face,
        faceTexture,
    }
};

export const setupFacial = (tomi) => {
    const {svg, Face, faceTexture} = TomiFace;
    tomi.face = Face;
   if(tomi._face) tomi._face.material = faceTexture;
    tomi.facial = TomiFace;
};

class Emitter {
  constructor() {
    this.$listeners = {};
  }

  on(type, listener) {
    if (!this.$listeners[type]) {
      this.$listeners[type] = {};
    }
    this.$listeners[type][listener.name] = listener;
  }

  off(type, listener) {
    if (this.$listeners[type][listener.name]) {
      delete this.$listeners[type][listener.name];
    }
  }

  emit(type, ...args) {
    if (this.$listeners[type]) {
      for (let k in this.$listeners[type]) {
        const fn = this.$listeners[type][k];
        fn.apply(null, [...args]);
      }
    }
  }
}

class GLTFLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = LoaderUtils$1.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new FileLoader$1( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let content;
		const extensions = {};
		const plugins = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			const magic = LoaderUtils$1.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = LoaderUtils$1.decodeText( new Uint8Array( data ) );

			}

		}

		const json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension$1();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new Color$2( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new DirectionalLight$1( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new PointLight$1( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new SpotLight$1( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension$1 {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return MeshBasicMaterial$1;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new Color$2( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial$1;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
				materialParams.clearcoatNormalScale = new Vector2$1( scale, - scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial$1;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const source = json.images[ extension.source ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const result = new ArrayBuffer( count * stride );
				const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: LoaderUtils$1.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = LoaderUtils$1.decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial$1 {

	constructor( params ) {

		super();

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		const specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		const glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		const specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	texelSpecular = sRGBToLinear( texelSpecular );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		const glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		const lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.specularRoughness += geometryRoughness;',
			'material.specularRoughness = min( material.specularRoughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		const uniforms = {
			specular: { value: new Color$2().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( const uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	copy( source ) {

		super.copy( source );

		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	}

}


class GLTFMaterialsPbrSpecularGlossinessExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

		this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity',
			'refractionRatio',
		];

	}

	getMaterialType() {

		return GLTFMeshStandardSGMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

		materialParams.color = new Color$2( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const pending = [];

		if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

			const array = pbrSpecularGlossiness.diffuseFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

		}

		materialParams.emissive = new Color$2( 0.0, 0.0, 0.0 );
		materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
		materialParams.specular = new Color$2( 1.0, 1.0, 1.0 );

		if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

			materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

		}

		if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

			const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
			pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
			pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

		}

		return Promise.all( pending );

	}

	createMaterial( materialParams ) {

		const material = new GLTFMeshStandardSGMaterial( materialParams );
		material.fog = true;

		material.color = materialParams.color;

		material.map = materialParams.map === undefined ? null : materialParams.map;

		material.lightMap = null;
		material.lightMapIntensity = 1.0;

		material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
		material.aoMapIntensity = 1.0;

		material.emissive = materialParams.emissive;
		material.emissiveIntensity = 1.0;
		material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

		material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
		material.bumpScale = 1;

		material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
		material.normalMapType = TangentSpaceNormalMap$1;

		if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

		material.displacementMap = null;
		material.displacementScale = 1;
		material.displacementBias = 0;

		material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
		material.specular = materialParams.specular;

		material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
		material.glossiness = materialParams.glossiness;

		material.alphaMap = null;

		material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
		material.envMapIntensity = 1.0;

		material.refractionRatio = 0.98;

		return material;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant$1 {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

}

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

	const result = this.resultBuffer;
	const values = this.sampleValues;
	const stride = this.valueSize;

	const stride2 = stride * 2;
	const stride3 = stride * 3;

	const td = t1 - t0;

	const p = ( t - t0 ) / td;
	const pp = p * p;
	const ppp = pp * p;

	const offset1 = i1 * stride3;
	const offset0 = offset1 - stride3;

	const s2 = - 2 * ppp + 3 * pp;
	const s3 = ppp - pp;
	const s0 = 1 - s2;
	const s1 = s3 - pp + p;

	// Layout of keyframe output values for CUBICSPLINE animations:
	//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
	for ( let i = 0; i !== stride; i ++ ) {

		const p0 = values[ offset0 + i + stride ]; // splineVertex_k
		const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
		const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
		const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

		result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

	}

	return result;

};

/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS$1 = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: NearestFilter$1,
	9729: LinearFilter$1,
	9984: NearestMipmapNearestFilter$1,
	9985: LinearMipmapNearestFilter$1,
	9986: NearestMipmapLinearFilter$1,
	9987: LinearMipmapLinearFilter$1
};

const WEBGL_WRAPPINGS = {
	33071: ClampToEdgeWrapping$1,
	33648: MirroredRepeatWrapping$1,
	10497: RepeatWrapping$1
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES$1 = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: InterpolateLinear$1,
	STEP: InterpolateDiscrete$1
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/* UTILITY FUNCTIONS */

function resolveURL( url, path ) {

	// Invalid URL
	if ( typeof url !== 'string' || url === '' ) return '';

	// Host Relative URL
	if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

		path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

	}

	// Absolute URL http://,https://,//
	if ( /^(https?:)?\/\//i.test( url ) ) return url;

	// Data URI
	if ( /^data:.*,.*$/i.test( url ) ) return url;

	// Blob URL
	if ( /^blob:.*$/i.test( url ) ) return url;

	// Relative URL
	return path + url;

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial$1( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: FrontSide$1
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;

		if ( hasMorphPosition && hasMorphNormal ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.
		if ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {

			this.textureLoader = new ImageBitmapLoader$1( this.options.manager );

		} else {

			this.textureLoader = new TextureLoader$1( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new FileLoader$1( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this.loadAnimation( index );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new InterleavedBuffer$1( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new InterleavedBufferAttribute$1( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new BufferAttribute$1( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new BufferAttribute$1( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const source = json.images[ textureDef.source ];

		let loader = this.textureLoader;

		if ( source.uri ) {

			const handler = options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, source, loader );

	}

	loadTextureImage( textureIndex, source, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		const textureDef = json.textures[ textureIndex ];

		const cacheKey = ( source.uri || source.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const URL = self.URL || self.webkitURL;

		let sourceURI = source.uri || '';
		let isObjectURL = false;
		let hasAlpha = true;

		const isJPEG = sourceURI.search( /\.jpe?g($|\?)/i ) > 0 || sourceURI.search( /^data\:image\/jpeg/ ) === 0;

		if ( source.mimeType === 'image/jpeg' || isJPEG ) hasAlpha = false;

		if ( source.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

				if ( source.mimeType === 'image/png' ) {

					// Inspect the PNG 'IHDR' chunk to determine whether the image could have an
					// alpha channel. This check is conservative — the image could have an alpha
					// channel with all values == 1, and the indexed type (colorType == 3) only
					// sometimes contains alpha.
					//
					// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
					const colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );
					hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;

				}

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: source.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( source.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new Texture$1( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			// When there is definitely no alpha channel in the texture, set RGBFormat to save space.
			if ( ! hasAlpha ) texture.format = RGBFormat$1;

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter$1;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter$1;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping$1;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping$1;

			parser.associations.set( texture, {
				type: 'textures',
				index: textureIndex
			} );

			return texture;

		} ).catch( function () {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise}
	 */
	assignTexture( materialParams, mapName, mapDef ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			materialParams[ mapName ] = texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useVertexTangents = geometry.attributes.tangent !== undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;
		const useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
		const useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new PointsMaterial$1();
				Material$1.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new LineBasicMaterial$1();
				Material$1.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useVertexTangents || useVertexColors || useFlatShading || useMorphTargets ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useVertexTangents ) cacheKey += 'vertex-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';
			if ( useMorphTargets ) cacheKey += 'morph-targets:';
			if ( useMorphNormals ) cacheKey += 'morph-normals:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;
				if ( useMorphTargets ) cachedMaterial.morphTargets = true;
				if ( useMorphNormals ) cachedMaterial.morphNormals = true;

				if ( useVertexTangents ) {

					cachedMaterial.vertexTangents = true;

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return MeshStandardMaterial$1;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new Color$2( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = DoubleSide$1;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial$1 ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
			materialParams.normalScale = new Vector2$1( 1, - 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				materialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial$1 ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial$1 ) {

			materialParams.emissive = new Color$2().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial$1 ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

		}

		return Promise.all( pending ).then( function () {

			let material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
			if ( material.map ) material.map.encoding = sRGBEncoding$1;
			if ( material.emissiveMap ) material.emissiveMap.encoding = sRGBEncoding$1;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { type: 'materials', index: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = PropertyBinding$1.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new BufferGeometry$1(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new SkinnedMesh$1( geometry, material )
						: new Mesh$1( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINES ) {

					mesh = new LineSegments$1( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP ) {

					mesh = new Line$1( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP ) {

					mesh = new LineLoop$1( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.POINTS ) {

					mesh = new Points$1( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new Group$1();

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new PerspectiveCamera$1( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new OrthographicCamera$1( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();
				node.matrixAutoUpdate = true;

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES$1[ target.path ] ) {

					case PATH_PROPERTIES$1.weights:

						TypedKeyframeTrack = NumberKeyframeTrack$1;
						break;

					case PATH_PROPERTIES$1.rotation:

						TypedKeyframeTrack = QuaternionKeyframeTrack$1;
						break;

					case PATH_PROPERTIES$1.position:
					case PATH_PROPERTIES$1.scale:
					default:

						TypedKeyframeTrack = VectorKeyframeTrack$1;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear$1;

				const targetNames = [];

				if ( PATH_PROPERTIES$1[ target.path ] === PATH_PROPERTIES$1.weights ) {

					// Node may be a Group (glTF mesh with several primitives) or a Mesh.
					node.traverse( function ( object ) {

						if ( object.isMesh === true && object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES$1[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new AnimationClip$1( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			const pending = [];

			const meshPromise = parser._invokeOne( function ( ext ) {

				return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

			} );

			if ( meshPromise ) {

				pending.push( meshPromise );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new Bone$1();

			} else if ( objects.length > 1 ) {

				node = new Group$1();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new Object3D$1();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new Matrix4$1();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			parser.associations.set( node, { type: 'nodes', index: nodeIndex } );

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new Group$1();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			return scene;

		} );

	}

}

function buildNodeHierachy( nodeId, parentObject, json, parser ) {

	const nodeDef = json.nodes[ nodeId ];

	return parser.getDependency( 'node', nodeId ).then( function ( node ) {

		if ( nodeDef.skin === undefined ) return node;

		// build skeleton here as well

		let skinEntry;

		return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

			skinEntry = skin;

			const pendingJoints = [];

			for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

				pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

			}

			return Promise.all( pendingJoints );

		} ).then( function ( jointNodes ) {

			node.traverse( function ( mesh ) {

				if ( ! mesh.isMesh ) return;

				const bones = [];
				const boneInverses = [];

				for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

					const jointNode = jointNodes[ j ];

					if ( jointNode ) {

						bones.push( jointNode );

						const mat = new Matrix4$1();

						if ( skinEntry.inverseBindMatrices !== undefined ) {

							mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

						}

						boneInverses.push( mat );

					} else {

						console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

					}

				}

				mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

			} );

			return node;

		} );

	} ).then( function ( node ) {

		// build node hierachy

		parentObject.add( node );

		const pending = [];

		if ( nodeDef.children ) {

			const children = nodeDef.children;

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				const child = children[ i ];
				pending.push( buildNodeHierachy( child, node, json, parser ) );

			}

		}

		return Promise.all( pending );

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new Box3$1();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new Vector3$1( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new Vector3$1( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new Vector3$1();
		const vector = new Vector3$1();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new Sphere$1();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	let index = geometry.getIndex();

	// generate index if not present

	if ( index === null ) {

		const indices = [];

		const position = geometry.getAttribute( 'position' );

		if ( position !== undefined ) {

			for ( let i = 0; i < position.count; i ++ ) {

				indices.push( i );

			}

			geometry.setIndex( indices );
			index = geometry.getIndex();

		} else {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
			return geometry;

		}

	}

	//

	const numberOfTriangles = index.count - 2;
	const newIndices = [];

	if ( drawMode === TriangleFanDrawMode ) {

		// gl.TRIANGLE_FAN

		for ( let i = 1; i <= numberOfTriangles; i ++ ) {

			newIndices.push( index.getX( 0 ) );
			newIndices.push( index.getX( i ) );
			newIndices.push( index.getX( i + 1 ) );

		}

	} else {

		// gl.TRIANGLE_STRIP

		for ( let i = 0; i < numberOfTriangles; i ++ ) {

			if ( i % 2 === 0 ) {

				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i + 2 ) );


			} else {

				newIndices.push( index.getX( i + 2 ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i ) );

			}

		}

	}

	if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

		console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

	}

	// build final geometry

	const newGeometry = geometry.clone();
	newGeometry.setIndex( newIndices );

	return newGeometry;

}

/**
 * Text-To-Speech JS Utility
 * author: Gabriel Lim (hello@gabriellim.com)
 */


 class TTS  {
  constructor(config = {}) {

    this.speech = new SpeechSynthesisUtterance();
    this.lang = config.lang || 'en-US';
    this.populateVoices();
    this.pitch = config.pitch || 1.2;
    this.voice = config.voice || 0;
    this.volume = 0.5;
    this.speech.onstart = (e) => this.emit('onstart', e);
    this.speech.onend = (e) => this.emit('onstart', e);
    this.speech.onmark = (e) => this.emit('onmark', e);
    window.speechSynthesis.onvoiceschanged = () => {
      //self.populateVoices()
     // self.emit('onvoiceschanged', self.voices);
    };

    return this;
  }

  populateVoices() {

    this._voices = window.speechSynthesis.getVoices();
  }

  get voices() {
    return this._voices;
  }


  set lang(lang) {
    this.speech.lang = lang;
  }

  get lang() {
    return this.speech.lang;
  }

  set voice(id) {
    this.speech.voice = this.voices[id] || this.voices[0];
  }

  get voice() {
    return this.speech.voice;
  }

  set pitch(p) {
    this.speech.pitch = p;
  }

  get pitch() {
    return this.speech.pitch;
  }

  set volume(v) {
    this.speech.volume = v;
  }

  get volume() {
    return this.speech.volume;
  }

  speak(text) {
    this.speech.text = text;
    this.synthesizer.speak(this.speech);
  }

  cancel() {
    this.synthesizer.cancel();
  }

  pause() {
    this.synthesizer.pause();
  }

  resume() {
    this.synthesizer.resume();
  }
  get synthesizer() {
    return window.speechSynthesis;
  }
}

const isMobile = () => {
  let check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};


function SaveFile( blob, filename ) {
  const link = document.createElement('a');
  link.href = URL.createObjectURL( blob );
  link.download = filename;
  link.click();
  return link;
  // URL.revokeObjectURL( url ); breaks Firefox...

}

function SaveString( text, filename ) {
  if (typeof text === 'object') text = JSON.stringify(text);
  return SaveFile( new Blob( [ text ], { type: 'text/plain' } ), filename );
}

class Pass {

	constructor() {

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;

	}

	setSize( /* width, height */ ) {}

	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

}

// Helper for passes that need to fill the viewport with a single quad.

const _camera = new OrthographicCamera$1( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry$2 = new BufferGeometry$1();
_geometry$2.setAttribute( 'position', new Float32BufferAttribute$1( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry$2.setAttribute( 'uv', new Float32BufferAttribute$1( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

class FullScreenQuad {

	constructor( material ) {

		this._mesh = new Mesh$1( _geometry$2, material );

	}

	dispose() {

		this._mesh.geometry.dispose();

	}

	render( renderer ) {

		renderer.render( this._mesh, _camera );

	}

	get material() {

		return this._mesh.material;

	}

	set material( value ) {

		this._mesh.material = value;

	}

}

class RenderPass extends Pass {

	constructor( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.overrideMaterial = overrideMaterial;

		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

		this.clear = true;
		this.clearDepth = false;
		this.needsSwap = false;
		this._oldClearColor = new Color$2();

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		let oldClearAlpha, oldOverrideMaterial;

		if ( this.overrideMaterial !== undefined ) {

			oldOverrideMaterial = this.scene.overrideMaterial;

			this.scene.overrideMaterial = this.overrideMaterial;

		}

		if ( this.clearColor ) {

			renderer.getClearColor( this._oldClearColor );
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		if ( this.clearDepth ) {

			renderer.clearDepth();

		}

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

		// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
		if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
		renderer.render( this.scene, this.camera );

		if ( this.clearColor ) {

			renderer.setClearColor( this._oldClearColor, oldClearAlpha );

		}

		if ( this.overrideMaterial !== undefined ) {

			this.scene.overrideMaterial = oldOverrideMaterial;

		}

		renderer.autoClear = oldAutoClear;

	}

}

/**
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

const FXAAShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2$1( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader:

	// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

	//----------------------------------------------------------------------------------
	// File:				es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag
	// SDK Version: v3.00
	// Email:			 gameworks@nvidia.com
	// Site:				http://developer.nvidia.com/
	//
	// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions
	// are met:
	//	* Redistributions of source code must retain the above copyright
	//		notice, this list of conditions and the following disclaimer.
	//	* Redistributions in binary form must reproduce the above copyright
	//		notice, this list of conditions and the following disclaimer in the
	//		documentation and/or other materials provided with the distribution.
	//	* Neither the name of NVIDIA CORPORATION nor the names of its
	//		contributors may be used to endorse or promote products derived
	//		from this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY
	// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	// PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	//----------------------------------------------------------------------------------

	/* glsl */`

		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		#define FXAA_PC 1
		#define FXAA_GLSL_100 1
		#define FXAA_QUALITY_PRESET 12

		#define FXAA_GREEN_AS_LUMA 1

		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_PC_CONSOLE
				//
				// The console algorithm for PC is included
				// for developers targeting really low spec machines.
				// Likely better to just run FXAA_PC, and use a really low preset.
				//
				#define FXAA_PC_CONSOLE 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_120
				#define FXAA_GLSL_120 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_130
				#define FXAA_GLSL_130 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_3
				#define FXAA_HLSL_3 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_4
				#define FXAA_HLSL_4 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_5
				#define FXAA_HLSL_5 0
		#endif
		/*==========================================================================*/
		#ifndef FXAA_GREEN_AS_LUMA
				//
				// For those using non-linear color,
				// and either not able to get luma in alpha, or not wanting to,
				// this enables FXAA to run using green as a proxy for luma.
				// So with this enabled, no need to pack luma in alpha.
				//
				// This will turn off AA on anything which lacks some amount of green.
				// Pure red and blue or combination of only R and B, will get no AA.
				//
				// Might want to lower the settings for both,
				//		fxaaConsoleEdgeThresholdMin
				//		fxaaQualityEdgeThresholdMin
				// In order to insure AA does not get turned off on colors
				// which contain a minor amount of green.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_GREEN_AS_LUMA 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_EARLY_EXIT
				//
				// Controls algorithm\'s early exit path.
				// On PS3 turning this ON adds 2 cycles to the shader.
				// On 360 turning this OFF adds 10ths of a millisecond to the shader.
				// Turning this off on console will result in a more blurry image.
				// So this defaults to on.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_EARLY_EXIT 1
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_DISCARD
				//
				// Only valid for PC OpenGL currently.
				// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
				//
				// 1 = Use discard on pixels which don\'t need AA.
				//		 For APIs which enable concurrent TEX+ROP from same surface.
				// 0 = Return unchanged color on pixels which don\'t need AA.
				//
				#define FXAA_DISCARD 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_FAST_PIXEL_OFFSET
				//
				// Used for GLSL 120 only.
				//
				// 1 = GL API supports fast pixel offsets
				// 0 = do not use fast pixel offsets
				//
				#ifdef GL_EXT_gpu_shader4
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifndef FXAA_FAST_PIXEL_OFFSET
						#define FXAA_FAST_PIXEL_OFFSET 0
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GATHER4_ALPHA
				//
				// 1 = API supports gather4 on alpha channel.
				// 0 = API does not support gather4 on alpha channel.
				//
				#if (FXAA_HLSL_5 == 1)
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifndef FXAA_GATHER4_ALPHA
						#define FXAA_GATHER4_ALPHA 0
				#endif
		#endif


		/*============================================================================
														FXAA QUALITY - TUNING KNOBS
		------------------------------------------------------------------------------
		NOTE the other tuning knobs are now in the shader function inputs!
		============================================================================*/
		#ifndef FXAA_QUALITY_PRESET
				//
				// Choose the quality preset.
				// This needs to be compiled into the shader as it effects code.
				// Best option to include multiple presets is to
				// in each shader define the preset, then include this file.
				//
				// OPTIONS
				// -----------------------------------------------------------------------
				// 10 to 15 - default medium dither (10=fastest, 15=highest quality)
				// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
				// 39			 - no dither, very expensive
				//
				// NOTES
				// -----------------------------------------------------------------------
				// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
				// 13 = about same speed as FXAA 3.9 and better than 12
				// 23 = closest to FXAA 3.9 visually and performance wise
				//	_ = the lowest digit is directly related to performance
				// _	= the highest digit is directly related to style
				//
				#define FXAA_QUALITY_PRESET 12
		#endif


		/*============================================================================

															 FXAA QUALITY - PRESETS

		============================================================================*/

		/*============================================================================
												 FXAA QUALITY - MEDIUM DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 10)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 3.0
				#define FXAA_QUALITY_P2 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 11)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 3.0
				#define FXAA_QUALITY_P3 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 12)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 4.0
				#define FXAA_QUALITY_P4 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 13)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 4.0
				#define FXAA_QUALITY_P5 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 14)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 4.0
				#define FXAA_QUALITY_P6 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 15)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 12.0
		#endif

		/*============================================================================
												 FXAA QUALITY - LOW DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 20)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 2.0
				#define FXAA_QUALITY_P2 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 21)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 22)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 23)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 24)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 3.0
				#define FXAA_QUALITY_P6 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 25)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 26)
				#define FXAA_QUALITY_PS 9
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 4.0
				#define FXAA_QUALITY_P8 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 27)
				#define FXAA_QUALITY_PS 10
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 4.0
				#define FXAA_QUALITY_P9 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 28)
				#define FXAA_QUALITY_PS 11
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 4.0
				#define FXAA_QUALITY_P10 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 29)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif

		/*============================================================================
												 FXAA QUALITY - EXTREME QUALITY
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 39)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.0
				#define FXAA_QUALITY_P2 1.0
				#define FXAA_QUALITY_P3 1.0
				#define FXAA_QUALITY_P4 1.0
				#define FXAA_QUALITY_P5 1.5
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif



		/*============================================================================

																		API PORTING

		============================================================================*/
		#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
				#define FxaaBool bool
				#define FxaaDiscard discard
				#define FxaaFloat float
				#define FxaaFloat2 vec2
				#define FxaaFloat3 vec3
				#define FxaaFloat4 vec4
				#define FxaaHalf float
				#define FxaaHalf2 vec2
				#define FxaaHalf3 vec3
				#define FxaaHalf4 vec4
				#define FxaaInt2 ivec2
				#define FxaaSat(x) clamp(x, 0.0, 1.0)
				#define FxaaTex sampler2D
		#else
				#define FxaaBool bool
				#define FxaaDiscard clip(-1)
				#define FxaaFloat float
				#define FxaaFloat2 float2
				#define FxaaFloat3 float3
				#define FxaaFloat4 float4
				#define FxaaHalf half
				#define FxaaHalf2 half2
				#define FxaaHalf3 half3
				#define FxaaHalf4 half4
				#define FxaaSat(x) saturate(x)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_100 == 1)
			#define FxaaTexTop(t, p) texture2D(t, p, 0.0)
			#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_120 == 1)
				// Requires,
				//	#version 120
				// And at least,
				//	#extension GL_EXT_gpu_shader4 : enable
				//	(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
				#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
				#if (FXAA_FAST_PIXEL_OFFSET == 1)
						#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
				#else
						#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
				#endif
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_130 == 1)
				// Requires "#version 130" or better
				#define FxaaTexTop(t, p) textureLod(t, p, 0.0)
				#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_3 == 1)
				#define FxaaInt2 float2
				#define FxaaTex sampler2D
				#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))
				#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_4 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_5 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
				#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)
				#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)
				#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)
				#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)
		#endif


		/*============================================================================
											 GREEN AS LUMA OPTION SUPPORT FUNCTION
		============================================================================*/
		#if (FXAA_GREEN_AS_LUMA == 0)
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
		#else
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
		#endif




		/*============================================================================

																 FXAA3 QUALITY - PC

		============================================================================*/
		#if (FXAA_PC == 1)
		/*--------------------------------------------------------------------------*/
		FxaaFloat4 FxaaPixelShader(
				//
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy} = center of pixel
				FxaaFloat2 pos,
				//
				// Used only for FXAA Console, and not used on the 360 version.
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy_} = upper left of pixel
				// {_zw} = lower right of pixel
				FxaaFloat4 fxaaConsolePosPos,
				//
				// Input color texture.
				// {rgb_} = color in linear or perceptual color space
				// if (FXAA_GREEN_AS_LUMA == 0)
				//		 {__a} = luma in perceptual color space (not linear)
				FxaaTex tex,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 2nd sampler.
				// This sampler needs to have an exponent bias of -1.
				FxaaTex fxaaConsole360TexExpBiasNegOne,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 3nd sampler.
				// This sampler needs to have an exponent bias of -2.
				FxaaTex fxaaConsole360TexExpBiasNegTwo,
				//
				// Only used on FXAA Quality.
				// This must be from a constant/uniform.
				// {x_} = 1.0/screenWidthInPixels
				// {_y} = 1.0/screenHeightInPixels
				FxaaFloat2 fxaaQualityRcpFrame,
				//
				// Only used on FXAA Console.
				// This must be from a constant/uniform.
				// This effects sub-pixel AA quality and inversely sharpness.
				//	 Where N ranges between,
				//		 N = 0.50 (default)
				//		 N = 0.33 (sharper)
				// {x__} = -N/screenWidthInPixels
				// {_y_} = -N/screenHeightInPixels
				// {_z_} =	N/screenWidthInPixels
				// {__w} =	N/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt,
				//
				// Only used on FXAA Console.
				// Not used on 360, but used on PS3 and PC.
				// This must be from a constant/uniform.
				// {x__} = -2.0/screenWidthInPixels
				// {_y_} = -2.0/screenHeightInPixels
				// {_z_} =	2.0/screenWidthInPixels
				// {__w} =	2.0/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt2,
				//
				// Only used on FXAA Console.
				// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
				// This must be from a constant/uniform.
				// {x__} =	8.0/screenWidthInPixels
				// {_y_} =	8.0/screenHeightInPixels
				// {_z_} = -4.0/screenWidthInPixels
				// {__w} = -4.0/screenHeightInPixels
				FxaaFloat4 fxaaConsole360RcpFrameOpt2,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_SUBPIX define.
				// It is here now to allow easier tuning.
				// Choose the amount of sub-pixel aliasing removal.
				// This can effect sharpness.
				//	 1.00 - upper limit (softer)
				//	 0.75 - default amount of filtering
				//	 0.50 - lower limit (sharper, less sub-pixel aliasing removal)
				//	 0.25 - almost off
				//	 0.00 - completely off
				FxaaFloat fxaaQualitySubpix,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// The minimum amount of local contrast required to apply algorithm.
				//	 0.333 - too little (faster)
				//	 0.250 - low quality
				//	 0.166 - default
				//	 0.125 - high quality
				//	 0.063 - overkill (slower)
				FxaaFloat fxaaQualityEdgeThreshold,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				//	 0.0833 - upper limit (default, the start of visible unfiltered edges)
				//	 0.0625 - high quality (faster)
				//	 0.0312 - visible limit (slower)
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaQualityEdgeThresholdMin,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only three safe values here: 2 and 4 and 8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// For all other platforms can be a non-power of two.
				//	 8.0 is sharper (default!!!)
				//	 4.0 is softer
				//	 2.0 is really soft (good only for vector graphics inputs)
				FxaaFloat fxaaConsoleEdgeSharpness,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only two safe values here: 1/4 and 1/8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// The console setting has a different mapping than the quality setting.
				// Other platforms can use other values.
				//	 0.125 leaves less aliasing, but is softer (default!!!)
				//	 0.25 leaves more aliasing, and is sharper
				FxaaFloat fxaaConsoleEdgeThreshold,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				// The console setting has a different mapping than the quality setting.
				// This only applies when FXAA_EARLY_EXIT is 1.
				// This does not apply to PS3,
				// PS3 was simplified to avoid more shader instructions.
				//	 0.06 - faster but more aliasing in darks
				//	 0.05 - default
				//	 0.04 - slower and less aliasing in darks
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaConsoleEdgeThresholdMin,
				//
				// Extra constants for 360 FXAA Console only.
				// Use zeros or anything else for other platforms.
				// These must be in physical constant registers and NOT immediates.
				// Immediates will result in compiler un-optimizing.
				// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
				FxaaFloat4 fxaaConsole360ConstDir
		) {
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posM;
				posM.x = pos.x;
				posM.y = pos.y;
				#if (FXAA_GATHER4_ALPHA == 1)
						#if (FXAA_DISCARD == 0)
								FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
								#if (FXAA_GREEN_AS_LUMA == 0)
										#define lumaM rgbyM.w
								#else
										#define lumaM rgbyM.y
								#endif
						#endif
						#if (FXAA_GREEN_AS_LUMA == 0)
								FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
						#else
								FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
						#endif
						#if (FXAA_DISCARD == 1)
								#define lumaM luma4A.w
						#endif
						#define lumaE luma4A.z
						#define lumaS luma4A.x
						#define lumaSE luma4A.y
						#define lumaNW luma4B.w
						#define lumaN luma4B.z
						#define lumaW luma4B.x
				#else
						FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
						#if (FXAA_GREEN_AS_LUMA == 0)
								#define lumaM rgbyM.w
						#else
								#define lumaM rgbyM.y
						#endif
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
						#endif
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat maxSM = max(lumaS, lumaM);
				FxaaFloat minSM = min(lumaS, lumaM);
				FxaaFloat maxESM = max(lumaE, maxSM);
				FxaaFloat minESM = min(lumaE, minSM);
				FxaaFloat maxWN = max(lumaN, lumaW);
				FxaaFloat minWN = min(lumaN, lumaW);
				FxaaFloat rangeMax = max(maxWN, maxESM);
				FxaaFloat rangeMin = min(minWN, minESM);
				FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
				FxaaFloat range = rangeMax - rangeMin;
				FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
				FxaaBool earlyExit = range < rangeMaxClamped;
		/*--------------------------------------------------------------------------*/
				if(earlyExit)
						#if (FXAA_DISCARD == 1)
								FxaaDiscard;
						#else
								return rgbyM;
						#endif
		/*--------------------------------------------------------------------------*/
				#if (FXAA_GATHER4_ALPHA == 0)
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
						#endif
				#else
						FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
						FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNS = lumaN + lumaS;
				FxaaFloat lumaWE = lumaW + lumaE;
				FxaaFloat subpixRcpRange = 1.0/range;
				FxaaFloat subpixNSWE = lumaNS + lumaWE;
				FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
				FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNESE = lumaNE + lumaSE;
				FxaaFloat lumaNWNE = lumaNW + lumaNE;
				FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
				FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNWSW = lumaNW + lumaSW;
				FxaaFloat lumaSWSE = lumaSW + lumaSE;
				FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
				FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
				FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
				FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
				FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
				FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
		/*--------------------------------------------------------------------------*/
				FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
				FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
				FxaaBool horzSpan = edgeHorz >= edgeVert;
				FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
		/*--------------------------------------------------------------------------*/
				if(!horzSpan) lumaN = lumaW;
				if(!horzSpan) lumaS = lumaE;
				if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
				FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
		/*--------------------------------------------------------------------------*/
				FxaaFloat gradientN = lumaN - lumaM;
				FxaaFloat gradientS = lumaS - lumaM;
				FxaaFloat lumaNN = lumaN + lumaM;
				FxaaFloat lumaSS = lumaS + lumaM;
				FxaaBool pairN = abs(gradientN) >= abs(gradientS);
				FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
				if(pairN) lengthSign = -lengthSign;
				FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posB;
				posB.x = posM.x;
				posB.y = posM.y;
				FxaaFloat2 offNP;
				offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
				offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
				if(!horzSpan) posB.x += lengthSign * 0.5;
				if( horzSpan) posB.y += lengthSign * 0.5;
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posN;
				posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
				posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
				FxaaFloat2 posP;
				posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
				posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
				FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
				FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
				FxaaFloat subpixE = subpixC * subpixC;
				FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
		/*--------------------------------------------------------------------------*/
				if(!pairN) lumaNN = lumaSS;
				FxaaFloat gradientScaled = gradient * 1.0/4.0;
				FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
				FxaaFloat subpixF = subpixD * subpixE;
				FxaaBool lumaMLTZero = lumaMM < 0.0;
		/*--------------------------------------------------------------------------*/
				lumaEndN -= lumaNN * 0.5;
				lumaEndP -= lumaNN * 0.5;
				FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
				FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
				FxaaBool doneNP = (!doneN) || (!doneP);
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
		/*--------------------------------------------------------------------------*/
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 3)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 4)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 5)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 6)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
		/*--------------------------------------------------------------------------*/
														#if (FXAA_QUALITY_PS > 7)
														if(doneNP) {
																if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
																if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
																if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
																if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
																doneN = abs(lumaEndN) >= gradientScaled;
																doneP = abs(lumaEndP) >= gradientScaled;
																if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
																if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
																doneNP = (!doneN) || (!doneP);
																if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
																if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
		/*--------------------------------------------------------------------------*/
				#if (FXAA_QUALITY_PS > 8)
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 9)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 10)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 11)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 12)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
				#endif
		/*--------------------------------------------------------------------------*/
														}
														#endif
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
		/*--------------------------------------------------------------------------*/
				FxaaFloat dstN = posM.x - posN.x;
				FxaaFloat dstP = posP.x - posM.x;
				if(!horzSpan) dstN = posM.y - posN.y;
				if(!horzSpan) dstP = posP.y - posM.y;
		/*--------------------------------------------------------------------------*/
				FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
				FxaaFloat spanLength = (dstP + dstN);
				FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
				FxaaFloat spanLengthRcp = 1.0/spanLength;
		/*--------------------------------------------------------------------------*/
				FxaaBool directionN = dstN < dstP;
				FxaaFloat dst = min(dstN, dstP);
				FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
				FxaaFloat subpixG = subpixF * subpixF;
				FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
				FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
		/*--------------------------------------------------------------------------*/
				FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
				FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
				if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
				if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
				#if (FXAA_DISCARD == 1)
						return FxaaTexTop(tex, posM);
				#else
						return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
				#endif
		}
		/*==========================================================================*/
		#endif

		void main() {
			gl_FragColor = FxaaPixelShader(
				vUv,
				vec4(0.0),
				tDiffuse,
				tDiffuse,
				tDiffuse,
				resolution,
				vec4(0.0),
				vec4(0.0),
				vec4(0.0),
				0.75,
				0.166,
				0.0833,
				0.0,
				0.0,
				0.0,
				vec4(0.0)
			);

			// TODO avoid querying texture twice for same texel
			gl_FragColor.a = texture2D(tDiffuse, vUv).a;
		}`

};

class ShaderPass extends Pass {

	constructor( shader, textureID ) {

		super();

		this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';

		if ( shader instanceof ShaderMaterial$1 ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = UniformsUtils$1.clone( shader.uniforms );

			this.material = new ShaderMaterial$1( {

				defines: Object.assign( {}, shader.defines ),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		this.fsQuad = new FullScreenQuad( this.material );

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.fsQuad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( writeBuffer );
			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			this.fsQuad.render( renderer );

		}

	}

}

/**
 * Full-screen textured quad shader
 */

var CopyShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`

};

/**
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */

const ConvolutionShader = {

	defines: {

		'KERNEL_SIZE_FLOAT': '25.0',
		'KERNEL_SIZE_INT': '25'

	},

	uniforms: {

		'tDiffuse': { value: null },
		'uImageIncrement': { value: new Vector2$1( 0.001953125, 0.0 ) },
		'cKernel': { value: [] }

	},

	vertexShader: /* glsl */`

		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float cKernel[ KERNEL_SIZE_INT ];

		uniform sampler2D tDiffuse;
		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vec2 imageCoord = vUv;
			vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );

			for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {

				sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];
				imageCoord += uImageIncrement;

			}

			gl_FragColor = sum;

		}`,

	buildKernel: function ( sigma ) {

		// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.

		const kMaxKernelSize = 25;
		let kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;

		if ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;

		const halfWidth = ( kernelSize - 1 ) * 0.5;

		const values = new Array( kernelSize );
		let sum = 0.0;
		for ( let i = 0; i < kernelSize; ++ i ) {

			values[ i ] = gauss( i - halfWidth, sigma );
			sum += values[ i ];

		}

		// normalize the kernel

		for ( let i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;

		return values;

	}

};

function gauss( x, sigma ) {

	return Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );

}

class BloomPass extends Pass {

	constructor( strength = 1, kernelSize = 25, sigma = 4, resolution = 256 ) {

		super();

		// render targets

		const pars = { minFilter: LinearFilter$1, magFilter: LinearFilter$1, format: RGBAFormat$1 };

		this.renderTargetX = new WebGLRenderTarget$1( resolution, resolution, pars );
		this.renderTargetX.texture.name = 'BloomPass.x';
		this.renderTargetY = new WebGLRenderTarget$1( resolution, resolution, pars );
		this.renderTargetY.texture.name = 'BloomPass.y';

		// copy material

		if ( CopyShader === undefined ) console.error( 'THREE.BloomPass relies on CopyShader' );

		const copyShader = CopyShader;

		this.copyUniforms = UniformsUtils$1.clone( copyShader.uniforms );

		this.copyUniforms[ 'opacity' ].value = strength;

		this.materialCopy = new ShaderMaterial$1( {

			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: AdditiveBlending$1,
			transparent: true

		} );

		// convolution material

		if ( ConvolutionShader === undefined ) console.error( 'THREE.BloomPass relies on ConvolutionShader' );

		const convolutionShader = ConvolutionShader;

		this.convolutionUniforms = UniformsUtils$1.clone( convolutionShader.uniforms );

		this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;
		this.convolutionUniforms[ 'cKernel' ].value = ConvolutionShader.buildKernel( sigma );

		this.materialConvolution = new ShaderMaterial$1( {

			uniforms: this.convolutionUniforms,
			vertexShader: convolutionShader.vertexShader,
			fragmentShader: convolutionShader.fragmentShader,
			defines: {
				'KERNEL_SIZE_FLOAT': kernelSize.toFixed( 1 ),
				'KERNEL_SIZE_INT': kernelSize.toFixed( 0 )
			}

		} );

		this.needsSwap = false;

		this.fsQuad = new FullScreenQuad( null );

	}

	render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

		if ( maskActive ) renderer.state.buffers.stencil.setTest( false );

		// Render quad with blured scene into texture (convolution pass 1)

		this.fsQuad.material = this.materialConvolution;

		this.convolutionUniforms[ 'tDiffuse' ].value = readBuffer.texture;
		this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;

		renderer.setRenderTarget( this.renderTargetX );
		renderer.clear();
		this.fsQuad.render( renderer );


		// Render quad with blured scene into texture (convolution pass 2)

		this.convolutionUniforms[ 'tDiffuse' ].value = this.renderTargetX.texture;
		this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurY;

		renderer.setRenderTarget( this.renderTargetY );
		renderer.clear();
		this.fsQuad.render( renderer );

		// Render original scene with superimposed blur to texture

		this.fsQuad.material = this.materialCopy;

		this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetY.texture;

		if ( maskActive ) renderer.state.buffers.stencil.setTest( true );

		renderer.setRenderTarget( readBuffer );
		if ( this.clear ) renderer.clear();
		this.fsQuad.render( renderer );

	}

}

BloomPass.blurX = new Vector2$1( 0.001953125, 0.0 );
BloomPass.blurY = new Vector2$1( 0.0, 0.001953125 );

class OutlinePass extends Pass {

	constructor( resolution, scene, camera, selectedObjects ) {

		super();

		this.renderScene = scene;
		this.renderCamera = camera;
		this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
		this.visibleEdgeColor = new Color$2( 1, 1, 1 );
		this.hiddenEdgeColor = new Color$2( 0.1, 0.04, 0.02 );
		this.edgeGlow = 0.0;
		this.usePatternTexture = false;
		this.edgeThickness = 1.0;
		this.edgeStrength = 3.0;
		this.downSampleRatio = 2;
		this.pulsePeriod = 0;

		this._visibilityCache = new Map();


		this.resolution = ( resolution !== undefined ) ? new Vector2$1( resolution.x, resolution.y ) : new Vector2$1( 256, 256 );

		const pars = { minFilter: LinearFilter$1, magFilter: LinearFilter$1, format: RGBAFormat$1 };

		const resx = Math.round( this.resolution.x / this.downSampleRatio );
		const resy = Math.round( this.resolution.y / this.downSampleRatio );

		this.maskBufferMaterial = new MeshBasicMaterial$1( { color: 0xffffff } );
		this.maskBufferMaterial.side = DoubleSide$1;
		this.renderTargetMaskBuffer = new WebGLRenderTarget$1( this.resolution.x, this.resolution.y, pars );
		this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';
		this.renderTargetMaskBuffer.texture.generateMipmaps = false;

		this.depthMaterial = new MeshDepthMaterial$1();
		this.depthMaterial.side = DoubleSide$1;
		this.depthMaterial.depthPacking = RGBADepthPacking$1;
		this.depthMaterial.blending = NoBlending$1;

		this.prepareMaskMaterial = this.getPrepareMaskMaterial();
		this.prepareMaskMaterial.side = DoubleSide$1;
		this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );

		this.renderTargetDepthBuffer = new WebGLRenderTarget$1( this.resolution.x, this.resolution.y, pars );
		this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';
		this.renderTargetDepthBuffer.texture.generateMipmaps = false;

		this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget$1( resx, resy, pars );
		this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';
		this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;

		this.renderTargetBlurBuffer1 = new WebGLRenderTarget$1( resx, resy, pars );
		this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';
		this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
		this.renderTargetBlurBuffer2 = new WebGLRenderTarget$1( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );
		this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';
		this.renderTargetBlurBuffer2.texture.generateMipmaps = false;

		this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
		this.renderTargetEdgeBuffer1 = new WebGLRenderTarget$1( resx, resy, pars );
		this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';
		this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
		this.renderTargetEdgeBuffer2 = new WebGLRenderTarget$1( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );
		this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';
		this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;

		const MAX_EDGE_THICKNESS = 4;
		const MAX_EDGE_GLOW = 4;

		this.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );
		this.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );
		this.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;
		this.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );
		this.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );
		this.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;

		// Overlay material
		this.overlayMaterial = this.getOverlayMaterial();

		// copy material
		if ( CopyShader === undefined ) console.error( 'THREE.OutlinePass relies on CopyShader' );

		const copyShader = CopyShader;

		this.copyUniforms = UniformsUtils$1.clone( copyShader.uniforms );
		this.copyUniforms[ 'opacity' ].value = 1.0;

		this.materialCopy = new ShaderMaterial$1( {
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: NoBlending$1,
			depthTest: false,
			depthWrite: false,
			transparent: true
		} );

		this.enabled = true;
		this.needsSwap = false;

		this._oldClearColor = new Color$2();
		this.oldClearAlpha = 1;

		this.fsQuad = new FullScreenQuad( null );

		this.tempPulseColor1 = new Color$2();
		this.tempPulseColor2 = new Color$2();
		this.textureMatrix = new Matrix4$1();

		function replaceDepthToViewZ( string, camera ) {

			var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';

			return string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );

		}

	}

	dispose() {

		this.renderTargetMaskBuffer.dispose();
		this.renderTargetDepthBuffer.dispose();
		this.renderTargetMaskDownSampleBuffer.dispose();
		this.renderTargetBlurBuffer1.dispose();
		this.renderTargetBlurBuffer2.dispose();
		this.renderTargetEdgeBuffer1.dispose();
		this.renderTargetEdgeBuffer2.dispose();

	}

	setSize( width, height ) {

		this.renderTargetMaskBuffer.setSize( width, height );
		this.renderTargetDepthBuffer.setSize( width, height );

		let resx = Math.round( width / this.downSampleRatio );
		let resy = Math.round( height / this.downSampleRatio );
		this.renderTargetMaskDownSampleBuffer.setSize( resx, resy );
		this.renderTargetBlurBuffer1.setSize( resx, resy );
		this.renderTargetEdgeBuffer1.setSize( resx, resy );
		this.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );

		resx = Math.round( resx / 2 );
		resy = Math.round( resy / 2 );

		this.renderTargetBlurBuffer2.setSize( resx, resy );
		this.renderTargetEdgeBuffer2.setSize( resx, resy );

		this.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );

	}

	changeVisibilityOfSelectedObjects( bVisible ) {

		const cache = this._visibilityCache;

		function gatherSelectedMeshesCallBack( object ) {

			if ( object.isMesh ) {

				if ( bVisible === true ) {

					object.visible = cache.get( object );

				} else {

					cache.set( object, object.visible );
					object.visible = bVisible;

				}

			}

		}

		for ( let i = 0; i < this.selectedObjects.length; i ++ ) {

			const selectedObject = this.selectedObjects[ i ];
			selectedObject.traverse( gatherSelectedMeshesCallBack );

		}

	}

	changeVisibilityOfNonSelectedObjects( bVisible ) {

		const cache = this._visibilityCache;
		const selectedMeshes = [];

		function gatherSelectedMeshesCallBack( object ) {

			if ( object.isMesh ) selectedMeshes.push( object );

		}

		for ( let i = 0; i < this.selectedObjects.length; i ++ ) {

			const selectedObject = this.selectedObjects[ i ];
			selectedObject.traverse( gatherSelectedMeshesCallBack );

		}

		function VisibilityChangeCallBack( object ) {

			if ( object.isMesh || object.isSprite ) {

				// only meshes and sprites are supported by OutlinePass

				let bFound = false;

				for ( let i = 0; i < selectedMeshes.length; i ++ ) {

					const selectedObjectId = selectedMeshes[ i ].id;

					if ( selectedObjectId === object.id ) {

						bFound = true;
						break;

					}

				}

				if ( bFound === false ) {

					const visibility = object.visible;

					if ( bVisible === false || cache.get( object ) === true ) {

						object.visible = bVisible;

					}

					cache.set( object, visibility );

				}

			} else if ( object.isPoints || object.isLine ) {

				// the visibilty of points and lines is always set to false in order to
				// not affect the outline computation

				if ( bVisible === true ) {

					object.visible = cache.get( object ); // restore

				} else {

					cache.set( object, object.visible );
					object.visible = bVisible;

				}

			}

		}

		this.renderScene.traverse( VisibilityChangeCallBack );

	}

	updateTextureMatrix() {

		this.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0 );
		this.textureMatrix.multiply( this.renderCamera.projectionMatrix );
		this.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );

	}

	render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

		if ( this.selectedObjects.length > 0 ) {

			renderer.getClearColor( this._oldClearColor );
			this.oldClearAlpha = renderer.getClearAlpha();
			const oldAutoClear = renderer.autoClear;

			renderer.autoClear = false;

			if ( maskActive ) renderer.state.buffers.stencil.setTest( false );

			renderer.setClearColor( 0xffffff, 1 );

			// Make selected objects invisible
			this.changeVisibilityOfSelectedObjects( false );

			const currentBackground = this.renderScene.background;
			this.renderScene.background = null;

			// 1. Draw Non Selected objects in the depth buffer
			this.renderScene.overrideMaterial = this.depthMaterial;
			renderer.setRenderTarget( this.renderTargetDepthBuffer );
			renderer.clear();
			renderer.render( this.renderScene, this.renderCamera );

			// Make selected objects visible
			this.changeVisibilityOfSelectedObjects( true );
			this._visibilityCache.clear();

			// Update Texture Matrix for Depth compare
			this.updateTextureMatrix();

			// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
			this.changeVisibilityOfNonSelectedObjects( false );
			this.renderScene.overrideMaterial = this.prepareMaskMaterial;
			this.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );
			this.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;
			this.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;
			renderer.setRenderTarget( this.renderTargetMaskBuffer );
			renderer.clear();
			renderer.render( this.renderScene, this.renderCamera );
			this.renderScene.overrideMaterial = null;
			this.changeVisibilityOfNonSelectedObjects( true );
			this._visibilityCache.clear();

			this.renderScene.background = currentBackground;

			// 2. Downsample to Half resolution
			this.fsQuad.material = this.materialCopy;
			this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;
			renderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );
			renderer.clear();
			this.fsQuad.render( renderer );

			this.tempPulseColor1.copy( this.visibleEdgeColor );
			this.tempPulseColor2.copy( this.hiddenEdgeColor );

			if ( this.pulsePeriod > 0 ) {

				const scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;
				this.tempPulseColor1.multiplyScalar( scalar );
				this.tempPulseColor2.multiplyScalar( scalar );

			}

			// 3. Apply Edge Detection Pass
			this.fsQuad.material = this.edgeDetectionMaterial;
			this.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;
			this.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );
			this.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;
			this.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;
			renderer.setRenderTarget( this.renderTargetEdgeBuffer1 );
			renderer.clear();
			this.fsQuad.render( renderer );

			// 4. Apply Blur on Half res
			this.fsQuad.material = this.separableBlurMaterial1;
			this.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;
			this.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;
			renderer.setRenderTarget( this.renderTargetBlurBuffer1 );
			renderer.clear();
			this.fsQuad.render( renderer );
			this.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;
			this.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;
			renderer.setRenderTarget( this.renderTargetEdgeBuffer1 );
			renderer.clear();
			this.fsQuad.render( renderer );

			// Apply Blur on quarter res
			this.fsQuad.material = this.separableBlurMaterial2;
			this.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;
			renderer.setRenderTarget( this.renderTargetBlurBuffer2 );
			renderer.clear();
			this.fsQuad.render( renderer );
			this.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;
			this.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;
			renderer.setRenderTarget( this.renderTargetEdgeBuffer2 );
			renderer.clear();
			this.fsQuad.render( renderer );

			// Blend it additively over the input texture
			this.fsQuad.material = this.overlayMaterial;
			this.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;
			this.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;
			this.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;
			this.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;
			this.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;
			this.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;
			this.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;


			if ( maskActive ) renderer.state.buffers.stencil.setTest( true );

			renderer.setRenderTarget( readBuffer );
			this.fsQuad.render( renderer );

			renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );
			renderer.autoClear = oldAutoClear;

		}

		if ( this.renderToScreen ) {

			this.fsQuad.material = this.materialCopy;
			this.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;
			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		}

	}

	getPrepareMaskMaterial() {

		return new ShaderMaterial$1( {

			uniforms: {
				'depthTexture': { value: null },
				'cameraNearFar': { value: new Vector2$1( 0.5, 0.5 ) },
				'textureMatrix': { value: null }
			},

			vertexShader:
				`#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;
					vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
					projTexCoord = textureMatrix * worldPosition;

				}`,

			fragmentShader:
				`#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`

		} );

	}

	getEdgeDetectionMaterial() {

		return new ShaderMaterial$1( {

			uniforms: {
				'maskTexture': { value: null },
				'texSize': { value: new Vector2$1( 0.5, 0.5 ) },
				'visibleEdgeColor': { value: new Vector3$1( 1.0, 1.0, 1.0 ) },
				'hiddenEdgeColor': { value: new Vector3$1( 1.0, 1.0, 1.0 ) },
			},

			vertexShader:
				`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`
		} );

	}

	getSeperableBlurMaterial( maxRadius ) {

		return new ShaderMaterial$1( {

			defines: {
				'MAX_RADIUS': maxRadius,
			},

			uniforms: {
				'colorTexture': { value: null },
				'texSize': { value: new Vector2$1( 0.5, 0.5 ) },
				'direction': { value: new Vector2$1( 0.5, 0.5 ) },
				'kernelRadius': { value: 1.0 }
			},

			vertexShader:
				`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float weightSum = gaussianPdf(0.0, kernelRadius);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float w = gaussianPdf(uvOffset.x, kernelRadius);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`
		} );

	}

	getOverlayMaterial() {

		return new ShaderMaterial$1( {

			uniforms: {
				'maskTexture': { value: null },
				'edgeTexture1': { value: null },
				'edgeTexture2': { value: null },
				'patternTexture': { value: null },
				'edgeStrength': { value: 1.0 },
				'edgeGlow': { value: 1.0 },
				'usePatternTexture': { value: 0.0 }
			},

			vertexShader:
				`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,
			blending: AdditiveBlending$1,
			depthTest: false,
			depthWrite: false,
			transparent: true
		} );

	}

}

OutlinePass.BlurDirectionX = new Vector2$1( 1.0, 0.0 );
OutlinePass.BlurDirectionY = new Vector2$1( 0.0, 1.0 );

/**
 * References:
 * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html
 */

var SSRShader = {

	defines: {
		MAX_STEP: 0,
		PERSPECTIVE_CAMERA: true,
		DISTANCE_ATTENUATION: true,
		FRESNEL: true,
		INFINITE_THICK: false,
		SELECTIVE: false,
	},

	uniforms: {

		'tDiffuse': { value: null },
		'tNormal': { value: null },
		'tMetalness': { value: null },
		'tDepth': { value: null },
		'cameraNear': { value: null },
		'cameraFar': { value: null },
		'resolution': { value: new Vector2$1() },
		'cameraProjectionMatrix': { value: new Matrix4$1() },
		'cameraInverseProjectionMatrix': { value: new Matrix4$1() },
		'opacity': { value: .5 },
		'maxDistance': { value: 180 },
		'cameraRange': { value: 0 },
		'thickness': { value: .018 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,

	fragmentShader: /* glsl */`
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float thickness;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef SELECTIVE
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
				#endif

				// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
				// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
				if(viewReflectRayZ<=vZ){

					bool hit;
					#ifdef INFINITE_THICK
						hit=true;
					#else
						float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

						float minThickness;
						vec2 xyNeighbor=xy;
						xyNeighbor.x+=1.;
						vec2 uvNeighbor=xyNeighbor/resolution;
						vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);
						minThickness=vPNeighbor.x-vP.x;
						minThickness*=3.;
						float tk=max(minThickness,thickness);

						hit=away<=tk;
					#endif

					if(hit){
						vec3 vN=getViewNormal( uv );
						if(dot(viewReflectDir,vN)>=0.) continue;
						float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
						if(distance>maxDistance) break;
						float op=opacity;
						#ifdef DISTANCE_ATTENUATION
							float ratio=1.-(distance/maxDistance);
							float attenuation=ratio*ratio;
							op=opacity*attenuation;
						#endif
						#ifdef FRESNEL
							float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;
							op*=fresnelCoe;
						#endif
						vec4 reflectColor=texture2D(tDiffuse,uv);
						gl_FragColor.xyz=reflectColor.xyz;
						gl_FragColor.a=op;
						break;
					}
				}
			}
		}
	`

};

var SSRDepthShader = {

	defines: {
		'PERSPECTIVE_CAMERA': 1
	},

	uniforms: {

		'tDepth': { value: null },
		'cameraNear': { value: null },
		'cameraFar': { value: null },

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	`

};

var SSRBlurShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2$1() },
		'opacity': { value: .5 },

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

			vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`


};

class SSRPass extends Pass {

	constructor( { renderer, scene, camera, width, height, selects, encoding, bouncing = false, morphTargets = false, groundReflector } ) {

		super();

		this.width = ( width !== undefined ) ? width : 512;
		this.height = ( height !== undefined ) ? height : 512;

		this.clear = true;

		this.renderer = renderer;
		this.scene = scene;
		this.camera = camera;
		this.groundReflector = groundReflector;

		this.opacity = SSRShader.uniforms.opacity.value;
		this.output = 0;

		this.maxDistance = SSRShader.uniforms.maxDistance.value;
		this.thickness = SSRShader.uniforms.thickness.value;

		this.encoding = encoding;

		this.tempColor = new Color$2();

		this._selects = selects;
		this.selective = Array.isArray( this._selects );
		Object.defineProperty( this, 'selects', {
			get() {

				return this._selects;

			},
			set( val ) {

				if ( this._selects === val ) return;
				this._selects = val;
				if ( Array.isArray( val ) ) {

					this.selective = true;
					this.ssrMaterial.defines.SELECTIVE = true;
					this.ssrMaterial.needsUpdate = true;

				} else {

					this.selective = false;
					this.ssrMaterial.defines.SELECTIVE = false;
					this.ssrMaterial.needsUpdate = true;

				}

			}
		} );

		this._bouncing = bouncing;
		Object.defineProperty( this, 'bouncing', {
			get() {

				return this._bouncing;

			},
			set( val ) {

				if ( this._bouncing === val ) return;
				this._bouncing = val;
				if ( val ) {

					this.ssrMaterial.uniforms[ 'tDiffuse' ].value = this.prevRenderTarget.texture;

				} else {

					this.ssrMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;

				}

			}
		} );

		this.blur = true;

		this._distanceAttenuation = SSRShader.defines.DISTANCE_ATTENUATION;
		Object.defineProperty( this, 'distanceAttenuation', {
			get() {

				return this._distanceAttenuation;

			},
			set( val ) {

				if ( this._distanceAttenuation === val ) return;
				this._distanceAttenuation = val;
				this.ssrMaterial.defines.DISTANCE_ATTENUATION = val;
				this.ssrMaterial.needsUpdate = true;

			}
		} );


		this._fresnel = SSRShader.defines.FRESNEL;
		Object.defineProperty( this, 'fresnel', {
			get() {

				return this._fresnel;

			},
			set( val ) {

				if ( this._fresnel === val ) return;
				this._fresnel = val;
				this.ssrMaterial.defines.FRESNEL = val;
				this.ssrMaterial.needsUpdate = true;

			}
		} );

		this._infiniteThick = SSRShader.defines.INFINITE_THICK;
		Object.defineProperty( this, 'infiniteThick', {
			get() {

				return this._infiniteThick;

			},
			set( val ) {

				if ( this._infiniteThick === val ) return;
				this._infiniteThick = val;
				this.ssrMaterial.defines.INFINITE_THICK = val;
				this.ssrMaterial.needsUpdate = true;

			}
		} );

		// beauty render target with depth buffer

		const depthTexture = new DepthTexture$1();
		depthTexture.type = UnsignedShortType$1;
		depthTexture.minFilter = NearestFilter$1;
		depthTexture.magFilter = NearestFilter$1;

		this.beautyRenderTarget = new WebGLRenderTarget$1( this.width, this.height, {
			minFilter: NearestFilter$1,
			magFilter: NearestFilter$1,
			format: RGBAFormat$1,
			depthTexture: depthTexture,
			depthBuffer: true
		} );

		//for bouncing
		this.prevRenderTarget = new WebGLRenderTarget$1( this.width, this.height, {
			minFilter: NearestFilter$1,
			magFilter: NearestFilter$1,
			format: RGBAFormat$1,
		} );

		// normal render target

		this.normalRenderTarget = new WebGLRenderTarget$1( this.width, this.height, {
			minFilter: NearestFilter$1,
			magFilter: NearestFilter$1,
			format: RGBAFormat$1,
			type: HalfFloatType$1,
		} );

		// metalness render target

		this.metalnessRenderTarget = new WebGLRenderTarget$1( this.width, this.height, {
			minFilter: NearestFilter$1,
			magFilter: NearestFilter$1,
			format: RGBAFormat$1
		} );



		// ssr render target

		this.ssrRenderTarget = new WebGLRenderTarget$1( this.width, this.height, {
			minFilter: NearestFilter$1,
			magFilter: NearestFilter$1,
			format: RGBAFormat$1
		} );

		this.blurRenderTarget = this.ssrRenderTarget.clone();
		this.blurRenderTarget2 = this.ssrRenderTarget.clone();
		// this.blurRenderTarget3 = this.ssrRenderTarget.clone();

		// ssr material

		if ( SSRShader === undefined ) {

			console.error( 'THREE.SSRPass: The pass relies on SSRShader.' );

		}

		this.ssrMaterial = new ShaderMaterial$1( {
			defines: Object.assign( {}, SSRShader.defines, {
				MAX_STEP: Math.sqrt( this.width * this.width + this.height * this.height )
			} ),
			uniforms: UniformsUtils$1.clone( SSRShader.uniforms ),
			vertexShader: SSRShader.vertexShader,
			fragmentShader: SSRShader.fragmentShader,
			blending: NoBlending$1
		} );

		this.ssrMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
		this.ssrMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
		this.ssrMaterial.defines.SELECTIVE = this.selective;
		this.ssrMaterial.needsUpdate = true;
		this.ssrMaterial.uniforms[ 'tMetalness' ].value = this.metalnessRenderTarget.texture;
		this.ssrMaterial.uniforms[ 'tDepth' ].value = this.beautyRenderTarget.depthTexture;
		this.ssrMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.ssrMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
		this.ssrMaterial.uniforms[ 'thickness' ].value = this.thickness;
		this.ssrMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );
		this.ssrMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
		this.ssrMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );

		// normal material

		this.normalMaterial = new MeshNormalMaterial$1( { morphTargets } );
		this.normalMaterial.blending = NoBlending$1;

		// metalnessOn material

		this.metalnessOnMaterial = new MeshBasicMaterial$1( {
			color: 'white'
		} );

		// metalnessOff material

		this.metalnessOffMaterial = new MeshBasicMaterial$1( {
			color: 'black'
		} );

		// blur material

		this.blurMaterial = new ShaderMaterial$1( {
			defines: Object.assign( {}, SSRBlurShader.defines ),
			uniforms: UniformsUtils$1.clone( SSRBlurShader.uniforms ),
			vertexShader: SSRBlurShader.vertexShader,
			fragmentShader: SSRBlurShader.fragmentShader
		} );
		this.blurMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;
		this.blurMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );

		// blur material 2

		this.blurMaterial2 = new ShaderMaterial$1( {
			defines: Object.assign( {}, SSRBlurShader.defines ),
			uniforms: UniformsUtils$1.clone( SSRBlurShader.uniforms ),
			vertexShader: SSRBlurShader.vertexShader,
			fragmentShader: SSRBlurShader.fragmentShader
		} );
		this.blurMaterial2.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;
		this.blurMaterial2.uniforms[ 'resolution' ].value.set( this.width, this.height );

		// // blur material 3

		// this.blurMaterial3 = new ShaderMaterial({
		//   defines: Object.assign({}, SSRBlurShader.defines),
		//   uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
		//   vertexShader: SSRBlurShader.vertexShader,
		//   fragmentShader: SSRBlurShader.fragmentShader
		// });
		// this.blurMaterial3.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;
		// this.blurMaterial3.uniforms['resolution'].value.set(this.width, this.height);

		// material for rendering the depth

		this.depthRenderMaterial = new ShaderMaterial$1( {
			defines: Object.assign( {}, SSRDepthShader.defines ),
			uniforms: UniformsUtils$1.clone( SSRDepthShader.uniforms ),
			vertexShader: SSRDepthShader.vertexShader,
			fragmentShader: SSRDepthShader.fragmentShader,
			blending: NoBlending$1
		} );
		this.depthRenderMaterial.uniforms[ 'tDepth' ].value = this.beautyRenderTarget.depthTexture;
		this.depthRenderMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.depthRenderMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;

		// material for rendering the content of a render target

		this.copyMaterial = new ShaderMaterial$1( {
			uniforms: UniformsUtils$1.clone( CopyShader.uniforms ),
			vertexShader: CopyShader.vertexShader,
			fragmentShader: CopyShader.fragmentShader,
			transparent: true,
			depthTest: false,
			depthWrite: false,
			blendSrc: SrcAlphaFactor$1,
			blendDst: OneMinusSrcAlphaFactor$1,
			blendEquation: AddEquation$1,
			blendSrcAlpha: SrcAlphaFactor$1,
			blendDstAlpha: OneMinusSrcAlphaFactor$1,
			blendEquationAlpha: AddEquation$1,
			// premultipliedAlpha:true,
		} );

		this.fsQuad = new FullScreenQuad( null );

		this.originalClearColor = new Color$2();

	}

	dispose() {

		// dispose render targets

		this.beautyRenderTarget.dispose();
		this.prevRenderTarget.dispose();
		this.normalRenderTarget.dispose();
		this.metalnessRenderTarget.dispose();
		this.ssrRenderTarget.dispose();
		this.blurRenderTarget.dispose();
		this.blurRenderTarget2.dispose();
		// this.blurRenderTarget3.dispose();

		// dispose materials

		this.normalMaterial.dispose();
		this.metalnessOnMaterial.dispose();
		this.metalnessOffMaterial.dispose();
		this.blurMaterial.dispose();
		this.blurMaterial2.dispose();
		this.copyMaterial.dispose();
		this.depthRenderMaterial.dispose();

		// dipsose full screen quad

		this.fsQuad.dispose();

	}

	render( renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */ ) {

		// render beauty and depth

		if ( this.encoding ) this.beautyRenderTarget.texture.encoding = this.encoding;
		renderer.setRenderTarget( this.beautyRenderTarget );
		renderer.clear();
		if ( this.groundReflector ) {

			this.groundReflector.visible = false;
			this.groundReflector.doRender( this.renderer, this.scene, this.camera );
			this.groundReflector.visible = true;

		}

		renderer.render( this.scene, this.camera );
		if ( this.groundReflector ) this.groundReflector.visible = false;

		// render normals

		this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0, 0 );

		// render metalnesses

		if ( this.selective ) {

			this.renderMetalness( renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0 );

		}

		// render SSR

		this.ssrMaterial.uniforms[ 'opacity' ].value = this.opacity;
		this.ssrMaterial.uniforms[ 'maxDistance' ].value = this.maxDistance;
		this.ssrMaterial.uniforms[ 'thickness' ].value = this.thickness;
		this.renderPass( renderer, this.ssrMaterial, this.ssrRenderTarget );


		// render blur

		if ( this.blur ) {

			this.renderPass( renderer, this.blurMaterial, this.blurRenderTarget );
			this.renderPass( renderer, this.blurMaterial2, this.blurRenderTarget2 );
			// this.renderPass(renderer, this.blurMaterial3, this.blurRenderTarget3);

		}

		// output result to screen

		switch ( this.output ) {

			case SSRPass.OUTPUT.Default:

				if ( this.bouncing ) {

					this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
					this.copyMaterial.blending = NoBlending$1;
					this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );

					if ( this.blur )
						this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;
					else
						this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;
					this.copyMaterial.blending = NormalBlending$1;
					this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );

					this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.prevRenderTarget.texture;
					this.copyMaterial.blending = NoBlending$1;
					this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				} else {

					this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
					this.copyMaterial.blending = NoBlending$1;
					this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

					if ( this.blur )
						this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;
					else
						this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;
					this.copyMaterial.blending = NormalBlending$1;
					this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				}

				break;
			case SSRPass.OUTPUT.SSR:

				if ( this.blur )
					this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;
				else
					this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;
				this.copyMaterial.blending = NoBlending$1;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				if ( this.bouncing ) {

					if ( this.blur )
						this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget2.texture;
					else
						this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
					this.copyMaterial.blending = NoBlending$1;
					this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );

					this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssrRenderTarget.texture;
					this.copyMaterial.blending = NormalBlending$1;
					this.renderPass( renderer, this.copyMaterial, this.prevRenderTarget );

				}

				break;

			case SSRPass.OUTPUT.Beauty:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
				this.copyMaterial.blending = NoBlending$1;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSRPass.OUTPUT.Depth:

				this.renderPass( renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSRPass.OUTPUT.Normal:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
				this.copyMaterial.blending = NoBlending$1;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSRPass.OUTPUT.Metalness:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.metalnessRenderTarget.texture;
				this.copyMaterial.blending = NoBlending$1;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			default:
				console.warn( 'THREE.SSRPass: Unknown output type.' );

		}

	}

	renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {

		// save original state
		this.originalClearColor.copy( renderer.getClearColor( this.tempColor ) );
		const originalClearAlpha = renderer.getClearAlpha( this.tempColor );
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );

		// setup pass state
		renderer.autoClear = false;
		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.fsQuad.material = passMaterial;
		this.fsQuad.render( renderer );

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

		this.originalClearColor.copy( renderer.getClearColor( this.tempColor ) );
		const originalClearAlpha = renderer.getClearAlpha( this.tempColor );
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );
		renderer.autoClear = false;

		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;

		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.scene.overrideMaterial = overrideMaterial;
		renderer.render( this.scene, this.camera );
		this.scene.overrideMaterial = null;

		// restore original state

		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	renderMetalness( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

		this.originalClearColor.copy( renderer.getClearColor( this.tempColor ) );
		const originalClearAlpha = renderer.getClearAlpha( this.tempColor );
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );
		renderer.autoClear = false;

		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;

		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.scene.traverseVisible( child => {

			child._SSRPassBackupMaterial = child.material;
			if ( this._selects.includes( child ) ) {

				child.material = this.metalnessOnMaterial;

			} else {

				child.material = this.metalnessOffMaterial;

			}

		} );
		renderer.render( this.scene, this.camera );
		this.scene.traverseVisible( child => {

			child.material = child._SSRPassBackupMaterial;

		} );

		// restore original state

		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	setSize( width, height ) {

		this.width = width;
		this.height = height;

		this.ssrMaterial.defines.MAX_STEP = Math.sqrt( width * width + height * height );
		this.ssrMaterial.needsUpdate = true;
		this.beautyRenderTarget.setSize( width, height );
		this.prevRenderTarget.setSize( width, height );
		this.ssrRenderTarget.setSize( width, height );
		this.normalRenderTarget.setSize( width, height );
		this.metalnessRenderTarget.setSize( width, height );
		this.blurRenderTarget.setSize( width, height );
		this.blurRenderTarget2.setSize( width, height );
		// this.blurRenderTarget3.setSize(width, height);

		this.ssrMaterial.uniforms[ 'resolution' ].value.set( width, height );
		this.ssrMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
		this.ssrMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );

		this.blurMaterial.uniforms[ 'resolution' ].value.set( width, height );
		this.blurMaterial2.uniforms[ 'resolution' ].value.set( width, height );

	}

}

SSRPass.OUTPUT = {
	'Default': 0,
	'SSR': 1,
	'Beauty': 3,
	'Depth': 4,
	'Normal': 5,
	'Metalness': 7,
};

class ReflectorForSSRPass extends Mesh$1 {

	constructor( geometry, options = {} ) {

		super( geometry );

		this.type = 'ReflectorForSSRPass';

		const scope = this;

		const color = ( options.color !== undefined ) ? new Color$2( options.color ) : new Color$2( 0x7F7F7F );
		const textureWidth = options.textureWidth || 512;
		const textureHeight = options.textureHeight || 512;
		const clipBias = options.clipBias || 0;
		const shader = options.shader || ReflectorForSSRPass.ReflectorShader;
		const useDepthTexture = options.useDepthTexture === true;
		const yAxis = new Vector3$1( 0, 1, 0 );
		const vecTemp0 = new Vector3$1();
		const vecTemp1 = new Vector3$1();

		//

		scope.needsUpdate = false;
		scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;
		scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;
		scope.color = color;
		scope.resolution = options.resolution || new Vector2$1( window.innerWidth, window.innerHeight );


		scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;
		Object.defineProperty( scope, 'distanceAttenuation', {
			get() {

				return scope._distanceAttenuation;

			},
			set( val ) {

				if ( scope._distanceAttenuation === val ) return;
				scope._distanceAttenuation = val;
				scope.material.defines.DISTANCE_ATTENUATION = val;
				scope.material.needsUpdate = true;

			}
		} );

		scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;
		Object.defineProperty( scope, 'fresnel', {
			get() {

				return scope._fresnel;

			},
			set( val ) {

				if ( scope._fresnel === val ) return;
				scope._fresnel = val;
				scope.material.defines.FRESNEL = val;
				scope.material.needsUpdate = true;

			}
		} );

		const normal = new Vector3$1();
		const reflectorWorldPosition = new Vector3$1();
		const cameraWorldPosition = new Vector3$1();
		const rotationMatrix = new Matrix4$1();
		const lookAtPosition = new Vector3$1( 0, 0, - 1 );

		const view = new Vector3$1();
		const target = new Vector3$1();

		const textureMatrix = new Matrix4$1();
		const virtualCamera = new PerspectiveCamera$1();

		let depthTexture;

		if ( useDepthTexture ) {

			depthTexture = new DepthTexture$1();
			depthTexture.type = UnsignedShortType$1;
			depthTexture.minFilter = NearestFilter$1;
			depthTexture.magFilter = NearestFilter$1;

		}

		const parameters = {
			minFilter: LinearFilter$1,
			magFilter: LinearFilter$1,
			format: RGBFormat$1,
			depthTexture: useDepthTexture ? depthTexture : null,
		};

		const renderTarget = new WebGLRenderTarget$1( textureWidth, textureHeight, parameters );

		if ( ! MathUtils.isPowerOfTwo( textureWidth ) || ! MathUtils.isPowerOfTwo( textureHeight ) ) {

			renderTarget.texture.generateMipmaps = false;

		}

		const material = new ShaderMaterial$1( {
			transparent: useDepthTexture,
			defines: Object.assign( {}, ReflectorForSSRPass.ReflectorShader.defines, {
				useDepthTexture
			} ),
			uniforms: UniformsUtils$1.clone( shader.uniforms ),
			fragmentShader: shader.fragmentShader,
			vertexShader: shader.vertexShader
		} );

		material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;
		material.uniforms[ 'color' ].value = scope.color;
		material.uniforms[ 'textureMatrix' ].value = textureMatrix;
		if ( useDepthTexture ) {

			material.uniforms[ 'tDepth' ].value = renderTarget.depthTexture;

		}

		this.material = material;

		const globalPlane = new Plane$1( new Vector3$1( 0, 1, 0 ), clipBias );
		const globalPlanes = [ globalPlane ];

		this.doRender = function ( renderer, scene, camera ) {

			material.uniforms[ 'maxDistance' ].value = scope.maxDistance;
			material.uniforms[ 'color' ].value = scope.color;
			material.uniforms[ 'opacity' ].value = scope.opacity;

			vecTemp0.copy( camera.position ).normalize();
			vecTemp1.copy( vecTemp0 ).reflect( yAxis );
			material.uniforms[ 'fresnelCoe' ].value = ( vecTemp0.dot( vecTemp1 ) + 1. ) / 2.; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.

			reflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );
			cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

			rotationMatrix.extractRotation( scope.matrixWorld );

			normal.set( 0, 0, 1 );
			normal.applyMatrix4( rotationMatrix );

			view.subVectors( reflectorWorldPosition, cameraWorldPosition );

			// Avoid rendering when reflector is facing away

			if ( view.dot( normal ) > 0 ) return;

			view.reflect( normal ).negate();
			view.add( reflectorWorldPosition );

			rotationMatrix.extractRotation( camera.matrixWorld );

			lookAtPosition.set( 0, 0, - 1 );
			lookAtPosition.applyMatrix4( rotationMatrix );
			lookAtPosition.add( cameraWorldPosition );

			target.subVectors( reflectorWorldPosition, lookAtPosition );
			target.reflect( normal ).negate();
			target.add( reflectorWorldPosition );

			virtualCamera.position.copy( view );
			virtualCamera.up.set( 0, 1, 0 );
			virtualCamera.up.applyMatrix4( rotationMatrix );
			virtualCamera.up.reflect( normal );
			virtualCamera.lookAt( target );

			virtualCamera.far = camera.far; // Used in WebGLBackground

			virtualCamera.updateMatrixWorld();
			virtualCamera.projectionMatrix.copy( camera.projectionMatrix );

			material.uniforms[ 'virtualCameraNear' ].value = camera.near;
			material.uniforms[ 'virtualCameraFar' ].value = camera.far;
			material.uniforms[ 'virtualCameraMatrixWorld' ].value = virtualCamera.matrixWorld;
			material.uniforms[ 'virtualCameraProjectionMatrix' ].value = camera.projectionMatrix;
			material.uniforms[ 'virtualCameraProjectionMatrixInverse' ].value = camera.projectionMatrixInverse;
			material.uniforms[ 'resolution' ].value = scope.resolution;

			// Update the texture matrix
			textureMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);
			textureMatrix.multiply( virtualCamera.projectionMatrix );
			textureMatrix.multiply( virtualCamera.matrixWorldInverse );
			textureMatrix.multiply( scope.matrixWorld );

			// Render

			renderTarget.texture.encoding = renderer.outputEncoding;

			// scope.visible = false;

			const currentRenderTarget = renderer.getRenderTarget();

			const currentXrEnabled = renderer.xr.enabled;
			const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
			const currentClippingPlanes = renderer.clippingPlanes;

			renderer.xr.enabled = false; // Avoid camera modification
			renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows
			renderer.clippingPlanes = globalPlanes;

			renderer.setRenderTarget( renderTarget );

			renderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897

			if ( renderer.autoClear === false ) renderer.clear();
			renderer.render( scene, virtualCamera );

			renderer.xr.enabled = currentXrEnabled;
			renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
			renderer.clippingPlanes = currentClippingPlanes;

			renderer.setRenderTarget( currentRenderTarget );

			// Restore viewport

			const viewport = camera.viewport;

			if ( viewport !== undefined ) {

				renderer.state.viewport( viewport );

			}

			// scope.visible = true;

		};

		this.getRenderTarget = function () {

			return renderTarget;

		};

	}

}

ReflectorForSSRPass.prototype.isReflectorForSSRPass = true;

ReflectorForSSRPass.ReflectorShader = {

	defines: {
		DISTANCE_ATTENUATION: true,
		FRESNEL: true,
	},

	uniforms: {

		color: { value: null },
		tDiffuse: { value: null },
		tDepth: { value: null },
		textureMatrix: { value: new Matrix4$1() },
		maxDistance: { value: 180 },
		opacity: { value: 0.5 },
		fresnelCoe: { value: null },
		virtualCameraNear: { value: null },
		virtualCameraFar: { value: null },
		virtualCameraProjectionMatrix: { value: new Matrix4$1() },
		virtualCameraMatrixWorld: { value: new Matrix4$1() },
		virtualCameraProjectionMatrixInverse: { value: new Matrix4$1() },
		resolution: { value: new Vector2$1() },

	},

	vertexShader: /* glsl */`
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float maxDistance;
		uniform float opacity;
		uniform float fresnelCoe;
		uniform float virtualCameraNear;
		uniform float virtualCameraFar;
		uniform mat4 virtualCameraProjectionMatrix;
		uniform mat4 virtualCameraProjectionMatrixInverse;
		uniform mat4 virtualCameraMatrixWorld;
		uniform vec2 resolution;
		varying vec4 vUv;
		#include <packing>
		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view
		}
		void main() {
			vec4 base = texture2DProj( tDiffuse, vUv );
			#ifdef useDepthTexture
				vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;
				uv.x=1.-uv.x;
				float depth = texture2DProj( tDepth, vUv ).r;
				float viewZ = getViewZ( depth );
				float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];
				vec3 viewPosition=getViewPosition( uv, depth, clipW );
				vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;
				if(worldPosition.y>maxDistance) discard;
				float op=opacity;
				#ifdef DISTANCE_ATTENUATION
					float ratio=1.-(worldPosition.y/maxDistance);
					float attenuation=ratio*ratio;
					op=opacity*attenuation;
				#endif
				#ifdef FRESNEL
					op*=fresnelCoe;
				#endif
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );
			#else
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );
			#endif
		}
	`,
};

class MaskPass extends Pass {

	constructor( scene, camera ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.clear = true;
		this.needsSwap = false;

		this.inverse = false;

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const context = renderer.getContext();
		const state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask( false );
		state.buffers.depth.setMask( false );

		// lock buffers

		state.buffers.color.setLocked( true );
		state.buffers.depth.setLocked( true );

		// set up stencil

		let writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		state.buffers.stencil.setTest( true );
		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
		state.buffers.stencil.setClear( clearValue );
		state.buffers.stencil.setLocked( true );

		// draw into the stencil buffer

		renderer.setRenderTarget( readBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		renderer.setRenderTarget( writeBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked( false );
		state.buffers.depth.setLocked( false );

		// only render where stencil is set to 1

		state.buffers.stencil.setLocked( false );
		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
		state.buffers.stencil.setLocked( true );

	}

}

class ClearMaskPass extends Pass {

	constructor() {

		super();

		this.needsSwap = false;

	}

	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		renderer.state.buffers.stencil.setLocked( false );
		renderer.state.buffers.stencil.setTest( false );

	}

}

class EffectComposer {

	constructor( renderer, renderTarget ) {

		this.renderer = renderer;

		if ( renderTarget === undefined ) {

			const parameters = {
				minFilter: LinearFilter$1,
				magFilter: LinearFilter$1,
				format: RGBAFormat$1
			};

			const size = renderer.getSize( new Vector2$1() );
			this._pixelRatio = renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = new WebGLRenderTarget$1( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );
			renderTarget.texture.name = 'EffectComposer.rt1';

		} else {

			this._pixelRatio = 1;
			this._width = renderTarget.width;
			this._height = renderTarget.height;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.renderToScreen = true;

		this.passes = [];

		// dependencies

		if ( CopyShader === undefined ) {

			console.error( 'THREE.EffectComposer relies on CopyShader' );

		}

		if ( ShaderPass === undefined ) {

			console.error( 'THREE.EffectComposer relies on ShaderPass' );

		}

		this.copyPass = new ShaderPass( CopyShader );

		this.clock = new Clock();

	}

	swapBuffers() {

		const tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	}

	addPass( pass ) {

		this.passes.push( pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	insertPass( pass, index ) {

		this.passes.splice( index, 0, pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	removePass( pass ) {

		const index = this.passes.indexOf( pass );

		if ( index !== - 1 ) {

			this.passes.splice( index, 1 );

		}

	}

	isLastEnabledPass( passIndex ) {

		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

			if ( this.passes[ i ].enabled ) {

				return false;

			}

		}

		return true;

	}

	render( deltaTime ) {

		// deltaTime value is in seconds

		if ( deltaTime === undefined ) {

			deltaTime = this.clock.getDelta();

		}

		const currentRenderTarget = this.renderer.getRenderTarget();

		let maskActive = false;

		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

			const pass = this.passes[ i ];

			if ( pass.enabled === false ) continue;

			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					const context = this.renderer.getContext();
					const stencil = this.renderer.state.buffers.stencil;

					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( MaskPass !== undefined ) {

				if ( pass instanceof MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof ClearMaskPass ) {

					maskActive = false;

				}

			}

		}

		this.renderer.setRenderTarget( currentRenderTarget );

	}

	reset( renderTarget ) {

		if ( renderTarget === undefined ) {

			const size = this.renderer.getSize( new Vector2$1() );
			this._pixelRatio = this.renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	}

	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

		for ( let i = 0; i < this.passes.length; i ++ ) {

			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

		}

	}

	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

}

// Helper for passes that need to fill the viewport with a single quad.

new OrthographicCamera$1( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry$1 = new BufferGeometry$1();
_geometry$1.setAttribute( 'position', new Float32BufferAttribute$1( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry$1.setAttribute( 'uv', new Float32BufferAttribute$1( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

/**
 * TODO
 */

const SAOShader = {
	defines: {
		'NUM_SAMPLES': 7,
		'NUM_RINGS': 4,
		'NORMAL_TEXTURE': 0,
		'DIFFUSE_TEXTURE': 0,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {

		'tDepth': { value: null },
		'tDiffuse': { value: null },
		'tNormal': { value: null },
		'size': { value: new Vector2$1( 512, 512 ) },

		'cameraNear': { value: 1 },
		'cameraFar': { value: 100 },
		'cameraProjectionMatrix': { value: new Matrix4$1() },
		'cameraInverseProjectionMatrix': { value: new Matrix4$1() },

		'scale': { value: 1.0 },
		'intensity': { value: 0.1 },
		'bias': { value: 0.5 },

		'minResolution': { value: 0.0 },
		'kernelRadius': { value: 100.0 },
		'randomSeed': { value: 0.0 }
	},
	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,

	fragmentShader: /* glsl */`

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;

		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			#if NORMAL_TEXTURE == 1
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#else
			return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}`

};

/**
 * TODO
 */

const DepthLimitedBlurShader = {
	defines: {
		'KERNEL_RADIUS': 4,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {
		'tDiffuse': { value: null },
		'size': { value: new Vector2$1( 512, 512 ) },
		'sampleUvOffsets': { value: [ new Vector2$1( 0, 0 ) ] },
		'sampleWeights': { value: [ 1.0 ] },
		'tDepth': { value: null },
		'cameraNear': { value: 10 },
		'cameraFar': { value: 1000 },
		'depthCutoff': { value: 10 },
	},
	vertexShader: /* glsl */`

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,

	fragmentShader: /* glsl */`

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`

};

const BlurShaderUtils = {

	createSampleWeights: function ( kernelRadius, stdDev ) {

		const weights = [];

		for ( let i = 0; i <= kernelRadius; i ++ ) {

			weights.push( gaussian( i, stdDev ) );

		}

		return weights;

	},

	createSampleOffsets: function ( kernelRadius, uvIncrement ) {

		const offsets = [];

		for ( let i = 0; i <= kernelRadius; i ++ ) {

			offsets.push( uvIncrement.clone().multiplyScalar( i ) );

		}

		return offsets;

	},

	configure: function ( material, kernelRadius, stdDev, uvIncrement ) {

		material.defines[ 'KERNEL_RADIUS' ] = kernelRadius;
		material.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );
		material.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );
		material.needsUpdate = true;

	}

};

function gaussian( x, stdDev ) {

	return Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );

}

/**
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

const UnpackDepthRGBAShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		#include <packing>

		void main() {

			float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );
			gl_FragColor = vec4( vec3( depth ), opacity );

		}`

};

/**
 * SAO implementation inspired from bhouston previous SAO work
 */

class SAOPass extends Pass {

	constructor( scene, camera, depthTexture, useNormals, resolution ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.clear = true;
		this.needsSwap = false;

		this.supportsDepthTextureExtension = ( depthTexture !== undefined ) ? depthTexture : false;
		this.supportsNormalTexture = ( useNormals !== undefined ) ? useNormals : false;

		this.originalClearColor = new Color$2();
		this._oldClearColor = new Color$2();
		this.oldClearAlpha = 1;

		this.params = {
			output: 0,
			saoBias: 0.5,
			saoIntensity: 0.18,
			saoScale: 1,
			saoKernelRadius: 100,
			saoMinResolution: 0,
			saoBlur: true,
			saoBlurRadius: 8,
			saoBlurStdDev: 4,
			saoBlurDepthCutoff: 0.01
		};

		this.resolution = ( resolution !== undefined ) ? new Vector2$1( resolution.x, resolution.y ) : new Vector2$1( 256, 256 );

		this.saoRenderTarget = new WebGLRenderTarget$1( this.resolution.x, this.resolution.y, {
			minFilter: LinearFilter$1,
			magFilter: LinearFilter$1,
			format: RGBAFormat$1
		} );
		this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
		this.beautyRenderTarget = this.saoRenderTarget.clone();

		this.normalRenderTarget = new WebGLRenderTarget$1( this.resolution.x, this.resolution.y, {
			minFilter: NearestFilter$1,
			magFilter: NearestFilter$1,
			format: RGBAFormat$1
		} );
		this.depthRenderTarget = this.normalRenderTarget.clone();

		if ( this.supportsDepthTextureExtension ) {

			const depthTexture = new DepthTexture$1();
			depthTexture.type = UnsignedShortType$1;

			this.beautyRenderTarget.depthTexture = depthTexture;
			this.beautyRenderTarget.depthBuffer = true;

		}

		this.depthMaterial = new MeshDepthMaterial$1();
		this.depthMaterial.depthPacking = RGBADepthPacking$1;
		this.depthMaterial.blending = NoBlending$1;

		this.normalMaterial = new MeshNormalMaterial$1();
		this.normalMaterial.blending = NoBlending$1;

		if ( SAOShader === undefined ) {

			console.error( 'THREE.SAOPass relies on SAOShader' );

		}

		this.saoMaterial = new ShaderMaterial$1( {
			defines: Object.assign( {}, SAOShader.defines ),
			fragmentShader: SAOShader.fragmentShader,
			vertexShader: SAOShader.vertexShader,
			uniforms: UniformsUtils$1.clone( SAOShader.uniforms )
		} );
		this.saoMaterial.extensions.derivatives = true;
		this.saoMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
		this.saoMaterial.defines[ 'NORMAL_TEXTURE' ] = this.supportsNormalTexture ? 1 : 0;
		this.saoMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
		this.saoMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
		this.saoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
		this.saoMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
		this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );
		this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;
		this.saoMaterial.blending = NoBlending$1;

		if ( DepthLimitedBlurShader === undefined ) {

			console.error( 'THREE.SAOPass relies on DepthLimitedBlurShader' );

		}

		this.vBlurMaterial = new ShaderMaterial$1( {
			uniforms: UniformsUtils$1.clone( DepthLimitedBlurShader.uniforms ),
			defines: Object.assign( {}, DepthLimitedBlurShader.defines ),
			vertexShader: DepthLimitedBlurShader.vertexShader,
			fragmentShader: DepthLimitedBlurShader.fragmentShader
		} );
		this.vBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
		this.vBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
		this.vBlurMaterial.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;
		this.vBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
		this.vBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
		this.vBlurMaterial.blending = NoBlending$1;

		this.hBlurMaterial = new ShaderMaterial$1( {
			uniforms: UniformsUtils$1.clone( DepthLimitedBlurShader.uniforms ),
			defines: Object.assign( {}, DepthLimitedBlurShader.defines ),
			vertexShader: DepthLimitedBlurShader.vertexShader,
			fragmentShader: DepthLimitedBlurShader.fragmentShader
		} );
		this.hBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
		this.hBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
		this.hBlurMaterial.uniforms[ 'tDiffuse' ].value = this.blurIntermediateRenderTarget.texture;
		this.hBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
		this.hBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
		this.hBlurMaterial.blending = NoBlending$1;

		if ( CopyShader === undefined ) {

			console.error( 'THREE.SAOPass relies on CopyShader' );

		}

		this.materialCopy = new ShaderMaterial$1( {
			uniforms: UniformsUtils$1.clone( CopyShader.uniforms ),
			vertexShader: CopyShader.vertexShader,
			fragmentShader: CopyShader.fragmentShader,
			blending: NoBlending$1
		} );
		this.materialCopy.transparent = true;
		this.materialCopy.depthTest = false;
		this.materialCopy.depthWrite = false;
		this.materialCopy.blending = CustomBlending$1;
		this.materialCopy.blendSrc = DstColorFactor$1;
		this.materialCopy.blendDst = ZeroFactor$1;
		this.materialCopy.blendEquation = AddEquation$1;
		this.materialCopy.blendSrcAlpha = DstAlphaFactor$1;
		this.materialCopy.blendDstAlpha = ZeroFactor$1;
		this.materialCopy.blendEquationAlpha = AddEquation$1;

		if ( UnpackDepthRGBAShader === undefined ) {

			console.error( 'THREE.SAOPass relies on UnpackDepthRGBAShader' );

		}

		this.depthCopy = new ShaderMaterial$1( {
			uniforms: UniformsUtils$1.clone( UnpackDepthRGBAShader.uniforms ),
			vertexShader: UnpackDepthRGBAShader.vertexShader,
			fragmentShader: UnpackDepthRGBAShader.fragmentShader,
			blending: NoBlending$1
		} );

		this.fsQuad = new FullScreenQuad( null );

	}

	render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {

		// Rendering readBuffer first when rendering to screen
		if ( this.renderToScreen ) {

			this.materialCopy.blending = NoBlending$1;
			this.materialCopy.uniforms[ 'tDiffuse' ].value = readBuffer.texture;
			this.materialCopy.needsUpdate = true;
			this.renderPass( renderer, this.materialCopy, null );

		}

		if ( this.params.output === 1 ) {

			return;

		}

		renderer.getClearColor( this._oldClearColor );
		this.oldClearAlpha = renderer.getClearAlpha();
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setRenderTarget( this.depthRenderTarget );
		renderer.clear();

		this.saoMaterial.uniforms[ 'bias' ].value = this.params.saoBias;
		this.saoMaterial.uniforms[ 'intensity' ].value = this.params.saoIntensity;
		this.saoMaterial.uniforms[ 'scale' ].value = this.params.saoScale;
		this.saoMaterial.uniforms[ 'kernelRadius' ].value = this.params.saoKernelRadius;
		this.saoMaterial.uniforms[ 'minResolution' ].value = this.params.saoMinResolution;
		this.saoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.saoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
		// this.saoMaterial.uniforms['randomSeed'].value = Math.random();

		const depthCutoff = this.params.saoBlurDepthCutoff * ( this.camera.far - this.camera.near );
		this.vBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;
		this.hBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;

		this.vBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.vBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
		this.hBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.hBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;

		this.params.saoBlurRadius = Math.floor( this.params.saoBlurRadius );
		if ( ( this.prevStdDev !== this.params.saoBlurStdDev ) || ( this.prevNumSamples !== this.params.saoBlurRadius ) ) {

			BlurShaderUtils.configure( this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2$1( 0, 1 ) );
			BlurShaderUtils.configure( this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2$1( 1, 0 ) );
			this.prevStdDev = this.params.saoBlurStdDev;
			this.prevNumSamples = this.params.saoBlurRadius;

		}

		// Rendering scene to depth texture
		renderer.setClearColor( 0x000000 );
		renderer.setRenderTarget( this.beautyRenderTarget );
		renderer.clear();
		renderer.render( this.scene, this.camera );

		// Re-render scene if depth texture extension is not supported
		if ( ! this.supportsDepthTextureExtension ) {

			// Clear rule : far clipping plane in both RGBA and Basic encoding
			this.renderOverride( renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0 );

		}

		if ( this.supportsNormalTexture ) {

			// Clear rule : default normal is facing the camera
			this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );

		}

		// Rendering SAO texture
		this.renderPass( renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0 );

		// Blurring SAO texture
		if ( this.params.saoBlur ) {

			this.renderPass( renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0 );
			this.renderPass( renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0 );

		}

		let outputMaterial = this.materialCopy;
		// Setting up SAO rendering
		if ( this.params.output === 3 ) {

			if ( this.supportsDepthTextureExtension ) {

				this.materialCopy.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.depthTexture;
				this.materialCopy.needsUpdate = true;

			} else {

				this.depthCopy.uniforms[ 'tDiffuse' ].value = this.depthRenderTarget.texture;
				this.depthCopy.needsUpdate = true;
				outputMaterial = this.depthCopy;

			}

		} else if ( this.params.output === 4 ) {

			this.materialCopy.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
			this.materialCopy.needsUpdate = true;

		} else {

			this.materialCopy.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;
			this.materialCopy.needsUpdate = true;

		}

		// Blending depends on output, only want a CustomBlending when showing SAO
		if ( this.params.output === 0 ) {

			outputMaterial.blending = CustomBlending$1;

		} else {

			outputMaterial.blending = NoBlending$1;

		}

		// Rendering SAOPass result on top of previous pass
		this.renderPass( renderer, outputMaterial, this.renderToScreen ? null : readBuffer );

		renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;

	}

	renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {

		// save original state
		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );

		// setup pass state
		renderer.autoClear = false;
		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.fsQuad.material = passMaterial;
		this.fsQuad.render( renderer );

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );
		renderer.autoClear = false;

		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.scene.overrideMaterial = overrideMaterial;
		renderer.render( this.scene, this.camera );
		this.scene.overrideMaterial = null;

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	setSize( width, height ) {

		this.beautyRenderTarget.setSize( width, height );
		this.saoRenderTarget.setSize( width, height );
		this.blurIntermediateRenderTarget.setSize( width, height );
		this.normalRenderTarget.setSize( width, height );
		this.depthRenderTarget.setSize( width, height );

		this.saoMaterial.uniforms[ 'size' ].value.set( width, height );
		this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );
		this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;
		this.saoMaterial.needsUpdate = true;

		this.vBlurMaterial.uniforms[ 'size' ].value.set( width, height );
		this.vBlurMaterial.needsUpdate = true;

		this.hBlurMaterial.uniforms[ 'size' ].value.set( width, height );
		this.hBlurMaterial.needsUpdate = true;

	}

}

SAOPass.OUTPUT = {
	'Beauty': 1,
	'Default': 0,
	'SAO': 2,
	'Depth': 3,
	'Normal': 4
};

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };

class OrbitControls extends EventDispatcher$1 {

	constructor( object, domElement ) {

		super();

		if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
		if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3$1();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = true;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = .5;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new Vector3$1();

			// so camera.up is the orbit axis
			const quat = new Quaternion$1().setFromUnitVectors( object.up, new Vector3$1( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new Vector3$1();
			const lastQuaternion = new Quaternion$1();

			const twoPI = 2 * Math.PI;

			return function update() {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				scale = 1;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );


			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();

		let scale = 1;
		const panOffset = new Vector3$1();
		let zoomChanged = false;

		const rotateStart = new Vector2$1();
		const rotateEnd = new Vector2$1();
		const rotateDelta = new Vector2$1();

		const panStart = new Vector2$1();
		const panEnd = new Vector2$1();
		const panDelta = new Vector2$1();

		const dollyStart = new Vector2$1();
		const dollyEnd = new Vector2$1();
		const dollyDelta = new Vector2$1();

		const pointers = [];
		const pointerPositions = {};

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new Vector3$1();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new Vector3$1();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new Vector3$1();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate() {

			if ( pointers.length === 1 ) {

				rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan() {

			if ( pointers.length === 1 ) {

				panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly() {

			const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
			const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enablePan ) handleTouchStartPan();

		}

		function handleTouchStartDollyRotate() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enableRotate ) handleTouchStartRotate();

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp );

			}

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchEnd();

			} else {

				onMouseUp();

			}

			removePointer( event );

			//

			if ( pointers.length === 0 ) {

				scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );
				scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );

			}

		}

		function onPointerCancel( event ) {

			removePointer( event );

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseUp( event ) {

			scope.dispatchEvent( _endEvent );

			state = STATE.NONE;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( event );

			scope.dispatchEvent( _endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate();

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan();

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan();

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate();

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onTouchEnd( event ) {

			scope.dispatchEvent( _endEvent );

			state = STATE.NONE;

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ].pointerId == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new Vector2$1();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointer.pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		// force an update at start

		this.update();

	}

}

class EXRCamera extends OrbitControls {
  constructor(camera, renderer, config = { target: null }) {
    super(camera, renderer.domElement);
    this.camera = camera;
    this._locked = true;

    this.isInteracting = false;

    this.screenSpacePanning = false;
    this.enablePan = true;
    this._lockTarget = null;
    this._tweening = false;
    this._camLook = new Vector3$1();

    return this;
  }

  get updated() {
    return this.needsUpdating || this.isInteracting;
  }

  get isLocked() {
    return this._locked;
  }

  lockOnTarget(target) {
    this._lockTarget = target;
    return this;
  }

  centerPivot() {
    const cpos = this.camera.position.clone();
    cpos.addScaledVector(new Vector3$1(0,0,0.01));
    this.target = cpos;
    return this;
  }

  async after(duration = 0) {
    return await new Promise((res) => {
      if (duration) {
        setTimeout(_ => {
          res(this);
        }, duration);
      }
    })
  }

  lookOnSelf() {
    
  }

  rotateTo(target, dur = 1) {
    if(target instanceof Object3D$1) target = target.position.clone();
    const v = new Vector3$1(0,0,0.01);
    v.applyQuaternion(this.camera.quarternion);
    const a = v.angleTo(target);
    gsap.to(this.camera.rotation, { ...a, duration: dur, ease: 'sine.out' });
  }

  lock() {
    this._locked = true;
    this.dispatchEvent({ type: "lock" });
  }

  unlock() {
    this._locked = false;
    this.dispatchEvent({ type: "unlock" });
  }

  lookAt(target, tween = false, gaze = true) {
    // this.target = target;
    const self = this;
    new Vector3$1().copy(this.target);

    if (tween) {
      if (!this._tweening) {
        this._tweening = true;

        gsap.to(this._camLook, {
          x: target.x, y: target.y, z: target.z, duration: 2, ease: 'sine.out', delay: 0.5, onComplete: () => {
            self._tweening = false;
          },
          onUpdate: () => {
            self.camera.lookAt(self._camLook);
          }
        });
      }
    } else {
      this.target = target;
    }
    this._target = target;
  }

  moveTo(target, delay = 0, complete = undefined) {
    let pos = target.clone();

    gsap.to(this.camera.position, { ...pos, duration: 1, delay: delay, onComplete: complete });
    // createjs.Tween.get(this.camera.position, { onComplete: complete }).wait(delay).to(pos, 1200);
  }
}

class SceneManager$1 extends Emitter {
  static __instance;
  constructor() {
    super();
    this._debug = true;
    this._light = true;
    this._helpers = true;
    this._cam;
    this._cams;
    this._animations;
    this._renderer;
    this._controls;
    this._scene;
    this._objects = [];
    this._rayHit = true;
    this._clock = new Clock(false);
    this._globListener;
    this._isNew = true;
    this._isLoading = false;
    this._isBusy = false;
    this.speech = new TTS({ voice: 0, pitch: 1.001 });
    this._audio = new Howler;
    this._layers = {
      lights: 2,
      meshes: 1,
      bounds: 3,
      helpers: 4,
    };
    this._loader;
  }

  static get instance() {
    if (!SceneManager$1.__instance) {
      SceneManager$1.__instance = new SceneManager$1();
    }
    return SceneManager$1.__instance;
  }

  get clock() {
    return this._clock;
  }

  get renderer() {
    return this._renderer;
  }

  set renderer(r) {
    this._renderer = r;
  }

  get camera() {
    return this._cam;
  }

  set camera(c) {
    this._cam = c;
    //TODO: switch camera
  }

  get scene() {
    return this._scene;
  }

  set scene(s) {
    this._scene = s;
  }

  get canvas() {
    return this._renderer.domElement;
  }

  async setup(domElement = undefined, id = "tmscene", conf = {}) {
    const config = {
      ...conf,
      width: window.offsetWidth,
      height: window.offsetHeight,
    };
    const { renderer, scene, camera } = await setupScene(
      domElement,
      id,
      config
    );
    if (renderer) {
      this._renderer = renderer;
      this._cam = camera;
      this._scene = scene;
      const controls = setupControls(this._cam, this._scene, this._renderer);
      this._controls = controls;
      this.emit("setupcompleted", this);
      return this;
    } else {
      this.emit("error", `error at setup scene are not created`);
      return;
    }
  }

  createHelper(mesh, helperType = undefined) {
    if (mesh.type === "Mesh") {
      if (!mesh.helper) {
        const box = new Box3$1().setFromObject(mesh);
        const bhelper = helperType
          ? new helperType(mesh)
          : new Box3Helper(box, 0xffff00);
        bhelper.layers.set(this._layers.helpers);
        mesh.add(bhelper);
      }
    } else if (mesh.type === "Light") {
      const lhelper = new helperType(mesh, 0.2, 0x00eeff);
      lhelper.layers.set(this._layers.lights);
      mesh.add(lhelper);
    }
  }

  async loadAssets(manifestData, reload = false) {
    if (this._isNew || reload) {
      this.reset();
      const { models, textures } = manifestData;
      this.emit("begin", models);
      for (let i = 0; i < models.length; i++) {
        models.length;
        const model = models[i];
        const mesh = await this.loadModel(model, ({ l, t }) => {
          this.emit("progress", { index: i, total: models.length, mesh: mesh });
        });
        if (mesh) {
          this._objects.push(mesh);
        }
      }
    }
  }

  sortTypes(mesh) {
    let meshes = {};
    let lights = {};
    let mats = {};

    mesh.traverse((node) => {
      if (node.type === "Mesh") {
        meshes[node.name] = node;
      } else if (node.type.contains("Light")) {
        lights[node.name] = node;
      } else if (node.type === "Material") {
        mats[node.name] = node;
      }
    });
    this._objects = { ...meshes, ...this._objects };
  }

  reset() {}
}
const SETTINGS = {
  physicallyCorrectLights: true,
  ambient: 1.8,
  sun: 1.8,
  shadow: true,
  bloom: true,
  ao: false,
  BLOOM_SCENE: 1,
  tone: LinearToneMapping$1,
  encoding: sRGBEncoding$1,
  precision: "highp",
  gamma: 2.2,
  useExportedAssets: true,
  reflective: false,
  outlined: true
};

const setupScene = async (
  targetEl,
  id = "three",
  config = undefined
) => {
  return await new Promise((resolve, reject) => {
    let parentEl;
    if (typeof targetEl===Object) {
      parentEl = targetEl;
    } else {
      parentEl = document.querySelector(targetEl);
    }

    if (!parentEl)  {
      reject("invalid target element");
      return
    }

    config = {
      width: parentEl.offsetWidth,
      height: parentEl.offsetHeight,
      far: 50,
      near: 0.1,
      showStats: true,
      shadow: true,
    };
    const aspect = config.width / config.height;
    const scene = new Scene$1();

    scene.background = 0x000000;
    const camera = new PerspectiveCamera$1(
      60,
      aspect,
      config.near,
      config.far
    );

    const renderer = new WebGLRenderer$1({
      antialias: false,
      alpha: false,
      depth: true,
      resizeTo: parentEl || null,
      autoRender: false,
      autoClear: false,
      pixelRatio: window.devicePixelRatio,
      // powerPreference: isMobile() ? '' : 'high-performance'
    });
    renderer.setClearColor(0x0000000, 1);
    renderer.toneMapping = SETTINGS.tone;
    renderer.outputEncoding = SETTINGS.encoding;
    renderer.physicallyCorrectLights = SETTINGS.physicallyCorrectLights;
    renderer.gammaFactor = SETTINGS.gamma;
    renderer.setSize(config.width, config.height);
    if (config.shadow) {
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = PCFSoftShadowMap$1;
      renderer.shadowMap.autoUpdate = false;
    }
    //CameraControls.install({ THREE: THREE });

    camera.position.set(0.5, 1.5, -7);

    const clock = SceneManager$1.clock;

    const canvas = renderer.domElement;

    parentEl.appendChild(canvas);

    camera.lookAt(0.5, 1, 0);

    const composer = postEffects(renderer, scene, camera);
    const result = {
      scene,
      renderer,
      camera,
      composer,
      clock,
    };
    //SceneManager.instance.createLightProbe(scene, renderer);

    resolve(result);
  });
};



function setupControls(
  camera,
  scene = undefined,
  targetEl = "#overlay",
  renderer = undefined
) {
  //const controls = new PointerLockControls(camera, document.body);
  const controls = new EXRCamera(
    camera,
    renderer,
    { dist: 7 },  
  );
  const screen = document.querySelector(targetEl);
  controls.addEventListener("lock", function () {
    anime({
      targets: screen,
      opacity: 0,
      duration: 800,
      easing: "easeOutSine",
      complete: () => {
        screen.style.display = "none";
      },
    });
  });

  controls.addEventListener("unlock", function () {
    screen.style.display = "flex";
    window.loadProgress("Click to continue");
    anime({
      targets: screen,
      opacity: 0.8,
      duration: 800,
      easing: "easeOutSine",
      complete: () => {
        screen.style.display = "flex";
        //screen.parentElement.removeChild(screen);
      },
    });
  });

  return controls;
}

// postEffects for shader filtering
// recommended to use AA from shader, as opposed to canvas AA
const postEffects = (
  renderer,
  scene,
  camera,
  renderTarget = undefined
) => {
  const renderPass = new RenderPass(scene, camera);
  const fxaaPass = new ShaderPass(FXAAShader);

  const pixelRatio = renderer.getPixelRatio();

  const container = renderer.domElement;
  const dim = new Vector2$1(container.offsetWidth, container.offsetHeight);

  const fxaa = fxaaPass;
  fxaaPass.material.uniforms["resolution"].value.x =
    1 / (dim.x * pixelRatio);
  fxaaPass.material.uniforms["resolution"].value.y =
    1 / (dim.y * pixelRatio);
  const target = renderTarget || renderer;

  const composer = new EffectComposer(target);

  let reflects;

  let outline;
  {
    
    const outlinePass = new OutlinePass(dim, scene, camera, SceneManager$1._objects);
    outlinePass.edgeThickness = 1;
    outlinePass.edgeStrength = 3;
    outlinePass.visibleEdgeColor = 0xffffff;
    
    outline = {selects: SceneManager$1._objects, pass: outlinePass};
    composer.addPass(outlinePass);
  }
  let fxCopy;
  if (!isMobile()) {
    fxCopy = new ShaderPass(CopyShader);
    const bloomPass = new BloomPass(1, 25, 5);
    fxCopy.renderToScreen = true;

    composer.addPass(bloomPass);
  }
  composer.addPass(renderPass);


  if (fxCopy) {
    composer.addPass(fxCopy);
  }
  composer.addPass(fxaaPass);

  return { composer, fxaa, reflects, outline };
};

/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
 const REVISION = '130';
 const CullFaceNone = 0;
 const CullFaceBack = 1;
 const CullFaceFront = 2;
 const PCFShadowMap = 1;
 const PCFSoftShadowMap = 2;
 const VSMShadowMap = 3;
 const FrontSide = 0;
 const BackSide = 1;
 const DoubleSide = 2;
 const FlatShading = 1;
 const NoBlending = 0;
 const NormalBlending = 1;
 const AdditiveBlending = 2;
 const SubtractiveBlending = 3;
 const MultiplyBlending = 4;
 const CustomBlending = 5;
 const AddEquation = 100;
 const SubtractEquation = 101;
 const ReverseSubtractEquation = 102;
 const MinEquation = 103;
 const MaxEquation = 104;
 const ZeroFactor = 200;
 const OneFactor = 201;
 const SrcColorFactor = 202;
 const OneMinusSrcColorFactor = 203;
 const SrcAlphaFactor = 204;
 const OneMinusSrcAlphaFactor = 205;
 const DstAlphaFactor = 206;
 const OneMinusDstAlphaFactor = 207;
 const DstColorFactor = 208;
 const OneMinusDstColorFactor = 209;
 const SrcAlphaSaturateFactor = 210;
 const NeverDepth = 0;
 const AlwaysDepth = 1;
 const LessDepth = 2;
 const LessEqualDepth = 3;
 const EqualDepth = 4;
 const GreaterEqualDepth = 5;
 const GreaterDepth = 6;
 const NotEqualDepth = 7;
 const MultiplyOperation = 0;
 const MixOperation = 1;
 const AddOperation = 2;
 const NoToneMapping = 0;
 const LinearToneMapping = 1;
 const ReinhardToneMapping = 2;
 const CineonToneMapping = 3;
 const ACESFilmicToneMapping = 4;
 const CustomToneMapping = 5;

 const UVMapping = 300;
 const CubeReflectionMapping = 301;
 const CubeRefractionMapping = 302;
 const EquirectangularReflectionMapping = 303;
 const EquirectangularRefractionMapping = 304;
 const CubeUVReflectionMapping = 306;
 const CubeUVRefractionMapping = 307;
 const RepeatWrapping = 1000;
 const ClampToEdgeWrapping = 1001;
 const MirroredRepeatWrapping = 1002;
 const NearestFilter = 1003;
 const NearestMipmapNearestFilter = 1004;
 const NearestMipmapLinearFilter = 1005;
 const LinearFilter = 1006;
 const LinearMipmapNearestFilter = 1007;
 const LinearMipmapLinearFilter = 1008;
 const UnsignedByteType = 1009;
 const ByteType = 1010;
 const ShortType = 1011;
 const UnsignedShortType = 1012;
 const IntType = 1013;
 const UnsignedIntType = 1014;
 const FloatType = 1015;
 const HalfFloatType = 1016;
 const UnsignedShort4444Type = 1017;
 const UnsignedShort5551Type = 1018;
 const UnsignedShort565Type = 1019;
 const UnsignedInt248Type = 1020;
 const AlphaFormat = 1021;
 const RGBFormat = 1022;
 const RGBAFormat = 1023;
 const LuminanceFormat = 1024;
 const LuminanceAlphaFormat = 1025;
 const DepthFormat = 1026;
 const DepthStencilFormat = 1027;
 const RedFormat = 1028;
 const RedIntegerFormat = 1029;
 const RGFormat = 1030;
 const RGIntegerFormat = 1031;
 const RGBIntegerFormat = 1032;
 const RGBAIntegerFormat = 1033;

 const RGB_S3TC_DXT1_Format = 33776;
 const RGBA_S3TC_DXT1_Format = 33777;
 const RGBA_S3TC_DXT3_Format = 33778;
 const RGBA_S3TC_DXT5_Format = 33779;
 const RGB_PVRTC_4BPPV1_Format = 35840;
 const RGB_PVRTC_2BPPV1_Format = 35841;
 const RGBA_PVRTC_4BPPV1_Format = 35842;
 const RGBA_PVRTC_2BPPV1_Format = 35843;
 const RGB_ETC1_Format = 36196;
 const RGB_ETC2_Format = 37492;
 const RGBA_ETC2_EAC_Format = 37496;
 const RGBA_ASTC_4x4_Format = 37808;
 const RGBA_ASTC_5x4_Format = 37809;
 const RGBA_ASTC_5x5_Format = 37810;
 const RGBA_ASTC_6x5_Format = 37811;
 const RGBA_ASTC_6x6_Format = 37812;
 const RGBA_ASTC_8x5_Format = 37813;
 const RGBA_ASTC_8x6_Format = 37814;
 const RGBA_ASTC_8x8_Format = 37815;
 const RGBA_ASTC_10x5_Format = 37816;
 const RGBA_ASTC_10x6_Format = 37817;
 const RGBA_ASTC_10x8_Format = 37818;
 const RGBA_ASTC_10x10_Format = 37819;
 const RGBA_ASTC_12x10_Format = 37820;
 const RGBA_ASTC_12x12_Format = 37821;
 const RGBA_BPTC_Format = 36492;
 const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
 const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
 const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
 const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
 const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
 const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
 const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
 const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
 const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
 const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
 const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
 const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
 const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
 const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
 const LoopOnce = 2200;
 const LoopRepeat = 2201;
 const LoopPingPong = 2202;
 const InterpolateDiscrete = 2300;
 const InterpolateLinear = 2301;
 const InterpolateSmooth = 2302;
 const ZeroCurvatureEnding = 2400;
 const ZeroSlopeEnding = 2401;
 const WrapAroundEnding = 2402;
 const NormalAnimationBlendMode = 2500;
 const AdditiveAnimationBlendMode = 2501;
 const TrianglesDrawMode = 0;
 const LinearEncoding = 3000;
 const sRGBEncoding = 3001;
 const GammaEncoding = 3007;
 const RGBEEncoding = 3002;
 const LogLuvEncoding = 3003;
 const RGBM7Encoding = 3004;
 const RGBM16Encoding = 3005;
 const RGBDEncoding = 3006;
 const BasicDepthPacking = 3200;
 const RGBADepthPacking = 3201;
 const TangentSpaceNormalMap = 0;
 const ObjectSpaceNormalMap = 1;
 const KeepStencilOp = 7680;
 const AlwaysStencilFunc = 519;

 const StaticDrawUsage = 35044;
 const DynamicDrawUsage = 35048;
 const GLSL3 = '300 es';

 /**
	* https://github.com/mrdoob/eventdispatcher.js/
	*/

 class EventDispatcher {

	 addEventListener( type, listener ) {

		 if ( this._listeners === undefined ) this._listeners = {};

		 const listeners = this._listeners;

		 if ( listeners[ type ] === undefined ) {

			 listeners[ type ] = [];

		 }

		 if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			 listeners[ type ].push( listener );

		 }

	 }

	 hasEventListener( type, listener ) {

		 if ( this._listeners === undefined ) return false;

		 const listeners = this._listeners;

		 return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	 }

	 removeEventListener( type, listener ) {

		 if ( this._listeners === undefined ) return;

		 const listeners = this._listeners;
		 const listenerArray = listeners[ type ];

		 if ( listenerArray !== undefined ) {

			 const index = listenerArray.indexOf( listener );

			 if ( index !== - 1 ) {

				 listenerArray.splice( index, 1 );

			 }

		 }

	 }

	 dispatchEvent( event ) {

		 if ( this._listeners === undefined ) return;

		 const listeners = this._listeners;
		 const listenerArray = listeners[ event.type ];

		 if ( listenerArray !== undefined ) {

			 event.target = this;

			 // Make a copy, in case listeners are removed while iterating.
			 const array = listenerArray.slice( 0 );

			 for ( let i = 0, l = array.length; i < l; i ++ ) {

				 array[ i ].call( this, event );

			 }

			 event.target = null;

		 }

	 }

 }

 const _lut = [];

 for ( let i = 0; i < 256; i ++ ) {

	 _lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

 }


 const DEG2RAD = Math.PI / 180;
 const RAD2DEG = 180 / Math.PI;

 // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
 function generateUUID() {

	 const d0 = Math.random() * 0xffffffff | 0;
	 const d1 = Math.random() * 0xffffffff | 0;
	 const d2 = Math.random() * 0xffffffff | 0;
	 const d3 = Math.random() * 0xffffffff | 0;
	 const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			 _lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			 _lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			 _lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	 // .toUpperCase() here flattens concatenated strings to save heap memory space.
	 return uuid.toUpperCase();

 }

 function clamp( value, min, max ) {

	 return Math.max( min, Math.min( max, value ) );

 }

 // compute euclidian modulo of m % n
 // https://en.wikipedia.org/wiki/Modulo_operation
 function euclideanModulo( n, m ) {

	 return ( ( n % m ) + m ) % m;

 }

 // https://en.wikipedia.org/wiki/Linear_interpolation
 function lerp( x, y, t ) {

	 return ( 1 - t ) * x + t * y;

 }

 function isPowerOfTwo( value ) {

	 return ( value & ( value - 1 ) ) === 0 && value !== 0;

 }

 function floorPowerOfTwo( value ) {

	 return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

 }

 class Vector2 {

	 constructor( x = 0, y = 0 ) {

		 this.x = x;
		 this.y = y;

	 }

	 get width() {

		 return this.x;

	 }

	 set width( value ) {

		 this.x = value;

	 }

	 get height() {

		 return this.y;

	 }

	 set height( value ) {

		 this.y = value;

	 }

	 set( x, y ) {

		 this.x = x;
		 this.y = y;

		 return this;

	 }

	 setScalar( scalar ) {

		 this.x = scalar;
		 this.y = scalar;

		 return this;

	 }

	 setX( x ) {

		 this.x = x;

		 return this;

	 }

	 setY( y ) {

		 this.y = y;

		 return this;

	 }

	 setComponent( index, value ) {

		 switch ( index ) {

			 case 0: this.x = value; break;
			 case 1: this.y = value; break;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

		 return this;

	 }

	 getComponent( index ) {

		 switch ( index ) {

			 case 0: return this.x;
			 case 1: return this.y;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

	 }

	 clone() {

		 return new this.constructor( this.x, this.y );

	 }

	 copy( v ) {

		 this.x = v.x;
		 this.y = v.y;

		 return this;

	 }

	 add( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			 return this.addVectors( v, w );

		 }

		 this.x += v.x;
		 this.y += v.y;

		 return this;

	 }

	 addScalar( s ) {

		 this.x += s;
		 this.y += s;

		 return this;

	 }

	 addVectors( a, b ) {

		 this.x = a.x + b.x;
		 this.y = a.y + b.y;

		 return this;

	 }

	 addScaledVector( v, s ) {

		 this.x += v.x * s;
		 this.y += v.y * s;

		 return this;

	 }

	 sub( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			 return this.subVectors( v, w );

		 }

		 this.x -= v.x;
		 this.y -= v.y;

		 return this;

	 }

	 subScalar( s ) {

		 this.x -= s;
		 this.y -= s;

		 return this;

	 }

	 subVectors( a, b ) {

		 this.x = a.x - b.x;
		 this.y = a.y - b.y;

		 return this;

	 }

	 multiply( v ) {

		 this.x *= v.x;
		 this.y *= v.y;

		 return this;

	 }

	 multiplyScalar( scalar ) {

		 this.x *= scalar;
		 this.y *= scalar;

		 return this;

	 }

	 divide( v ) {

		 this.x /= v.x;
		 this.y /= v.y;

		 return this;

	 }

	 divideScalar( scalar ) {

		 return this.multiplyScalar( 1 / scalar );

	 }

	 applyMatrix3( m ) {

		 const x = this.x, y = this.y;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		 this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		 return this;

	 }

	 min( v ) {

		 this.x = Math.min( this.x, v.x );
		 this.y = Math.min( this.y, v.y );

		 return this;

	 }

	 max( v ) {

		 this.x = Math.max( this.x, v.x );
		 this.y = Math.max( this.y, v.y );

		 return this;

	 }

	 clamp( min, max ) {

		 // assumes min < max, componentwise

		 this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		 this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		 return this;

	 }

	 clampScalar( minVal, maxVal ) {

		 this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		 this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		 return this;

	 }

	 clampLength( min, max ) {

		 const length = this.length();

		 return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	 }

	 floor() {

		 this.x = Math.floor( this.x );
		 this.y = Math.floor( this.y );

		 return this;

	 }

	 ceil() {

		 this.x = Math.ceil( this.x );
		 this.y = Math.ceil( this.y );

		 return this;

	 }

	 round() {

		 this.x = Math.round( this.x );
		 this.y = Math.round( this.y );

		 return this;

	 }

	 roundToZero() {

		 this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		 this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		 return this;

	 }

	 negate() {

		 this.x = - this.x;
		 this.y = - this.y;

		 return this;

	 }

	 dot( v ) {

		 return this.x * v.x + this.y * v.y;

	 }

	 cross( v ) {

		 return this.x * v.y - this.y * v.x;

	 }

	 lengthSq() {

		 return this.x * this.x + this.y * this.y;

	 }

	 length() {

		 return Math.sqrt( this.x * this.x + this.y * this.y );

	 }

	 manhattanLength() {

		 return Math.abs( this.x ) + Math.abs( this.y );

	 }

	 normalize() {

		 return this.divideScalar( this.length() || 1 );

	 }

	 angle() {

		 // computes the angle in radians with respect to the positive x-axis

		 const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		 return angle;

	 }

	 distanceTo( v ) {

		 return Math.sqrt( this.distanceToSquared( v ) );

	 }

	 distanceToSquared( v ) {

		 const dx = this.x - v.x, dy = this.y - v.y;
		 return dx * dx + dy * dy;

	 }

	 manhattanDistanceTo( v ) {

		 return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	 }

	 setLength( length ) {

		 return this.normalize().multiplyScalar( length );

	 }

	 lerp( v, alpha ) {

		 this.x += ( v.x - this.x ) * alpha;
		 this.y += ( v.y - this.y ) * alpha;

		 return this;

	 }

	 lerpVectors( v1, v2, alpha ) {

		 this.x = v1.x + ( v2.x - v1.x ) * alpha;
		 this.y = v1.y + ( v2.y - v1.y ) * alpha;

		 return this;

	 }

	 equals( v ) {

		 return ( ( v.x === this.x ) && ( v.y === this.y ) );

	 }

	 fromArray( array, offset = 0 ) {

		 this.x = array[ offset ];
		 this.y = array[ offset + 1 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.x;
		 array[ offset + 1 ] = this.y;

		 return array;

	 }

	 fromBufferAttribute( attribute, index, offset ) {

		 if ( offset !== undefined ) {

			 console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		 }

		 this.x = attribute.getX( index );
		 this.y = attribute.getY( index );

		 return this;

	 }

	 rotateAround( center, angle ) {

		 const c = Math.cos( angle ), s = Math.sin( angle );

		 const x = this.x - center.x;
		 const y = this.y - center.y;

		 this.x = x * c - y * s + center.x;
		 this.y = x * s + y * c + center.y;

		 return this;

	 }

	 random() {

		 this.x = Math.random();
		 this.y = Math.random();

		 return this;

	 }

 }

 Vector2.prototype.isVector2 = true;

 class Matrix3 {

	 constructor() {

		 this.elements = [

			 1, 0, 0,
			 0, 1, 0,
			 0, 0, 1

		 ];

		 if ( arguments.length > 0 ) {

			 console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		 }

	 }

	 set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		 const te = this.elements;

		 te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		 te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		 te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		 return this;

	 }

	 identity() {

		 this.set(

			 1, 0, 0,
			 0, 1, 0,
			 0, 0, 1

		 );

		 return this;

	 }

	 copy( m ) {

		 const te = this.elements;
		 const me = m.elements;

		 te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		 te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		 te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		 return this;

	 }

	 extractBasis( xAxis, yAxis, zAxis ) {

		 xAxis.setFromMatrix3Column( this, 0 );
		 yAxis.setFromMatrix3Column( this, 1 );
		 zAxis.setFromMatrix3Column( this, 2 );

		 return this;

	 }

	 setFromMatrix4( m ) {

		 const me = m.elements;

		 this.set(

			 me[ 0 ], me[ 4 ], me[ 8 ],
			 me[ 1 ], me[ 5 ], me[ 9 ],
			 me[ 2 ], me[ 6 ], me[ 10 ]

		 );

		 return this;

	 }

	 multiply( m ) {

		 return this.multiplyMatrices( this, m );

	 }

	 premultiply( m ) {

		 return this.multiplyMatrices( m, this );

	 }

	 multiplyMatrices( a, b ) {

		 const ae = a.elements;
		 const be = b.elements;
		 const te = this.elements;

		 const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		 const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		 const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		 const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		 const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		 const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		 te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		 te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		 te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		 te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		 te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		 te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		 te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		 te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		 te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		 return this;

	 }

	 multiplyScalar( s ) {

		 const te = this.elements;

		 te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		 te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		 te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		 return this;

	 }

	 determinant() {

		 const te = this.elements;

		 const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			 d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			 g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		 return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	 }

	 invert() {

		 const te = this.elements,

			 n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			 n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			 n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			 t11 = n33 * n22 - n32 * n23,
			 t12 = n32 * n13 - n33 * n12,
			 t13 = n23 * n12 - n22 * n13,

			 det = n11 * t11 + n21 * t12 + n31 * t13;

		 if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		 const detInv = 1 / det;

		 te[ 0 ] = t11 * detInv;
		 te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		 te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		 te[ 3 ] = t12 * detInv;
		 te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		 te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		 te[ 6 ] = t13 * detInv;
		 te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		 te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		 return this;

	 }

	 transpose() {

		 let tmp;
		 const m = this.elements;

		 tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		 tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		 tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		 return this;

	 }

	 getNormalMatrix( matrix4 ) {

		 return this.setFromMatrix4( matrix4 ).invert().transpose();

	 }

	 transposeIntoArray( r ) {

		 const m = this.elements;

		 r[ 0 ] = m[ 0 ];
		 r[ 1 ] = m[ 3 ];
		 r[ 2 ] = m[ 6 ];
		 r[ 3 ] = m[ 1 ];
		 r[ 4 ] = m[ 4 ];
		 r[ 5 ] = m[ 7 ];
		 r[ 6 ] = m[ 2 ];
		 r[ 7 ] = m[ 5 ];
		 r[ 8 ] = m[ 8 ];

		 return this;

	 }

	 setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		 const c = Math.cos( rotation );
		 const s = Math.sin( rotation );

		 this.set(
			 sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			 - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			 0, 0, 1
		 );

		 return this;

	 }

	 scale( sx, sy ) {

		 const te = this.elements;

		 te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		 te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		 return this;

	 }

	 rotate( theta ) {

		 const c = Math.cos( theta );
		 const s = Math.sin( theta );

		 const te = this.elements;

		 const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		 const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		 te[ 0 ] = c * a11 + s * a21;
		 te[ 3 ] = c * a12 + s * a22;
		 te[ 6 ] = c * a13 + s * a23;

		 te[ 1 ] = - s * a11 + c * a21;
		 te[ 4 ] = - s * a12 + c * a22;
		 te[ 7 ] = - s * a13 + c * a23;

		 return this;

	 }

	 translate( tx, ty ) {

		 const te = this.elements;

		 te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		 te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		 return this;

	 }

	 equals( matrix ) {

		 const te = this.elements;
		 const me = matrix.elements;

		 for ( let i = 0; i < 9; i ++ ) {

			 if ( te[ i ] !== me[ i ] ) return false;

		 }

		 return true;

	 }

	 fromArray( array, offset = 0 ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.elements[ i ] = array[ i + offset ];

		 }

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 const te = this.elements;

		 array[ offset ] = te[ 0 ];
		 array[ offset + 1 ] = te[ 1 ];
		 array[ offset + 2 ] = te[ 2 ];

		 array[ offset + 3 ] = te[ 3 ];
		 array[ offset + 4 ] = te[ 4 ];
		 array[ offset + 5 ] = te[ 5 ];

		 array[ offset + 6 ] = te[ 6 ];
		 array[ offset + 7 ] = te[ 7 ];
		 array[ offset + 8 ] = te[ 8 ];

		 return array;

	 }

	 clone() {

		 return new this.constructor().fromArray( this.elements );

	 }

 }

 Matrix3.prototype.isMatrix3 = true;

 let _canvas;

 class ImageUtils {

	 static getDataURL( image ) {

		 if ( /^data:/i.test( image.src ) ) {

			 return image.src;

		 }

		 if ( typeof HTMLCanvasElement == 'undefined' ) {

			 return image.src;

		 }

		 let canvas;

		 if ( image instanceof HTMLCanvasElement ) {

			 canvas = image;

		 } else {

			 if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			 _canvas.width = image.width;
			 _canvas.height = image.height;

			 const context = _canvas.getContext( '2d' );

			 if ( image instanceof ImageData ) {

				 context.putImageData( image, 0, 0 );

			 } else {

				 context.drawImage( image, 0, 0, image.width, image.height );

			 }

			 canvas = _canvas;

		 }

		 if ( canvas.width > 2048 || canvas.height > 2048 ) {

			 console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			 return canvas.toDataURL( 'image/jpeg', 0.6 );

		 } else {

			 return canvas.toDataURL( 'image/png' );

		 }

	 }

 }

 let textureId = 0;

 class Texture extends EventDispatcher {

	 constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		 super();

		 Object.defineProperty( this, 'id', { value: textureId ++ } );

		 this.uuid = generateUUID();

		 this.name = '';

		 this.image = image;
		 this.mipmaps = [];

		 this.mapping = mapping;

		 this.wrapS = wrapS;
		 this.wrapT = wrapT;

		 this.magFilter = magFilter;
		 this.minFilter = minFilter;

		 this.anisotropy = anisotropy;

		 this.format = format;
		 this.internalFormat = null;
		 this.type = type;

		 this.offset = new Vector2( 0, 0 );
		 this.repeat = new Vector2( 1, 1 );
		 this.center = new Vector2( 0, 0 );
		 this.rotation = 0;

		 this.matrixAutoUpdate = true;
		 this.matrix = new Matrix3();

		 this.generateMipmaps = true;
		 this.premultiplyAlpha = false;
		 this.flipY = true;
		 this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		 // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		 //
		 // Also changing the encoding after already used by a Material will not automatically make the Material
		 // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		 this.encoding = encoding;

		 this.version = 0;
		 this.onUpdate = null;

	 }

	 updateMatrix() {

		 this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.name = source.name;

		 this.image = source.image;
		 this.mipmaps = source.mipmaps.slice( 0 );

		 this.mapping = source.mapping;

		 this.wrapS = source.wrapS;
		 this.wrapT = source.wrapT;

		 this.magFilter = source.magFilter;
		 this.minFilter = source.minFilter;

		 this.anisotropy = source.anisotropy;

		 this.format = source.format;
		 this.internalFormat = source.internalFormat;
		 this.type = source.type;

		 this.offset.copy( source.offset );
		 this.repeat.copy( source.repeat );
		 this.center.copy( source.center );
		 this.rotation = source.rotation;

		 this.matrixAutoUpdate = source.matrixAutoUpdate;
		 this.matrix.copy( source.matrix );

		 this.generateMipmaps = source.generateMipmaps;
		 this.premultiplyAlpha = source.premultiplyAlpha;
		 this.flipY = source.flipY;
		 this.unpackAlignment = source.unpackAlignment;
		 this.encoding = source.encoding;

		 return this;

	 }

	 toJSON( meta ) {

		 const isRootObject = ( meta === undefined || typeof meta === 'string' );

		 if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			 return meta.textures[ this.uuid ];

		 }

		 const output = {

			 metadata: {
				 version: 4.5,
				 type: 'Texture',
				 generator: 'Texture.toJSON'
			 },

			 uuid: this.uuid,
			 name: this.name,

			 mapping: this.mapping,

			 repeat: [ this.repeat.x, this.repeat.y ],
			 offset: [ this.offset.x, this.offset.y ],
			 center: [ this.center.x, this.center.y ],
			 rotation: this.rotation,

			 wrap: [ this.wrapS, this.wrapT ],

			 format: this.format,
			 type: this.type,
			 encoding: this.encoding,

			 minFilter: this.minFilter,
			 magFilter: this.magFilter,
			 anisotropy: this.anisotropy,

			 flipY: this.flipY,

			 premultiplyAlpha: this.premultiplyAlpha,
			 unpackAlignment: this.unpackAlignment

		 };

		 if ( this.image !== undefined ) {

			 // TODO: Move to THREE.Image

			 const image = this.image;

			 if ( image.uuid === undefined ) {

				 image.uuid = generateUUID(); // UGH

			 }

			 if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				 let url;

				 if ( Array.isArray( image ) ) {

					 // process array of images e.g. CubeTexture

					 url = [];

					 for ( let i = 0, l = image.length; i < l; i ++ ) {

						 // check cube texture with data textures

						 if ( image[ i ].isDataTexture ) {

							 url.push( serializeImage( image[ i ].image ) );

						 } else {

							 url.push( serializeImage( image[ i ] ) );

						 }

					 }

				 } else {

					 // process single image

					 url = serializeImage( image );

				 }

				 meta.images[ image.uuid ] = {
					 uuid: image.uuid,
					 url: url
				 };

			 }

			 output.image = image.uuid;

		 }

		 if ( ! isRootObject ) {

			 meta.textures[ this.uuid ] = output;

		 }

		 return output;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

	 transformUv( uv ) {

		 if ( this.mapping !== UVMapping ) return uv;

		 uv.applyMatrix3( this.matrix );

		 if ( uv.x < 0 || uv.x > 1 ) {

			 switch ( this.wrapS ) {

				 case RepeatWrapping:

					 uv.x = uv.x - Math.floor( uv.x );
					 break;

				 case ClampToEdgeWrapping:

					 uv.x = uv.x < 0 ? 0 : 1;
					 break;

				 case MirroredRepeatWrapping:

					 if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						 uv.x = Math.ceil( uv.x ) - uv.x;

					 } else {

						 uv.x = uv.x - Math.floor( uv.x );

					 }

					 break;

			 }

		 }

		 if ( uv.y < 0 || uv.y > 1 ) {

			 switch ( this.wrapT ) {

				 case RepeatWrapping:

					 uv.y = uv.y - Math.floor( uv.y );
					 break;

				 case ClampToEdgeWrapping:

					 uv.y = uv.y < 0 ? 0 : 1;
					 break;

				 case MirroredRepeatWrapping:

					 if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						 uv.y = Math.ceil( uv.y ) - uv.y;

					 } else {

						 uv.y = uv.y - Math.floor( uv.y );

					 }

					 break;

			 }

		 }

		 if ( this.flipY ) {

			 uv.y = 1 - uv.y;

		 }

		 return uv;

	 }

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

 }

 Texture.DEFAULT_IMAGE = undefined;
 Texture.DEFAULT_MAPPING = UVMapping;

 Texture.prototype.isTexture = true;

 function serializeImage( image ) {

	 if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		 ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		 ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		 // default images

		 return ImageUtils.getDataURL( image );

	 } else {

		 if ( image.data ) {

			 // images of DataTexture

			 return {
				 data: Array.prototype.slice.call( image.data ),
				 width: image.width,
				 height: image.height,
				 type: image.data.constructor.name
			 };

		 } else {

			 console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			 return {};

		 }

	 }

 }

 class Vector4 {

	 constructor( x = 0, y = 0, z = 0, w = 1 ) {

		 this.x = x;
		 this.y = y;
		 this.z = z;
		 this.w = w;

	 }

	 get width() {

		 return this.z;

	 }

	 set width( value ) {

		 this.z = value;

	 }

	 get height() {

		 return this.w;

	 }

	 set height( value ) {

		 this.w = value;

	 }

	 set( x, y, z, w ) {

		 this.x = x;
		 this.y = y;
		 this.z = z;
		 this.w = w;

		 return this;

	 }

	 setScalar( scalar ) {

		 this.x = scalar;
		 this.y = scalar;
		 this.z = scalar;
		 this.w = scalar;

		 return this;

	 }

	 setX( x ) {

		 this.x = x;

		 return this;

	 }

	 setY( y ) {

		 this.y = y;

		 return this;

	 }

	 setZ( z ) {

		 this.z = z;

		 return this;

	 }

	 setW( w ) {

		 this.w = w;

		 return this;

	 }

	 setComponent( index, value ) {

		 switch ( index ) {

			 case 0: this.x = value; break;
			 case 1: this.y = value; break;
			 case 2: this.z = value; break;
			 case 3: this.w = value; break;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

		 return this;

	 }

	 getComponent( index ) {

		 switch ( index ) {

			 case 0: return this.x;
			 case 1: return this.y;
			 case 2: return this.z;
			 case 3: return this.w;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

	 }

	 clone() {

		 return new this.constructor( this.x, this.y, this.z, this.w );

	 }

	 copy( v ) {

		 this.x = v.x;
		 this.y = v.y;
		 this.z = v.z;
		 this.w = ( v.w !== undefined ) ? v.w : 1;

		 return this;

	 }

	 add( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			 return this.addVectors( v, w );

		 }

		 this.x += v.x;
		 this.y += v.y;
		 this.z += v.z;
		 this.w += v.w;

		 return this;

	 }

	 addScalar( s ) {

		 this.x += s;
		 this.y += s;
		 this.z += s;
		 this.w += s;

		 return this;

	 }

	 addVectors( a, b ) {

		 this.x = a.x + b.x;
		 this.y = a.y + b.y;
		 this.z = a.z + b.z;
		 this.w = a.w + b.w;

		 return this;

	 }

	 addScaledVector( v, s ) {

		 this.x += v.x * s;
		 this.y += v.y * s;
		 this.z += v.z * s;
		 this.w += v.w * s;

		 return this;

	 }

	 sub( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			 return this.subVectors( v, w );

		 }

		 this.x -= v.x;
		 this.y -= v.y;
		 this.z -= v.z;
		 this.w -= v.w;

		 return this;

	 }

	 subScalar( s ) {

		 this.x -= s;
		 this.y -= s;
		 this.z -= s;
		 this.w -= s;

		 return this;

	 }

	 subVectors( a, b ) {

		 this.x = a.x - b.x;
		 this.y = a.y - b.y;
		 this.z = a.z - b.z;
		 this.w = a.w - b.w;

		 return this;

	 }

	 multiply( v ) {

		 this.x *= v.x;
		 this.y *= v.y;
		 this.z *= v.z;
		 this.w *= v.w;

		 return this;

	 }

	 multiplyScalar( scalar ) {

		 this.x *= scalar;
		 this.y *= scalar;
		 this.z *= scalar;
		 this.w *= scalar;

		 return this;

	 }

	 applyMatrix4( m ) {

		 const x = this.x, y = this.y, z = this.z, w = this.w;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		 this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		 this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		 this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		 return this;

	 }

	 divideScalar( scalar ) {

		 return this.multiplyScalar( 1 / scalar );

	 }

	 setAxisAngleFromQuaternion( q ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		 // q is assumed to be normalized

		 this.w = 2 * Math.acos( q.w );

		 const s = Math.sqrt( 1 - q.w * q.w );

		 if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		 } else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		 }

		 return this;

	 }

	 setAxisAngleFromRotationMatrix( m ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 let angle, x, y, z; // variables for result
		 const epsilon = 0.01,		// margin to allow for rounding errors
			 epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			 te = m.elements,

			 m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			 m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			 m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		 if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
					( Math.abs( m13 - m31 ) < epsilon ) &&
					( Math.abs( m23 - m32 ) < epsilon ) ) {

			 // singularity found
			 // first check for identity matrix which must have +1 for all terms
			 // in leading diagonal and zero in other terms

			 if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
						( Math.abs( m13 + m31 ) < epsilon2 ) &&
						( Math.abs( m23 + m32 ) < epsilon2 ) &&
						( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				 // this singularity is identity matrix so angle = 0

				 this.set( 1, 0, 0, 0 );

				 return this; // zero angle, arbitrary axis

			 }

			 // otherwise this singularity is angle = 180

			 angle = Math.PI;

			 const xx = ( m11 + 1 ) / 2;
			 const yy = ( m22 + 1 ) / 2;
			 const zz = ( m33 + 1 ) / 2;
			 const xy = ( m12 + m21 ) / 4;
			 const xz = ( m13 + m31 ) / 4;
			 const yz = ( m23 + m32 ) / 4;

			 if ( ( xx > yy ) && ( xx > zz ) ) {

				 // m11 is the largest diagonal term

				 if ( xx < epsilon ) {

					 x = 0;
					 y = 0.707106781;
					 z = 0.707106781;

				 } else {

					 x = Math.sqrt( xx );
					 y = xy / x;
					 z = xz / x;

				 }

			 } else if ( yy > zz ) {

				 // m22 is the largest diagonal term

				 if ( yy < epsilon ) {

					 x = 0.707106781;
					 y = 0;
					 z = 0.707106781;

				 } else {

					 y = Math.sqrt( yy );
					 x = xy / y;
					 z = yz / y;

				 }

			 } else {

				 // m33 is the largest diagonal term so base result on this

				 if ( zz < epsilon ) {

					 x = 0.707106781;
					 y = 0.707106781;
					 z = 0;

				 } else {

					 z = Math.sqrt( zz );
					 x = xz / z;
					 y = yz / z;

				 }

			 }

			 this.set( x, y, z, angle );

			 return this; // return 180 deg rotation

		 }

		 // as we have reached here there are no singularities so we can handle normally

		 let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			 ( m13 - m31 ) * ( m13 - m31 ) +
			 ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		 if ( Math.abs( s ) < 0.001 ) s = 1;

		 // prevent divide by zero, should not happen if matrix is orthogonal and should be
		 // caught by singularity test above, but I've left it in just in case

		 this.x = ( m32 - m23 ) / s;
		 this.y = ( m13 - m31 ) / s;
		 this.z = ( m21 - m12 ) / s;
		 this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		 return this;

	 }

	 min( v ) {

		 this.x = Math.min( this.x, v.x );
		 this.y = Math.min( this.y, v.y );
		 this.z = Math.min( this.z, v.z );
		 this.w = Math.min( this.w, v.w );

		 return this;

	 }

	 max( v ) {

		 this.x = Math.max( this.x, v.x );
		 this.y = Math.max( this.y, v.y );
		 this.z = Math.max( this.z, v.z );
		 this.w = Math.max( this.w, v.w );

		 return this;

	 }

	 clamp( min, max ) {

		 // assumes min < max, componentwise

		 this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		 this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		 this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		 this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		 return this;

	 }

	 clampScalar( minVal, maxVal ) {

		 this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		 this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		 this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		 this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		 return this;

	 }

	 clampLength( min, max ) {

		 const length = this.length();

		 return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	 }

	 floor() {

		 this.x = Math.floor( this.x );
		 this.y = Math.floor( this.y );
		 this.z = Math.floor( this.z );
		 this.w = Math.floor( this.w );

		 return this;

	 }

	 ceil() {

		 this.x = Math.ceil( this.x );
		 this.y = Math.ceil( this.y );
		 this.z = Math.ceil( this.z );
		 this.w = Math.ceil( this.w );

		 return this;

	 }

	 round() {

		 this.x = Math.round( this.x );
		 this.y = Math.round( this.y );
		 this.z = Math.round( this.z );
		 this.w = Math.round( this.w );

		 return this;

	 }

	 roundToZero() {

		 this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		 this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		 this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		 this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		 return this;

	 }

	 negate() {

		 this.x = - this.x;
		 this.y = - this.y;
		 this.z = - this.z;
		 this.w = - this.w;

		 return this;

	 }

	 dot( v ) {

		 return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	 }

	 lengthSq() {

		 return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	 }

	 length() {

		 return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	 }

	 manhattanLength() {

		 return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	 }

	 normalize() {

		 return this.divideScalar( this.length() || 1 );

	 }

	 setLength( length ) {

		 return this.normalize().multiplyScalar( length );

	 }

	 lerp( v, alpha ) {

		 this.x += ( v.x - this.x ) * alpha;
		 this.y += ( v.y - this.y ) * alpha;
		 this.z += ( v.z - this.z ) * alpha;
		 this.w += ( v.w - this.w ) * alpha;

		 return this;

	 }

	 lerpVectors( v1, v2, alpha ) {

		 this.x = v1.x + ( v2.x - v1.x ) * alpha;
		 this.y = v1.y + ( v2.y - v1.y ) * alpha;
		 this.z = v1.z + ( v2.z - v1.z ) * alpha;
		 this.w = v1.w + ( v2.w - v1.w ) * alpha;

		 return this;

	 }

	 equals( v ) {

		 return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	 }

	 fromArray( array, offset = 0 ) {

		 this.x = array[ offset ];
		 this.y = array[ offset + 1 ];
		 this.z = array[ offset + 2 ];
		 this.w = array[ offset + 3 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.x;
		 array[ offset + 1 ] = this.y;
		 array[ offset + 2 ] = this.z;
		 array[ offset + 3 ] = this.w;

		 return array;

	 }

	 fromBufferAttribute( attribute, index, offset ) {

		 if ( offset !== undefined ) {

			 console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		 }

		 this.x = attribute.getX( index );
		 this.y = attribute.getY( index );
		 this.z = attribute.getZ( index );
		 this.w = attribute.getW( index );

		 return this;

	 }

	 random() {

		 this.x = Math.random();
		 this.y = Math.random();
		 this.z = Math.random();
		 this.w = Math.random();

		 return this;

	 }

 }

 Vector4.prototype.isVector4 = true;

 /*
	In options, we can specify:
	* Texture parameters for an auto-generated target texture
	* depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
 */
 class WebGLRenderTarget extends EventDispatcher {

	 constructor( width, height, options = {} ) {

		 super();

		 this.width = width;
		 this.height = height;
		 this.depth = 1;

		 this.scissor = new Vector4( 0, 0, width, height );
		 this.scissorTest = false;

		 this.viewport = new Vector4( 0, 0, width, height );

		 this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		 this.texture.image = { width: width, height: height, depth: 1 };

		 this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		 this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		 this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		 this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		 this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	 }

	 setTexture( texture ) {

		 texture.image = {
			 width: this.width,
			 height: this.height,
			 depth: this.depth
		 };

		 this.texture = texture;

	 }

	 setSize( width, height, depth = 1 ) {

		 if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			 this.width = width;
			 this.height = height;
			 this.depth = depth;

			 this.texture.image.width = width;
			 this.texture.image.height = height;
			 this.texture.image.depth = depth;

			 this.dispose();

		 }

		 this.viewport.set( 0, 0, width, height );
		 this.scissor.set( 0, 0, width, height );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.width = source.width;
		 this.height = source.height;
		 this.depth = source.depth;

		 this.viewport.copy( source.viewport );

		 this.texture = source.texture.clone();
		 this.texture.image = { ...this.texture.image }; // See #20328.

		 this.depthBuffer = source.depthBuffer;
		 this.stencilBuffer = source.stencilBuffer;
		 this.depthTexture = source.depthTexture;

		 return this;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

 }

 WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

 class WebGLMultipleRenderTargets extends WebGLRenderTarget {

	 constructor( width, height, count ) {

		 super( width, height );

		 const texture = this.texture;

		 this.texture = [];

		 for ( let i = 0; i < count; i ++ ) {

			 this.texture[ i ] = texture.clone();

		 }

	 }

	 setSize( width, height, depth = 1 ) {

		 if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			 this.width = width;
			 this.height = height;
			 this.depth = depth;

			 for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

				 this.texture[ i ].image.width = width;
				 this.texture[ i ].image.height = height;
				 this.texture[ i ].image.depth = depth;

			 }

			 this.dispose();

		 }

		 this.viewport.set( 0, 0, width, height );
		 this.scissor.set( 0, 0, width, height );

		 return this;

	 }

	 copy( source ) {

		 this.dispose();

		 this.width = source.width;
		 this.height = source.height;
		 this.depth = source.depth;

		 this.viewport.set( 0, 0, this.width, this.height );
		 this.scissor.set( 0, 0, this.width, this.height );

		 this.depthBuffer = source.depthBuffer;
		 this.stencilBuffer = source.stencilBuffer;
		 this.depthTexture = source.depthTexture;

		 this.texture.length = 0;

		 for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

			 this.texture[ i ] = source.texture[ i ].clone();

		 }

		 return this;

	 }

 }

 WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

 class WebGLMultisampleRenderTarget extends WebGLRenderTarget {

	 constructor( width, height, options ) {

		 super( width, height, options );

		 this.samples = 4;

	 }

	 copy( source ) {

		 super.copy.call( this, source );

		 this.samples = source.samples;

		 return this;

	 }

 }

 WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

 class Quaternion {

	 constructor( x = 0, y = 0, z = 0, w = 1 ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._w = w;

	 }

	 static slerp( qa, qb, qm, t ) {

		 console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		 return qm.slerpQuaternions( qa, qb, t );

	 }

	 static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		 // fuzz-free, array-based Quaternion SLERP operation

		 let x0 = src0[ srcOffset0 + 0 ],
			 y0 = src0[ srcOffset0 + 1 ],
			 z0 = src0[ srcOffset0 + 2 ],
			 w0 = src0[ srcOffset0 + 3 ];

		 const x1 = src1[ srcOffset1 + 0 ],
			 y1 = src1[ srcOffset1 + 1 ],
			 z1 = src1[ srcOffset1 + 2 ],
			 w1 = src1[ srcOffset1 + 3 ];

		 if ( t === 0 ) {

			 dst[ dstOffset + 0 ] = x0;
			 dst[ dstOffset + 1 ] = y0;
			 dst[ dstOffset + 2 ] = z0;
			 dst[ dstOffset + 3 ] = w0;
			 return;

		 }

		 if ( t === 1 ) {

			 dst[ dstOffset + 0 ] = x1;
			 dst[ dstOffset + 1 ] = y1;
			 dst[ dstOffset + 2 ] = z1;
			 dst[ dstOffset + 3 ] = w1;
			 return;

		 }

		 if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			 let s = 1 - t;
			 const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				 dir = ( cos >= 0 ? 1 : - 1 ),
				 sqrSin = 1 - cos * cos;

			 // Skip the Slerp for tiny steps to avoid numeric problems:
			 if ( sqrSin > Number.EPSILON ) {

				 const sin = Math.sqrt( sqrSin ),
					 len = Math.atan2( sin, cos * dir );

				 s = Math.sin( s * len ) / sin;
				 t = Math.sin( t * len ) / sin;

			 }

			 const tDir = t * dir;

			 x0 = x0 * s + x1 * tDir;
			 y0 = y0 * s + y1 * tDir;
			 z0 = z0 * s + z1 * tDir;
			 w0 = w0 * s + w1 * tDir;

			 // Normalize in case we just did a lerp:
			 if ( s === 1 - t ) {

				 const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				 x0 *= f;
				 y0 *= f;
				 z0 *= f;
				 w0 *= f;

			 }

		 }

		 dst[ dstOffset ] = x0;
		 dst[ dstOffset + 1 ] = y0;
		 dst[ dstOffset + 2 ] = z0;
		 dst[ dstOffset + 3 ] = w0;

	 }

	 static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		 const x0 = src0[ srcOffset0 ];
		 const y0 = src0[ srcOffset0 + 1 ];
		 const z0 = src0[ srcOffset0 + 2 ];
		 const w0 = src0[ srcOffset0 + 3 ];

		 const x1 = src1[ srcOffset1 ];
		 const y1 = src1[ srcOffset1 + 1 ];
		 const z1 = src1[ srcOffset1 + 2 ];
		 const w1 = src1[ srcOffset1 + 3 ];

		 dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		 dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		 dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		 dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		 return dst;

	 }

	 get x() {

		 return this._x;

	 }

	 set x( value ) {

		 this._x = value;
		 this._onChangeCallback();

	 }

	 get y() {

		 return this._y;

	 }

	 set y( value ) {

		 this._y = value;
		 this._onChangeCallback();

	 }

	 get z() {

		 return this._z;

	 }

	 set z( value ) {

		 this._z = value;
		 this._onChangeCallback();

	 }

	 get w() {

		 return this._w;

	 }

	 set w( value ) {

		 this._w = value;
		 this._onChangeCallback();

	 }

	 set( x, y, z, w ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._w = w;

		 this._onChangeCallback();

		 return this;

	 }

	 clone() {

		 return new this.constructor( this._x, this._y, this._z, this._w );

	 }

	 copy( quaternion ) {

		 this._x = quaternion.x;
		 this._y = quaternion.y;
		 this._z = quaternion.z;
		 this._w = quaternion.w;

		 this._onChangeCallback();

		 return this;

	 }

	 setFromEuler( euler, update ) {

		 if ( ! ( euler && euler.isEuler ) ) {

			 throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		 }

		 const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		 // http://www.mathworks.com/matlabcentral/fileexchange/
		 // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		 //	content/SpinCalc.m

		 const cos = Math.cos;
		 const sin = Math.sin;

		 const c1 = cos( x / 2 );
		 const c2 = cos( y / 2 );
		 const c3 = cos( z / 2 );

		 const s1 = sin( x / 2 );
		 const s2 = sin( y / 2 );
		 const s3 = sin( z / 2 );

		 switch ( order ) {

			 case 'XYZ':
				 this._x = s1 * c2 * c3 + c1 * s2 * s3;
				 this._y = c1 * s2 * c3 - s1 * c2 * s3;
				 this._z = c1 * c2 * s3 + s1 * s2 * c3;
				 this._w = c1 * c2 * c3 - s1 * s2 * s3;
				 break;

			 case 'YXZ':
				 this._x = s1 * c2 * c3 + c1 * s2 * s3;
				 this._y = c1 * s2 * c3 - s1 * c2 * s3;
				 this._z = c1 * c2 * s3 - s1 * s2 * c3;
				 this._w = c1 * c2 * c3 + s1 * s2 * s3;
				 break;

			 case 'ZXY':
				 this._x = s1 * c2 * c3 - c1 * s2 * s3;
				 this._y = c1 * s2 * c3 + s1 * c2 * s3;
				 this._z = c1 * c2 * s3 + s1 * s2 * c3;
				 this._w = c1 * c2 * c3 - s1 * s2 * s3;
				 break;

			 case 'ZYX':
				 this._x = s1 * c2 * c3 - c1 * s2 * s3;
				 this._y = c1 * s2 * c3 + s1 * c2 * s3;
				 this._z = c1 * c2 * s3 - s1 * s2 * c3;
				 this._w = c1 * c2 * c3 + s1 * s2 * s3;
				 break;

			 case 'YZX':
				 this._x = s1 * c2 * c3 + c1 * s2 * s3;
				 this._y = c1 * s2 * c3 + s1 * c2 * s3;
				 this._z = c1 * c2 * s3 - s1 * s2 * c3;
				 this._w = c1 * c2 * c3 - s1 * s2 * s3;
				 break;

			 case 'XZY':
				 this._x = s1 * c2 * c3 - c1 * s2 * s3;
				 this._y = c1 * s2 * c3 - s1 * c2 * s3;
				 this._z = c1 * c2 * s3 + s1 * s2 * c3;
				 this._w = c1 * c2 * c3 + s1 * s2 * s3;
				 break;

			 default:
				 console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		 }

		 if ( update !== false ) this._onChangeCallback();

		 return this;

	 }

	 setFromAxisAngle( axis, angle ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		 // assumes axis is normalized

		 const halfAngle = angle / 2, s = Math.sin( halfAngle );

		 this._x = axis.x * s;
		 this._y = axis.y * s;
		 this._z = axis.z * s;
		 this._w = Math.cos( halfAngle );

		 this._onChangeCallback();

		 return this;

	 }

	 setFromRotationMatrix( m ) {

		 // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 const te = m.elements,

			 m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			 m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			 m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			 trace = m11 + m22 + m33;

		 if ( trace > 0 ) {

			 const s = 0.5 / Math.sqrt( trace + 1.0 );

			 this._w = 0.25 / s;
			 this._x = ( m32 - m23 ) * s;
			 this._y = ( m13 - m31 ) * s;
			 this._z = ( m21 - m12 ) * s;

		 } else if ( m11 > m22 && m11 > m33 ) {

			 const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			 this._w = ( m32 - m23 ) / s;
			 this._x = 0.25 * s;
			 this._y = ( m12 + m21 ) / s;
			 this._z = ( m13 + m31 ) / s;

		 } else if ( m22 > m33 ) {

			 const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			 this._w = ( m13 - m31 ) / s;
			 this._x = ( m12 + m21 ) / s;
			 this._y = 0.25 * s;
			 this._z = ( m23 + m32 ) / s;

		 } else {

			 const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			 this._w = ( m21 - m12 ) / s;
			 this._x = ( m13 + m31 ) / s;
			 this._y = ( m23 + m32 ) / s;
			 this._z = 0.25 * s;

		 }

		 this._onChangeCallback();

		 return this;

	 }

	 setFromUnitVectors( vFrom, vTo ) {

		 // assumes direction vectors vFrom and vTo are normalized

		 let r = vFrom.dot( vTo ) + 1;

		 if ( r < Number.EPSILON ) {

			 // vFrom and vTo point in opposite directions

			 r = 0;

			 if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				 this._x = - vFrom.y;
				 this._y = vFrom.x;
				 this._z = 0;
				 this._w = r;

			 } else {

				 this._x = 0;
				 this._y = - vFrom.z;
				 this._z = vFrom.y;
				 this._w = r;

			 }

		 } else {

			 // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			 this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			 this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			 this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			 this._w = r;

		 }

		 return this.normalize();

	 }

	 angleTo( q ) {

		 return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	 }

	 rotateTowards( q, step ) {

		 const angle = this.angleTo( q );

		 if ( angle === 0 ) return this;

		 const t = Math.min( 1, step / angle );

		 this.slerp( q, t );

		 return this;

	 }

	 identity() {

		 return this.set( 0, 0, 0, 1 );

	 }

	 invert() {

		 // quaternion is assumed to have unit length

		 return this.conjugate();

	 }

	 conjugate() {

		 this._x *= - 1;
		 this._y *= - 1;
		 this._z *= - 1;

		 this._onChangeCallback();

		 return this;

	 }

	 dot( v ) {

		 return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	 }

	 lengthSq() {

		 return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	 }

	 length() {

		 return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	 }

	 normalize() {

		 let l = this.length();

		 if ( l === 0 ) {

			 this._x = 0;
			 this._y = 0;
			 this._z = 0;
			 this._w = 1;

		 } else {

			 l = 1 / l;

			 this._x = this._x * l;
			 this._y = this._y * l;
			 this._z = this._z * l;
			 this._w = this._w * l;

		 }

		 this._onChangeCallback();

		 return this;

	 }

	 multiply( q, p ) {

		 if ( p !== undefined ) {

			 console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			 return this.multiplyQuaternions( q, p );

		 }

		 return this.multiplyQuaternions( this, q );

	 }

	 premultiply( q ) {

		 return this.multiplyQuaternions( q, this );

	 }

	 multiplyQuaternions( a, b ) {

		 // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		 const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		 const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		 this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		 this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		 this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		 this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		 this._onChangeCallback();

		 return this;

	 }

	 slerp( qb, t ) {

		 if ( t === 0 ) return this;
		 if ( t === 1 ) return this.copy( qb );

		 const x = this._x, y = this._y, z = this._z, w = this._w;

		 // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		 let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		 if ( cosHalfTheta < 0 ) {

			 this._w = - qb._w;
			 this._x = - qb._x;
			 this._y = - qb._y;
			 this._z = - qb._z;

			 cosHalfTheta = - cosHalfTheta;

		 } else {

			 this.copy( qb );

		 }

		 if ( cosHalfTheta >= 1.0 ) {

			 this._w = w;
			 this._x = x;
			 this._y = y;
			 this._z = z;

			 return this;

		 }

		 const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		 if ( sqrSinHalfTheta <= Number.EPSILON ) {

			 const s = 1 - t;
			 this._w = s * w + t * this._w;
			 this._x = s * x + t * this._x;
			 this._y = s * y + t * this._y;
			 this._z = s * z + t * this._z;

			 this.normalize();
			 this._onChangeCallback();

			 return this;

		 }

		 const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		 const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		 const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			 ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		 this._w = ( w * ratioA + this._w * ratioB );
		 this._x = ( x * ratioA + this._x * ratioB );
		 this._y = ( y * ratioA + this._y * ratioB );
		 this._z = ( z * ratioA + this._z * ratioB );

		 this._onChangeCallback();

		 return this;

	 }

	 slerpQuaternions( qa, qb, t ) {

		 this.copy( qa ).slerp( qb, t );

	 }

	 equals( quaternion ) {

		 return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	 }

	 fromArray( array, offset = 0 ) {

		 this._x = array[ offset ];
		 this._y = array[ offset + 1 ];
		 this._z = array[ offset + 2 ];
		 this._w = array[ offset + 3 ];

		 this._onChangeCallback();

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this._x;
		 array[ offset + 1 ] = this._y;
		 array[ offset + 2 ] = this._z;
		 array[ offset + 3 ] = this._w;

		 return array;

	 }

	 fromBufferAttribute( attribute, index ) {

		 this._x = attribute.getX( index );
		 this._y = attribute.getY( index );
		 this._z = attribute.getZ( index );
		 this._w = attribute.getW( index );

		 return this;

	 }

	 _onChange( callback ) {

		 this._onChangeCallback = callback;

		 return this;

	 }

	 _onChangeCallback() {}

 }

 Quaternion.prototype.isQuaternion = true;

 class Vector3 {

	 constructor( x = 0, y = 0, z = 0 ) {

		 this.x = x;
		 this.y = y;
		 this.z = z;

	 }

	 set( x, y, z ) {

		 if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		 this.x = x;
		 this.y = y;
		 this.z = z;

		 return this;

	 }

	 setScalar( scalar ) {

		 this.x = scalar;
		 this.y = scalar;
		 this.z = scalar;

		 return this;

	 }

	 setX( x ) {

		 this.x = x;

		 return this;

	 }

	 setY( y ) {

		 this.y = y;

		 return this;

	 }

	 setZ( z ) {

		 this.z = z;

		 return this;

	 }

	 setComponent( index, value ) {

		 switch ( index ) {

			 case 0: this.x = value; break;
			 case 1: this.y = value; break;
			 case 2: this.z = value; break;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

		 return this;

	 }

	 getComponent( index ) {

		 switch ( index ) {

			 case 0: return this.x;
			 case 1: return this.y;
			 case 2: return this.z;
			 default: throw new Error( 'index is out of range: ' + index );

		 }

	 }

	 clone() {

		 return new this.constructor( this.x, this.y, this.z );

	 }

	 copy( v ) {

		 this.x = v.x;
		 this.y = v.y;
		 this.z = v.z;

		 return this;

	 }

	 add( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			 return this.addVectors( v, w );

		 }

		 this.x += v.x;
		 this.y += v.y;
		 this.z += v.z;

		 return this;

	 }

	 addScalar( s ) {

		 this.x += s;
		 this.y += s;
		 this.z += s;

		 return this;

	 }

	 addVectors( a, b ) {

		 this.x = a.x + b.x;
		 this.y = a.y + b.y;
		 this.z = a.z + b.z;

		 return this;

	 }

	 addScaledVector( v, s ) {

		 this.x += v.x * s;
		 this.y += v.y * s;
		 this.z += v.z * s;

		 return this;

	 }

	 sub( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			 return this.subVectors( v, w );

		 }

		 this.x -= v.x;
		 this.y -= v.y;
		 this.z -= v.z;

		 return this;

	 }

	 subScalar( s ) {

		 this.x -= s;
		 this.y -= s;
		 this.z -= s;

		 return this;

	 }

	 subVectors( a, b ) {

		 this.x = a.x - b.x;
		 this.y = a.y - b.y;
		 this.z = a.z - b.z;

		 return this;

	 }

	 multiply( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			 return this.multiplyVectors( v, w );

		 }

		 this.x *= v.x;
		 this.y *= v.y;
		 this.z *= v.z;

		 return this;

	 }

	 multiplyScalar( scalar ) {

		 this.x *= scalar;
		 this.y *= scalar;
		 this.z *= scalar;

		 return this;

	 }

	 multiplyVectors( a, b ) {

		 this.x = a.x * b.x;
		 this.y = a.y * b.y;
		 this.z = a.z * b.z;

		 return this;

	 }

	 applyEuler( euler ) {

		 if ( ! ( euler && euler.isEuler ) ) {

			 console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		 }

		 return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	 }

	 applyAxisAngle( axis, angle ) {

		 return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	 }

	 applyMatrix3( m ) {

		 const x = this.x, y = this.y, z = this.z;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		 this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		 this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		 return this;

	 }

	 applyNormalMatrix( m ) {

		 return this.applyMatrix3( m ).normalize();

	 }

	 applyMatrix4( m ) {

		 const x = this.x, y = this.y, z = this.z;
		 const e = m.elements;

		 const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		 this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		 this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		 this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		 return this;

	 }

	 applyQuaternion( q ) {

		 const x = this.x, y = this.y, z = this.z;
		 const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		 // calculate quat * vector

		 const ix = qw * x + qy * z - qz * y;
		 const iy = qw * y + qz * x - qx * z;
		 const iz = qw * z + qx * y - qy * x;
		 const iw = - qx * x - qy * y - qz * z;

		 // calculate result * inverse quat

		 this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		 this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		 this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		 return this;

	 }

	 project( camera ) {

		 return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	 }

	 unproject( camera ) {

		 return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	 }

	 transformDirection( m ) {

		 // input: THREE.Matrix4 affine matrix
		 // vector interpreted as a direction

		 const x = this.x, y = this.y, z = this.z;
		 const e = m.elements;

		 this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		 this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		 this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		 return this.normalize();

	 }

	 divide( v ) {

		 this.x /= v.x;
		 this.y /= v.y;
		 this.z /= v.z;

		 return this;

	 }

	 divideScalar( scalar ) {

		 return this.multiplyScalar( 1 / scalar );

	 }

	 min( v ) {

		 this.x = Math.min( this.x, v.x );
		 this.y = Math.min( this.y, v.y );
		 this.z = Math.min( this.z, v.z );

		 return this;

	 }

	 max( v ) {

		 this.x = Math.max( this.x, v.x );
		 this.y = Math.max( this.y, v.y );
		 this.z = Math.max( this.z, v.z );

		 return this;

	 }

	 clamp( min, max ) {

		 // assumes min < max, componentwise

		 this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		 this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		 this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		 return this;

	 }

	 clampScalar( minVal, maxVal ) {

		 this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		 this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		 this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		 return this;

	 }

	 clampLength( min, max ) {

		 const length = this.length();

		 return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	 }

	 floor() {

		 this.x = Math.floor( this.x );
		 this.y = Math.floor( this.y );
		 this.z = Math.floor( this.z );

		 return this;

	 }

	 ceil() {

		 this.x = Math.ceil( this.x );
		 this.y = Math.ceil( this.y );
		 this.z = Math.ceil( this.z );

		 return this;

	 }

	 round() {

		 this.x = Math.round( this.x );
		 this.y = Math.round( this.y );
		 this.z = Math.round( this.z );

		 return this;

	 }

	 roundToZero() {

		 this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		 this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		 this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		 return this;

	 }

	 negate() {

		 this.x = - this.x;
		 this.y = - this.y;
		 this.z = - this.z;

		 return this;

	 }

	 dot( v ) {

		 return this.x * v.x + this.y * v.y + this.z * v.z;

	 }

	 // TODO lengthSquared?

	 lengthSq() {

		 return this.x * this.x + this.y * this.y + this.z * this.z;

	 }

	 length() {

		 return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	 }

	 manhattanLength() {

		 return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	 }

	 normalize() {

		 return this.divideScalar( this.length() || 1 );

	 }

	 setLength( length ) {

		 return this.normalize().multiplyScalar( length );

	 }

	 lerp( v, alpha ) {

		 this.x += ( v.x - this.x ) * alpha;
		 this.y += ( v.y - this.y ) * alpha;
		 this.z += ( v.z - this.z ) * alpha;

		 return this;

	 }

	 lerpVectors( v1, v2, alpha ) {

		 this.x = v1.x + ( v2.x - v1.x ) * alpha;
		 this.y = v1.y + ( v2.y - v1.y ) * alpha;
		 this.z = v1.z + ( v2.z - v1.z ) * alpha;

		 return this;

	 }

	 cross( v, w ) {

		 if ( w !== undefined ) {

			 console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			 return this.crossVectors( v, w );

		 }

		 return this.crossVectors( this, v );

	 }

	 crossVectors( a, b ) {

		 const ax = a.x, ay = a.y, az = a.z;
		 const bx = b.x, by = b.y, bz = b.z;

		 this.x = ay * bz - az * by;
		 this.y = az * bx - ax * bz;
		 this.z = ax * by - ay * bx;

		 return this;

	 }

	 projectOnVector( v ) {

		 const denominator = v.lengthSq();

		 if ( denominator === 0 ) return this.set( 0, 0, 0 );

		 const scalar = v.dot( this ) / denominator;

		 return this.copy( v ).multiplyScalar( scalar );

	 }

	 projectOnPlane( planeNormal ) {

		 _vector$c.copy( this ).projectOnVector( planeNormal );

		 return this.sub( _vector$c );

	 }

	 reflect( normal ) {

		 // reflect incident vector off plane orthogonal to normal
		 // normal is assumed to have unit length

		 return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	 }

	 angleTo( v ) {

		 const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		 if ( denominator === 0 ) return Math.PI / 2;

		 const theta = this.dot( v ) / denominator;

		 // clamp, to handle numerical problems

		 return Math.acos( clamp( theta, - 1, 1 ) );

	 }

	 distanceTo( v ) {

		 return Math.sqrt( this.distanceToSquared( v ) );

	 }

	 distanceToSquared( v ) {

		 const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		 return dx * dx + dy * dy + dz * dz;

	 }

	 manhattanDistanceTo( v ) {

		 return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	 }

	 setFromSpherical( s ) {

		 return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	 }

	 setFromSphericalCoords( radius, phi, theta ) {

		 const sinPhiRadius = Math.sin( phi ) * radius;

		 this.x = sinPhiRadius * Math.sin( theta );
		 this.y = Math.cos( phi ) * radius;
		 this.z = sinPhiRadius * Math.cos( theta );

		 return this;

	 }

	 setFromCylindrical( c ) {

		 return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	 }

	 setFromCylindricalCoords( radius, theta, y ) {

		 this.x = radius * Math.sin( theta );
		 this.y = y;
		 this.z = radius * Math.cos( theta );

		 return this;

	 }

	 setFromMatrixPosition( m ) {

		 const e = m.elements;

		 this.x = e[ 12 ];
		 this.y = e[ 13 ];
		 this.z = e[ 14 ];

		 return this;

	 }

	 setFromMatrixScale( m ) {

		 const sx = this.setFromMatrixColumn( m, 0 ).length();
		 const sy = this.setFromMatrixColumn( m, 1 ).length();
		 const sz = this.setFromMatrixColumn( m, 2 ).length();

		 this.x = sx;
		 this.y = sy;
		 this.z = sz;

		 return this;

	 }

	 setFromMatrixColumn( m, index ) {

		 return this.fromArray( m.elements, index * 4 );

	 }

	 setFromMatrix3Column( m, index ) {

		 return this.fromArray( m.elements, index * 3 );

	 }

	 equals( v ) {

		 return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	 }

	 fromArray( array, offset = 0 ) {

		 this.x = array[ offset ];
		 this.y = array[ offset + 1 ];
		 this.z = array[ offset + 2 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.x;
		 array[ offset + 1 ] = this.y;
		 array[ offset + 2 ] = this.z;

		 return array;

	 }

	 fromBufferAttribute( attribute, index, offset ) {

		 if ( offset !== undefined ) {

			 console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		 }

		 this.x = attribute.getX( index );
		 this.y = attribute.getY( index );
		 this.z = attribute.getZ( index );

		 return this;

	 }

	 random() {

		 this.x = Math.random();
		 this.y = Math.random();
		 this.z = Math.random();

		 return this;

	 }

 }

 Vector3.prototype.isVector3 = true;

 const _vector$c = /*@__PURE__*/ new Vector3();
 const _quaternion$4 = /*@__PURE__*/ new Quaternion();

 class Box3 {

	 constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		 this.min = min;
		 this.max = max;

	 }

	 set( min, max ) {

		 this.min.copy( min );
		 this.max.copy( max );

		 return this;

	 }

	 setFromArray( array ) {

		 let minX = + Infinity;
		 let minY = + Infinity;
		 let minZ = + Infinity;

		 let maxX = - Infinity;
		 let maxY = - Infinity;
		 let maxZ = - Infinity;

		 for ( let i = 0, l = array.length; i < l; i += 3 ) {

			 const x = array[ i ];
			 const y = array[ i + 1 ];
			 const z = array[ i + 2 ];

			 if ( x < minX ) minX = x;
			 if ( y < minY ) minY = y;
			 if ( z < minZ ) minZ = z;

			 if ( x > maxX ) maxX = x;
			 if ( y > maxY ) maxY = y;
			 if ( z > maxZ ) maxZ = z;

		 }

		 this.min.set( minX, minY, minZ );
		 this.max.set( maxX, maxY, maxZ );

		 return this;

	 }

	 setFromBufferAttribute( attribute ) {

		 let minX = + Infinity;
		 let minY = + Infinity;
		 let minZ = + Infinity;

		 let maxX = - Infinity;
		 let maxY = - Infinity;
		 let maxZ = - Infinity;

		 for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			 const x = attribute.getX( i );
			 const y = attribute.getY( i );
			 const z = attribute.getZ( i );

			 if ( x < minX ) minX = x;
			 if ( y < minY ) minY = y;
			 if ( z < minZ ) minZ = z;

			 if ( x > maxX ) maxX = x;
			 if ( y > maxY ) maxY = y;
			 if ( z > maxZ ) maxZ = z;

		 }

		 this.min.set( minX, minY, minZ );
		 this.max.set( maxX, maxY, maxZ );

		 return this;

	 }

	 setFromPoints( points ) {

		 this.makeEmpty();

		 for ( let i = 0, il = points.length; i < il; i ++ ) {

			 this.expandByPoint( points[ i ] );

		 }

		 return this;

	 }

	 setFromCenterAndSize( center, size ) {

		 const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		 this.min.copy( center ).sub( halfSize );
		 this.max.copy( center ).add( halfSize );

		 return this;

	 }

	 setFromObject( object ) {

		 this.makeEmpty();

		 return this.expandByObject( object );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( box ) {

		 this.min.copy( box.min );
		 this.max.copy( box.max );

		 return this;

	 }

	 makeEmpty() {

		 this.min.x = this.min.y = this.min.z = + Infinity;
		 this.max.x = this.max.y = this.max.z = - Infinity;

		 return this;

	 }

	 isEmpty() {

		 // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		 return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	 }

	 getCenter( target ) {

		 return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	 }

	 getSize( target ) {

		 return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	 }

	 expandByPoint( point ) {

		 this.min.min( point );
		 this.max.max( point );

		 return this;

	 }

	 expandByVector( vector ) {

		 this.min.sub( vector );
		 this.max.add( vector );

		 return this;

	 }

	 expandByScalar( scalar ) {

		 this.min.addScalar( - scalar );
		 this.max.addScalar( scalar );

		 return this;

	 }

	 expandByObject( object ) {

		 // Computes the world-axis-aligned bounding box of an object (including its children),
		 // accounting for both the object's, and children's, world transforms

		 object.updateWorldMatrix( false, false );

		 const geometry = object.geometry;

		 if ( geometry !== undefined ) {

			 if ( geometry.boundingBox === null ) {

				 geometry.computeBoundingBox();

			 }

			 _box$3.copy( geometry.boundingBox );
			 _box$3.applyMatrix4( object.matrixWorld );

			 this.union( _box$3 );

		 }

		 const children = object.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 this.expandByObject( children[ i ] );

		 }

		 return this;

	 }

	 containsPoint( point ) {

		 return point.x < this.min.x || point.x > this.max.x ||
			 point.y < this.min.y || point.y > this.max.y ||
			 point.z < this.min.z || point.z > this.max.z ? false : true;

	 }

	 containsBox( box ) {

		 return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			 this.min.y <= box.min.y && box.max.y <= this.max.y &&
			 this.min.z <= box.min.z && box.max.z <= this.max.z;

	 }

	 getParameter( point, target ) {

		 // This can potentially have a divide by zero if the box
		 // has a size dimension of 0.

		 return target.set(
			 ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			 ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			 ( point.z - this.min.z ) / ( this.max.z - this.min.z )
		 );

	 }

	 intersectsBox( box ) {

		 // using 6 splitting planes to rule out intersections.
		 return box.max.x < this.min.x || box.min.x > this.max.x ||
			 box.max.y < this.min.y || box.min.y > this.max.y ||
			 box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	 }

	 intersectsSphere( sphere ) {

		 // Find the point on the AABB closest to the sphere center.
		 this.clampPoint( sphere.center, _vector$b );

		 // If that point is inside the sphere, the AABB and sphere intersect.
		 return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	 }

	 intersectsPlane( plane ) {

		 // We compute the minimum and maximum dot product values. If those values
		 // are on the same side (back or front) of the plane, then there is no intersection.

		 let min, max;

		 if ( plane.normal.x > 0 ) {

			 min = plane.normal.x * this.min.x;
			 max = plane.normal.x * this.max.x;

		 } else {

			 min = plane.normal.x * this.max.x;
			 max = plane.normal.x * this.min.x;

		 }

		 if ( plane.normal.y > 0 ) {

			 min += plane.normal.y * this.min.y;
			 max += plane.normal.y * this.max.y;

		 } else {

			 min += plane.normal.y * this.max.y;
			 max += plane.normal.y * this.min.y;

		 }

		 if ( plane.normal.z > 0 ) {

			 min += plane.normal.z * this.min.z;
			 max += plane.normal.z * this.max.z;

		 } else {

			 min += plane.normal.z * this.max.z;
			 max += plane.normal.z * this.min.z;

		 }

		 return ( min <= - plane.constant && max >= - plane.constant );

	 }

	 intersectsTriangle( triangle ) {

		 if ( this.isEmpty() ) {

			 return false;

		 }

		 // compute box center and extents
		 this.getCenter( _center );
		 _extents.subVectors( this.max, _center );

		 // translate triangle to aabb origin
		 _v0$2.subVectors( triangle.a, _center );
		 _v1$7.subVectors( triangle.b, _center );
		 _v2$3.subVectors( triangle.c, _center );

		 // compute edge vectors for triangle
		 _f0.subVectors( _v1$7, _v0$2 );
		 _f1.subVectors( _v2$3, _v1$7 );
		 _f2.subVectors( _v0$2, _v2$3 );

		 // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		 // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		 // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		 let axes = [
			 0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			 _f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			 - _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		 ];
		 if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			 return false;

		 }

		 // test 3 face normals from the aabb
		 axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		 if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			 return false;

		 }

		 // finally testing the face normal of the triangle
		 // use already existing triangle edge vectors here
		 _triangleNormal.crossVectors( _f0, _f1 );
		 axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		 return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

	 }

	 clampPoint( point, target ) {

		 return target.copy( point ).clamp( this.min, this.max );

	 }

	 distanceToPoint( point ) {

		 const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		 return clampedPoint.sub( point ).length();

	 }

	 getBoundingSphere( target ) {

		 this.getCenter( target.center );

		 target.radius = this.getSize( _vector$b ).length() * 0.5;

		 return target;

	 }

	 intersect( box ) {

		 this.min.max( box.min );
		 this.max.min( box.max );

		 // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		 if ( this.isEmpty() ) this.makeEmpty();

		 return this;

	 }

	 union( box ) {

		 this.min.min( box.min );
		 this.max.max( box.max );

		 return this;

	 }

	 applyMatrix4( matrix ) {

		 // transform of empty box is an empty box.
		 if ( this.isEmpty() ) return this;

		 // NOTE: I am using a binary pattern to specify all 2^3 combinations below
		 _points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		 _points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		 _points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		 _points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		 _points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		 _points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		 _points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		 _points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		 this.setFromPoints( _points );

		 return this;

	 }

	 translate( offset ) {

		 this.min.add( offset );
		 this.max.add( offset );

		 return this;

	 }

	 equals( box ) {

		 return box.min.equals( this.min ) && box.max.equals( this.max );

	 }

 }

 Box3.prototype.isBox3 = true;

 const _points = [
	 /*@__PURE__*/ new Vector3(),
	 /*@__PURE__*/ new Vector3(),
	 /*@__PURE__*/ new Vector3(),
	 /*@__PURE__*/ new Vector3(),
	 /*@__PURE__*/ new Vector3(),
	 /*@__PURE__*/ new Vector3(),
	 /*@__PURE__*/ new Vector3(),
	 /*@__PURE__*/ new Vector3()
 ];

 const _vector$b = /*@__PURE__*/ new Vector3();

 const _box$3 = /*@__PURE__*/ new Box3();

 // triangle centered vertices

 const _v0$2 = /*@__PURE__*/ new Vector3();
 const _v1$7 = /*@__PURE__*/ new Vector3();
 const _v2$3 = /*@__PURE__*/ new Vector3();

 // triangle edge vectors

 const _f0 = /*@__PURE__*/ new Vector3();
 const _f1 = /*@__PURE__*/ new Vector3();
 const _f2 = /*@__PURE__*/ new Vector3();

 const _center = /*@__PURE__*/ new Vector3();
 const _extents = /*@__PURE__*/ new Vector3();
 const _triangleNormal = /*@__PURE__*/ new Vector3();
 const _testAxis = /*@__PURE__*/ new Vector3();

 function satForAxes( axes, v0, v1, v2, extents ) {

	 for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		 _testAxis.fromArray( axes, i );
		 // project the aabb onto the seperating axis
		 const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		 // project all 3 vertices of the triangle onto the seperating axis
		 const p0 = v0.dot( _testAxis );
		 const p1 = v1.dot( _testAxis );
		 const p2 = v2.dot( _testAxis );
		 // actual test, basically see if either of the most extreme of the triangle points intersects r
		 if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			 // points of the projected triangle are outside the projected half-length of the aabb
			 // the axis is seperating and we can exit
			 return false;

		 }

	 }

	 return true;

 }

 const _box$2 = /*@__PURE__*/ new Box3();
 const _v1$6 = /*@__PURE__*/ new Vector3();
 const _toFarthestPoint = /*@__PURE__*/ new Vector3();
 const _toPoint = /*@__PURE__*/ new Vector3();

 class Sphere {

	 constructor( center = new Vector3(), radius = - 1 ) {

		 this.center = center;
		 this.radius = radius;

	 }

	 set( center, radius ) {

		 this.center.copy( center );
		 this.radius = radius;

		 return this;

	 }

	 setFromPoints( points, optionalCenter ) {

		 const center = this.center;

		 if ( optionalCenter !== undefined ) {

			 center.copy( optionalCenter );

		 } else {

			 _box$2.setFromPoints( points ).getCenter( center );

		 }

		 let maxRadiusSq = 0;

		 for ( let i = 0, il = points.length; i < il; i ++ ) {

			 maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		 }

		 this.radius = Math.sqrt( maxRadiusSq );

		 return this;

	 }

	 copy( sphere ) {

		 this.center.copy( sphere.center );
		 this.radius = sphere.radius;

		 return this;

	 }

	 isEmpty() {

		 return ( this.radius < 0 );

	 }

	 makeEmpty() {

		 this.center.set( 0, 0, 0 );
		 this.radius = - 1;

		 return this;

	 }

	 containsPoint( point ) {

		 return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	 }

	 distanceToPoint( point ) {

		 return ( point.distanceTo( this.center ) - this.radius );

	 }

	 intersectsSphere( sphere ) {

		 const radiusSum = this.radius + sphere.radius;

		 return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	 }

	 intersectsBox( box ) {

		 return box.intersectsSphere( this );

	 }

	 intersectsPlane( plane ) {

		 return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	 }

	 clampPoint( point, target ) {

		 const deltaLengthSq = this.center.distanceToSquared( point );

		 target.copy( point );

		 if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			 target.sub( this.center ).normalize();
			 target.multiplyScalar( this.radius ).add( this.center );

		 }

		 return target;

	 }

	 getBoundingBox( target ) {

		 if ( this.isEmpty() ) {

			 // Empty sphere produces empty bounding box
			 target.makeEmpty();
			 return target;

		 }

		 target.set( this.center, this.center );
		 target.expandByScalar( this.radius );

		 return target;

	 }

	 applyMatrix4( matrix ) {

		 this.center.applyMatrix4( matrix );
		 this.radius = this.radius * matrix.getMaxScaleOnAxis();

		 return this;

	 }

	 translate( offset ) {

		 this.center.add( offset );

		 return this;

	 }

	 expandByPoint( point ) {

		 // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		 _toPoint.subVectors( point, this.center );

		 const lengthSq = _toPoint.lengthSq();

		 if ( lengthSq > ( this.radius * this.radius ) ) {

			 const length = Math.sqrt( lengthSq );
			 const missingRadiusHalf = ( length - this.radius ) * 0.5;

			 // Nudge this sphere towards the target point. Add half the missing distance to radius,
			 // and the other half to position. This gives a tighter enclosure, instead of if
			 // the whole missing distance were just added to radius.

			 this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			 this.radius += missingRadiusHalf;

		 }

		 return this;

	 }

	 union( sphere ) {

		 // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		 // To enclose another sphere into this sphere, we only need to enclose two points:
		 // 1) Enclose the farthest point on the other sphere into this sphere.
		 // 2) Enclose the opposite point of the farthest point into this sphere.

		 _toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		 this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
		 this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

		 return this;

	 }

	 equals( sphere ) {

		 return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 const _vector$a = /*@__PURE__*/ new Vector3();
 const _segCenter = /*@__PURE__*/ new Vector3();
 const _segDir = /*@__PURE__*/ new Vector3();
 const _diff = /*@__PURE__*/ new Vector3();

 const _edge1 = /*@__PURE__*/ new Vector3();
 const _edge2 = /*@__PURE__*/ new Vector3();
 const _normal$1 = /*@__PURE__*/ new Vector3();

 class Ray {

	 constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		 this.origin = origin;
		 this.direction = direction;

	 }

	 set( origin, direction ) {

		 this.origin.copy( origin );
		 this.direction.copy( direction );

		 return this;

	 }

	 copy( ray ) {

		 this.origin.copy( ray.origin );
		 this.direction.copy( ray.direction );

		 return this;

	 }

	 at( t, target ) {

		 return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	 }

	 lookAt( v ) {

		 this.direction.copy( v ).sub( this.origin ).normalize();

		 return this;

	 }

	 recast( t ) {

		 this.origin.copy( this.at( t, _vector$a ) );

		 return this;

	 }

	 closestPointToPoint( point, target ) {

		 target.subVectors( point, this.origin );

		 const directionDistance = target.dot( this.direction );

		 if ( directionDistance < 0 ) {

			 return target.copy( this.origin );

		 }

		 return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	 }

	 distanceToPoint( point ) {

		 return Math.sqrt( this.distanceSqToPoint( point ) );

	 }

	 distanceSqToPoint( point ) {

		 const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		 // point behind the ray

		 if ( directionDistance < 0 ) {

			 return this.origin.distanceToSquared( point );

		 }

		 _vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		 return _vector$a.distanceToSquared( point );

	 }

	 distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		 // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		 // It returns the min distance between the ray and the segment
		 // defined by v0 and v1
		 // It can also set two optional targets :
		 // - The closest point on the ray
		 // - The closest point on the segment

		 _segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		 _segDir.copy( v1 ).sub( v0 ).normalize();
		 _diff.copy( this.origin ).sub( _segCenter );

		 const segExtent = v0.distanceTo( v1 ) * 0.5;
		 const a01 = - this.direction.dot( _segDir );
		 const b0 = _diff.dot( this.direction );
		 const b1 = - _diff.dot( _segDir );
		 const c = _diff.lengthSq();
		 const det = Math.abs( 1 - a01 * a01 );
		 let s0, s1, sqrDist, extDet;

		 if ( det > 0 ) {

			 // The ray and segment are not parallel.

			 s0 = a01 * b1 - b0;
			 s1 = a01 * b0 - b1;
			 extDet = segExtent * det;

			 if ( s0 >= 0 ) {

				 if ( s1 >= - extDet ) {

					 if ( s1 <= extDet ) {

						 // region 0
						 // Minimum at interior points of ray and segment.

						 const invDet = 1 / det;
						 s0 *= invDet;
						 s1 *= invDet;
						 sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					 } else {

						 // region 1

						 s1 = segExtent;
						 s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					 }

				 } else {

					 // region 5

					 s1 = - segExtent;
					 s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				 }

			 } else {

				 if ( s1 <= - extDet ) {

					 // region 4

					 s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					 s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				 } else if ( s1 <= extDet ) {

					 // region 3

					 s0 = 0;
					 s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					 sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				 } else {

					 // region 2

					 s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					 s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				 }

			 }

		 } else {

			 // Ray and segment are parallel.

			 s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			 s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			 sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		 }

		 if ( optionalPointOnRay ) {

			 optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		 }

		 if ( optionalPointOnSegment ) {

			 optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		 }

		 return sqrDist;

	 }

	 intersectSphere( sphere, target ) {

		 _vector$a.subVectors( sphere.center, this.origin );
		 const tca = _vector$a.dot( this.direction );
		 const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		 const radius2 = sphere.radius * sphere.radius;

		 if ( d2 > radius2 ) return null;

		 const thc = Math.sqrt( radius2 - d2 );

		 // t0 = first intersect point - entrance on front of sphere
		 const t0 = tca - thc;

		 // t1 = second intersect point - exit point on back of sphere
		 const t1 = tca + thc;

		 // test to see if both t0 and t1 are behind the ray - if so, return null
		 if ( t0 < 0 && t1 < 0 ) return null;

		 // test to see if t0 is behind the ray:
		 // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		 // in order to always return an intersect point that is in front of the ray.
		 if ( t0 < 0 ) return this.at( t1, target );

		 // else t0 is in front of the ray, so return the first collision point scaled by t0
		 return this.at( t0, target );

	 }

	 intersectsSphere( sphere ) {

		 return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	 }

	 distanceToPlane( plane ) {

		 const denominator = plane.normal.dot( this.direction );

		 if ( denominator === 0 ) {

			 // line is coplanar, return origin
			 if ( plane.distanceToPoint( this.origin ) === 0 ) {

				 return 0;

			 }

			 // Null is preferable to undefined since undefined means.... it is undefined

			 return null;

		 }

		 const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		 // Return if the ray never intersects the plane

		 return t >= 0 ? t : null;

	 }

	 intersectPlane( plane, target ) {

		 const t = this.distanceToPlane( plane );

		 if ( t === null ) {

			 return null;

		 }

		 return this.at( t, target );

	 }

	 intersectsPlane( plane ) {

		 // check if the ray lies on the plane first

		 const distToPoint = plane.distanceToPoint( this.origin );

		 if ( distToPoint === 0 ) {

			 return true;

		 }

		 const denominator = plane.normal.dot( this.direction );

		 if ( denominator * distToPoint < 0 ) {

			 return true;

		 }

		 // ray origin is behind the plane (and is pointing behind it)

		 return false;

	 }

	 intersectBox( box, target ) {

		 let tmin, tmax, tymin, tymax, tzmin, tzmax;

		 const invdirx = 1 / this.direction.x,
			 invdiry = 1 / this.direction.y,
			 invdirz = 1 / this.direction.z;

		 const origin = this.origin;

		 if ( invdirx >= 0 ) {

			 tmin = ( box.min.x - origin.x ) * invdirx;
			 tmax = ( box.max.x - origin.x ) * invdirx;

		 } else {

			 tmin = ( box.max.x - origin.x ) * invdirx;
			 tmax = ( box.min.x - origin.x ) * invdirx;

		 }

		 if ( invdiry >= 0 ) {

			 tymin = ( box.min.y - origin.y ) * invdiry;
			 tymax = ( box.max.y - origin.y ) * invdiry;

		 } else {

			 tymin = ( box.max.y - origin.y ) * invdiry;
			 tymax = ( box.min.y - origin.y ) * invdiry;

		 }

		 if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		 // These lines also handle the case where tmin or tmax is NaN
		 // (result of 0 * Infinity). x !== x returns true if x is NaN

		 if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		 if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		 if ( invdirz >= 0 ) {

			 tzmin = ( box.min.z - origin.z ) * invdirz;
			 tzmax = ( box.max.z - origin.z ) * invdirz;

		 } else {

			 tzmin = ( box.max.z - origin.z ) * invdirz;
			 tzmax = ( box.min.z - origin.z ) * invdirz;

		 }

		 if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		 if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		 if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		 //return point closest to the ray (positive side)

		 if ( tmax < 0 ) return null;

		 return this.at( tmin >= 0 ? tmin : tmax, target );

	 }

	 intersectsBox( box ) {

		 return this.intersectBox( box, _vector$a ) !== null;

	 }

	 intersectTriangle( a, b, c, backfaceCulling, target ) {

		 // Compute the offset origin, edges, and normal.

		 // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		 _edge1.subVectors( b, a );
		 _edge2.subVectors( c, a );
		 _normal$1.crossVectors( _edge1, _edge2 );

		 // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		 // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		 //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		 //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		 //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		 let DdN = this.direction.dot( _normal$1 );
		 let sign;

		 if ( DdN > 0 ) {

			 if ( backfaceCulling ) return null;
			 sign = 1;

		 } else if ( DdN < 0 ) {

			 sign = - 1;
			 DdN = - DdN;

		 } else {

			 return null;

		 }

		 _diff.subVectors( this.origin, a );
		 const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		 // b1 < 0, no intersection
		 if ( DdQxE2 < 0 ) {

			 return null;

		 }

		 const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		 // b2 < 0, no intersection
		 if ( DdE1xQ < 0 ) {

			 return null;

		 }

		 // b1+b2 > 1, no intersection
		 if ( DdQxE2 + DdE1xQ > DdN ) {

			 return null;

		 }

		 // Line intersects triangle, check if ray does.
		 const QdN = - sign * _diff.dot( _normal$1 );

		 // t < 0, no intersection
		 if ( QdN < 0 ) {

			 return null;

		 }

		 // Ray intersects triangle.
		 return this.at( QdN / DdN, target );

	 }

	 applyMatrix4( matrix4 ) {

		 this.origin.applyMatrix4( matrix4 );
		 this.direction.transformDirection( matrix4 );

		 return this;

	 }

	 equals( ray ) {

		 return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 class Matrix4 {

	 constructor() {

		 this.elements = [

			 1, 0, 0, 0,
			 0, 1, 0, 0,
			 0, 0, 1, 0,
			 0, 0, 0, 1

		 ];

		 if ( arguments.length > 0 ) {

			 console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		 }

	 }

	 set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		 const te = this.elements;

		 te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		 te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		 te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		 te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		 return this;

	 }

	 identity() {

		 this.set(

			 1, 0, 0, 0,
			 0, 1, 0, 0,
			 0, 0, 1, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 clone() {

		 return new Matrix4().fromArray( this.elements );

	 }

	 copy( m ) {

		 const te = this.elements;
		 const me = m.elements;

		 te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		 te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		 te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		 te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		 return this;

	 }

	 copyPosition( m ) {

		 const te = this.elements, me = m.elements;

		 te[ 12 ] = me[ 12 ];
		 te[ 13 ] = me[ 13 ];
		 te[ 14 ] = me[ 14 ];

		 return this;

	 }

	 setFromMatrix3( m ) {

		 const me = m.elements;

		 this.set(

			 me[ 0 ], me[ 3 ], me[ 6 ], 0,
			 me[ 1 ], me[ 4 ], me[ 7 ], 0,
			 me[ 2 ], me[ 5 ], me[ 8 ], 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 extractBasis( xAxis, yAxis, zAxis ) {

		 xAxis.setFromMatrixColumn( this, 0 );
		 yAxis.setFromMatrixColumn( this, 1 );
		 zAxis.setFromMatrixColumn( this, 2 );

		 return this;

	 }

	 makeBasis( xAxis, yAxis, zAxis ) {

		 this.set(
			 xAxis.x, yAxis.x, zAxis.x, 0,
			 xAxis.y, yAxis.y, zAxis.y, 0,
			 xAxis.z, yAxis.z, zAxis.z, 0,
			 0, 0, 0, 1
		 );

		 return this;

	 }

	 extractRotation( m ) {

		 // this method does not support reflection matrices

		 const te = this.elements;
		 const me = m.elements;

		 const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		 const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		 const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		 te[ 0 ] = me[ 0 ] * scaleX;
		 te[ 1 ] = me[ 1 ] * scaleX;
		 te[ 2 ] = me[ 2 ] * scaleX;
		 te[ 3 ] = 0;

		 te[ 4 ] = me[ 4 ] * scaleY;
		 te[ 5 ] = me[ 5 ] * scaleY;
		 te[ 6 ] = me[ 6 ] * scaleY;
		 te[ 7 ] = 0;

		 te[ 8 ] = me[ 8 ] * scaleZ;
		 te[ 9 ] = me[ 9 ] * scaleZ;
		 te[ 10 ] = me[ 10 ] * scaleZ;
		 te[ 11 ] = 0;

		 te[ 12 ] = 0;
		 te[ 13 ] = 0;
		 te[ 14 ] = 0;
		 te[ 15 ] = 1;

		 return this;

	 }

	 makeRotationFromEuler( euler ) {

		 if ( ! ( euler && euler.isEuler ) ) {

			 console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		 }

		 const te = this.elements;

		 const x = euler.x, y = euler.y, z = euler.z;
		 const a = Math.cos( x ), b = Math.sin( x );
		 const c = Math.cos( y ), d = Math.sin( y );
		 const e = Math.cos( z ), f = Math.sin( z );

		 if ( euler.order === 'XYZ' ) {

			 const ae = a * e, af = a * f, be = b * e, bf = b * f;

			 te[ 0 ] = c * e;
			 te[ 4 ] = - c * f;
			 te[ 8 ] = d;

			 te[ 1 ] = af + be * d;
			 te[ 5 ] = ae - bf * d;
			 te[ 9 ] = - b * c;

			 te[ 2 ] = bf - ae * d;
			 te[ 6 ] = be + af * d;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'YXZ' ) {

			 const ce = c * e, cf = c * f, de = d * e, df = d * f;

			 te[ 0 ] = ce + df * b;
			 te[ 4 ] = de * b - cf;
			 te[ 8 ] = a * d;

			 te[ 1 ] = a * f;
			 te[ 5 ] = a * e;
			 te[ 9 ] = - b;

			 te[ 2 ] = cf * b - de;
			 te[ 6 ] = df + ce * b;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'ZXY' ) {

			 const ce = c * e, cf = c * f, de = d * e, df = d * f;

			 te[ 0 ] = ce - df * b;
			 te[ 4 ] = - a * f;
			 te[ 8 ] = de + cf * b;

			 te[ 1 ] = cf + de * b;
			 te[ 5 ] = a * e;
			 te[ 9 ] = df - ce * b;

			 te[ 2 ] = - a * d;
			 te[ 6 ] = b;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'ZYX' ) {

			 const ae = a * e, af = a * f, be = b * e, bf = b * f;

			 te[ 0 ] = c * e;
			 te[ 4 ] = be * d - af;
			 te[ 8 ] = ae * d + bf;

			 te[ 1 ] = c * f;
			 te[ 5 ] = bf * d + ae;
			 te[ 9 ] = af * d - be;

			 te[ 2 ] = - d;
			 te[ 6 ] = b * c;
			 te[ 10 ] = a * c;

		 } else if ( euler.order === 'YZX' ) {

			 const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			 te[ 0 ] = c * e;
			 te[ 4 ] = bd - ac * f;
			 te[ 8 ] = bc * f + ad;

			 te[ 1 ] = f;
			 te[ 5 ] = a * e;
			 te[ 9 ] = - b * e;

			 te[ 2 ] = - d * e;
			 te[ 6 ] = ad * f + bc;
			 te[ 10 ] = ac - bd * f;

		 } else if ( euler.order === 'XZY' ) {

			 const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			 te[ 0 ] = c * e;
			 te[ 4 ] = - f;
			 te[ 8 ] = d * e;

			 te[ 1 ] = ac * f + bd;
			 te[ 5 ] = a * e;
			 te[ 9 ] = ad * f - bc;

			 te[ 2 ] = bc * f - ad;
			 te[ 6 ] = b * e;
			 te[ 10 ] = bd * f + ac;

		 }

		 // bottom row
		 te[ 3 ] = 0;
		 te[ 7 ] = 0;
		 te[ 11 ] = 0;

		 // last column
		 te[ 12 ] = 0;
		 te[ 13 ] = 0;
		 te[ 14 ] = 0;
		 te[ 15 ] = 1;

		 return this;

	 }

	 makeRotationFromQuaternion( q ) {

		 return this.compose( _zero, q, _one );

	 }

	 lookAt( eye, target, up ) {

		 const te = this.elements;

		 _z.subVectors( eye, target );

		 if ( _z.lengthSq() === 0 ) {

			 // eye and target are in the same position

			 _z.z = 1;

		 }

		 _z.normalize();
		 _x.crossVectors( up, _z );

		 if ( _x.lengthSq() === 0 ) {

			 // up and z are parallel

			 if ( Math.abs( up.z ) === 1 ) {

				 _z.x += 0.0001;

			 } else {

				 _z.z += 0.0001;

			 }

			 _z.normalize();
			 _x.crossVectors( up, _z );

		 }

		 _x.normalize();
		 _y.crossVectors( _z, _x );

		 te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		 te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		 te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		 return this;

	 }

	 multiply( m, n ) {

		 if ( n !== undefined ) {

			 console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			 return this.multiplyMatrices( m, n );

		 }

		 return this.multiplyMatrices( this, m );

	 }

	 premultiply( m ) {

		 return this.multiplyMatrices( m, this );

	 }

	 multiplyMatrices( a, b ) {

		 const ae = a.elements;
		 const be = b.elements;
		 const te = this.elements;

		 const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		 const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		 const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		 const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		 const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		 const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		 const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		 const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		 te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		 te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		 te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		 te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		 te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		 te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		 te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		 te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		 te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		 te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		 te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		 te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		 te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		 te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		 te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		 te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		 return this;

	 }

	 multiplyScalar( s ) {

		 const te = this.elements;

		 te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		 te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		 te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		 te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		 return this;

	 }

	 determinant() {

		 const te = this.elements;

		 const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		 const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		 const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		 const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		 //TODO: make this more efficient
		 //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		 return (
			 n41 * (
				 + n14 * n23 * n32
					- n13 * n24 * n32
					- n14 * n22 * n33
					+ n12 * n24 * n33
					+ n13 * n22 * n34
					- n12 * n23 * n34
			 ) +
			 n42 * (
				 + n11 * n23 * n34
					- n11 * n24 * n33
					+ n14 * n21 * n33
					- n13 * n21 * n34
					+ n13 * n24 * n31
					- n14 * n23 * n31
			 ) +
			 n43 * (
				 + n11 * n24 * n32
					- n11 * n22 * n34
					- n14 * n21 * n32
					+ n12 * n21 * n34
					+ n14 * n22 * n31
					- n12 * n24 * n31
			 ) +
			 n44 * (
				 - n13 * n22 * n31
					- n11 * n23 * n32
					+ n11 * n22 * n33
					+ n13 * n21 * n32
					- n12 * n21 * n33
					+ n12 * n23 * n31
			 )

		 );

	 }

	 transpose() {

		 const te = this.elements;
		 let tmp;

		 tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		 tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		 tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		 tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		 tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		 tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		 return this;

	 }

	 setPosition( x, y, z ) {

		 const te = this.elements;

		 if ( x.isVector3 ) {

			 te[ 12 ] = x.x;
			 te[ 13 ] = x.y;
			 te[ 14 ] = x.z;

		 } else {

			 te[ 12 ] = x;
			 te[ 13 ] = y;
			 te[ 14 ] = z;

		 }

		 return this;

	 }

	 invert() {

		 // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		 const te = this.elements,

			 n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			 n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			 n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			 n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			 t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			 t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			 t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			 t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		 const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		 if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		 const detInv = 1 / det;

		 te[ 0 ] = t11 * detInv;
		 te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		 te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		 te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		 te[ 4 ] = t12 * detInv;
		 te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		 te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		 te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		 te[ 8 ] = t13 * detInv;
		 te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		 te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		 te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		 te[ 12 ] = t14 * detInv;
		 te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		 te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		 te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		 return this;

	 }

	 scale( v ) {

		 const te = this.elements;
		 const x = v.x, y = v.y, z = v.z;

		 te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		 te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		 te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		 te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		 return this;

	 }

	 getMaxScaleOnAxis() {

		 const te = this.elements;

		 const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		 const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		 const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		 return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	 }

	 makeTranslation( x, y, z ) {

		 this.set(

			 1, 0, 0, x,
			 0, 1, 0, y,
			 0, 0, 1, z,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationX( theta ) {

		 const c = Math.cos( theta ), s = Math.sin( theta );

		 this.set(

			 1, 0, 0, 0,
			 0, c, - s, 0,
			 0, s, c, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationY( theta ) {

		 const c = Math.cos( theta ), s = Math.sin( theta );

		 this.set(

				c, 0, s, 0,
				0, 1, 0, 0,
			 - s, 0, c, 0,
				0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationZ( theta ) {

		 const c = Math.cos( theta ), s = Math.sin( theta );

		 this.set(

			 c, - s, 0, 0,
			 s, c, 0, 0,
			 0, 0, 1, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeRotationAxis( axis, angle ) {

		 // Based on http://www.gamedev.net/reference/articles/article1199.asp

		 const c = Math.cos( angle );
		 const s = Math.sin( angle );
		 const t = 1 - c;
		 const x = axis.x, y = axis.y, z = axis.z;
		 const tx = t * x, ty = t * y;

		 this.set(

			 tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			 tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			 tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeScale( x, y, z ) {

		 this.set(

			 x, 0, 0, 0,
			 0, y, 0, 0,
			 0, 0, z, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 makeShear( xy, xz, yx, yz, zx, zy ) {

		 this.set(

			 1, yx, zx, 0,
			 xy, 1, zy, 0,
			 xz, yz, 1, 0,
			 0, 0, 0, 1

		 );

		 return this;

	 }

	 compose( position, quaternion, scale ) {

		 const te = this.elements;

		 const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		 const x2 = x + x,	y2 = y + y, z2 = z + z;
		 const xx = x * x2, xy = x * y2, xz = x * z2;
		 const yy = y * y2, yz = y * z2, zz = z * z2;
		 const wx = w * x2, wy = w * y2, wz = w * z2;

		 const sx = scale.x, sy = scale.y, sz = scale.z;

		 te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		 te[ 1 ] = ( xy + wz ) * sx;
		 te[ 2 ] = ( xz - wy ) * sx;
		 te[ 3 ] = 0;

		 te[ 4 ] = ( xy - wz ) * sy;
		 te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		 te[ 6 ] = ( yz + wx ) * sy;
		 te[ 7 ] = 0;

		 te[ 8 ] = ( xz + wy ) * sz;
		 te[ 9 ] = ( yz - wx ) * sz;
		 te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		 te[ 11 ] = 0;

		 te[ 12 ] = position.x;
		 te[ 13 ] = position.y;
		 te[ 14 ] = position.z;
		 te[ 15 ] = 1;

		 return this;

	 }

	 decompose( position, quaternion, scale ) {

		 const te = this.elements;

		 let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		 const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		 const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		 // if determine is negative, we need to invert one scale
		 const det = this.determinant();
		 if ( det < 0 ) sx = - sx;

		 position.x = te[ 12 ];
		 position.y = te[ 13 ];
		 position.z = te[ 14 ];

		 // scale the rotation part
		 _m1$2.copy( this );

		 const invSX = 1 / sx;
		 const invSY = 1 / sy;
		 const invSZ = 1 / sz;

		 _m1$2.elements[ 0 ] *= invSX;
		 _m1$2.elements[ 1 ] *= invSX;
		 _m1$2.elements[ 2 ] *= invSX;

		 _m1$2.elements[ 4 ] *= invSY;
		 _m1$2.elements[ 5 ] *= invSY;
		 _m1$2.elements[ 6 ] *= invSY;

		 _m1$2.elements[ 8 ] *= invSZ;
		 _m1$2.elements[ 9 ] *= invSZ;
		 _m1$2.elements[ 10 ] *= invSZ;

		 quaternion.setFromRotationMatrix( _m1$2 );

		 scale.x = sx;
		 scale.y = sy;
		 scale.z = sz;

		 return this;

	 }

	 makePerspective( left, right, top, bottom, near, far ) {

		 if ( far === undefined ) {

			 console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		 }

		 const te = this.elements;
		 const x = 2 * near / ( right - left );
		 const y = 2 * near / ( top - bottom );

		 const a = ( right + left ) / ( right - left );
		 const b = ( top + bottom ) / ( top - bottom );
		 const c = - ( far + near ) / ( far - near );
		 const d = - 2 * far * near / ( far - near );

		 te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		 te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		 te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		 te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		 return this;

	 }

	 makeOrthographic( left, right, top, bottom, near, far ) {

		 const te = this.elements;
		 const w = 1.0 / ( right - left );
		 const h = 1.0 / ( top - bottom );
		 const p = 1.0 / ( far - near );

		 const x = ( right + left ) * w;
		 const y = ( top + bottom ) * h;
		 const z = ( far + near ) * p;

		 te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		 te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		 te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		 te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		 return this;

	 }

	 equals( matrix ) {

		 const te = this.elements;
		 const me = matrix.elements;

		 for ( let i = 0; i < 16; i ++ ) {

			 if ( te[ i ] !== me[ i ] ) return false;

		 }

		 return true;

	 }

	 fromArray( array, offset = 0 ) {

		 for ( let i = 0; i < 16; i ++ ) {

			 this.elements[ i ] = array[ i + offset ];

		 }

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 const te = this.elements;

		 array[ offset ] = te[ 0 ];
		 array[ offset + 1 ] = te[ 1 ];
		 array[ offset + 2 ] = te[ 2 ];
		 array[ offset + 3 ] = te[ 3 ];

		 array[ offset + 4 ] = te[ 4 ];
		 array[ offset + 5 ] = te[ 5 ];
		 array[ offset + 6 ] = te[ 6 ];
		 array[ offset + 7 ] = te[ 7 ];

		 array[ offset + 8 ] = te[ 8 ];
		 array[ offset + 9 ] = te[ 9 ];
		 array[ offset + 10 ] = te[ 10 ];
		 array[ offset + 11 ] = te[ 11 ];

		 array[ offset + 12 ] = te[ 12 ];
		 array[ offset + 13 ] = te[ 13 ];
		 array[ offset + 14 ] = te[ 14 ];
		 array[ offset + 15 ] = te[ 15 ];

		 return array;

	 }

 }

 Matrix4.prototype.isMatrix4 = true;

 const _v1$5 = /*@__PURE__*/ new Vector3();
 const _m1$2 = /*@__PURE__*/ new Matrix4();
 const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
 const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
 const _x = /*@__PURE__*/ new Vector3();
 const _y = /*@__PURE__*/ new Vector3();
 const _z = /*@__PURE__*/ new Vector3();

 const _matrix$1 = /*@__PURE__*/ new Matrix4();
 const _quaternion$3 = /*@__PURE__*/ new Quaternion();

 class Euler {

	 constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._order = order;

	 }

	 get x() {

		 return this._x;

	 }

	 set x( value ) {

		 this._x = value;
		 this._onChangeCallback();

	 }

	 get y() {

		 return this._y;

	 }

	 set y( value ) {

		 this._y = value;
		 this._onChangeCallback();

	 }

	 get z() {

		 return this._z;

	 }

	 set z( value ) {

		 this._z = value;
		 this._onChangeCallback();

	 }

	 get order() {

		 return this._order;

	 }

	 set order( value ) {

		 this._order = value;
		 this._onChangeCallback();

	 }

	 set( x, y, z, order = this._order ) {

		 this._x = x;
		 this._y = y;
		 this._z = z;
		 this._order = order;

		 this._onChangeCallback();

		 return this;

	 }

	 clone() {

		 return new this.constructor( this._x, this._y, this._z, this._order );

	 }

	 copy( euler ) {

		 this._x = euler._x;
		 this._y = euler._y;
		 this._z = euler._z;
		 this._order = euler._order;

		 this._onChangeCallback();

		 return this;

	 }

	 setFromRotationMatrix( m, order = this._order, update = true ) {

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 const te = m.elements;
		 const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		 const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		 const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		 switch ( order ) {

			 case 'XYZ':

				 this._y = Math.asin( clamp( m13, - 1, 1 ) );

				 if ( Math.abs( m13 ) < 0.9999999 ) {

					 this._x = Math.atan2( - m23, m33 );
					 this._z = Math.atan2( - m12, m11 );

				 } else {

					 this._x = Math.atan2( m32, m22 );
					 this._z = 0;

				 }

				 break;

			 case 'YXZ':

				 this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				 if ( Math.abs( m23 ) < 0.9999999 ) {

					 this._y = Math.atan2( m13, m33 );
					 this._z = Math.atan2( m21, m22 );

				 } else {

					 this._y = Math.atan2( - m31, m11 );
					 this._z = 0;

				 }

				 break;

			 case 'ZXY':

				 this._x = Math.asin( clamp( m32, - 1, 1 ) );

				 if ( Math.abs( m32 ) < 0.9999999 ) {

					 this._y = Math.atan2( - m31, m33 );
					 this._z = Math.atan2( - m12, m22 );

				 } else {

					 this._y = 0;
					 this._z = Math.atan2( m21, m11 );

				 }

				 break;

			 case 'ZYX':

				 this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				 if ( Math.abs( m31 ) < 0.9999999 ) {

					 this._x = Math.atan2( m32, m33 );
					 this._z = Math.atan2( m21, m11 );

				 } else {

					 this._x = 0;
					 this._z = Math.atan2( - m12, m22 );

				 }

				 break;

			 case 'YZX':

				 this._z = Math.asin( clamp( m21, - 1, 1 ) );

				 if ( Math.abs( m21 ) < 0.9999999 ) {

					 this._x = Math.atan2( - m23, m22 );
					 this._y = Math.atan2( - m31, m11 );

				 } else {

					 this._x = 0;
					 this._y = Math.atan2( m13, m33 );

				 }

				 break;

			 case 'XZY':

				 this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				 if ( Math.abs( m12 ) < 0.9999999 ) {

					 this._x = Math.atan2( m32, m22 );
					 this._y = Math.atan2( m13, m11 );

				 } else {

					 this._x = Math.atan2( - m23, m33 );
					 this._y = 0;

				 }

				 break;

			 default:

				 console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		 }

		 this._order = order;

		 if ( update === true ) this._onChangeCallback();

		 return this;

	 }

	 setFromQuaternion( q, order, update ) {

		 _matrix$1.makeRotationFromQuaternion( q );

		 return this.setFromRotationMatrix( _matrix$1, order, update );

	 }

	 setFromVector3( v, order = this._order ) {

		 return this.set( v.x, v.y, v.z, order );

	 }

	 reorder( newOrder ) {

		 // WARNING: this discards revolution information -bhouston

		 _quaternion$3.setFromEuler( this );

		 return this.setFromQuaternion( _quaternion$3, newOrder );

	 }

	 equals( euler ) {

		 return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	 }

	 fromArray( array ) {

		 this._x = array[ 0 ];
		 this._y = array[ 1 ];
		 this._z = array[ 2 ];
		 if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		 this._onChangeCallback();

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this._x;
		 array[ offset + 1 ] = this._y;
		 array[ offset + 2 ] = this._z;
		 array[ offset + 3 ] = this._order;

		 return array;

	 }

	 toVector3( optionalResult ) {

		 if ( optionalResult ) {

			 return optionalResult.set( this._x, this._y, this._z );

		 } else {

			 return new Vector3( this._x, this._y, this._z );

		 }

	 }

	 _onChange( callback ) {

		 this._onChangeCallback = callback;

		 return this;

	 }

	 _onChangeCallback() {}

 }

 Euler.prototype.isEuler = true;

 Euler.DefaultOrder = 'XYZ';
 Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

 class Layers {

	 constructor() {

		 this.mask = 1 | 0;

	 }

	 set( channel ) {

		 this.mask = 1 << channel | 0;

	 }

	 enable( channel ) {

		 this.mask |= 1 << channel | 0;

	 }

	 enableAll() {

		 this.mask = 0xffffffff | 0;

	 }

	 toggle( channel ) {

		 this.mask ^= 1 << channel | 0;

	 }

	 disable( channel ) {

		 this.mask &= ~ ( 1 << channel | 0 );

	 }

	 disableAll() {

		 this.mask = 0;

	 }

	 test( layers ) {

		 return ( this.mask & layers.mask ) !== 0;

	 }

 }

 let _object3DId = 0;

 const _v1$4 = /*@__PURE__*/ new Vector3();
 const _q1 = /*@__PURE__*/ new Quaternion();
 const _m1$1 = /*@__PURE__*/ new Matrix4();
 const _target = /*@__PURE__*/ new Vector3();

 const _position$3 = /*@__PURE__*/ new Vector3();
 const _scale$2 = /*@__PURE__*/ new Vector3();
 const _quaternion$2 = /*@__PURE__*/ new Quaternion();

 const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
 const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
 const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

 const _addedEvent = { type: 'added' };
 const _removedEvent = { type: 'removed' };

 class Object3D extends EventDispatcher {

	 constructor() {

		 super();

		 Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		 this.uuid = generateUUID();

		 this.name = '';
		 this.type = 'Object3D';

		 this.parent = null;
		 this.children = [];

		 this.up = Object3D.DefaultUp.clone();

		 const position = new Vector3();
		 const rotation = new Euler();
		 const quaternion = new Quaternion();
		 const scale = new Vector3( 1, 1, 1 );

		 function onRotationChange() {

			 quaternion.setFromEuler( rotation, false );

		 }

		 function onQuaternionChange() {

			 rotation.setFromQuaternion( quaternion, undefined, false );

		 }

		 rotation._onChange( onRotationChange );
		 quaternion._onChange( onQuaternionChange );

		 Object.defineProperties( this, {
			 position: {
				 configurable: true,
				 enumerable: true,
				 value: position
			 },
			 rotation: {
				 configurable: true,
				 enumerable: true,
				 value: rotation
			 },
			 quaternion: {
				 configurable: true,
				 enumerable: true,
				 value: quaternion
			 },
			 scale: {
				 configurable: true,
				 enumerable: true,
				 value: scale
			 },
			 modelViewMatrix: {
				 value: new Matrix4()
			 },
			 normalMatrix: {
				 value: new Matrix3()
			 }
		 } );

		 this.matrix = new Matrix4();
		 this.matrixWorld = new Matrix4();

		 this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		 this.matrixWorldNeedsUpdate = false;

		 this.layers = new Layers();
		 this.visible = true;

		 this.castShadow = false;
		 this.receiveShadow = false;

		 this.frustumCulled = true;
		 this.renderOrder = 0;

		 this.animations = [];

		 this.userData = {};

	 }

	 onBeforeRender() {}
	 onAfterRender() {}

	 applyMatrix4( matrix ) {

		 if ( this.matrixAutoUpdate ) this.updateMatrix();

		 this.matrix.premultiply( matrix );

		 this.matrix.decompose( this.position, this.quaternion, this.scale );

	 }

	 applyQuaternion( q ) {

		 this.quaternion.premultiply( q );

		 return this;

	 }

	 setRotationFromAxisAngle( axis, angle ) {

		 // assumes axis is normalized

		 this.quaternion.setFromAxisAngle( axis, angle );

	 }

	 setRotationFromEuler( euler ) {

		 this.quaternion.setFromEuler( euler, true );

	 }

	 setRotationFromMatrix( m ) {

		 // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		 this.quaternion.setFromRotationMatrix( m );

	 }

	 setRotationFromQuaternion( q ) {

		 // assumes q is normalized

		 this.quaternion.copy( q );

	 }

	 rotateOnAxis( axis, angle ) {

		 // rotate object on axis in object space
		 // axis is assumed to be normalized

		 _q1.setFromAxisAngle( axis, angle );

		 this.quaternion.multiply( _q1 );

		 return this;

	 }

	 rotateOnWorldAxis( axis, angle ) {

		 // rotate object on axis in world space
		 // axis is assumed to be normalized
		 // method assumes no rotated parent

		 _q1.setFromAxisAngle( axis, angle );

		 this.quaternion.premultiply( _q1 );

		 return this;

	 }

	 rotateX( angle ) {

		 return this.rotateOnAxis( _xAxis, angle );

	 }

	 rotateY( angle ) {

		 return this.rotateOnAxis( _yAxis, angle );

	 }

	 rotateZ( angle ) {

		 return this.rotateOnAxis( _zAxis, angle );

	 }

	 translateOnAxis( axis, distance ) {

		 // translate object by distance along axis in object space
		 // axis is assumed to be normalized

		 _v1$4.copy( axis ).applyQuaternion( this.quaternion );

		 this.position.add( _v1$4.multiplyScalar( distance ) );

		 return this;

	 }

	 translateX( distance ) {

		 return this.translateOnAxis( _xAxis, distance );

	 }

	 translateY( distance ) {

		 return this.translateOnAxis( _yAxis, distance );

	 }

	 translateZ( distance ) {

		 return this.translateOnAxis( _zAxis, distance );

	 }

	 localToWorld( vector ) {

		 return vector.applyMatrix4( this.matrixWorld );

	 }

	 worldToLocal( vector ) {

		 return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	 }

	 lookAt( x, y, z ) {

		 // This method does not support objects having non-uniformly-scaled parent(s)

		 if ( x.isVector3 ) {

			 _target.copy( x );

		 } else {

			 _target.set( x, y, z );

		 }

		 const parent = this.parent;

		 this.updateWorldMatrix( true, false );

		 _position$3.setFromMatrixPosition( this.matrixWorld );

		 if ( this.isCamera || this.isLight ) {

			 _m1$1.lookAt( _position$3, _target, this.up );

		 } else {

			 _m1$1.lookAt( _target, _position$3, this.up );

		 }

		 this.quaternion.setFromRotationMatrix( _m1$1 );

		 if ( parent ) {

			 _m1$1.extractRotation( parent.matrixWorld );
			 _q1.setFromRotationMatrix( _m1$1 );
			 this.quaternion.premultiply( _q1.invert() );

		 }

	 }

	 add( object ) {

		 if ( arguments.length > 1 ) {

			 for ( let i = 0; i < arguments.length; i ++ ) {

				 this.add( arguments[ i ] );

			 }

			 return this;

		 }

		 if ( object === this ) {

			 console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			 return this;

		 }

		 if ( object && object.isObject3D ) {

			 if ( object.parent !== null ) {

				 object.parent.remove( object );

			 }

			 object.parent = this;
			 this.children.push( object );

			 object.dispatchEvent( _addedEvent );

		 } else {

			 console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		 }

		 return this;

	 }

	 remove( object ) {

		 if ( arguments.length > 1 ) {

			 for ( let i = 0; i < arguments.length; i ++ ) {

				 this.remove( arguments[ i ] );

			 }

			 return this;

		 }

		 const index = this.children.indexOf( object );

		 if ( index !== - 1 ) {

			 object.parent = null;
			 this.children.splice( index, 1 );

			 object.dispatchEvent( _removedEvent );

		 }

		 return this;

	 }

	 removeFromParent() {

		 const parent = this.parent;

		 if ( parent !== null ) {

			 parent.remove( this );

		 }

		 return this;

	 }

	 clear() {

		 for ( let i = 0; i < this.children.length; i ++ ) {

			 const object = this.children[ i ];

			 object.parent = null;

			 object.dispatchEvent( _removedEvent );

		 }

		 this.children.length = 0;

		 return this;


	 }

	 attach( object ) {

		 // adds object as a child of this, while maintaining the object's world transform

		 this.updateWorldMatrix( true, false );

		 _m1$1.copy( this.matrixWorld ).invert();

		 if ( object.parent !== null ) {

			 object.parent.updateWorldMatrix( true, false );

			 _m1$1.multiply( object.parent.matrixWorld );

		 }

		 object.applyMatrix4( _m1$1 );

		 this.add( object );

		 object.updateWorldMatrix( false, true );

		 return this;

	 }

	 getObjectById( id ) {

		 return this.getObjectByProperty( 'id', id );

	 }

	 getObjectByName( name ) {

		 return this.getObjectByProperty( 'name', name );

	 }

	 getObjectByProperty( name, value ) {

		 if ( this[ name ] === value ) return this;

		 for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			 const child = this.children[ i ];
			 const object = child.getObjectByProperty( name, value );

			 if ( object !== undefined ) {

				 return object;

			 }

		 }

		 return undefined;

	 }

	 getWorldPosition( target ) {

		 this.updateWorldMatrix( true, false );

		 return target.setFromMatrixPosition( this.matrixWorld );

	 }

	 getWorldQuaternion( target ) {

		 this.updateWorldMatrix( true, false );

		 this.matrixWorld.decompose( _position$3, target, _scale$2 );

		 return target;

	 }

	 getWorldScale( target ) {

		 this.updateWorldMatrix( true, false );

		 this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		 return target;

	 }

	 getWorldDirection( target ) {

		 this.updateWorldMatrix( true, false );

		 const e = this.matrixWorld.elements;

		 return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	 }

	 raycast() {}

	 traverse( callback ) {

		 callback( this );

		 const children = this.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 children[ i ].traverse( callback );

		 }

	 }

	 traverseVisible( callback ) {

		 if ( this.visible === false ) return;

		 callback( this );

		 const children = this.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 children[ i ].traverseVisible( callback );

		 }

	 }

	 traverseAncestors( callback ) {

		 const parent = this.parent;

		 if ( parent !== null ) {

			 callback( parent );

			 parent.traverseAncestors( callback );

		 }

	 }

	 updateMatrix() {

		 this.matrix.compose( this.position, this.quaternion, this.scale );

		 this.matrixWorldNeedsUpdate = true;

	 }

	 updateMatrixWorld( force ) {

		 if ( this.matrixAutoUpdate ) this.updateMatrix();

		 if ( this.matrixWorldNeedsUpdate || force ) {

			 if ( this.parent === null ) {

				 this.matrixWorld.copy( this.matrix );

			 } else {

				 this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			 }

			 this.matrixWorldNeedsUpdate = false;

			 force = true;

		 }

		 // update children

		 const children = this.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 children[ i ].updateMatrixWorld( force );

		 }

	 }

	 updateWorldMatrix( updateParents, updateChildren ) {

		 const parent = this.parent;

		 if ( updateParents === true && parent !== null ) {

			 parent.updateWorldMatrix( true, false );

		 }

		 if ( this.matrixAutoUpdate ) this.updateMatrix();

		 if ( this.parent === null ) {

			 this.matrixWorld.copy( this.matrix );

		 } else {

			 this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		 }

		 // update children

		 if ( updateChildren === true ) {

			 const children = this.children;

			 for ( let i = 0, l = children.length; i < l; i ++ ) {

				 children[ i ].updateWorldMatrix( false, true );

			 }

		 }

	 }

	 toJSON( meta ) {

		 // meta is a string when called from JSON.stringify
		 const isRootObject = ( meta === undefined || typeof meta === 'string' );

		 const output = {};

		 // meta is a hash used to collect geometries, materials.
		 // not providing it implies that this is the root object
		 // being serialized.
		 if ( isRootObject ) {

			 // initialize meta obj
			 meta = {
				 geometries: {},
				 materials: {},
				 textures: {},
				 images: {},
				 shapes: {},
				 skeletons: {},
				 animations: {}
			 };

			 output.metadata = {
				 version: 4.5,
				 type: 'Object',
				 generator: 'Object3D.toJSON'
			 };

		 }

		 // standard Object3D serialization

		 const object = {};

		 object.uuid = this.uuid;
		 object.type = this.type;

		 if ( this.name !== '' ) object.name = this.name;
		 if ( this.castShadow === true ) object.castShadow = true;
		 if ( this.receiveShadow === true ) object.receiveShadow = true;
		 if ( this.visible === false ) object.visible = false;
		 if ( this.frustumCulled === false ) object.frustumCulled = false;
		 if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		 if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		 object.layers = this.layers.mask;
		 object.matrix = this.matrix.toArray();

		 if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		 // object specific properties

		 if ( this.isInstancedMesh ) {

			 object.type = 'InstancedMesh';
			 object.count = this.count;
			 object.instanceMatrix = this.instanceMatrix.toJSON();
			 if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		 }

		 //

		 function serialize( library, element ) {

			 if ( library[ element.uuid ] === undefined ) {

				 library[ element.uuid ] = element.toJSON( meta );

			 }

			 return element.uuid;

		 }

		 if ( this.isScene ) {

			 if ( this.background ) {

				 if ( this.background.isColor ) {

					 object.background = this.background.toJSON();

				 } else if ( this.background.isTexture ) {

					 object.background = this.background.toJSON( meta ).uuid;

				 }

			 }

			 if ( this.environment && this.environment.isTexture ) {

				 object.environment = this.environment.toJSON( meta ).uuid;

			 }

		 } else if ( this.isMesh || this.isLine || this.isPoints ) {

			 object.geometry = serialize( meta.geometries, this.geometry );

			 const parameters = this.geometry.parameters;

			 if ( parameters !== undefined && parameters.shapes !== undefined ) {

				 const shapes = parameters.shapes;

				 if ( Array.isArray( shapes ) ) {

					 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						 const shape = shapes[ i ];

						 serialize( meta.shapes, shape );

					 }

				 } else {

					 serialize( meta.shapes, shapes );

				 }

			 }

		 }

		 if ( this.isSkinnedMesh ) {

			 object.bindMode = this.bindMode;
			 object.bindMatrix = this.bindMatrix.toArray();

			 if ( this.skeleton !== undefined ) {

				 serialize( meta.skeletons, this.skeleton );

				 object.skeleton = this.skeleton.uuid;

			 }

		 }

		 if ( this.material !== undefined ) {

			 if ( Array.isArray( this.material ) ) {

				 const uuids = [];

				 for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					 uuids.push( serialize( meta.materials, this.material[ i ] ) );

				 }

				 object.material = uuids;

			 } else {

				 object.material = serialize( meta.materials, this.material );

			 }

		 }

		 //

		 if ( this.children.length > 0 ) {

			 object.children = [];

			 for ( let i = 0; i < this.children.length; i ++ ) {

				 object.children.push( this.children[ i ].toJSON( meta ).object );

			 }

		 }

		 //

		 if ( this.animations.length > 0 ) {

			 object.animations = [];

			 for ( let i = 0; i < this.animations.length; i ++ ) {

				 const animation = this.animations[ i ];

				 object.animations.push( serialize( meta.animations, animation ) );

			 }

		 }

		 if ( isRootObject ) {

			 const geometries = extractFromCache( meta.geometries );
			 const materials = extractFromCache( meta.materials );
			 const textures = extractFromCache( meta.textures );
			 const images = extractFromCache( meta.images );
			 const shapes = extractFromCache( meta.shapes );
			 const skeletons = extractFromCache( meta.skeletons );
			 const animations = extractFromCache( meta.animations );

			 if ( geometries.length > 0 ) output.geometries = geometries;
			 if ( materials.length > 0 ) output.materials = materials;
			 if ( textures.length > 0 ) output.textures = textures;
			 if ( images.length > 0 ) output.images = images;
			 if ( shapes.length > 0 ) output.shapes = shapes;
			 if ( skeletons.length > 0 ) output.skeletons = skeletons;
			 if ( animations.length > 0 ) output.animations = animations;

		 }

		 output.object = object;

		 return output;

		 // extract data from the cache hash
		 // remove metadata on each item
		 // and return as array
		 function extractFromCache( cache ) {

			 const values = [];
			 for ( const key in cache ) {

				 const data = cache[ key ];
				 delete data.metadata;
				 values.push( data );

			 }

			 return values;

		 }

	 }

	 clone( recursive ) {

		 return new this.constructor().copy( this, recursive );

	 }

	 copy( source, recursive = true ) {

		 this.name = source.name;

		 this.up.copy( source.up );

		 this.position.copy( source.position );
		 this.rotation.order = source.rotation.order;
		 this.quaternion.copy( source.quaternion );
		 this.scale.copy( source.scale );

		 this.matrix.copy( source.matrix );
		 this.matrixWorld.copy( source.matrixWorld );

		 this.matrixAutoUpdate = source.matrixAutoUpdate;
		 this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		 this.layers.mask = source.layers.mask;
		 this.visible = source.visible;

		 this.castShadow = source.castShadow;
		 this.receiveShadow = source.receiveShadow;

		 this.frustumCulled = source.frustumCulled;
		 this.renderOrder = source.renderOrder;

		 this.userData = JSON.parse( JSON.stringify( source.userData ) );

		 if ( recursive === true ) {

			 for ( let i = 0; i < source.children.length; i ++ ) {

				 const child = source.children[ i ];
				 this.add( child.clone() );

			 }

		 }

		 return this;

	 }

 }

 Object3D.DefaultUp = new Vector3( 0, 1, 0 );
 Object3D.DefaultMatrixAutoUpdate = true;

 Object3D.prototype.isObject3D = true;

 const _v0$1 = /*@__PURE__*/ new Vector3();
 const _v1$3 = /*@__PURE__*/ new Vector3();
 const _v2$2 = /*@__PURE__*/ new Vector3();
 const _v3$1 = /*@__PURE__*/ new Vector3();

 const _vab = /*@__PURE__*/ new Vector3();
 const _vac = /*@__PURE__*/ new Vector3();
 const _vbc = /*@__PURE__*/ new Vector3();
 const _vap = /*@__PURE__*/ new Vector3();
 const _vbp = /*@__PURE__*/ new Vector3();
 const _vcp = /*@__PURE__*/ new Vector3();

 class Triangle {

	 constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		 this.a = a;
		 this.b = b;
		 this.c = c;

	 }

	 static getNormal( a, b, c, target ) {

		 target.subVectors( c, b );
		 _v0$1.subVectors( a, b );
		 target.cross( _v0$1 );

		 const targetLengthSq = target.lengthSq();
		 if ( targetLengthSq > 0 ) {

			 return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		 }

		 return target.set( 0, 0, 0 );

	 }

	 // static/instance method to calculate barycentric coordinates
	 // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	 static getBarycoord( point, a, b, c, target ) {

		 _v0$1.subVectors( c, a );
		 _v1$3.subVectors( b, a );
		 _v2$2.subVectors( point, a );

		 const dot00 = _v0$1.dot( _v0$1 );
		 const dot01 = _v0$1.dot( _v1$3 );
		 const dot02 = _v0$1.dot( _v2$2 );
		 const dot11 = _v1$3.dot( _v1$3 );
		 const dot12 = _v1$3.dot( _v2$2 );

		 const denom = ( dot00 * dot11 - dot01 * dot01 );

		 // collinear or singular triangle
		 if ( denom === 0 ) {

			 // arbitrary location outside of triangle?
			 // not sure if this is the best idea, maybe should be returning undefined
			 return target.set( - 2, - 1, - 1 );

		 }

		 const invDenom = 1 / denom;
		 const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		 const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		 // barycentric coordinates must always sum to 1
		 return target.set( 1 - u - v, v, u );

	 }

	 static containsPoint( point, a, b, c ) {

		 this.getBarycoord( point, a, b, c, _v3$1 );

		 return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	 }

	 static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		 this.getBarycoord( point, p1, p2, p3, _v3$1 );

		 target.set( 0, 0 );
		 target.addScaledVector( uv1, _v3$1.x );
		 target.addScaledVector( uv2, _v3$1.y );
		 target.addScaledVector( uv3, _v3$1.z );

		 return target;

	 }

	 static isFrontFacing( a, b, c, direction ) {

		 _v0$1.subVectors( c, b );
		 _v1$3.subVectors( a, b );

		 // strictly front facing
		 return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	 }

	 set( a, b, c ) {

		 this.a.copy( a );
		 this.b.copy( b );
		 this.c.copy( c );

		 return this;

	 }

	 setFromPointsAndIndices( points, i0, i1, i2 ) {

		 this.a.copy( points[ i0 ] );
		 this.b.copy( points[ i1 ] );
		 this.c.copy( points[ i2 ] );

		 return this;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( triangle ) {

		 this.a.copy( triangle.a );
		 this.b.copy( triangle.b );
		 this.c.copy( triangle.c );

		 return this;

	 }

	 getArea() {

		 _v0$1.subVectors( this.c, this.b );
		 _v1$3.subVectors( this.a, this.b );

		 return _v0$1.cross( _v1$3 ).length() * 0.5;

	 }

	 getMidpoint( target ) {

		 return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	 }

	 getNormal( target ) {

		 return Triangle.getNormal( this.a, this.b, this.c, target );

	 }

	 getPlane( target ) {

		 return target.setFromCoplanarPoints( this.a, this.b, this.c );

	 }

	 getBarycoord( point, target ) {

		 return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	 }

	 getUV( point, uv1, uv2, uv3, target ) {

		 return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	 }

	 containsPoint( point ) {

		 return Triangle.containsPoint( point, this.a, this.b, this.c );

	 }

	 isFrontFacing( direction ) {

		 return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	 }

	 intersectsBox( box ) {

		 return box.intersectsTriangle( this );

	 }

	 closestPointToPoint( p, target ) {

		 const a = this.a, b = this.b, c = this.c;
		 let v, w;

		 // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		 // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		 // under the accompanying license; see chapter 5.1.5 for detailed explanation.
		 // basically, we're distinguishing which of the voronoi regions of the triangle
		 // the point lies in with the minimum amount of redundant computation.

		 _vab.subVectors( b, a );
		 _vac.subVectors( c, a );
		 _vap.subVectors( p, a );
		 const d1 = _vab.dot( _vap );
		 const d2 = _vac.dot( _vap );
		 if ( d1 <= 0 && d2 <= 0 ) {

			 // vertex region of A; barycentric coords (1, 0, 0)
			 return target.copy( a );

		 }

		 _vbp.subVectors( p, b );
		 const d3 = _vab.dot( _vbp );
		 const d4 = _vac.dot( _vbp );
		 if ( d3 >= 0 && d4 <= d3 ) {

			 // vertex region of B; barycentric coords (0, 1, 0)
			 return target.copy( b );

		 }

		 const vc = d1 * d4 - d3 * d2;
		 if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			 v = d1 / ( d1 - d3 );
			 // edge region of AB; barycentric coords (1-v, v, 0)
			 return target.copy( a ).addScaledVector( _vab, v );

		 }

		 _vcp.subVectors( p, c );
		 const d5 = _vab.dot( _vcp );
		 const d6 = _vac.dot( _vcp );
		 if ( d6 >= 0 && d5 <= d6 ) {

			 // vertex region of C; barycentric coords (0, 0, 1)
			 return target.copy( c );

		 }

		 const vb = d5 * d2 - d1 * d6;
		 if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			 w = d2 / ( d2 - d6 );
			 // edge region of AC; barycentric coords (1-w, 0, w)
			 return target.copy( a ).addScaledVector( _vac, w );

		 }

		 const va = d3 * d6 - d5 * d4;
		 if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			 _vbc.subVectors( c, b );
			 w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			 // edge region of BC; barycentric coords (0, 1-w, w)
			 return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		 }

		 // face region
		 const denom = 1 / ( va + vb + vc );
		 // u = va * denom
		 v = vb * denom;
		 w = vc * denom;

		 return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	 }

	 equals( triangle ) {

		 return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	 }

 }

 let materialId = 0;

 class Material extends EventDispatcher {

	 constructor() {

		 super();

		 Object.defineProperty( this, 'id', { value: materialId ++ } );

		 this.uuid = generateUUID();

		 this.name = '';
		 this.type = 'Material';

		 this.fog = true;

		 this.blending = NormalBlending;
		 this.side = FrontSide;
		 this.vertexColors = false;

		 this.opacity = 1;
		 this.transparent = false;

		 this.blendSrc = SrcAlphaFactor;
		 this.blendDst = OneMinusSrcAlphaFactor;
		 this.blendEquation = AddEquation;
		 this.blendSrcAlpha = null;
		 this.blendDstAlpha = null;
		 this.blendEquationAlpha = null;

		 this.depthFunc = LessEqualDepth;
		 this.depthTest = true;
		 this.depthWrite = true;

		 this.stencilWriteMask = 0xff;
		 this.stencilFunc = AlwaysStencilFunc;
		 this.stencilRef = 0;
		 this.stencilFuncMask = 0xff;
		 this.stencilFail = KeepStencilOp;
		 this.stencilZFail = KeepStencilOp;
		 this.stencilZPass = KeepStencilOp;
		 this.stencilWrite = false;

		 this.clippingPlanes = null;
		 this.clipIntersection = false;
		 this.clipShadows = false;

		 this.shadowSide = null;

		 this.colorWrite = true;

		 this.precision = null; // override the renderer's default precision for this material

		 this.polygonOffset = false;
		 this.polygonOffsetFactor = 0;
		 this.polygonOffsetUnits = 0;

		 this.dithering = false;

		 this.alphaTest = 0;
		 this.alphaToCoverage = false;
		 this.premultipliedAlpha = false;

		 this.visible = true;

		 this.toneMapped = true;

		 this.userData = {};

		 this.version = 0;

	 }

	 onBuild( /* shaderobject, renderer */ ) {}

	 onBeforeCompile( /* shaderobject, renderer */ ) {}

	 customProgramCacheKey() {

		 return this.onBeforeCompile.toString();

	 }

	 setValues( values ) {

		 if ( values === undefined ) return;

		 for ( const key in values ) {

			 const newValue = values[ key ];

			 if ( newValue === undefined ) {

				 console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				 continue;

			 }

			 // for backward compatability if shading is set in the constructor
			 if ( key === 'shading' ) {

				 console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				 this.flatShading = ( newValue === FlatShading ) ? true : false;
				 continue;

			 }

			 const currentValue = this[ key ];

			 if ( currentValue === undefined ) {

				 console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				 continue;

			 }

			 if ( currentValue && currentValue.isColor ) {

				 currentValue.set( newValue );

			 } else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				 currentValue.copy( newValue );

			 } else {

				 this[ key ] = newValue;

			 }

		 }

	 }

	 toJSON( meta ) {

		 const isRoot = ( meta === undefined || typeof meta === 'string' );

		 if ( isRoot ) {

			 meta = {
				 textures: {},
				 images: {}
			 };

		 }

		 const data = {
			 metadata: {
				 version: 4.5,
				 type: 'Material',
				 generator: 'Material.toJSON'
			 }
		 };

		 // standard Material serialization
		 data.uuid = this.uuid;
		 data.type = this.type;

		 if ( this.name !== '' ) data.name = this.name;

		 if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		 if ( this.roughness !== undefined ) data.roughness = this.roughness;
		 if ( this.metalness !== undefined ) data.metalness = this.metalness;

		 if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		 if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		 if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		 if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		 if ( this.shininess !== undefined ) data.shininess = this.shininess;
		 if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		 if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		 if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			 data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		 }

		 if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			 data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		 }

		 if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			 data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			 data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		 }

		 if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		 if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		 if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		 if ( this.lightMap && this.lightMap.isTexture ) {

			 data.lightMap = this.lightMap.toJSON( meta ).uuid;
			 data.lightMapIntensity = this.lightMapIntensity;

		 }

		 if ( this.aoMap && this.aoMap.isTexture ) {

			 data.aoMap = this.aoMap.toJSON( meta ).uuid;
			 data.aoMapIntensity = this.aoMapIntensity;

		 }

		 if ( this.bumpMap && this.bumpMap.isTexture ) {

			 data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			 data.bumpScale = this.bumpScale;

		 }

		 if ( this.normalMap && this.normalMap.isTexture ) {

			 data.normalMap = this.normalMap.toJSON( meta ).uuid;
			 data.normalMapType = this.normalMapType;
			 data.normalScale = this.normalScale.toArray();

		 }

		 if ( this.displacementMap && this.displacementMap.isTexture ) {

			 data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			 data.displacementScale = this.displacementScale;
			 data.displacementBias = this.displacementBias;

		 }

		 if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		 if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		 if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		 if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		 if ( this.envMap && this.envMap.isTexture ) {

			 data.envMap = this.envMap.toJSON( meta ).uuid;

			 if ( this.combine !== undefined ) data.combine = this.combine;

		 }

		 if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		 if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		 if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		 if ( this.gradientMap && this.gradientMap.isTexture ) {

			 data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		 }

		 if ( this.transmission !== undefined ) data.transmission = this.transmission;
		 if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		 if ( this.thickness !== undefined ) data.thickness = this.thickness;
		 if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		 if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
		 if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		 if ( this.size !== undefined ) data.size = this.size;
		 if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		 if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		 if ( this.blending !== NormalBlending ) data.blending = this.blending;
		 if ( this.side !== FrontSide ) data.side = this.side;
		 if ( this.vertexColors ) data.vertexColors = true;

		 if ( this.opacity < 1 ) data.opacity = this.opacity;
		 if ( this.transparent === true ) data.transparent = this.transparent;

		 data.depthFunc = this.depthFunc;
		 data.depthTest = this.depthTest;
		 data.depthWrite = this.depthWrite;
		 data.colorWrite = this.colorWrite;

		 data.stencilWrite = this.stencilWrite;
		 data.stencilWriteMask = this.stencilWriteMask;
		 data.stencilFunc = this.stencilFunc;
		 data.stencilRef = this.stencilRef;
		 data.stencilFuncMask = this.stencilFuncMask;
		 data.stencilFail = this.stencilFail;
		 data.stencilZFail = this.stencilZFail;
		 data.stencilZPass = this.stencilZPass;

		 // rotation (SpriteMaterial)
		 if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		 if ( this.polygonOffset === true ) data.polygonOffset = true;
		 if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		 if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		 if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		 if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		 if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		 if ( this.scale !== undefined ) data.scale = this.scale;

		 if ( this.dithering === true ) data.dithering = true;

		 if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		 if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		 if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		 if ( this.wireframe === true ) data.wireframe = this.wireframe;
		 if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		 if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		 if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		 if ( this.morphTargets === true ) data.morphTargets = true;
		 if ( this.morphNormals === true ) data.morphNormals = true;

		 if ( this.flatShading === true ) data.flatShading = this.flatShading;

		 if ( this.visible === false ) data.visible = false;

		 if ( this.toneMapped === false ) data.toneMapped = false;

		 if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		 // TODO: Copied from Object3D.toJSON

		 function extractFromCache( cache ) {

			 const values = [];

			 for ( const key in cache ) {

				 const data = cache[ key ];
				 delete data.metadata;
				 values.push( data );

			 }

			 return values;

		 }

		 if ( isRoot ) {

			 const textures = extractFromCache( meta.textures );
			 const images = extractFromCache( meta.images );

			 if ( textures.length > 0 ) data.textures = textures;
			 if ( images.length > 0 ) data.images = images;

		 }

		 return data;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.name = source.name;

		 this.fog = source.fog;

		 this.blending = source.blending;
		 this.side = source.side;
		 this.vertexColors = source.vertexColors;

		 this.opacity = source.opacity;
		 this.transparent = source.transparent;

		 this.blendSrc = source.blendSrc;
		 this.blendDst = source.blendDst;
		 this.blendEquation = source.blendEquation;
		 this.blendSrcAlpha = source.blendSrcAlpha;
		 this.blendDstAlpha = source.blendDstAlpha;
		 this.blendEquationAlpha = source.blendEquationAlpha;

		 this.depthFunc = source.depthFunc;
		 this.depthTest = source.depthTest;
		 this.depthWrite = source.depthWrite;

		 this.stencilWriteMask = source.stencilWriteMask;
		 this.stencilFunc = source.stencilFunc;
		 this.stencilRef = source.stencilRef;
		 this.stencilFuncMask = source.stencilFuncMask;
		 this.stencilFail = source.stencilFail;
		 this.stencilZFail = source.stencilZFail;
		 this.stencilZPass = source.stencilZPass;
		 this.stencilWrite = source.stencilWrite;

		 const srcPlanes = source.clippingPlanes;
		 let dstPlanes = null;

		 if ( srcPlanes !== null ) {

			 const n = srcPlanes.length;
			 dstPlanes = new Array( n );

			 for ( let i = 0; i !== n; ++ i ) {

				 dstPlanes[ i ] = srcPlanes[ i ].clone();

			 }

		 }

		 this.clippingPlanes = dstPlanes;
		 this.clipIntersection = source.clipIntersection;
		 this.clipShadows = source.clipShadows;

		 this.shadowSide = source.shadowSide;

		 this.colorWrite = source.colorWrite;

		 this.precision = source.precision;

		 this.polygonOffset = source.polygonOffset;
		 this.polygonOffsetFactor = source.polygonOffsetFactor;
		 this.polygonOffsetUnits = source.polygonOffsetUnits;

		 this.dithering = source.dithering;

		 this.alphaTest = source.alphaTest;
		 this.alphaToCoverage = source.alphaToCoverage;
		 this.premultipliedAlpha = source.premultipliedAlpha;

		 this.visible = source.visible;

		 this.toneMapped = source.toneMapped;

		 this.userData = JSON.parse( JSON.stringify( source.userData ) );

		 return this;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

 }

 Material.prototype.isMaterial = true;

 const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	 'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	 'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	 'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	 'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	 'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	 'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	 'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	 'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	 'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	 'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	 'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	 'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	 'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	 'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	 'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	 'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	 'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	 'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	 'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	 'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	 'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	 'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	 'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

 const _hslA = { h: 0, s: 0, l: 0 };
 const _hslB = { h: 0, s: 0, l: 0 };

 function hue2rgb( p, q, t ) {

	 if ( t < 0 ) t += 1;
	 if ( t > 1 ) t -= 1;
	 if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	 if ( t < 1 / 2 ) return q;
	 if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	 return p;

 }

 function SRGBToLinear( c ) {

	 return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

 }

 function LinearToSRGB( c ) {

	 return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

 }

 class Color$1 {

	 constructor( r, g, b ) {

		 if ( g === undefined && b === undefined ) {

			 // r is THREE.Color, hex or string
			 return this.set( r );

		 }

		 return this.setRGB( r, g, b );

	 }

	 set( value ) {

		 if ( value && value.isColor ) {

			 this.copy( value );

		 } else if ( typeof value === 'number' ) {

			 this.setHex( value );

		 } else if ( typeof value === 'string' ) {

			 this.setStyle( value );

		 }

		 return this;

	 }

	 setScalar( scalar ) {

		 this.r = scalar;
		 this.g = scalar;
		 this.b = scalar;

		 return this;

	 }

	 setHex( hex ) {

		 hex = Math.floor( hex );

		 this.r = ( hex >> 16 & 255 ) / 255;
		 this.g = ( hex >> 8 & 255 ) / 255;
		 this.b = ( hex & 255 ) / 255;

		 return this;

	 }

	 setRGB( r, g, b ) {

		 this.r = r;
		 this.g = g;
		 this.b = b;

		 return this;

	 }

	 setHSL( h, s, l ) {

		 // h,s,l ranges are in 0.0 - 1.0
		 h = euclideanModulo( h, 1 );
		 s = clamp( s, 0, 1 );
		 l = clamp( l, 0, 1 );

		 if ( s === 0 ) {

			 this.r = this.g = this.b = l;

		 } else {

			 const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			 const q = ( 2 * l ) - p;

			 this.r = hue2rgb( q, p, h + 1 / 3 );
			 this.g = hue2rgb( q, p, h );
			 this.b = hue2rgb( q, p, h - 1 / 3 );

		 }

		 return this;

	 }

	 setStyle( style ) {

		 function handleAlpha( string ) {

			 if ( string === undefined ) return;

			 if ( parseFloat( string ) < 1 ) {

				 console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			 }

		 }


		 let m;

		 if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			 // rgb / hsl

			 let color;
			 const name = m[ 1 ];
			 const components = m[ 2 ];

			 switch ( name ) {

				 case 'rgb':
				 case 'rgba':

					 if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						 // rgb(255,0,0) rgba(255,0,0,0.5)
						 this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						 this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						 this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						 handleAlpha( color[ 4 ] );

						 return this;

					 }

					 if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						 // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						 this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						 this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						 this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						 handleAlpha( color[ 4 ] );

						 return this;

					 }

					 break;

				 case 'hsl':
				 case 'hsla':

					 if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						 // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						 const h = parseFloat( color[ 1 ] ) / 360;
						 const s = parseInt( color[ 2 ], 10 ) / 100;
						 const l = parseInt( color[ 3 ], 10 ) / 100;

						 handleAlpha( color[ 4 ] );

						 return this.setHSL( h, s, l );

					 }

					 break;

			 }

		 } else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			 // hex color

			 const hex = m[ 1 ];
			 const size = hex.length;

			 if ( size === 3 ) {

				 // #ff0
				 this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				 this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				 this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				 return this;

			 } else if ( size === 6 ) {

				 // #ff0000
				 this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				 this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				 this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				 return this;

			 }

		 }

		 if ( style && style.length > 0 ) {

			 return this.setColorName( style );

		 }

		 return this;

	 }

	 setColorName( style ) {

		 // color keywords
		 const hex = _colorKeywords[ style.toLowerCase() ];

		 if ( hex !== undefined ) {

			 // red
			 this.setHex( hex );

		 } else {

			 // unknown color
			 console.warn( 'THREE.Color: Unknown color ' + style );

		 }

		 return this;

	 }

	 clone() {

		 return new this.constructor( this.r, this.g, this.b );

	 }

	 copy( color ) {

		 this.r = color.r;
		 this.g = color.g;
		 this.b = color.b;

		 return this;

	 }

	 copyGammaToLinear( color, gammaFactor = 2.0 ) {

		 this.r = Math.pow( color.r, gammaFactor );
		 this.g = Math.pow( color.g, gammaFactor );
		 this.b = Math.pow( color.b, gammaFactor );

		 return this;

	 }

	 copyLinearToGamma( color, gammaFactor = 2.0 ) {

		 const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		 this.r = Math.pow( color.r, safeInverse );
		 this.g = Math.pow( color.g, safeInverse );
		 this.b = Math.pow( color.b, safeInverse );

		 return this;

	 }

	 convertGammaToLinear( gammaFactor ) {

		 this.copyGammaToLinear( this, gammaFactor );

		 return this;

	 }

	 convertLinearToGamma( gammaFactor ) {

		 this.copyLinearToGamma( this, gammaFactor );

		 return this;

	 }

	 copySRGBToLinear( color ) {

		 this.r = SRGBToLinear( color.r );
		 this.g = SRGBToLinear( color.g );
		 this.b = SRGBToLinear( color.b );

		 return this;

	 }

	 copyLinearToSRGB( color ) {

		 this.r = LinearToSRGB( color.r );
		 this.g = LinearToSRGB( color.g );
		 this.b = LinearToSRGB( color.b );

		 return this;

	 }

	 convertSRGBToLinear() {

		 this.copySRGBToLinear( this );

		 return this;

	 }

	 convertLinearToSRGB() {

		 this.copyLinearToSRGB( this );

		 return this;

	 }

	 getHex() {

		 return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	 }

	 getHexString() {

		 return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	 }

	 getHSL( target ) {

		 // h,s,l ranges are in 0.0 - 1.0

		 const r = this.r, g = this.g, b = this.b;

		 const max = Math.max( r, g, b );
		 const min = Math.min( r, g, b );

		 let hue, saturation;
		 const lightness = ( min + max ) / 2.0;

		 if ( min === max ) {

			 hue = 0;
			 saturation = 0;

		 } else {

			 const delta = max - min;

			 saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			 switch ( max ) {

				 case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				 case g: hue = ( b - r ) / delta + 2; break;
				 case b: hue = ( r - g ) / delta + 4; break;

			 }

			 hue /= 6;

		 }

		 target.h = hue;
		 target.s = saturation;
		 target.l = lightness;

		 return target;

	 }

	 getStyle() {

		 return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	 }

	 offsetHSL( h, s, l ) {

		 this.getHSL( _hslA );

		 _hslA.h += h; _hslA.s += s; _hslA.l += l;

		 this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		 return this;

	 }

	 add( color ) {

		 this.r += color.r;
		 this.g += color.g;
		 this.b += color.b;

		 return this;

	 }

	 addColors( color1, color2 ) {

		 this.r = color1.r + color2.r;
		 this.g = color1.g + color2.g;
		 this.b = color1.b + color2.b;

		 return this;

	 }

	 addScalar( s ) {

		 this.r += s;
		 this.g += s;
		 this.b += s;

		 return this;

	 }

	 sub( color ) {

		 this.r = Math.max( 0, this.r - color.r );
		 this.g = Math.max( 0, this.g - color.g );
		 this.b = Math.max( 0, this.b - color.b );

		 return this;

	 }

	 multiply( color ) {

		 this.r *= color.r;
		 this.g *= color.g;
		 this.b *= color.b;

		 return this;

	 }

	 multiplyScalar( s ) {

		 this.r *= s;
		 this.g *= s;
		 this.b *= s;

		 return this;

	 }

	 lerp( color, alpha ) {

		 this.r += ( color.r - this.r ) * alpha;
		 this.g += ( color.g - this.g ) * alpha;
		 this.b += ( color.b - this.b ) * alpha;

		 return this;

	 }

	 lerpColors( color1, color2, alpha ) {

		 this.r = color1.r + ( color2.r - color1.r ) * alpha;
		 this.g = color1.g + ( color2.g - color1.g ) * alpha;
		 this.b = color1.b + ( color2.b - color1.b ) * alpha;

		 return this;

	 }

	 lerpHSL( color, alpha ) {

		 this.getHSL( _hslA );
		 color.getHSL( _hslB );

		 const h = lerp( _hslA.h, _hslB.h, alpha );
		 const s = lerp( _hslA.s, _hslB.s, alpha );
		 const l = lerp( _hslA.l, _hslB.l, alpha );

		 this.setHSL( h, s, l );

		 return this;

	 }

	 equals( c ) {

		 return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	 }

	 fromArray( array, offset = 0 ) {

		 this.r = array[ offset ];
		 this.g = array[ offset + 1 ];
		 this.b = array[ offset + 2 ];

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 array[ offset ] = this.r;
		 array[ offset + 1 ] = this.g;
		 array[ offset + 2 ] = this.b;

		 return array;

	 }

	 fromBufferAttribute( attribute, index ) {

		 this.r = attribute.getX( index );
		 this.g = attribute.getY( index );
		 this.b = attribute.getZ( index );

		 if ( attribute.normalized === true ) {

			 // assuming Uint8Array

			 this.r /= 255;
			 this.g /= 255;
			 this.b /= 255;

		 }

		 return this;

	 }

	 toJSON() {

		 return this.getHex();

	 }

 }

 Color$1.NAMES = _colorKeywords;

 Color$1.prototype.isColor = true;
 Color$1.prototype.r = 1;
 Color$1.prototype.g = 1;
 Color$1.prototype.b = 1;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  specularMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  combine: THREE.Multiply,
	*  reflectivity: <float>,
	*  refractionRatio: <float>,
	*
	*  depthTest: <bool>,
	*  depthWrite: <bool>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>
	* }
	*/

 class MeshBasicMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshBasicMaterial';

		 this.color = new Color$1( 0xffffff ); // emissive

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.specularMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.combine = MultiplyOperation;
		 this.reflectivity = 1;
		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.specularMap = source.specularMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.combine = source.combine;
		 this.reflectivity = source.reflectivity;
		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;

		 return this;

	 }

 }

 MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

 const _vector$9 = /*@__PURE__*/ new Vector3();
 const _vector2$1 = /*@__PURE__*/ new Vector2();

 class BufferAttribute {

	 constructor( array, itemSize, normalized ) {

		 if ( Array.isArray( array ) ) {

			 throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		 }

		 this.name = '';

		 this.array = array;
		 this.itemSize = itemSize;
		 this.count = array !== undefined ? array.length / itemSize : 0;
		 this.normalized = normalized === true;

		 this.usage = StaticDrawUsage;
		 this.updateRange = { offset: 0, count: - 1 };

		 this.version = 0;

	 }

	 onUploadCallback() {}

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

	 setUsage( value ) {

		 this.usage = value;

		 return this;

	 }

	 copy( source ) {

		 this.name = source.name;
		 this.array = new source.array.constructor( source.array );
		 this.itemSize = source.itemSize;
		 this.count = source.count;
		 this.normalized = source.normalized;

		 this.usage = source.usage;

		 return this;

	 }

	 copyAt( index1, attribute, index2 ) {

		 index1 *= this.itemSize;
		 index2 *= attribute.itemSize;

		 for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			 this.array[ index1 + i ] = attribute.array[ index2 + i ];

		 }

		 return this;

	 }

	 copyArray( array ) {

		 this.array.set( array );

		 return this;

	 }

	 copyColorsArray( colors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = colors.length; i < l; i ++ ) {

			 let color = colors[ i ];

			 if ( color === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				 color = new Color$1();

			 }

			 array[ offset ++ ] = color.r;
			 array[ offset ++ ] = color.g;
			 array[ offset ++ ] = color.b;

		 }

		 return this;

	 }

	 copyVector2sArray( vectors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			 let vector = vectors[ i ];

			 if ( vector === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				 vector = new Vector2();

			 }

			 array[ offset ++ ] = vector.x;
			 array[ offset ++ ] = vector.y;

		 }

		 return this;

	 }

	 copyVector3sArray( vectors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			 let vector = vectors[ i ];

			 if ( vector === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				 vector = new Vector3();

			 }

			 array[ offset ++ ] = vector.x;
			 array[ offset ++ ] = vector.y;
			 array[ offset ++ ] = vector.z;

		 }

		 return this;

	 }

	 copyVector4sArray( vectors ) {

		 const array = this.array;
		 let offset = 0;

		 for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			 let vector = vectors[ i ];

			 if ( vector === undefined ) {

				 console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				 vector = new Vector4();

			 }

			 array[ offset ++ ] = vector.x;
			 array[ offset ++ ] = vector.y;
			 array[ offset ++ ] = vector.z;
			 array[ offset ++ ] = vector.w;

		 }

		 return this;

	 }

	 applyMatrix3( m ) {

		 if ( this.itemSize === 2 ) {

			 for ( let i = 0, l = this.count; i < l; i ++ ) {

				 _vector2$1.fromBufferAttribute( this, i );
				 _vector2$1.applyMatrix3( m );

				 this.setXY( i, _vector2$1.x, _vector2$1.y );

			 }

		 } else if ( this.itemSize === 3 ) {

			 for ( let i = 0, l = this.count; i < l; i ++ ) {

				 _vector$9.fromBufferAttribute( this, i );
				 _vector$9.applyMatrix3( m );

				 this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			 }

		 }

		 return this;

	 }

	 applyMatrix4( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$9.x = this.getX( i );
			 _vector$9.y = this.getY( i );
			 _vector$9.z = this.getZ( i );

			 _vector$9.applyMatrix4( m );

			 this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		 }

		 return this;

	 }

	 applyNormalMatrix( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$9.x = this.getX( i );
			 _vector$9.y = this.getY( i );
			 _vector$9.z = this.getZ( i );

			 _vector$9.applyNormalMatrix( m );

			 this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		 }

		 return this;

	 }

	 transformDirection( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$9.x = this.getX( i );
			 _vector$9.y = this.getY( i );
			 _vector$9.z = this.getZ( i );

			 _vector$9.transformDirection( m );

			 this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		 }

		 return this;

	 }

	 set( value, offset = 0 ) {

		 this.array.set( value, offset );

		 return this;

	 }

	 getX( index ) {

		 return this.array[ index * this.itemSize ];

	 }

	 setX( index, x ) {

		 this.array[ index * this.itemSize ] = x;

		 return this;

	 }

	 getY( index ) {

		 return this.array[ index * this.itemSize + 1 ];

	 }

	 setY( index, y ) {

		 this.array[ index * this.itemSize + 1 ] = y;

		 return this;

	 }

	 getZ( index ) {

		 return this.array[ index * this.itemSize + 2 ];

	 }

	 setZ( index, z ) {

		 this.array[ index * this.itemSize + 2 ] = z;

		 return this;

	 }

	 getW( index ) {

		 return this.array[ index * this.itemSize + 3 ];

	 }

	 setW( index, w ) {

		 this.array[ index * this.itemSize + 3 ] = w;

		 return this;

	 }

	 setXY( index, x, y ) {

		 index *= this.itemSize;

		 this.array[ index + 0 ] = x;
		 this.array[ index + 1 ] = y;

		 return this;

	 }

	 setXYZ( index, x, y, z ) {

		 index *= this.itemSize;

		 this.array[ index + 0 ] = x;
		 this.array[ index + 1 ] = y;
		 this.array[ index + 2 ] = z;

		 return this;

	 }

	 setXYZW( index, x, y, z, w ) {

		 index *= this.itemSize;

		 this.array[ index + 0 ] = x;
		 this.array[ index + 1 ] = y;
		 this.array[ index + 2 ] = z;
		 this.array[ index + 3 ] = w;

		 return this;

	 }

	 onUpload( callback ) {

		 this.onUploadCallback = callback;

		 return this;

	 }

	 clone() {

		 return new this.constructor( this.array, this.itemSize ).copy( this );

	 }

	 toJSON() {

		 const data = {
			 itemSize: this.itemSize,
			 type: this.array.constructor.name,
			 array: Array.prototype.slice.call( this.array ),
			 normalized: this.normalized
		 };

		 if ( this.name !== '' ) data.name = this.name;
		 if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		 if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		 return data;

	 }

 }

 BufferAttribute.prototype.isBufferAttribute = true;

 class Uint16BufferAttribute extends BufferAttribute {

	 constructor( array, itemSize, normalized ) {

		 super( new Uint16Array( array ), itemSize, normalized );

	 }

 }

 class Uint32BufferAttribute extends BufferAttribute {

	 constructor( array, itemSize, normalized ) {

		 super( new Uint32Array( array ), itemSize, normalized );

	 }

 }

 class Float16BufferAttribute extends BufferAttribute {

	 constructor( array, itemSize, normalized ) {

		 super( new Uint16Array( array ), itemSize, normalized );

	 }

 }

 Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

 class Float32BufferAttribute extends BufferAttribute {

	 constructor( array, itemSize, normalized ) {

		 super( new Float32Array( array ), itemSize, normalized );

	 }

 }

 function arrayMax( array ) {

	 if ( array.length === 0 ) return - Infinity;

	 let max = array[ 0 ];

	 for ( let i = 1, l = array.length; i < l; ++ i ) {

		 if ( array[ i ] > max ) max = array[ i ];

	 }

	 return max;

 }

 let _id = 0;

 const _m1 = /*@__PURE__*/ new Matrix4();
 const _obj = /*@__PURE__*/ new Object3D();
 const _offset = /*@__PURE__*/ new Vector3();
 const _box$1 = /*@__PURE__*/ new Box3();
 const _boxMorphTargets = /*@__PURE__*/ new Box3();
 const _vector$8 = /*@__PURE__*/ new Vector3();

 class BufferGeometry extends EventDispatcher {

	 constructor() {

		 super();

		 Object.defineProperty( this, 'id', { value: _id ++ } );

		 this.uuid = generateUUID();

		 this.name = '';
		 this.type = 'BufferGeometry';

		 this.index = null;
		 this.attributes = {};

		 this.morphAttributes = {};
		 this.morphTargetsRelative = false;

		 this.groups = [];

		 this.boundingBox = null;
		 this.boundingSphere = null;

		 this.drawRange = { start: 0, count: Infinity };

		 this.userData = {};

	 }

	 getIndex() {

		 return this.index;

	 }

	 setIndex( index ) {

		 if ( Array.isArray( index ) ) {

			 this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		 } else {

			 this.index = index;

		 }

		 return this;

	 }

	 getAttribute( name ) {

		 return this.attributes[ name ];

	 }

	 setAttribute( name, attribute ) {

		 this.attributes[ name ] = attribute;

		 return this;

	 }

	 deleteAttribute( name ) {

		 delete this.attributes[ name ];

		 return this;

	 }

	 hasAttribute( name ) {

		 return this.attributes[ name ] !== undefined;

	 }

	 addGroup( start, count, materialIndex = 0 ) {

		 this.groups.push( {

			 start: start,
			 count: count,
			 materialIndex: materialIndex

		 } );

	 }

	 clearGroups() {

		 this.groups = [];

	 }

	 setDrawRange( start, count ) {

		 this.drawRange.start = start;
		 this.drawRange.count = count;

	 }

	 applyMatrix4( matrix ) {

		 const position = this.attributes.position;

		 if ( position !== undefined ) {

			 position.applyMatrix4( matrix );

			 position.needsUpdate = true;

		 }

		 const normal = this.attributes.normal;

		 if ( normal !== undefined ) {

			 const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			 normal.applyNormalMatrix( normalMatrix );

			 normal.needsUpdate = true;

		 }

		 const tangent = this.attributes.tangent;

		 if ( tangent !== undefined ) {

			 tangent.transformDirection( matrix );

			 tangent.needsUpdate = true;

		 }

		 if ( this.boundingBox !== null ) {

			 this.computeBoundingBox();

		 }

		 if ( this.boundingSphere !== null ) {

			 this.computeBoundingSphere();

		 }

		 return this;

	 }

	 applyQuaternion( q ) {

		 _m1.makeRotationFromQuaternion( q );

		 this.applyMatrix4( _m1 );

		 return this;

	 }

	 rotateX( angle ) {

		 // rotate geometry around world x-axis

		 _m1.makeRotationX( angle );

		 this.applyMatrix4( _m1 );

		 return this;

	 }

	 rotateY( angle ) {

		 // rotate geometry around world y-axis

		 _m1.makeRotationY( angle );

		 this.applyMatrix4( _m1 );

		 return this;

	 }

	 rotateZ( angle ) {

		 // rotate geometry around world z-axis

		 _m1.makeRotationZ( angle );

		 this.applyMatrix4( _m1 );

		 return this;

	 }

	 translate( x, y, z ) {

		 // translate geometry

		 _m1.makeTranslation( x, y, z );

		 this.applyMatrix4( _m1 );

		 return this;

	 }

	 scale( x, y, z ) {

		 // scale geometry

		 _m1.makeScale( x, y, z );

		 this.applyMatrix4( _m1 );

		 return this;

	 }

	 lookAt( vector ) {

		 _obj.lookAt( vector );

		 _obj.updateMatrix();

		 this.applyMatrix4( _obj.matrix );

		 return this;

	 }

	 center() {

		 this.computeBoundingBox();

		 this.boundingBox.getCenter( _offset ).negate();

		 this.translate( _offset.x, _offset.y, _offset.z );

		 return this;

	 }

	 setFromPoints( points ) {

		 const position = [];

		 for ( let i = 0, l = points.length; i < l; i ++ ) {

			 const point = points[ i ];
			 position.push( point.x, point.y, point.z || 0 );

		 }

		 this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		 return this;

	 }

	 computeBoundingBox() {

		 if ( this.boundingBox === null ) {

			 this.boundingBox = new Box3();

		 }

		 const position = this.attributes.position;
		 const morphAttributesPosition = this.morphAttributes.position;

		 if ( position && position.isGLBufferAttribute ) {

			 console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			 this.boundingBox.set(
				 new Vector3( - Infinity, - Infinity, - Infinity ),
				 new Vector3( + Infinity, + Infinity, + Infinity )
			 );

			 return;

		 }

		 if ( position !== undefined ) {

			 this.boundingBox.setFromBufferAttribute( position );

			 // process morph attributes if present

			 if ( morphAttributesPosition ) {

				 for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					 const morphAttribute = morphAttributesPosition[ i ];
					 _box$1.setFromBufferAttribute( morphAttribute );

					 if ( this.morphTargetsRelative ) {

						 _vector$8.addVectors( this.boundingBox.min, _box$1.min );
						 this.boundingBox.expandByPoint( _vector$8 );

						 _vector$8.addVectors( this.boundingBox.max, _box$1.max );
						 this.boundingBox.expandByPoint( _vector$8 );

					 } else {

						 this.boundingBox.expandByPoint( _box$1.min );
						 this.boundingBox.expandByPoint( _box$1.max );

					 }

				 }

			 }

		 } else {

			 this.boundingBox.makeEmpty();

		 }

		 if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			 console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		 }

	 }

	 computeBoundingSphere() {

		 if ( this.boundingSphere === null ) {

			 this.boundingSphere = new Sphere();

		 }

		 const position = this.attributes.position;
		 const morphAttributesPosition = this.morphAttributes.position;

		 if ( position && position.isGLBufferAttribute ) {

			 console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			 this.boundingSphere.set( new Vector3(), Infinity );

			 return;

		 }

		 if ( position ) {

			 // first, find the center of the bounding sphere

			 const center = this.boundingSphere.center;

			 _box$1.setFromBufferAttribute( position );

			 // process morph attributes if present

			 if ( morphAttributesPosition ) {

				 for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					 const morphAttribute = morphAttributesPosition[ i ];
					 _boxMorphTargets.setFromBufferAttribute( morphAttribute );

					 if ( this.morphTargetsRelative ) {

						 _vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
						 _box$1.expandByPoint( _vector$8 );

						 _vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
						 _box$1.expandByPoint( _vector$8 );

					 } else {

						 _box$1.expandByPoint( _boxMorphTargets.min );
						 _box$1.expandByPoint( _boxMorphTargets.max );

					 }

				 }

			 }

			 _box$1.getCenter( center );

			 // second, try to find a boundingSphere with a radius smaller than the
			 // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			 let maxRadiusSq = 0;

			 for ( let i = 0, il = position.count; i < il; i ++ ) {

				 _vector$8.fromBufferAttribute( position, i );

				 maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			 }

			 // process morph attributes if present

			 if ( morphAttributesPosition ) {

				 for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					 const morphAttribute = morphAttributesPosition[ i ];
					 const morphTargetsRelative = this.morphTargetsRelative;

					 for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						 _vector$8.fromBufferAttribute( morphAttribute, j );

						 if ( morphTargetsRelative ) {

							 _offset.fromBufferAttribute( position, j );
							 _vector$8.add( _offset );

						 }

						 maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					 }

				 }

			 }

			 this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			 if ( isNaN( this.boundingSphere.radius ) ) {

				 console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			 }

		 }

	 }

	 computeFaceNormals() {

		 // backwards compatibility

	 }

	 computeTangents() {

		 const index = this.index;
		 const attributes = this.attributes;

		 // based on http://www.terathon.com/code/tangent.html
		 // (per vertex tangents)

		 if ( index === null ||
				attributes.position === undefined ||
				attributes.normal === undefined ||
				attributes.uv === undefined ) {

			 console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			 return;

		 }

		 const indices = index.array;
		 const positions = attributes.position.array;
		 const normals = attributes.normal.array;
		 const uvs = attributes.uv.array;

		 const nVertices = positions.length / 3;

		 if ( attributes.tangent === undefined ) {

			 this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		 }

		 const tangents = attributes.tangent.array;

		 const tan1 = [], tan2 = [];

		 for ( let i = 0; i < nVertices; i ++ ) {

			 tan1[ i ] = new Vector3();
			 tan2[ i ] = new Vector3();

		 }

		 const vA = new Vector3(),
			 vB = new Vector3(),
			 vC = new Vector3(),

			 uvA = new Vector2(),
			 uvB = new Vector2(),
			 uvC = new Vector2(),

			 sdir = new Vector3(),
			 tdir = new Vector3();

		 function handleTriangle( a, b, c ) {

			 vA.fromArray( positions, a * 3 );
			 vB.fromArray( positions, b * 3 );
			 vC.fromArray( positions, c * 3 );

			 uvA.fromArray( uvs, a * 2 );
			 uvB.fromArray( uvs, b * 2 );
			 uvC.fromArray( uvs, c * 2 );

			 vB.sub( vA );
			 vC.sub( vA );

			 uvB.sub( uvA );
			 uvC.sub( uvA );

			 const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			 // silently ignore degenerate uv triangles having coincident or colinear vertices

			 if ( ! isFinite( r ) ) return;

			 sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			 tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			 tan1[ a ].add( sdir );
			 tan1[ b ].add( sdir );
			 tan1[ c ].add( sdir );

			 tan2[ a ].add( tdir );
			 tan2[ b ].add( tdir );
			 tan2[ c ].add( tdir );

		 }

		 let groups = this.groups;

		 if ( groups.length === 0 ) {

			 groups = [ {
				 start: 0,
				 count: indices.length
			 } ];

		 }

		 for ( let i = 0, il = groups.length; i < il; ++ i ) {

			 const group = groups[ i ];

			 const start = group.start;
			 const count = group.count;

			 for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				 handleTriangle(
					 indices[ j + 0 ],
					 indices[ j + 1 ],
					 indices[ j + 2 ]
				 );

			 }

		 }

		 const tmp = new Vector3(), tmp2 = new Vector3();
		 const n = new Vector3(), n2 = new Vector3();

		 function handleVertex( v ) {

			 n.fromArray( normals, v * 3 );
			 n2.copy( n );

			 const t = tan1[ v ];

			 // Gram-Schmidt orthogonalize

			 tmp.copy( t );
			 tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			 // Calculate handedness

			 tmp2.crossVectors( n2, t );
			 const test = tmp2.dot( tan2[ v ] );
			 const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			 tangents[ v * 4 ] = tmp.x;
			 tangents[ v * 4 + 1 ] = tmp.y;
			 tangents[ v * 4 + 2 ] = tmp.z;
			 tangents[ v * 4 + 3 ] = w;

		 }

		 for ( let i = 0, il = groups.length; i < il; ++ i ) {

			 const group = groups[ i ];

			 const start = group.start;
			 const count = group.count;

			 for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				 handleVertex( indices[ j + 0 ] );
				 handleVertex( indices[ j + 1 ] );
				 handleVertex( indices[ j + 2 ] );

			 }

		 }

	 }

	 computeVertexNormals() {

		 const index = this.index;
		 const positionAttribute = this.getAttribute( 'position' );

		 if ( positionAttribute !== undefined ) {

			 let normalAttribute = this.getAttribute( 'normal' );

			 if ( normalAttribute === undefined ) {

				 normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				 this.setAttribute( 'normal', normalAttribute );

			 } else {

				 // reset existing normals to zero

				 for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					 normalAttribute.setXYZ( i, 0, 0, 0 );

				 }

			 }

			 const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			 const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			 const cb = new Vector3(), ab = new Vector3();

			 // indexed elements

			 if ( index ) {

				 for ( let i = 0, il = index.count; i < il; i += 3 ) {

					 const vA = index.getX( i + 0 );
					 const vB = index.getX( i + 1 );
					 const vC = index.getX( i + 2 );

					 pA.fromBufferAttribute( positionAttribute, vA );
					 pB.fromBufferAttribute( positionAttribute, vB );
					 pC.fromBufferAttribute( positionAttribute, vC );

					 cb.subVectors( pC, pB );
					 ab.subVectors( pA, pB );
					 cb.cross( ab );

					 nA.fromBufferAttribute( normalAttribute, vA );
					 nB.fromBufferAttribute( normalAttribute, vB );
					 nC.fromBufferAttribute( normalAttribute, vC );

					 nA.add( cb );
					 nB.add( cb );
					 nC.add( cb );

					 normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					 normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					 normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				 }

			 } else {

				 // non-indexed elements (unconnected triangle soup)

				 for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					 pA.fromBufferAttribute( positionAttribute, i + 0 );
					 pB.fromBufferAttribute( positionAttribute, i + 1 );
					 pC.fromBufferAttribute( positionAttribute, i + 2 );

					 cb.subVectors( pC, pB );
					 ab.subVectors( pA, pB );
					 cb.cross( ab );

					 normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					 normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					 normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				 }

			 }

			 this.normalizeNormals();

			 normalAttribute.needsUpdate = true;

		 }

	 }

	 merge( geometry, offset ) {

		 if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			 console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			 return;

		 }

		 if ( offset === undefined ) {

			 offset = 0;

			 console.warn(
				 'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				 + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			 );

		 }

		 const attributes = this.attributes;

		 for ( const key in attributes ) {

			 if ( geometry.attributes[ key ] === undefined ) continue;

			 const attribute1 = attributes[ key ];
			 const attributeArray1 = attribute1.array;

			 const attribute2 = geometry.attributes[ key ];
			 const attributeArray2 = attribute2.array;

			 const attributeOffset = attribute2.itemSize * offset;
			 const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			 for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				 attributeArray1[ j ] = attributeArray2[ i ];

			 }

		 }

		 return this;

	 }

	 normalizeNormals() {

		 const normals = this.attributes.normal;

		 for ( let i = 0, il = normals.count; i < il; i ++ ) {

			 _vector$8.fromBufferAttribute( normals, i );

			 _vector$8.normalize();

			 normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		 }

	 }

	 toNonIndexed() {

		 function convertBufferAttribute( attribute, indices ) {

			 const array = attribute.array;
			 const itemSize = attribute.itemSize;
			 const normalized = attribute.normalized;

			 const array2 = new array.constructor( indices.length * itemSize );

			 let index = 0, index2 = 0;

			 for ( let i = 0, l = indices.length; i < l; i ++ ) {

				 if ( attribute.isInterleavedBufferAttribute ) {

					 index = indices[ i ] * attribute.data.stride + attribute.offset;

				 } else {

					 index = indices[ i ] * itemSize;

				 }

				 for ( let j = 0; j < itemSize; j ++ ) {

					 array2[ index2 ++ ] = array[ index ++ ];

				 }

			 }

			 return new BufferAttribute( array2, itemSize, normalized );

		 }

		 //

		 if ( this.index === null ) {

			 console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			 return this;

		 }

		 const geometry2 = new BufferGeometry();

		 const indices = this.index.array;
		 const attributes = this.attributes;

		 // attributes

		 for ( const name in attributes ) {

			 const attribute = attributes[ name ];

			 const newAttribute = convertBufferAttribute( attribute, indices );

			 geometry2.setAttribute( name, newAttribute );

		 }

		 // morph attributes

		 const morphAttributes = this.morphAttributes;

		 for ( const name in morphAttributes ) {

			 const morphArray = [];
			 const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			 for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				 const attribute = morphAttribute[ i ];

				 const newAttribute = convertBufferAttribute( attribute, indices );

				 morphArray.push( newAttribute );

			 }

			 geometry2.morphAttributes[ name ] = morphArray;

		 }

		 geometry2.morphTargetsRelative = this.morphTargetsRelative;

		 // groups

		 const groups = this.groups;

		 for ( let i = 0, l = groups.length; i < l; i ++ ) {

			 const group = groups[ i ];
			 geometry2.addGroup( group.start, group.count, group.materialIndex );

		 }

		 return geometry2;

	 }

	 toJSON() {

		 const data = {
			 metadata: {
				 version: 4.5,
				 type: 'BufferGeometry',
				 generator: 'BufferGeometry.toJSON'
			 }
		 };

		 // standard BufferGeometry serialization

		 data.uuid = this.uuid;
		 data.type = this.type;
		 if ( this.name !== '' ) data.name = this.name;
		 if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		 if ( this.parameters !== undefined ) {

			 const parameters = this.parameters;

			 for ( const key in parameters ) {

				 if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			 }

			 return data;

		 }

		 // for simplicity the code assumes attributes are not shared across geometries, see #15811

		 data.data = { attributes: {} };

		 const index = this.index;

		 if ( index !== null ) {

			 data.data.index = {
				 type: index.array.constructor.name,
				 array: Array.prototype.slice.call( index.array )
			 };

		 }

		 const attributes = this.attributes;

		 for ( const key in attributes ) {

			 const attribute = attributes[ key ];

			 data.data.attributes[ key ] = attribute.toJSON( data.data );

		 }

		 const morphAttributes = {};
		 let hasMorphAttributes = false;

		 for ( const key in this.morphAttributes ) {

			 const attributeArray = this.morphAttributes[ key ];

			 const array = [];

			 for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				 const attribute = attributeArray[ i ];

				 array.push( attribute.toJSON( data.data ) );

			 }

			 if ( array.length > 0 ) {

				 morphAttributes[ key ] = array;

				 hasMorphAttributes = true;

			 }

		 }

		 if ( hasMorphAttributes ) {

			 data.data.morphAttributes = morphAttributes;
			 data.data.morphTargetsRelative = this.morphTargetsRelative;

		 }

		 const groups = this.groups;

		 if ( groups.length > 0 ) {

			 data.data.groups = JSON.parse( JSON.stringify( groups ) );

		 }

		 const boundingSphere = this.boundingSphere;

		 if ( boundingSphere !== null ) {

			 data.data.boundingSphere = {
				 center: boundingSphere.center.toArray(),
				 radius: boundingSphere.radius
			 };

		 }

		 return data;

	 }

	 clone() {

		 /*
			// Handle primitives

			const parameters = this.parameters;

			if ( parameters !== undefined ) {

			const values = [];

			for ( const key in parameters ) {

			values.push( parameters[ key ] );

			}

			const geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

			}

			return new this.constructor().copy( this );
			*/

		 return new BufferGeometry().copy( this );

	 }

	 copy( source ) {

		 // reset

		 this.index = null;
		 this.attributes = {};
		 this.morphAttributes = {};
		 this.groups = [];
		 this.boundingBox = null;
		 this.boundingSphere = null;

		 // used for storing cloned, shared data

		 const data = {};

		 // name

		 this.name = source.name;

		 // index

		 const index = source.index;

		 if ( index !== null ) {

			 this.setIndex( index.clone( data ) );

		 }

		 // attributes

		 const attributes = source.attributes;

		 for ( const name in attributes ) {

			 const attribute = attributes[ name ];
			 this.setAttribute( name, attribute.clone( data ) );

		 }

		 // morph attributes

		 const morphAttributes = source.morphAttributes;

		 for ( const name in morphAttributes ) {

			 const array = [];
			 const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			 for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				 array.push( morphAttribute[ i ].clone( data ) );

			 }

			 this.morphAttributes[ name ] = array;

		 }

		 this.morphTargetsRelative = source.morphTargetsRelative;

		 // groups

		 const groups = source.groups;

		 for ( let i = 0, l = groups.length; i < l; i ++ ) {

			 const group = groups[ i ];
			 this.addGroup( group.start, group.count, group.materialIndex );

		 }

		 // bounding box

		 const boundingBox = source.boundingBox;

		 if ( boundingBox !== null ) {

			 this.boundingBox = boundingBox.clone();

		 }

		 // bounding sphere

		 const boundingSphere = source.boundingSphere;

		 if ( boundingSphere !== null ) {

			 this.boundingSphere = boundingSphere.clone();

		 }

		 // draw range

		 this.drawRange.start = source.drawRange.start;
		 this.drawRange.count = source.drawRange.count;

		 // user data

		 this.userData = source.userData;

		 return this;

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

 }

 BufferGeometry.prototype.isBufferGeometry = true;

 const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
 const _ray$2 = /*@__PURE__*/ new Ray();
 const _sphere$3 = /*@__PURE__*/ new Sphere();

 const _vA$1 = /*@__PURE__*/ new Vector3();
 const _vB$1 = /*@__PURE__*/ new Vector3();
 const _vC$1 = /*@__PURE__*/ new Vector3();

 const _tempA = /*@__PURE__*/ new Vector3();
 const _tempB = /*@__PURE__*/ new Vector3();
 const _tempC = /*@__PURE__*/ new Vector3();

 const _morphA = /*@__PURE__*/ new Vector3();
 const _morphB = /*@__PURE__*/ new Vector3();
 const _morphC = /*@__PURE__*/ new Vector3();

 const _uvA$1 = /*@__PURE__*/ new Vector2();
 const _uvB$1 = /*@__PURE__*/ new Vector2();
 const _uvC$1 = /*@__PURE__*/ new Vector2();

 const _intersectionPoint = /*@__PURE__*/ new Vector3();
 const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

 class Mesh extends Object3D {

	 constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		 super();

		 this.type = 'Mesh';

		 this.geometry = geometry;
		 this.material = material;

		 this.updateMorphTargets();

	 }

	 copy( source ) {

		 super.copy( source );

		 if ( source.morphTargetInfluences !== undefined ) {

			 this.morphTargetInfluences = source.morphTargetInfluences.slice();

		 }

		 if ( source.morphTargetDictionary !== undefined ) {

			 this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		 }

		 this.material = source.material;
		 this.geometry = source.geometry;

		 return this;

	 }

	 updateMorphTargets() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 const morphAttributes = geometry.morphAttributes;
			 const keys = Object.keys( morphAttributes );

			 if ( keys.length > 0 ) {

				 const morphAttribute = morphAttributes[ keys[ 0 ] ];

				 if ( morphAttribute !== undefined ) {

					 this.morphTargetInfluences = [];
					 this.morphTargetDictionary = {};

					 for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						 const name = morphAttribute[ m ].name || String( m );

						 this.morphTargetInfluences.push( 0 );
						 this.morphTargetDictionary[ name ] = m;

					 }

				 }

			 }

		 } else {

			 const morphTargets = geometry.morphTargets;

			 if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				 console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			 }

		 }

	 }

	 raycast( raycaster, intersects ) {

		 const geometry = this.geometry;
		 const material = this.material;
		 const matrixWorld = this.matrixWorld;

		 if ( material === undefined ) return;

		 // Checking boundingSphere distance to ray

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere$3.copy( geometry.boundingSphere );
		 _sphere$3.applyMatrix4( matrixWorld );

		 if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		 //

		 _inverseMatrix$2.copy( matrixWorld ).invert();
		 _ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		 // Check boundingBox before continuing

		 if ( geometry.boundingBox !== null ) {

			 if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		 }

		 let intersection;

		 if ( geometry.isBufferGeometry ) {

			 const index = geometry.index;
			 const position = geometry.attributes.position;
			 const morphPosition = geometry.morphAttributes.position;
			 const morphTargetsRelative = geometry.morphTargetsRelative;
			 const uv = geometry.attributes.uv;
			 const uv2 = geometry.attributes.uv2;
			 const groups = geometry.groups;
			 const drawRange = geometry.drawRange;

			 if ( index !== null ) {

				 // indexed buffer geometry

				 if ( Array.isArray( material ) ) {

					 for ( let i = 0, il = groups.length; i < il; i ++ ) {

						 const group = groups[ i ];
						 const groupMaterial = material[ group.materialIndex ];

						 const start = Math.max( group.start, drawRange.start );
						 const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						 for ( let j = start, jl = end; j < jl; j += 3 ) {

							 const a = index.getX( j );
							 const b = index.getX( j + 1 );
							 const c = index.getX( j + 2 );

							 intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							 if ( intersection ) {

								 intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								 intersection.face.materialIndex = group.materialIndex;
								 intersects.push( intersection );

							 }

						 }

					 }

				 } else {

					 const start = Math.max( 0, drawRange.start );
					 const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					 for ( let i = start, il = end; i < il; i += 3 ) {

						 const a = index.getX( i );
						 const b = index.getX( i + 1 );
						 const c = index.getX( i + 2 );

						 intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						 if ( intersection ) {

							 intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							 intersects.push( intersection );

						 }

					 }

				 }

			 } else if ( position !== undefined ) {

				 // non-indexed buffer geometry

				 if ( Array.isArray( material ) ) {

					 for ( let i = 0, il = groups.length; i < il; i ++ ) {

						 const group = groups[ i ];
						 const groupMaterial = material[ group.materialIndex ];

						 const start = Math.max( group.start, drawRange.start );
						 const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						 for ( let j = start, jl = end; j < jl; j += 3 ) {

							 const a = j;
							 const b = j + 1;
							 const c = j + 2;

							 intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							 if ( intersection ) {

								 intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								 intersection.face.materialIndex = group.materialIndex;
								 intersects.push( intersection );

							 }

						 }

					 }

				 } else {

					 const start = Math.max( 0, drawRange.start );
					 const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					 for ( let i = start, il = end; i < il; i += 3 ) {

						 const a = i;
						 const b = i + 1;
						 const c = i + 2;

						 intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						 if ( intersection ) {

							 intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							 intersects.push( intersection );

						 }

					 }

				 }

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

	 }

 }

 Mesh.prototype.isMesh = true;

 function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	 let intersect;

	 if ( material.side === BackSide ) {

		 intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	 } else {

		 intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	 }

	 if ( intersect === null ) return null;

	 _intersectionPointWorld.copy( point );
	 _intersectionPointWorld.applyMatrix4( object.matrixWorld );

	 const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	 if ( distance < raycaster.near || distance > raycaster.far ) return null;

	 return {
		 distance: distance,
		 point: _intersectionPointWorld.clone(),
		 object: object
	 };

 }

 function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	 _vA$1.fromBufferAttribute( position, a );
	 _vB$1.fromBufferAttribute( position, b );
	 _vC$1.fromBufferAttribute( position, c );

	 const morphInfluences = object.morphTargetInfluences;

	 if ( material.morphTargets && morphPosition && morphInfluences ) {

		 _morphA.set( 0, 0, 0 );
		 _morphB.set( 0, 0, 0 );
		 _morphC.set( 0, 0, 0 );

		 for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			 const influence = morphInfluences[ i ];
			 const morphAttribute = morphPosition[ i ];

			 if ( influence === 0 ) continue;

			 _tempA.fromBufferAttribute( morphAttribute, a );
			 _tempB.fromBufferAttribute( morphAttribute, b );
			 _tempC.fromBufferAttribute( morphAttribute, c );

			 if ( morphTargetsRelative ) {

				 _morphA.addScaledVector( _tempA, influence );
				 _morphB.addScaledVector( _tempB, influence );
				 _morphC.addScaledVector( _tempC, influence );

			 } else {

				 _morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
				 _morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
				 _morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

			 }

		 }

		 _vA$1.add( _morphA );
		 _vB$1.add( _morphB );
		 _vC$1.add( _morphC );

	 }

	 if ( object.isSkinnedMesh ) {

		 object.boneTransform( a, _vA$1 );
		 object.boneTransform( b, _vB$1 );
		 object.boneTransform( c, _vC$1 );

	 }

	 const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	 if ( intersection ) {

		 if ( uv ) {

			 _uvA$1.fromBufferAttribute( uv, a );
			 _uvB$1.fromBufferAttribute( uv, b );
			 _uvC$1.fromBufferAttribute( uv, c );

			 intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		 }

		 if ( uv2 ) {

			 _uvA$1.fromBufferAttribute( uv2, a );
			 _uvB$1.fromBufferAttribute( uv2, b );
			 _uvC$1.fromBufferAttribute( uv2, c );

			 intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		 }

		 const face = {
			 a: a,
			 b: b,
			 c: c,
			 normal: new Vector3(),
			 materialIndex: 0
		 };

		 Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		 intersection.face = face;

	 }

	 return intersection;

 }

 class BoxGeometry extends BufferGeometry {

	 constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		 super();

		 this.type = 'BoxGeometry';

		 this.parameters = {
			 width: width,
			 height: height,
			 depth: depth,
			 widthSegments: widthSegments,
			 heightSegments: heightSegments,
			 depthSegments: depthSegments
		 };

		 const scope = this;

		 // segments

		 widthSegments = Math.floor( widthSegments );
		 heightSegments = Math.floor( heightSegments );
		 depthSegments = Math.floor( depthSegments );

		 // buffers

		 const indices = [];
		 const vertices = [];
		 const normals = [];
		 const uvs = [];

		 // helper variables

		 let numberOfVertices = 0;
		 let groupStart = 0;

		 // build each side of the box geometry

		 buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		 buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		 buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		 buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		 buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		 buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		 // build geometry

		 this.setIndex( indices );
		 this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		 this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		 function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			 const segmentWidth = width / gridX;
			 const segmentHeight = height / gridY;

			 const widthHalf = width / 2;
			 const heightHalf = height / 2;
			 const depthHalf = depth / 2;

			 const gridX1 = gridX + 1;
			 const gridY1 = gridY + 1;

			 let vertexCounter = 0;
			 let groupCount = 0;

			 const vector = new Vector3();

			 // generate vertices, normals and uvs

			 for ( let iy = 0; iy < gridY1; iy ++ ) {

				 const y = iy * segmentHeight - heightHalf;

				 for ( let ix = 0; ix < gridX1; ix ++ ) {

					 const x = ix * segmentWidth - widthHalf;

					 // set values to correct vector component

					 vector[ u ] = x * udir;
					 vector[ v ] = y * vdir;
					 vector[ w ] = depthHalf;

					 // now apply vector to vertex buffer

					 vertices.push( vector.x, vector.y, vector.z );

					 // set values to correct vector component

					 vector[ u ] = 0;
					 vector[ v ] = 0;
					 vector[ w ] = depth > 0 ? 1 : - 1;

					 // now apply vector to normal buffer

					 normals.push( vector.x, vector.y, vector.z );

					 // uvs

					 uvs.push( ix / gridX );
					 uvs.push( 1 - ( iy / gridY ) );

					 // counters

					 vertexCounter += 1;

				 }

			 }

			 // indices

			 // 1. you need three indices to draw a single face
			 // 2. a single segment consists of two faces
			 // 3. so we need to generate six (2*3) indices per segment

			 for ( let iy = 0; iy < gridY; iy ++ ) {

				 for ( let ix = 0; ix < gridX; ix ++ ) {

					 const a = numberOfVertices + ix + gridX1 * iy;
					 const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					 const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					 const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					 // faces

					 indices.push( a, b, d );
					 indices.push( b, c, d );

					 // increase counter

					 groupCount += 6;

				 }

			 }

			 // add a group to the geometry. this will ensure multi material support

			 scope.addGroup( groupStart, groupCount, materialIndex );

			 // calculate new start value for groups

			 groupStart += groupCount;

			 // update total number of vertices

			 numberOfVertices += vertexCounter;

		 }

	 }

	 static fromJSON( data ) {

		 return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	 }

 }

 /**
	* Uniform Utilities
	*/

 function cloneUniforms( src ) {

	 const dst = {};

	 for ( const u in src ) {

		 dst[ u ] = {};

		 for ( const p in src[ u ] ) {

			 const property = src[ u ][ p ];

			 if ( property && ( property.isColor ||
				 property.isMatrix3 || property.isMatrix4 ||
				 property.isVector2 || property.isVector3 || property.isVector4 ||
				 property.isTexture || property.isQuaternion ) ) {

				 dst[ u ][ p ] = property.clone();

			 } else if ( Array.isArray( property ) ) {

				 dst[ u ][ p ] = property.slice();

			 } else {

				 dst[ u ][ p ] = property;

			 }

		 }

	 }

	 return dst;

 }

 function mergeUniforms( uniforms ) {

	 const merged = {};

	 for ( let u = 0; u < uniforms.length; u ++ ) {

		 const tmp = cloneUniforms( uniforms[ u ] );

		 for ( const p in tmp ) {

			 merged[ p ] = tmp[ p ];

		 }

	 }

	 return merged;

 }

 // Legacy

 const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

 var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

 var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

 /**
	* parameters = {
	*  defines: { "label" : "value" },
	*  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	*
	*  fragmentShader: <string>,
	*  vertexShader: <string>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  lights: <bool>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	* }
	*/

 class ShaderMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'ShaderMaterial';

		 this.defines = {};
		 this.uniforms = {};

		 this.vertexShader = default_vertex;
		 this.fragmentShader = default_fragment;

		 this.linewidth = 1;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;

		 this.fog = false; // set to use scene fog
		 this.lights = false; // set to use scene lights
		 this.clipping = false; // set to use user-defined clipping planes

		 this.morphTargets = false; // set to use morph targets
		 this.morphNormals = false; // set to use morph normals

		 this.extensions = {
			 derivatives: false, // set to use derivatives
			 fragDepth: false, // set to use fragment depth values
			 drawBuffers: false, // set to use draw buffers
			 shaderTextureLOD: false // set to use shader texture LOD
		 };

		 // When rendered geometry doesn't include these attributes but the material does,
		 // use these default values in WebGL. This avoids errors when buffer data is missing.
		 this.defaultAttributeValues = {
			 'color': [ 1, 1, 1 ],
			 'uv': [ 0, 0 ],
			 'uv2': [ 0, 0 ]
		 };

		 this.index0AttributeName = undefined;
		 this.uniformsNeedUpdate = false;

		 this.glslVersion = null;

		 if ( parameters !== undefined ) {

			 if ( parameters.attributes !== undefined ) {

				 console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			 }

			 this.setValues( parameters );

		 }

	 }

	 copy( source ) {

		 super.copy( source );

		 this.fragmentShader = source.fragmentShader;
		 this.vertexShader = source.vertexShader;

		 this.uniforms = cloneUniforms( source.uniforms );

		 this.defines = Object.assign( {}, source.defines );

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;

		 this.lights = source.lights;
		 this.clipping = source.clipping;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.extensions = Object.assign( {}, source.extensions );

		 this.glslVersion = source.glslVersion;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.glslVersion = this.glslVersion;
		 data.uniforms = {};

		 for ( const name in this.uniforms ) {

			 const uniform = this.uniforms[ name ];
			 const value = uniform.value;

			 if ( value && value.isTexture ) {

				 data.uniforms[ name ] = {
					 type: 't',
					 value: value.toJSON( meta ).uuid
				 };

			 } else if ( value && value.isColor ) {

				 data.uniforms[ name ] = {
					 type: 'c',
					 value: value.getHex()
				 };

			 } else if ( value && value.isVector2 ) {

				 data.uniforms[ name ] = {
					 type: 'v2',
					 value: value.toArray()
				 };

			 } else if ( value && value.isVector3 ) {

				 data.uniforms[ name ] = {
					 type: 'v3',
					 value: value.toArray()
				 };

			 } else if ( value && value.isVector4 ) {

				 data.uniforms[ name ] = {
					 type: 'v4',
					 value: value.toArray()
				 };

			 } else if ( value && value.isMatrix3 ) {

				 data.uniforms[ name ] = {
					 type: 'm3',
					 value: value.toArray()
				 };

			 } else if ( value && value.isMatrix4 ) {

				 data.uniforms[ name ] = {
					 type: 'm4',
					 value: value.toArray()
				 };

			 } else {

				 data.uniforms[ name ] = {
					 value: value
				 };

				 // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			 }

		 }

		 if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		 data.vertexShader = this.vertexShader;
		 data.fragmentShader = this.fragmentShader;

		 const extensions = {};

		 for ( const key in this.extensions ) {

			 if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		 }

		 if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		 return data;

	 }

 }

 ShaderMaterial.prototype.isShaderMaterial = true;

 class Camera extends Object3D {

	 constructor() {

		 super();

		 this.type = 'Camera';

		 this.matrixWorldInverse = new Matrix4();

		 this.projectionMatrix = new Matrix4();
		 this.projectionMatrixInverse = new Matrix4();

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 this.matrixWorldInverse.copy( source.matrixWorldInverse );

		 this.projectionMatrix.copy( source.projectionMatrix );
		 this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		 return this;

	 }

	 getWorldDirection( target ) {

		 this.updateWorldMatrix( true, false );

		 const e = this.matrixWorld.elements;

		 return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	 }

	 updateMatrixWorld( force ) {

		 super.updateMatrixWorld( force );

		 this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	 }

	 updateWorldMatrix( updateParents, updateChildren ) {

		 super.updateWorldMatrix( updateParents, updateChildren );

		 this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 Camera.prototype.isCamera = true;

 class PerspectiveCamera extends Camera {

	 constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		 super();

		 this.type = 'PerspectiveCamera';

		 this.fov = fov;
		 this.zoom = 1;

		 this.near = near;
		 this.far = far;
		 this.focus = 10;

		 this.aspect = aspect;
		 this.view = null;

		 this.filmGauge = 35;	// width of the film (default in millimeters)
		 this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		 this.updateProjectionMatrix();

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 this.fov = source.fov;
		 this.zoom = source.zoom;

		 this.near = source.near;
		 this.far = source.far;
		 this.focus = source.focus;

		 this.aspect = source.aspect;
		 this.view = source.view === null ? null : Object.assign( {}, source.view );

		 this.filmGauge = source.filmGauge;
		 this.filmOffset = source.filmOffset;

		 return this;

	 }

	 /**
		* Sets the FOV by focal length in respect to the current .filmGauge.
		*
		* The default film gauge is 35, so that the focal length can be specified for
		* a 35mm (full frame) camera.
		*
		* Values for focal length and film gauge must have the same unit.
		*/
	 setFocalLength( focalLength ) {

		 /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		 const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		 this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		 this.updateProjectionMatrix();

	 }

	 /**
		* Calculates the focal length from the current .fov and .filmGauge.
		*/
	 getFocalLength() {

		 const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		 return 0.5 * this.getFilmHeight() / vExtentSlope;

	 }

	 getEffectiveFOV() {

		 return RAD2DEG * 2 * Math.atan(
			 Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	 }

	 getFilmWidth() {

		 // film not completely covered in portrait format (aspect < 1)
		 return this.filmGauge * Math.min( this.aspect, 1 );

	 }

	 getFilmHeight() {

		 // film not completely covered in landscape format (aspect > 1)
		 return this.filmGauge / Math.max( this.aspect, 1 );

	 }

	 /**
		* Sets an offset in a larger frustum. This is useful for multi-window or
		* multi-monitor/multi-machine setups.
		*
		* For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		* the monitors are in grid like this
		*
		*   +---+---+---+
		*   | A | B | C |
		*   +---+---+---+
		*   | D | E | F |
		*   +---+---+---+
		*
		* then for each monitor you would call it like this
		*
		*   const w = 1920;
		*   const h = 1080;
		*   const fullWidth = w * 3;
		*   const fullHeight = h * 2;
		*
		*   --A--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		*   --B--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		*   --C--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		*   --D--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		*   --E--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		*   --F--
		*   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		*
		*   Note there is no reason monitors have to be the same size or in a grid.
		*/
	 setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		 this.aspect = fullWidth / fullHeight;

		 if ( this.view === null ) {

			 this.view = {
				 enabled: true,
				 fullWidth: 1,
				 fullHeight: 1,
				 offsetX: 0,
				 offsetY: 0,
				 width: 1,
				 height: 1
			 };

		 }

		 this.view.enabled = true;
		 this.view.fullWidth = fullWidth;
		 this.view.fullHeight = fullHeight;
		 this.view.offsetX = x;
		 this.view.offsetY = y;
		 this.view.width = width;
		 this.view.height = height;

		 this.updateProjectionMatrix();

	 }

	 clearViewOffset() {

		 if ( this.view !== null ) {

			 this.view.enabled = false;

		 }

		 this.updateProjectionMatrix();

	 }

	 updateProjectionMatrix() {

		 const near = this.near;
		 let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		 let height = 2 * top;
		 let width = this.aspect * height;
		 let left = - 0.5 * width;
		 const view = this.view;

		 if ( this.view !== null && this.view.enabled ) {

			 const fullWidth = view.fullWidth,
				 fullHeight = view.fullHeight;

			 left += view.offsetX * width / fullWidth;
			 top -= view.offsetY * height / fullHeight;
			 width *= view.width / fullWidth;
			 height *= view.height / fullHeight;

		 }

		 const skew = this.filmOffset;
		 if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		 this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		 this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.fov = this.fov;
		 data.object.zoom = this.zoom;

		 data.object.near = this.near;
		 data.object.far = this.far;
		 data.object.focus = this.focus;

		 data.object.aspect = this.aspect;

		 if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		 data.object.filmGauge = this.filmGauge;
		 data.object.filmOffset = this.filmOffset;

		 return data;

	 }

 }

 PerspectiveCamera.prototype.isPerspectiveCamera = true;

 const fov = 90, aspect = 1;

 class CubeCamera extends Object3D {

	 constructor( near, far, renderTarget ) {

		 super();

		 this.type = 'CubeCamera';

		 if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			 console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			 return;

		 }

		 this.renderTarget = renderTarget;

		 const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		 cameraPX.layers = this.layers;
		 cameraPX.up.set( 0, - 1, 0 );
		 cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		 this.add( cameraPX );

		 const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		 cameraNX.layers = this.layers;
		 cameraNX.up.set( 0, - 1, 0 );
		 cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		 this.add( cameraNX );

		 const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		 cameraPY.layers = this.layers;
		 cameraPY.up.set( 0, 0, 1 );
		 cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		 this.add( cameraPY );

		 const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		 cameraNY.layers = this.layers;
		 cameraNY.up.set( 0, 0, - 1 );
		 cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		 this.add( cameraNY );

		 const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		 cameraPZ.layers = this.layers;
		 cameraPZ.up.set( 0, - 1, 0 );
		 cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		 this.add( cameraPZ );

		 const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		 cameraNZ.layers = this.layers;
		 cameraNZ.up.set( 0, - 1, 0 );
		 cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		 this.add( cameraNZ );

	 }

	 update( renderer, scene ) {

		 if ( this.parent === null ) this.updateMatrixWorld();

		 const renderTarget = this.renderTarget;

		 const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		 const currentXrEnabled = renderer.xr.enabled;
		 const currentRenderTarget = renderer.getRenderTarget();

		 renderer.xr.enabled = false;

		 const generateMipmaps = renderTarget.texture.generateMipmaps;

		 renderTarget.texture.generateMipmaps = false;

		 renderer.setRenderTarget( renderTarget, 0 );
		 renderer.render( scene, cameraPX );

		 renderer.setRenderTarget( renderTarget, 1 );
		 renderer.render( scene, cameraNX );

		 renderer.setRenderTarget( renderTarget, 2 );
		 renderer.render( scene, cameraPY );

		 renderer.setRenderTarget( renderTarget, 3 );
		 renderer.render( scene, cameraNY );

		 renderer.setRenderTarget( renderTarget, 4 );
		 renderer.render( scene, cameraPZ );

		 renderTarget.texture.generateMipmaps = generateMipmaps;

		 renderer.setRenderTarget( renderTarget, 5 );
		 renderer.render( scene, cameraNZ );

		 renderer.setRenderTarget( currentRenderTarget );

		 renderer.xr.enabled = currentXrEnabled;

	 }

 }

 class CubeTexture extends Texture {

	 constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		 images = images !== undefined ? images : [];
		 mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		 format = format !== undefined ? format : RGBFormat;

		 super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		 // Why CubeTexture._needsFlipEnvMap is necessary:
		 //
		 // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		 // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		 // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		 // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		 // and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
		 // when using WebGLCubeRenderTarget.texture as a cube texture.

		 this._needsFlipEnvMap = true;

		 this.flipY = false;

	 }

	 get images() {

		 return this.image;

	 }

	 set images( value ) {

		 this.image = value;

	 }

 }

 CubeTexture.prototype.isCubeTexture = true;

 class WebGLCubeRenderTarget extends WebGLRenderTarget {

	 constructor( size, options, dummy ) {

		 if ( Number.isInteger( options ) ) {

			 console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

			 options = dummy;

		 }

		 super( size, size, options );

		 options = options || {};

		 this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		 this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		 this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		 this.texture._needsFlipEnvMap = false;

	 }

	 fromEquirectangularTexture( renderer, texture ) {

		 this.texture.type = texture.type;
		 this.texture.format = RGBAFormat; // see #18859
		 this.texture.encoding = texture.encoding;

		 this.texture.generateMipmaps = texture.generateMipmaps;
		 this.texture.minFilter = texture.minFilter;
		 this.texture.magFilter = texture.magFilter;

		 const shader = {

			 uniforms: {
				 tEquirect: { value: null },
			 },

			 vertexShader: /* glsl */`

				 varying vec3 vWorldDirection;

				 vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					 return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				 }

				 void main() {

					 vWorldDirection = transformDirection( position, modelMatrix );

					 #include <begin_vertex>
					 #include <project_vertex>

				 }
			 `,

			 fragmentShader: /* glsl */`

				 uniform sampler2D tEquirect;

				 varying vec3 vWorldDirection;

				 #include <common>

				 void main() {

					 vec3 direction = normalize( vWorldDirection );

					 vec2 sampleUV = equirectUv( direction );

					 gl_FragColor = texture2D( tEquirect, sampleUV );

				 }
			 `
		 };

		 const geometry = new BoxGeometry( 5, 5, 5 );

		 const material = new ShaderMaterial( {

			 name: 'CubemapFromEquirect',

			 uniforms: cloneUniforms( shader.uniforms ),
			 vertexShader: shader.vertexShader,
			 fragmentShader: shader.fragmentShader,
			 side: BackSide,
			 blending: NoBlending

		 } );

		 material.uniforms.tEquirect.value = texture;

		 const mesh = new Mesh( geometry, material );

		 const currentMinFilter = texture.minFilter;

		 // Avoid blurred poles
		 if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		 const camera = new CubeCamera( 1, 10, this );
		 camera.update( renderer, mesh );

		 texture.minFilter = currentMinFilter;

		 mesh.geometry.dispose();
		 mesh.material.dispose();

		 return this;

	 }

	 clear( renderer, color, depth, stencil ) {

		 const currentRenderTarget = renderer.getRenderTarget();

		 for ( let i = 0; i < 6; i ++ ) {

			 renderer.setRenderTarget( this, i );

			 renderer.clear( color, depth, stencil );

		 }

		 renderer.setRenderTarget( currentRenderTarget );

	 }

 }

 WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

 const _vector1 = /*@__PURE__*/ new Vector3();
 const _vector2 = /*@__PURE__*/ new Vector3();
 const _normalMatrix = /*@__PURE__*/ new Matrix3();

 class Plane {

	 constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		 // normal is assumed to be normalized

		 this.normal = normal;
		 this.constant = constant;

	 }

	 set( normal, constant ) {

		 this.normal.copy( normal );
		 this.constant = constant;

		 return this;

	 }

	 setComponents( x, y, z, w ) {

		 this.normal.set( x, y, z );
		 this.constant = w;

		 return this;

	 }

	 setFromNormalAndCoplanarPoint( normal, point ) {

		 this.normal.copy( normal );
		 this.constant = - point.dot( this.normal );

		 return this;

	 }

	 setFromCoplanarPoints( a, b, c ) {

		 const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		 // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		 this.setFromNormalAndCoplanarPoint( normal, a );

		 return this;

	 }

	 copy( plane ) {

		 this.normal.copy( plane.normal );
		 this.constant = plane.constant;

		 return this;

	 }

	 normalize() {

		 // Note: will lead to a divide by zero if the plane is invalid.

		 const inverseNormalLength = 1.0 / this.normal.length();
		 this.normal.multiplyScalar( inverseNormalLength );
		 this.constant *= inverseNormalLength;

		 return this;

	 }

	 negate() {

		 this.constant *= - 1;
		 this.normal.negate();

		 return this;

	 }

	 distanceToPoint( point ) {

		 return this.normal.dot( point ) + this.constant;

	 }

	 distanceToSphere( sphere ) {

		 return this.distanceToPoint( sphere.center ) - sphere.radius;

	 }

	 projectPoint( point, target ) {

		 return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	 }

	 intersectLine( line, target ) {

		 const direction = line.delta( _vector1 );

		 const denominator = this.normal.dot( direction );

		 if ( denominator === 0 ) {

			 // line is coplanar, return origin
			 if ( this.distanceToPoint( line.start ) === 0 ) {

				 return target.copy( line.start );

			 }

			 // Unsure if this is the correct method to handle this case.
			 return null;

		 }

		 const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		 if ( t < 0 || t > 1 ) {

			 return null;

		 }

		 return target.copy( direction ).multiplyScalar( t ).add( line.start );

	 }

	 intersectsLine( line ) {

		 // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		 const startSign = this.distanceToPoint( line.start );
		 const endSign = this.distanceToPoint( line.end );

		 return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	 }

	 intersectsBox( box ) {

		 return box.intersectsPlane( this );

	 }

	 intersectsSphere( sphere ) {

		 return sphere.intersectsPlane( this );

	 }

	 coplanarPoint( target ) {

		 return target.copy( this.normal ).multiplyScalar( - this.constant );

	 }

	 applyMatrix4( matrix, optionalNormalMatrix ) {

		 const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		 const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		 const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		 this.constant = - referencePoint.dot( normal );

		 return this;

	 }

	 translate( offset ) {

		 this.constant -= offset.dot( this.normal );

		 return this;

	 }

	 equals( plane ) {

		 return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 Plane.prototype.isPlane = true;

 const _sphere$2 = /*@__PURE__*/ new Sphere();
 const _vector$7 = /*@__PURE__*/ new Vector3();

 class Frustum {

	 constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		 this.planes = [ p0, p1, p2, p3, p4, p5 ];

	 }

	 set( p0, p1, p2, p3, p4, p5 ) {

		 const planes = this.planes;

		 planes[ 0 ].copy( p0 );
		 planes[ 1 ].copy( p1 );
		 planes[ 2 ].copy( p2 );
		 planes[ 3 ].copy( p3 );
		 planes[ 4 ].copy( p4 );
		 planes[ 5 ].copy( p5 );

		 return this;

	 }

	 copy( frustum ) {

		 const planes = this.planes;

		 for ( let i = 0; i < 6; i ++ ) {

			 planes[ i ].copy( frustum.planes[ i ] );

		 }

		 return this;

	 }

	 setFromProjectionMatrix( m ) {

		 const planes = this.planes;
		 const me = m.elements;
		 const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		 const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		 const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		 const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		 planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		 planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		 planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		 planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		 planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		 planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		 return this;

	 }

	 intersectsObject( object ) {

		 const geometry = object.geometry;

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		 return this.intersectsSphere( _sphere$2 );

	 }

	 intersectsSprite( sprite ) {

		 _sphere$2.center.set( 0, 0, 0 );
		 _sphere$2.radius = 0.7071067811865476;
		 _sphere$2.applyMatrix4( sprite.matrixWorld );

		 return this.intersectsSphere( _sphere$2 );

	 }

	 intersectsSphere( sphere ) {

		 const planes = this.planes;
		 const center = sphere.center;
		 const negRadius = - sphere.radius;

		 for ( let i = 0; i < 6; i ++ ) {

			 const distance = planes[ i ].distanceToPoint( center );

			 if ( distance < negRadius ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 intersectsBox( box ) {

		 const planes = this.planes;

		 for ( let i = 0; i < 6; i ++ ) {

			 const plane = planes[ i ];

			 // corner at max distance

			 _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			 _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			 _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			 if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 containsPoint( point ) {

		 const planes = this.planes;

		 for ( let i = 0; i < 6; i ++ ) {

			 if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

 }

 function WebGLAnimation() {

	 let context = null;
	 let isAnimating = false;
	 let animationLoop = null;
	 let requestId = null;

	 function onAnimationFrame( time, frame ) {

		 animationLoop( time, frame );

		 requestId = context.requestAnimationFrame( onAnimationFrame );

	 }

	 return {

		 start: function () {

			 if ( isAnimating === true ) return;
			 if ( animationLoop === null ) return;

			 requestId = context.requestAnimationFrame( onAnimationFrame );

			 isAnimating = true;

		 },

		 stop: function () {

			 context.cancelAnimationFrame( requestId );

			 isAnimating = false;

		 },

		 setAnimationLoop: function ( callback ) {

			 animationLoop = callback;

		 },

		 setContext: function ( value ) {

			 context = value;

		 }

	 };

 }

 function WebGLAttributes( gl, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 const buffers = new WeakMap();

	 function createBuffer( attribute, bufferType ) {

		 const array = attribute.array;
		 const usage = attribute.usage;

		 const buffer = gl.createBuffer();

		 gl.bindBuffer( bufferType, buffer );
		 gl.bufferData( bufferType, array, usage );

		 attribute.onUploadCallback();

		 let type = 5126;

		 if ( array instanceof Float32Array ) {

			 type = 5126;

		 } else if ( array instanceof Float64Array ) {

			 console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		 } else if ( array instanceof Uint16Array ) {

			 if ( attribute.isFloat16BufferAttribute ) {

				 if ( isWebGL2 ) {

					 type = 5131;

				 } else {

					 console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				 }

			 } else {

				 type = 5123;

			 }

		 } else if ( array instanceof Int16Array ) {

			 type = 5122;

		 } else if ( array instanceof Uint32Array ) {

			 type = 5125;

		 } else if ( array instanceof Int32Array ) {

			 type = 5124;

		 } else if ( array instanceof Int8Array ) {

			 type = 5120;

		 } else if ( array instanceof Uint8Array ) {

			 type = 5121;

		 } else if ( array instanceof Uint8ClampedArray ) {

			 type = 5121;

		 }

		 return {
			 buffer: buffer,
			 type: type,
			 bytesPerElement: array.BYTES_PER_ELEMENT,
			 version: attribute.version
		 };

	 }

	 function updateBuffer( buffer, attribute, bufferType ) {

		 const array = attribute.array;
		 const updateRange = attribute.updateRange;

		 gl.bindBuffer( bufferType, buffer );

		 if ( updateRange.count === - 1 ) {

			 // Not using update ranges

			 gl.bufferSubData( bufferType, 0, array );

		 } else {

			 if ( isWebGL2 ) {

				 gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					 array, updateRange.offset, updateRange.count );

			 } else {

				 gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					 array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			 }

			 updateRange.count = - 1; // reset range

		 }

	 }

	 //

	 function get( attribute ) {

		 if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		 return buffers.get( attribute );

	 }

	 function remove( attribute ) {

		 if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		 const data = buffers.get( attribute );

		 if ( data ) {

			 gl.deleteBuffer( data.buffer );

			 buffers.delete( attribute );

		 }

	 }

	 function update( attribute, bufferType ) {

		 if ( attribute.isGLBufferAttribute ) {

			 const cached = buffers.get( attribute );

			 if ( ! cached || cached.version < attribute.version ) {

				 buffers.set( attribute, {
					 buffer: attribute.buffer,
					 type: attribute.type,
					 bytesPerElement: attribute.elementSize,
					 version: attribute.version
				 } );

			 }

			 return;

		 }

		 if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		 const data = buffers.get( attribute );

		 if ( data === undefined ) {

			 buffers.set( attribute, createBuffer( attribute, bufferType ) );

		 } else if ( data.version < attribute.version ) {

			 updateBuffer( data.buffer, attribute, bufferType );

			 data.version = attribute.version;

		 }

	 }

	 return {

		 get: get,
		 remove: remove,
		 update: update

	 };

 }

 class PlaneGeometry extends BufferGeometry {

	 constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		 super();
		 this.type = 'PlaneGeometry';

		 this.parameters = {
			 width: width,
			 height: height,
			 widthSegments: widthSegments,
			 heightSegments: heightSegments
		 };

		 const width_half = width / 2;
		 const height_half = height / 2;

		 const gridX = Math.floor( widthSegments );
		 const gridY = Math.floor( heightSegments );

		 const gridX1 = gridX + 1;
		 const gridY1 = gridY + 1;

		 const segment_width = width / gridX;
		 const segment_height = height / gridY;

		 //

		 const indices = [];
		 const vertices = [];
		 const normals = [];
		 const uvs = [];

		 for ( let iy = 0; iy < gridY1; iy ++ ) {

			 const y = iy * segment_height - height_half;

			 for ( let ix = 0; ix < gridX1; ix ++ ) {

				 const x = ix * segment_width - width_half;

				 vertices.push( x, - y, 0 );

				 normals.push( 0, 0, 1 );

				 uvs.push( ix / gridX );
				 uvs.push( 1 - ( iy / gridY ) );

			 }

		 }

		 for ( let iy = 0; iy < gridY; iy ++ ) {

			 for ( let ix = 0; ix < gridX; ix ++ ) {

				 const a = ix + gridX1 * iy;
				 const b = ix + gridX1 * ( iy + 1 );
				 const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				 const d = ( ix + 1 ) + gridX1 * iy;

				 indices.push( a, b, d );
				 indices.push( b, c, d );

			 }

		 }

		 this.setIndex( indices );
		 this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		 this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	 }

	 static fromJSON( data ) {

		 return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	 }

 }

 var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

 var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

 var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

 var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

 var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

 var begin_vertex = "vec3 transformed = vec3( position );";

 var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

 var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

 var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

 var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

 var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

 var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

 var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

 var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

 var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

 var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

 var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

 var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

 var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

 var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

 var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

 var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

 var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

 var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

 var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

 var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

 var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

 var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

 var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

 var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

 var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

 var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

 var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

 var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

 var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

 var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

 var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

 var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

 var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

 var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

 var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

 var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

 var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

 var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

 var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

 var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

 var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

 var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

 var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

 var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

 var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

 var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

 var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

 var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

 var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

 var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

 var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

 var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

 var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

 var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

 var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

 var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

 var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

 var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

 var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

 var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

 var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

 var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

 var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

 var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

 var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

 var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

 var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

 var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

 var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

 var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

 var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

 var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

 var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

 var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

 var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

 var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

 var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

 var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

 var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

 var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

 var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

 var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

 var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";

 var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";

 var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

 var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

 var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

 var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

 var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

 var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

 var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

 var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

 var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

 var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

 var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

 var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

 var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

 var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

 var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

 var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

 var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

 var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

 var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

 var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

 var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

 var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";

 var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

 var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

 var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

 var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

 var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

 var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

 var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

 var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

 const ShaderChunk = {
	 alphamap_fragment: alphamap_fragment,
	 alphamap_pars_fragment: alphamap_pars_fragment,
	 alphatest_fragment: alphatest_fragment,
	 aomap_fragment: aomap_fragment,
	 aomap_pars_fragment: aomap_pars_fragment,
	 begin_vertex: begin_vertex,
	 beginnormal_vertex: beginnormal_vertex,
	 bsdfs: bsdfs,
	 bumpmap_pars_fragment: bumpmap_pars_fragment,
	 clipping_planes_fragment: clipping_planes_fragment,
	 clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	 clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	 clipping_planes_vertex: clipping_planes_vertex,
	 color_fragment: color_fragment,
	 color_pars_fragment: color_pars_fragment,
	 color_pars_vertex: color_pars_vertex,
	 color_vertex: color_vertex,
	 common: common,
	 cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	 defaultnormal_vertex: defaultnormal_vertex,
	 displacementmap_pars_vertex: displacementmap_pars_vertex,
	 displacementmap_vertex: displacementmap_vertex,
	 emissivemap_fragment: emissivemap_fragment,
	 emissivemap_pars_fragment: emissivemap_pars_fragment,
	 encodings_fragment: encodings_fragment,
	 encodings_pars_fragment: encodings_pars_fragment,
	 envmap_fragment: envmap_fragment,
	 envmap_common_pars_fragment: envmap_common_pars_fragment,
	 envmap_pars_fragment: envmap_pars_fragment,
	 envmap_pars_vertex: envmap_pars_vertex,
	 envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	 envmap_vertex: envmap_vertex,
	 fog_vertex: fog_vertex,
	 fog_pars_vertex: fog_pars_vertex,
	 fog_fragment: fog_fragment,
	 fog_pars_fragment: fog_pars_fragment,
	 gradientmap_pars_fragment: gradientmap_pars_fragment,
	 lightmap_fragment: lightmap_fragment,
	 lightmap_pars_fragment: lightmap_pars_fragment,
	 lights_lambert_vertex: lights_lambert_vertex,
	 lights_pars_begin: lights_pars_begin,
	 lights_toon_fragment: lights_toon_fragment,
	 lights_toon_pars_fragment: lights_toon_pars_fragment,
	 lights_phong_fragment: lights_phong_fragment,
	 lights_phong_pars_fragment: lights_phong_pars_fragment,
	 lights_physical_fragment: lights_physical_fragment,
	 lights_physical_pars_fragment: lights_physical_pars_fragment,
	 lights_fragment_begin: lights_fragment_begin,
	 lights_fragment_maps: lights_fragment_maps,
	 lights_fragment_end: lights_fragment_end,
	 logdepthbuf_fragment: logdepthbuf_fragment,
	 logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	 logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	 logdepthbuf_vertex: logdepthbuf_vertex,
	 map_fragment: map_fragment,
	 map_pars_fragment: map_pars_fragment,
	 map_particle_fragment: map_particle_fragment,
	 map_particle_pars_fragment: map_particle_pars_fragment,
	 metalnessmap_fragment: metalnessmap_fragment,
	 metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	 morphnormal_vertex: morphnormal_vertex,
	 morphtarget_pars_vertex: morphtarget_pars_vertex,
	 morphtarget_vertex: morphtarget_vertex,
	 normal_fragment_begin: normal_fragment_begin,
	 normal_fragment_maps: normal_fragment_maps,
	 normalmap_pars_fragment: normalmap_pars_fragment,
	 clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	 clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	 clearcoat_pars_fragment: clearcoat_pars_fragment,
	 packing: packing,
	 premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	 project_vertex: project_vertex,
	 dithering_fragment: dithering_fragment,
	 dithering_pars_fragment: dithering_pars_fragment,
	 roughnessmap_fragment: roughnessmap_fragment,
	 roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	 shadowmap_pars_fragment: shadowmap_pars_fragment,
	 shadowmap_pars_vertex: shadowmap_pars_vertex,
	 shadowmap_vertex: shadowmap_vertex,
	 shadowmask_pars_fragment: shadowmask_pars_fragment,
	 skinbase_vertex: skinbase_vertex,
	 skinning_pars_vertex: skinning_pars_vertex,
	 skinning_vertex: skinning_vertex,
	 skinnormal_vertex: skinnormal_vertex,
	 specularmap_fragment: specularmap_fragment,
	 specularmap_pars_fragment: specularmap_pars_fragment,
	 tonemapping_fragment: tonemapping_fragment,
	 tonemapping_pars_fragment: tonemapping_pars_fragment,
	 transmission_fragment: transmission_fragment,
	 transmission_pars_fragment: transmission_pars_fragment,
	 uv_pars_fragment: uv_pars_fragment,
	 uv_pars_vertex: uv_pars_vertex,
	 uv_vertex: uv_vertex,
	 uv2_pars_fragment: uv2_pars_fragment,
	 uv2_pars_vertex: uv2_pars_vertex,
	 uv2_vertex: uv2_vertex,
	 worldpos_vertex: worldpos_vertex,

	 background_frag: background_frag,
	 background_vert: background_vert,
	 cube_frag: cube_frag,
	 cube_vert: cube_vert,
	 depth_frag: depth_frag,
	 depth_vert: depth_vert,
	 distanceRGBA_frag: distanceRGBA_frag,
	 distanceRGBA_vert: distanceRGBA_vert,
	 equirect_frag: equirect_frag,
	 equirect_vert: equirect_vert,
	 linedashed_frag: linedashed_frag,
	 linedashed_vert: linedashed_vert,
	 meshbasic_frag: meshbasic_frag,
	 meshbasic_vert: meshbasic_vert,
	 meshlambert_frag: meshlambert_frag,
	 meshlambert_vert: meshlambert_vert,
	 meshmatcap_frag: meshmatcap_frag,
	 meshmatcap_vert: meshmatcap_vert,
	 meshtoon_frag: meshtoon_frag,
	 meshtoon_vert: meshtoon_vert,
	 meshphong_frag: meshphong_frag,
	 meshphong_vert: meshphong_vert,
	 meshphysical_frag: meshphysical_frag,
	 meshphysical_vert: meshphysical_vert,
	 normal_frag: normal_frag,
	 normal_vert: normal_vert,
	 points_frag: points_frag,
	 points_vert: points_vert,
	 shadow_frag: shadow_frag,
	 shadow_vert: shadow_vert,
	 sprite_frag: sprite_frag,
	 sprite_vert: sprite_vert
 };

 /**
	* Uniforms library for shared webgl shaders
	*/

 const UniformsLib = {

	 common: {

		 diffuse: { value: new Color$1( 0xffffff ) },
		 opacity: { value: 1.0 },

		 map: { value: null },
		 uvTransform: { value: new Matrix3() },
		 uv2Transform: { value: new Matrix3() },

		 alphaMap: { value: null },

	 },

	 specularmap: {

		 specularMap: { value: null },

	 },

	 envmap: {

		 envMap: { value: null },
		 flipEnvMap: { value: - 1 },
		 reflectivity: { value: 1.0 },
		 refractionRatio: { value: 0.98 },
		 maxMipLevel: { value: 0 }

	 },

	 aomap: {

		 aoMap: { value: null },
		 aoMapIntensity: { value: 1 }

	 },

	 lightmap: {

		 lightMap: { value: null },
		 lightMapIntensity: { value: 1 }

	 },

	 emissivemap: {

		 emissiveMap: { value: null }

	 },

	 bumpmap: {

		 bumpMap: { value: null },
		 bumpScale: { value: 1 }

	 },

	 normalmap: {

		 normalMap: { value: null },
		 normalScale: { value: new Vector2( 1, 1 ) }

	 },

	 displacementmap: {

		 displacementMap: { value: null },
		 displacementScale: { value: 1 },
		 displacementBias: { value: 0 }

	 },

	 roughnessmap: {

		 roughnessMap: { value: null }

	 },

	 metalnessmap: {

		 metalnessMap: { value: null }

	 },

	 gradientmap: {

		 gradientMap: { value: null }

	 },

	 fog: {

		 fogDensity: { value: 0.00025 },
		 fogNear: { value: 1 },
		 fogFar: { value: 2000 },
		 fogColor: { value: new Color$1( 0xffffff ) }

	 },

	 lights: {

		 ambientLightColor: { value: [] },

		 lightProbe: { value: [] },

		 directionalLights: { value: [], properties: {
			 direction: {},
			 color: {}
		 } },

		 directionalLightShadows: { value: [], properties: {
			 shadowBias: {},
			 shadowNormalBias: {},
			 shadowRadius: {},
			 shadowMapSize: {}
		 } },

		 directionalShadowMap: { value: [] },
		 directionalShadowMatrix: { value: [] },

		 spotLights: { value: [], properties: {
			 color: {},
			 position: {},
			 direction: {},
			 distance: {},
			 coneCos: {},
			 penumbraCos: {},
			 decay: {}
		 } },

		 spotLightShadows: { value: [], properties: {
			 shadowBias: {},
			 shadowNormalBias: {},
			 shadowRadius: {},
			 shadowMapSize: {}
		 } },

		 spotShadowMap: { value: [] },
		 spotShadowMatrix: { value: [] },

		 pointLights: { value: [], properties: {
			 color: {},
			 position: {},
			 decay: {},
			 distance: {}
		 } },

		 pointLightShadows: { value: [], properties: {
			 shadowBias: {},
			 shadowNormalBias: {},
			 shadowRadius: {},
			 shadowMapSize: {},
			 shadowCameraNear: {},
			 shadowCameraFar: {}
		 } },

		 pointShadowMap: { value: [] },
		 pointShadowMatrix: { value: [] },

		 hemisphereLights: { value: [], properties: {
			 direction: {},
			 skyColor: {},
			 groundColor: {}
		 } },

		 // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		 rectAreaLights: { value: [], properties: {
			 color: {},
			 position: {},
			 width: {},
			 height: {}
		 } },

		 ltc_1: { value: null },
		 ltc_2: { value: null }

	 },

	 points: {

		 diffuse: { value: new Color$1( 0xffffff ) },
		 opacity: { value: 1.0 },
		 size: { value: 1.0 },
		 scale: { value: 1.0 },
		 map: { value: null },
		 alphaMap: { value: null },
		 uvTransform: { value: new Matrix3() }

	 },

	 sprite: {

		 diffuse: { value: new Color$1( 0xffffff ) },
		 opacity: { value: 1.0 },
		 center: { value: new Vector2( 0.5, 0.5 ) },
		 rotation: { value: 0.0 },
		 map: { value: null },
		 alphaMap: { value: null },
		 uvTransform: { value: new Matrix3() }

	 }

 };

 const ShaderLib = {

	 basic: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.specularmap,
			 UniformsLib.envmap,
			 UniformsLib.aomap,
			 UniformsLib.lightmap,
			 UniformsLib.fog
		 ] ),

		 vertexShader: ShaderChunk.meshbasic_vert,
		 fragmentShader: ShaderChunk.meshbasic_frag

	 },

	 lambert: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.specularmap,
			 UniformsLib.envmap,
			 UniformsLib.aomap,
			 UniformsLib.lightmap,
			 UniformsLib.emissivemap,
			 UniformsLib.fog,
			 UniformsLib.lights,
			 {
				 emissive: { value: new Color$1( 0x000000 ) }
			 }
		 ] ),

		 vertexShader: ShaderChunk.meshlambert_vert,
		 fragmentShader: ShaderChunk.meshlambert_frag

	 },

	 phong: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.specularmap,
			 UniformsLib.envmap,
			 UniformsLib.aomap,
			 UniformsLib.lightmap,
			 UniformsLib.emissivemap,
			 UniformsLib.bumpmap,
			 UniformsLib.normalmap,
			 UniformsLib.displacementmap,
			 UniformsLib.fog,
			 UniformsLib.lights,
			 {
				 emissive: { value: new Color$1( 0x000000 ) },
				 specular: { value: new Color$1( 0x111111 ) },
				 shininess: { value: 30 }
			 }
		 ] ),

		 vertexShader: ShaderChunk.meshphong_vert,
		 fragmentShader: ShaderChunk.meshphong_frag

	 },

	 standard: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.envmap,
			 UniformsLib.aomap,
			 UniformsLib.lightmap,
			 UniformsLib.emissivemap,
			 UniformsLib.bumpmap,
			 UniformsLib.normalmap,
			 UniformsLib.displacementmap,
			 UniformsLib.roughnessmap,
			 UniformsLib.metalnessmap,
			 UniformsLib.fog,
			 UniformsLib.lights,
			 {
				 emissive: { value: new Color$1( 0x000000 ) },
				 roughness: { value: 1.0 },
				 metalness: { value: 0.0 },
				 envMapIntensity: { value: 1 } // temporary
			 }
		 ] ),

		 vertexShader: ShaderChunk.meshphysical_vert,
		 fragmentShader: ShaderChunk.meshphysical_frag

	 },

	 toon: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.aomap,
			 UniformsLib.lightmap,
			 UniformsLib.emissivemap,
			 UniformsLib.bumpmap,
			 UniformsLib.normalmap,
			 UniformsLib.displacementmap,
			 UniformsLib.gradientmap,
			 UniformsLib.fog,
			 UniformsLib.lights,
			 {
				 emissive: { value: new Color$1( 0x000000 ) }
			 }
		 ] ),

		 vertexShader: ShaderChunk.meshtoon_vert,
		 fragmentShader: ShaderChunk.meshtoon_frag

	 },

	 matcap: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.bumpmap,
			 UniformsLib.normalmap,
			 UniformsLib.displacementmap,
			 UniformsLib.fog,
			 {
				 matcap: { value: null }
			 }
		 ] ),

		 vertexShader: ShaderChunk.meshmatcap_vert,
		 fragmentShader: ShaderChunk.meshmatcap_frag

	 },

	 points: {

		 uniforms: mergeUniforms( [
			 UniformsLib.points,
			 UniformsLib.fog
		 ] ),

		 vertexShader: ShaderChunk.points_vert,
		 fragmentShader: ShaderChunk.points_frag

	 },

	 dashed: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.fog,
			 {
				 scale: { value: 1 },
				 dashSize: { value: 1 },
				 totalSize: { value: 2 }
			 }
		 ] ),

		 vertexShader: ShaderChunk.linedashed_vert,
		 fragmentShader: ShaderChunk.linedashed_frag

	 },

	 depth: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.displacementmap
		 ] ),

		 vertexShader: ShaderChunk.depth_vert,
		 fragmentShader: ShaderChunk.depth_frag

	 },

	 normal: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.bumpmap,
			 UniformsLib.normalmap,
			 UniformsLib.displacementmap,
			 {
				 opacity: { value: 1.0 }
			 }
		 ] ),

		 vertexShader: ShaderChunk.normal_vert,
		 fragmentShader: ShaderChunk.normal_frag

	 },

	 sprite: {

		 uniforms: mergeUniforms( [
			 UniformsLib.sprite,
			 UniformsLib.fog
		 ] ),

		 vertexShader: ShaderChunk.sprite_vert,
		 fragmentShader: ShaderChunk.sprite_frag

	 },

	 background: {

		 uniforms: {
			 uvTransform: { value: new Matrix3() },
			 t2D: { value: null },
		 },

		 vertexShader: ShaderChunk.background_vert,
		 fragmentShader: ShaderChunk.background_frag

	 },
	 /* -------------------------------------------------------------------------
	 //	Cube map shader
		------------------------------------------------------------------------- */

	 cube: {

		 uniforms: mergeUniforms( [
			 UniformsLib.envmap,
			 {
				 opacity: { value: 1.0 }
			 }
		 ] ),

		 vertexShader: ShaderChunk.cube_vert,
		 fragmentShader: ShaderChunk.cube_frag

	 },

	 equirect: {

		 uniforms: {
			 tEquirect: { value: null },
		 },

		 vertexShader: ShaderChunk.equirect_vert,
		 fragmentShader: ShaderChunk.equirect_frag

	 },

	 distanceRGBA: {

		 uniforms: mergeUniforms( [
			 UniformsLib.common,
			 UniformsLib.displacementmap,
			 {
				 referencePosition: { value: new Vector3() },
				 nearDistance: { value: 1 },
				 farDistance: { value: 1000 }
			 }
		 ] ),

		 vertexShader: ShaderChunk.distanceRGBA_vert,
		 fragmentShader: ShaderChunk.distanceRGBA_frag

	 },

	 shadow: {

		 uniforms: mergeUniforms( [
			 UniformsLib.lights,
			 UniformsLib.fog,
			 {
				 color: { value: new Color$1( 0x00000 ) },
				 opacity: { value: 1.0 }
			 },
		 ] ),

		 vertexShader: ShaderChunk.shadow_vert,
		 fragmentShader: ShaderChunk.shadow_frag

	 }

 };

 ShaderLib.physical = {

	 uniforms: mergeUniforms( [
		 ShaderLib.standard.uniforms,
		 {
			 clearcoat: { value: 0 },
			 clearcoatMap: { value: null },
			 clearcoatRoughness: { value: 0 },
			 clearcoatRoughnessMap: { value: null },
			 clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			 clearcoatNormalMap: { value: null },
			 sheen: { value: new Color$1( 0x000000 ) },
			 transmission: { value: 0 },
			 transmissionMap: { value: null },
			 transmissionSamplerSize: { value: new Vector2() },
			 transmissionSamplerMap: { value: null },
			 thickness: { value: 0 },
			 thicknessMap: { value: null },
			 attenuationDistance: { value: 0 },
			 attenuationColor: { value: new Color$1( 0x000000 ) }
		 }
	 ] ),

	 vertexShader: ShaderChunk.meshphysical_vert,
	 fragmentShader: ShaderChunk.meshphysical_frag

 };

 function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

	 const clearColor = new Color$1( 0x000000 );
	 let clearAlpha = 0;

	 let planeMesh;
	 let boxMesh;

	 let currentBackground = null;
	 let currentBackgroundVersion = 0;
	 let currentTonemapping = null;

	 function render( renderList, scene ) {

		 let forceClear = false;
		 let background = scene.isScene === true ? scene.background : null;

		 if ( background && background.isTexture ) {

			 background = cubemaps.get( background );

		 }

		 // Ignore background in AR
		 // TODO: Reconsider this.

		 const xr = renderer.xr;
		 const session = xr.getSession && xr.getSession();

		 if ( session && session.environmentBlendMode === 'additive' ) {

			 background = null;

		 }

		 if ( background === null ) {

			 setClear( clearColor, clearAlpha );

		 } else if ( background && background.isColor ) {

			 setClear( background, 1 );
			 forceClear = true;

		 }

		 if ( renderer.autoClear || forceClear ) {

			 renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		 }

		 if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			 if ( boxMesh === undefined ) {

				 boxMesh = new Mesh(
					 new BoxGeometry( 1, 1, 1 ),
					 new ShaderMaterial( {
						 name: 'BackgroundCubeMaterial',
						 uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						 vertexShader: ShaderLib.cube.vertexShader,
						 fragmentShader: ShaderLib.cube.fragmentShader,
						 side: BackSide,
						 depthTest: false,
						 depthWrite: false,
						 fog: false
					 } )
				 );

				 boxMesh.geometry.deleteAttribute( 'normal' );
				 boxMesh.geometry.deleteAttribute( 'uv' );

				 boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					 this.matrixWorld.copyPosition( camera.matrixWorld );

				 };

				 // enable code injection for non-built-in material
				 Object.defineProperty( boxMesh.material, 'envMap', {

					 get: function () {

						 return this.uniforms.envMap.value;

					 }

				 } );

				 objects.update( boxMesh );

			 }

			 boxMesh.material.uniforms.envMap.value = background;
			 boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

			 if ( currentBackground !== background ||
				 currentBackgroundVersion !== background.version ||
				 currentTonemapping !== renderer.toneMapping ) {

				 boxMesh.material.needsUpdate = true;

				 currentBackground = background;
				 currentBackgroundVersion = background.version;
				 currentTonemapping = renderer.toneMapping;

			 }

			 // push to the pre-sorted opaque render list
			 renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		 } else if ( background && background.isTexture ) {

			 if ( planeMesh === undefined ) {

				 planeMesh = new Mesh(
					 new PlaneGeometry( 2, 2 ),
					 new ShaderMaterial( {
						 name: 'BackgroundMaterial',
						 uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						 vertexShader: ShaderLib.background.vertexShader,
						 fragmentShader: ShaderLib.background.fragmentShader,
						 side: FrontSide,
						 depthTest: false,
						 depthWrite: false,
						 fog: false
					 } )
				 );

				 planeMesh.geometry.deleteAttribute( 'normal' );

				 // enable code injection for non-built-in material
				 Object.defineProperty( planeMesh.material, 'map', {

					 get: function () {

						 return this.uniforms.t2D.value;

					 }

				 } );

				 objects.update( planeMesh );

			 }

			 planeMesh.material.uniforms.t2D.value = background;

			 if ( background.matrixAutoUpdate === true ) {

				 background.updateMatrix();

			 }

			 planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			 if ( currentBackground !== background ||
				 currentBackgroundVersion !== background.version ||
				 currentTonemapping !== renderer.toneMapping ) {

				 planeMesh.material.needsUpdate = true;

				 currentBackground = background;
				 currentBackgroundVersion = background.version;
				 currentTonemapping = renderer.toneMapping;

			 }


			 // push to the pre-sorted opaque render list
			 renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		 }

	 }

	 function setClear( color, alpha ) {

		 state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	 }

	 return {

		 getClearColor: function () {

			 return clearColor;

		 },
		 setClearColor: function ( color, alpha = 1 ) {

			 clearColor.set( color );
			 clearAlpha = alpha;
			 setClear( clearColor, clearAlpha );

		 },
		 getClearAlpha: function () {

			 return clearAlpha;

		 },
		 setClearAlpha: function ( alpha ) {

			 clearAlpha = alpha;
			 setClear( clearColor, clearAlpha );

		 },
		 render: render

	 };

 }

 function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	 const maxVertexAttributes = gl.getParameter( 34921 );

	 const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	 const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	 const bindingStates = {};

	 const defaultState = createBindingState( null );
	 let currentState = defaultState;

	 function setup( object, material, program, geometry, index ) {

		 let updateBuffers = false;

		 if ( vaoAvailable ) {

			 const state = getBindingState( geometry, program, material );

			 if ( currentState !== state ) {

				 currentState = state;
				 bindVertexArrayObject( currentState.object );

			 }

			 updateBuffers = needsUpdate( geometry, index );

			 if ( updateBuffers ) saveCache( geometry, index );

		 } else {

			 const wireframe = ( material.wireframe === true );

			 if ( currentState.geometry !== geometry.id ||
				 currentState.program !== program.id ||
				 currentState.wireframe !== wireframe ) {

				 currentState.geometry = geometry.id;
				 currentState.program = program.id;
				 currentState.wireframe = wireframe;

				 updateBuffers = true;

			 }

		 }

		 if ( object.isInstancedMesh === true ) {

			 updateBuffers = true;

		 }

		 if ( index !== null ) {

			 attributes.update( index, 34963 );

		 }

		 if ( updateBuffers ) {

			 setupVertexAttributes( object, material, program, geometry );

			 if ( index !== null ) {

				 gl.bindBuffer( 34963, attributes.get( index ).buffer );

			 }

		 }

	 }

	 function createVertexArrayObject() {

		 if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		 return extension.createVertexArrayOES();

	 }

	 function bindVertexArrayObject( vao ) {

		 if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		 return extension.bindVertexArrayOES( vao );

	 }

	 function deleteVertexArrayObject( vao ) {

		 if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		 return extension.deleteVertexArrayOES( vao );

	 }

	 function getBindingState( geometry, program, material ) {

		 const wireframe = ( material.wireframe === true );

		 let programMap = bindingStates[ geometry.id ];

		 if ( programMap === undefined ) {

			 programMap = {};
			 bindingStates[ geometry.id ] = programMap;

		 }

		 let stateMap = programMap[ program.id ];

		 if ( stateMap === undefined ) {

			 stateMap = {};
			 programMap[ program.id ] = stateMap;

		 }

		 let state = stateMap[ wireframe ];

		 if ( state === undefined ) {

			 state = createBindingState( createVertexArrayObject() );
			 stateMap[ wireframe ] = state;

		 }

		 return state;

	 }

	 function createBindingState( vao ) {

		 const newAttributes = [];
		 const enabledAttributes = [];
		 const attributeDivisors = [];

		 for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			 newAttributes[ i ] = 0;
			 enabledAttributes[ i ] = 0;
			 attributeDivisors[ i ] = 0;

		 }

		 return {

			 // for backward compatibility on non-VAO support browser
			 geometry: null,
			 program: null,
			 wireframe: false,

			 newAttributes: newAttributes,
			 enabledAttributes: enabledAttributes,
			 attributeDivisors: attributeDivisors,
			 object: vao,
			 attributes: {},
			 index: null

		 };

	 }

	 function needsUpdate( geometry, index ) {

		 const cachedAttributes = currentState.attributes;
		 const geometryAttributes = geometry.attributes;

		 let attributesNum = 0;

		 for ( const key in geometryAttributes ) {

			 const cachedAttribute = cachedAttributes[ key ];
			 const geometryAttribute = geometryAttributes[ key ];

			 if ( cachedAttribute === undefined ) return true;

			 if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			 if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			 attributesNum ++;

		 }

		 if ( currentState.attributesNum !== attributesNum ) return true;

		 if ( currentState.index !== index ) return true;

		 return false;

	 }

	 function saveCache( geometry, index ) {

		 const cache = {};
		 const attributes = geometry.attributes;
		 let attributesNum = 0;

		 for ( const key in attributes ) {

			 const attribute = attributes[ key ];

			 const data = {};
			 data.attribute = attribute;

			 if ( attribute.data ) {

				 data.data = attribute.data;

			 }

			 cache[ key ] = data;

			 attributesNum ++;

		 }

		 currentState.attributes = cache;
		 currentState.attributesNum = attributesNum;

		 currentState.index = index;

	 }

	 function initAttributes() {

		 const newAttributes = currentState.newAttributes;

		 for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			 newAttributes[ i ] = 0;

		 }

	 }

	 function enableAttribute( attribute ) {

		 enableAttributeAndDivisor( attribute, 0 );

	 }

	 function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		 const newAttributes = currentState.newAttributes;
		 const enabledAttributes = currentState.enabledAttributes;
		 const attributeDivisors = currentState.attributeDivisors;

		 newAttributes[ attribute ] = 1;

		 if ( enabledAttributes[ attribute ] === 0 ) {

			 gl.enableVertexAttribArray( attribute );
			 enabledAttributes[ attribute ] = 1;

		 }

		 if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			 const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			 extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			 attributeDivisors[ attribute ] = meshPerAttribute;

		 }

	 }

	 function disableUnusedAttributes() {

		 const newAttributes = currentState.newAttributes;
		 const enabledAttributes = currentState.enabledAttributes;

		 for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			 if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				 gl.disableVertexAttribArray( i );
				 enabledAttributes[ i ] = 0;

			 }

		 }

	 }

	 function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		 if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			 gl.vertexAttribIPointer( index, size, type, stride, offset );

		 } else {

			 gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		 }

	 }

	 function setupVertexAttributes( object, material, program, geometry ) {

		 if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			 if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		 }

		 initAttributes();

		 const geometryAttributes = geometry.attributes;

		 const programAttributes = program.getAttributes();

		 const materialDefaultAttributeValues = material.defaultAttributeValues;

		 for ( const name in programAttributes ) {

			 const programAttribute = programAttributes[ name ];

			 if ( programAttribute >= 0 ) {

				 const geometryAttribute = geometryAttributes[ name ];

				 if ( geometryAttribute !== undefined ) {

					 const normalized = geometryAttribute.normalized;
					 const size = geometryAttribute.itemSize;

					 const attribute = attributes.get( geometryAttribute );

					 // TODO Attribute may not be available on context restore

					 if ( attribute === undefined ) continue;

					 const buffer = attribute.buffer;
					 const type = attribute.type;
					 const bytesPerElement = attribute.bytesPerElement;

					 if ( geometryAttribute.isInterleavedBufferAttribute ) {

						 const data = geometryAttribute.data;
						 const stride = data.stride;
						 const offset = geometryAttribute.offset;

						 if ( data && data.isInstancedInterleavedBuffer ) {

							 enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							 if ( geometry._maxInstanceCount === undefined ) {

								 geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							 }

						 } else {

							 enableAttribute( programAttribute );

						 }

						 gl.bindBuffer( 34962, buffer );
						 vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					 } else {

						 if ( geometryAttribute.isInstancedBufferAttribute ) {

							 enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							 if ( geometry._maxInstanceCount === undefined ) {

								 geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							 }

						 } else {

							 enableAttribute( programAttribute );

						 }

						 gl.bindBuffer( 34962, buffer );
						 vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					 }

				 } else if ( name === 'instanceMatrix' ) {

					 const attribute = attributes.get( object.instanceMatrix );

					 // TODO Attribute may not be available on context restore

					 if ( attribute === undefined ) continue;

					 const buffer = attribute.buffer;
					 const type = attribute.type;

					 enableAttributeAndDivisor( programAttribute + 0, 1 );
					 enableAttributeAndDivisor( programAttribute + 1, 1 );
					 enableAttributeAndDivisor( programAttribute + 2, 1 );
					 enableAttributeAndDivisor( programAttribute + 3, 1 );

					 gl.bindBuffer( 34962, buffer );

					 gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					 gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					 gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					 gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				 } else if ( name === 'instanceColor' ) {

					 const attribute = attributes.get( object.instanceColor );

					 // TODO Attribute may not be available on context restore

					 if ( attribute === undefined ) continue;

					 const buffer = attribute.buffer;
					 const type = attribute.type;

					 enableAttributeAndDivisor( programAttribute, 1 );

					 gl.bindBuffer( 34962, buffer );

					 gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

				 } else if ( materialDefaultAttributeValues !== undefined ) {

					 const value = materialDefaultAttributeValues[ name ];

					 if ( value !== undefined ) {

						 switch ( value.length ) {

							 case 2:
								 gl.vertexAttrib2fv( programAttribute, value );
								 break;

							 case 3:
								 gl.vertexAttrib3fv( programAttribute, value );
								 break;

							 case 4:
								 gl.vertexAttrib4fv( programAttribute, value );
								 break;

							 default:
								 gl.vertexAttrib1fv( programAttribute, value );

						 }

					 }

				 }

			 }

		 }

		 disableUnusedAttributes();

	 }

	 function dispose() {

		 reset();

		 for ( const geometryId in bindingStates ) {

			 const programMap = bindingStates[ geometryId ];

			 for ( const programId in programMap ) {

				 const stateMap = programMap[ programId ];

				 for ( const wireframe in stateMap ) {

					 deleteVertexArrayObject( stateMap[ wireframe ].object );

					 delete stateMap[ wireframe ];

				 }

				 delete programMap[ programId ];

			 }

			 delete bindingStates[ geometryId ];

		 }

	 }

	 function releaseStatesOfGeometry( geometry ) {

		 if ( bindingStates[ geometry.id ] === undefined ) return;

		 const programMap = bindingStates[ geometry.id ];

		 for ( const programId in programMap ) {

			 const stateMap = programMap[ programId ];

			 for ( const wireframe in stateMap ) {

				 deleteVertexArrayObject( stateMap[ wireframe ].object );

				 delete stateMap[ wireframe ];

			 }

			 delete programMap[ programId ];

		 }

		 delete bindingStates[ geometry.id ];

	 }

	 function releaseStatesOfProgram( program ) {

		 for ( const geometryId in bindingStates ) {

			 const programMap = bindingStates[ geometryId ];

			 if ( programMap[ program.id ] === undefined ) continue;

			 const stateMap = programMap[ program.id ];

			 for ( const wireframe in stateMap ) {

				 deleteVertexArrayObject( stateMap[ wireframe ].object );

				 delete stateMap[ wireframe ];

			 }

			 delete programMap[ program.id ];

		 }

	 }

	 function reset() {

		 resetDefaultState();

		 if ( currentState === defaultState ) return;

		 currentState = defaultState;
		 bindVertexArrayObject( currentState.object );

	 }

	 // for backward-compatilibity

	 function resetDefaultState() {

		 defaultState.geometry = null;
		 defaultState.program = null;
		 defaultState.wireframe = false;

	 }

	 return {

		 setup: setup,
		 reset: reset,
		 resetDefaultState: resetDefaultState,
		 dispose: dispose,
		 releaseStatesOfGeometry: releaseStatesOfGeometry,
		 releaseStatesOfProgram: releaseStatesOfProgram,

		 initAttributes: initAttributes,
		 enableAttribute: enableAttribute,
		 disableUnusedAttributes: disableUnusedAttributes

	 };

 }

 function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 let mode;

	 function setMode( value ) {

		 mode = value;

	 }

	 function render( start, count ) {

		 gl.drawArrays( mode, start, count );

		 info.update( count, mode, 1 );

	 }

	 function renderInstances( start, count, primcount ) {

		 if ( primcount === 0 ) return;

		 let extension, methodName;

		 if ( isWebGL2 ) {

			 extension = gl;
			 methodName = 'drawArraysInstanced';

		 } else {

			 extension = extensions.get( 'ANGLE_instanced_arrays' );
			 methodName = 'drawArraysInstancedANGLE';

			 if ( extension === null ) {

				 console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				 return;

			 }

		 }

		 extension[ methodName ]( mode, start, count, primcount );

		 info.update( count, mode, primcount );

	 }

	 //

	 this.setMode = setMode;
	 this.render = render;
	 this.renderInstances = renderInstances;

 }

 function WebGLCapabilities( gl, extensions, parameters ) {

	 let maxAnisotropy;

	 function getMaxAnisotropy() {

		 if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		 if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			 const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			 maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		 } else {

			 maxAnisotropy = 0;

		 }

		 return maxAnisotropy;

	 }

	 function getMaxPrecision( precision ) {

		 if ( precision === 'highp' ) {

			 if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				 gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				 return 'highp';

			 }

			 precision = 'mediump';

		 }

		 if ( precision === 'mediump' ) {

			 if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				 gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				 return 'mediump';

			 }

		 }

		 return 'lowp';

	 }

	 /* eslint-disable no-undef */
	 const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		 ( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	 /* eslint-enable no-undef */

	 let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	 const maxPrecision = getMaxPrecision( precision );

	 if ( maxPrecision !== precision ) {

		 console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		 precision = maxPrecision;

	 }

	 const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

	 const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	 const maxTextures = gl.getParameter( 34930 );
	 const maxVertexTextures = gl.getParameter( 35660 );
	 const maxTextureSize = gl.getParameter( 3379 );
	 const maxCubemapSize = gl.getParameter( 34076 );

	 const maxAttributes = gl.getParameter( 34921 );
	 const maxVertexUniforms = gl.getParameter( 36347 );
	 const maxVaryings = gl.getParameter( 36348 );
	 const maxFragmentUniforms = gl.getParameter( 36349 );

	 const vertexTextures = maxVertexTextures > 0;
	 const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	 const floatVertexTextures = vertexTextures && floatFragmentTextures;

	 const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	 return {

		 isWebGL2: isWebGL2,

		 drawBuffers: drawBuffers,

		 getMaxAnisotropy: getMaxAnisotropy,
		 getMaxPrecision: getMaxPrecision,

		 precision: precision,
		 logarithmicDepthBuffer: logarithmicDepthBuffer,

		 maxTextures: maxTextures,
		 maxVertexTextures: maxVertexTextures,
		 maxTextureSize: maxTextureSize,
		 maxCubemapSize: maxCubemapSize,

		 maxAttributes: maxAttributes,
		 maxVertexUniforms: maxVertexUniforms,
		 maxVaryings: maxVaryings,
		 maxFragmentUniforms: maxFragmentUniforms,

		 vertexTextures: vertexTextures,
		 floatFragmentTextures: floatFragmentTextures,
		 floatVertexTextures: floatVertexTextures,

		 maxSamples: maxSamples

	 };

 }

 function WebGLClipping( properties ) {

	 const scope = this;

	 let globalState = null,
		 numGlobalPlanes = 0,
		 localClippingEnabled = false,
		 renderingShadows = false;

	 const plane = new Plane(),
		 viewNormalMatrix = new Matrix3(),

		 uniform = { value: null, needsUpdate: false };

	 this.uniform = uniform;
	 this.numPlanes = 0;
	 this.numIntersection = 0;

	 this.init = function ( planes, enableLocalClipping, camera ) {

		 const enabled =
			 planes.length !== 0 ||
			 enableLocalClipping ||
			 // enable state of previous frame - the clipping code has to
			 // run another frame in order to reset the state:
			 numGlobalPlanes !== 0 ||
			 localClippingEnabled;

		 localClippingEnabled = enableLocalClipping;

		 globalState = projectPlanes( planes, camera, 0 );
		 numGlobalPlanes = planes.length;

		 return enabled;

	 };

	 this.beginShadows = function () {

		 renderingShadows = true;
		 projectPlanes( null );

	 };

	 this.endShadows = function () {

		 renderingShadows = false;
		 resetGlobalState();

	 };

	 this.setState = function ( material, camera, useCache ) {

		 const planes = material.clippingPlanes,
			 clipIntersection = material.clipIntersection,
			 clipShadows = material.clipShadows;

		 const materialProperties = properties.get( material );

		 if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			 // there's no local clipping

			 if ( renderingShadows ) {

				 // there's no global clipping

				 projectPlanes( null );

			 } else {

				 resetGlobalState();

			 }

		 } else {

			 const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				 lGlobal = nGlobal * 4;

			 let dstArray = materialProperties.clippingState || null;

			 uniform.value = dstArray; // ensure unique state

			 dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			 for ( let i = 0; i !== lGlobal; ++ i ) {

				 dstArray[ i ] = globalState[ i ];

			 }

			 materialProperties.clippingState = dstArray;
			 this.numIntersection = clipIntersection ? this.numPlanes : 0;
			 this.numPlanes += nGlobal;

		 }


	 };

	 function resetGlobalState() {

		 if ( uniform.value !== globalState ) {

			 uniform.value = globalState;
			 uniform.needsUpdate = numGlobalPlanes > 0;

		 }

		 scope.numPlanes = numGlobalPlanes;
		 scope.numIntersection = 0;

	 }

	 function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		 const nPlanes = planes !== null ? planes.length : 0;
		 let dstArray = null;

		 if ( nPlanes !== 0 ) {

			 dstArray = uniform.value;

			 if ( skipTransform !== true || dstArray === null ) {

				 const flatSize = dstOffset + nPlanes * 4,
					 viewMatrix = camera.matrixWorldInverse;

				 viewNormalMatrix.getNormalMatrix( viewMatrix );

				 if ( dstArray === null || dstArray.length < flatSize ) {

					 dstArray = new Float32Array( flatSize );

				 }

				 for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					 plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					 plane.normal.toArray( dstArray, i4 );
					 dstArray[ i4 + 3 ] = plane.constant;

				 }

			 }

			 uniform.value = dstArray;
			 uniform.needsUpdate = true;

		 }

		 scope.numPlanes = nPlanes;
		 scope.numIntersection = 0;

		 return dstArray;

	 }

 }

 function WebGLCubeMaps( renderer ) {

	 let cubemaps = new WeakMap();

	 function mapTextureMapping( texture, mapping ) {

		 if ( mapping === EquirectangularReflectionMapping ) {

			 texture.mapping = CubeReflectionMapping;

		 } else if ( mapping === EquirectangularRefractionMapping ) {

			 texture.mapping = CubeRefractionMapping;

		 }

		 return texture;

	 }

	 function get( texture ) {

		 if ( texture && texture.isTexture ) {

			 const mapping = texture.mapping;

			 if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				 if ( cubemaps.has( texture ) ) {

					 const cubemap = cubemaps.get( texture ).texture;
					 return mapTextureMapping( cubemap, texture.mapping );

				 } else {

					 const image = texture.image;

					 if ( image && image.height > 0 ) {

						 const currentRenderTarget = renderer.getRenderTarget();

						 const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						 renderTarget.fromEquirectangularTexture( renderer, texture );
						 cubemaps.set( texture, renderTarget );

						 renderer.setRenderTarget( currentRenderTarget );

						 texture.addEventListener( 'dispose', onTextureDispose );

						 return mapTextureMapping( renderTarget.texture, texture.mapping );

					 } else {

						 // image not yet ready. try the conversion next frame

						 return null;

					 }

				 }

			 }

		 }

		 return texture;

	 }

	 function onTextureDispose( event ) {

		 const texture = event.target;

		 texture.removeEventListener( 'dispose', onTextureDispose );

		 const cubemap = cubemaps.get( texture );

		 if ( cubemap !== undefined ) {

			 cubemaps.delete( texture );
			 cubemap.dispose();

		 }

	 }

	 function dispose() {

		 cubemaps = new WeakMap();

	 }

	 return {
		 get: get,
		 dispose: dispose
	 };

 }

 function WebGLExtensions( gl ) {

	 const extensions = {};

	 function getExtension( name ) {

		 if ( extensions[ name ] !== undefined ) {

			 return extensions[ name ];

		 }

		 let extension;

		 switch ( name ) {

			 case 'WEBGL_depth_texture':
				 extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				 break;

			 case 'EXT_texture_filter_anisotropic':
				 extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				 break;

			 case 'WEBGL_compressed_texture_s3tc':
				 extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				 break;

			 case 'WEBGL_compressed_texture_pvrtc':
				 extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				 break;

			 default:
				 extension = gl.getExtension( name );

		 }

		 extensions[ name ] = extension;

		 return extension;

	 }

	 return {

		 has: function ( name ) {

			 return getExtension( name ) !== null;

		 },

		 init: function ( capabilities ) {

			 if ( capabilities.isWebGL2 ) {

				 getExtension( 'EXT_color_buffer_float' );

			 } else {

				 getExtension( 'WEBGL_depth_texture' );
				 getExtension( 'OES_texture_float' );
				 getExtension( 'OES_texture_half_float' );
				 getExtension( 'OES_texture_half_float_linear' );
				 getExtension( 'OES_standard_derivatives' );
				 getExtension( 'OES_element_index_uint' );
				 getExtension( 'OES_vertex_array_object' );
				 getExtension( 'ANGLE_instanced_arrays' );

			 }

			 getExtension( 'OES_texture_float_linear' );
			 getExtension( 'EXT_color_buffer_half_float' );

		 },

		 get: function ( name ) {

			 const extension = getExtension( name );

			 if ( extension === null ) {

				 console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			 }

			 return extension;

		 }

	 };

 }

 function WebGLGeometries( gl, attributes, info, bindingStates ) {

	 const geometries = {};
	 const wireframeAttributes = new WeakMap();

	 function onGeometryDispose( event ) {

		 const geometry = event.target;

		 if ( geometry.index !== null ) {

			 attributes.remove( geometry.index );

		 }

		 for ( const name in geometry.attributes ) {

			 attributes.remove( geometry.attributes[ name ] );

		 }

		 geometry.removeEventListener( 'dispose', onGeometryDispose );

		 delete geometries[ geometry.id ];

		 const attribute = wireframeAttributes.get( geometry );

		 if ( attribute ) {

			 attributes.remove( attribute );
			 wireframeAttributes.delete( geometry );

		 }

		 bindingStates.releaseStatesOfGeometry( geometry );

		 if ( geometry.isInstancedBufferGeometry === true ) {

			 delete geometry._maxInstanceCount;

		 }

		 //

		 info.memory.geometries --;

	 }

	 function get( object, geometry ) {

		 if ( geometries[ geometry.id ] === true ) return geometry;

		 geometry.addEventListener( 'dispose', onGeometryDispose );

		 geometries[ geometry.id ] = true;

		 info.memory.geometries ++;

		 return geometry;

	 }

	 function update( geometry ) {

		 const geometryAttributes = geometry.attributes;

		 // Updating index buffer in VAO now. See WebGLBindingStates.

		 for ( const name in geometryAttributes ) {

			 attributes.update( geometryAttributes[ name ], 34962 );

		 }

		 // morph targets

		 const morphAttributes = geometry.morphAttributes;

		 for ( const name in morphAttributes ) {

			 const array = morphAttributes[ name ];

			 for ( let i = 0, l = array.length; i < l; i ++ ) {

				 attributes.update( array[ i ], 34962 );

			 }

		 }

	 }

	 function updateWireframeAttribute( geometry ) {

		 const indices = [];

		 const geometryIndex = geometry.index;
		 const geometryPosition = geometry.attributes.position;
		 let version = 0;

		 if ( geometryIndex !== null ) {

			 const array = geometryIndex.array;
			 version = geometryIndex.version;

			 for ( let i = 0, l = array.length; i < l; i += 3 ) {

				 const a = array[ i + 0 ];
				 const b = array[ i + 1 ];
				 const c = array[ i + 2 ];

				 indices.push( a, b, b, c, c, a );

			 }

		 } else {

			 const array = geometryPosition.array;
			 version = geometryPosition.version;

			 for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				 const a = i + 0;
				 const b = i + 1;
				 const c = i + 2;

				 indices.push( a, b, b, c, c, a );

			 }

		 }

		 const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		 attribute.version = version;

		 // Updating index buffer in VAO now. See WebGLBindingStates

		 //

		 const previousAttribute = wireframeAttributes.get( geometry );

		 if ( previousAttribute ) attributes.remove( previousAttribute );

		 //

		 wireframeAttributes.set( geometry, attribute );

	 }

	 function getWireframeAttribute( geometry ) {

		 const currentAttribute = wireframeAttributes.get( geometry );

		 if ( currentAttribute ) {

			 const geometryIndex = geometry.index;

			 if ( geometryIndex !== null ) {

				 // if the attribute is obsolete, create a new one

				 if ( currentAttribute.version < geometryIndex.version ) {

					 updateWireframeAttribute( geometry );

				 }

			 }

		 } else {

			 updateWireframeAttribute( geometry );

		 }

		 return wireframeAttributes.get( geometry );

	 }

	 return {

		 get: get,
		 update: update,

		 getWireframeAttribute: getWireframeAttribute

	 };

 }

 function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 let mode;

	 function setMode( value ) {

		 mode = value;

	 }

	 let type, bytesPerElement;

	 function setIndex( value ) {

		 type = value.type;
		 bytesPerElement = value.bytesPerElement;

	 }

	 function render( start, count ) {

		 gl.drawElements( mode, count, type, start * bytesPerElement );

		 info.update( count, mode, 1 );

	 }

	 function renderInstances( start, count, primcount ) {

		 if ( primcount === 0 ) return;

		 let extension, methodName;

		 if ( isWebGL2 ) {

			 extension = gl;
			 methodName = 'drawElementsInstanced';

		 } else {

			 extension = extensions.get( 'ANGLE_instanced_arrays' );
			 methodName = 'drawElementsInstancedANGLE';

			 if ( extension === null ) {

				 console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				 return;

			 }

		 }

		 extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		 info.update( count, mode, primcount );

	 }

	 //

	 this.setMode = setMode;
	 this.setIndex = setIndex;
	 this.render = render;
	 this.renderInstances = renderInstances;

 }

 function WebGLInfo( gl ) {

	 const memory = {
		 geometries: 0,
		 textures: 0
	 };

	 const render = {
		 frame: 0,
		 calls: 0,
		 triangles: 0,
		 points: 0,
		 lines: 0
	 };

	 function update( count, mode, instanceCount ) {

		 render.calls ++;

		 switch ( mode ) {

			 case 4:
				 render.triangles += instanceCount * ( count / 3 );
				 break;

			 case 1:
				 render.lines += instanceCount * ( count / 2 );
				 break;

			 case 3:
				 render.lines += instanceCount * ( count - 1 );
				 break;

			 case 2:
				 render.lines += instanceCount * count;
				 break;

			 case 0:
				 render.points += instanceCount * count;
				 break;

			 default:
				 console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				 break;

		 }

	 }

	 function reset() {

		 render.frame ++;
		 render.calls = 0;
		 render.triangles = 0;
		 render.points = 0;
		 render.lines = 0;

	 }

	 return {
		 memory: memory,
		 render: render,
		 programs: null,
		 autoReset: true,
		 reset: reset,
		 update: update
	 };

 }

 function numericalSort( a, b ) {

	 return a[ 0 ] - b[ 0 ];

 }

 function absNumericalSort( a, b ) {

	 return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

 }

 function WebGLMorphtargets( gl ) {

	 const influencesList = {};
	 const morphInfluences = new Float32Array( 8 );

	 const workInfluences = [];

	 for ( let i = 0; i < 8; i ++ ) {

		 workInfluences[ i ] = [ i, 0 ];

	 }

	 function update( object, geometry, material, program ) {

		 const objectInfluences = object.morphTargetInfluences;

		 // When object doesn't have morph target influences defined, we treat it as a 0-length array
		 // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		 const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		 let influences = influencesList[ geometry.id ];

		 if ( influences === undefined || influences.length !== length ) {

			 // initialise list

			 influences = [];

			 for ( let i = 0; i < length; i ++ ) {

				 influences[ i ] = [ i, 0 ];

			 }

			 influencesList[ geometry.id ] = influences;

		 }

		 // Collect influences

		 for ( let i = 0; i < length; i ++ ) {

			 const influence = influences[ i ];

			 influence[ 0 ] = i;
			 influence[ 1 ] = objectInfluences[ i ];

		 }

		 influences.sort( absNumericalSort );

		 for ( let i = 0; i < 8; i ++ ) {

			 if ( i < length && influences[ i ][ 1 ] ) {

				 workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
				 workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

			 } else {

				 workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
				 workInfluences[ i ][ 1 ] = 0;

			 }

		 }

		 workInfluences.sort( numericalSort );

		 const morphTargets = material.morphTargets && geometry.morphAttributes.position;
		 const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		 let morphInfluencesSum = 0;

		 for ( let i = 0; i < 8; i ++ ) {

			 const influence = workInfluences[ i ];
			 const index = influence[ 0 ];
			 const value = influence[ 1 ];

			 if ( index !== Number.MAX_SAFE_INTEGER && value ) {

				 if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

					 geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

				 }

				 if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

					 geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

				 }

				 morphInfluences[ i ] = value;
				 morphInfluencesSum += value;

			 } else {

				 if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

					 geometry.deleteAttribute( 'morphTarget' + i );

				 }

				 if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

					 geometry.deleteAttribute( 'morphNormal' + i );

				 }

				 morphInfluences[ i ] = 0;

			 }

		 }

		 // GLSL shader uses formula baseinfluence * base + sum(target * influence)
		 // This allows us to switch between absolute morphs and relative morphs without changing shader code
		 // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		 const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		 program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		 program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	 }

	 return {

		 update: update

	 };

 }

 function WebGLObjects( gl, geometries, attributes, info ) {

	 let updateMap = new WeakMap();

	 function update( object ) {

		 const frame = info.render.frame;

		 const geometry = object.geometry;
		 const buffergeometry = geometries.get( object, geometry );

		 // Update once per frame

		 if ( updateMap.get( buffergeometry ) !== frame ) {

			 geometries.update( buffergeometry );

			 updateMap.set( buffergeometry, frame );

		 }

		 if ( object.isInstancedMesh ) {

			 if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				 object.addEventListener( 'dispose', onInstancedMeshDispose );

			 }

			 attributes.update( object.instanceMatrix, 34962 );

			 if ( object.instanceColor !== null ) {

				 attributes.update( object.instanceColor, 34962 );

			 }

		 }

		 return buffergeometry;

	 }

	 function dispose() {

		 updateMap = new WeakMap();

	 }

	 function onInstancedMeshDispose( event ) {

		 const instancedMesh = event.target;

		 instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		 attributes.remove( instancedMesh.instanceMatrix );

		 if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	 }

	 return {

		 update: update,
		 dispose: dispose

	 };

 }

 class DataTexture2DArray extends Texture {

	 constructor( data = null, width = 1, height = 1, depth = 1 ) {

		 super( null );

		 this.image = { data, width, height, depth };

		 this.magFilter = NearestFilter;
		 this.minFilter = NearestFilter;

		 this.wrapR = ClampToEdgeWrapping;

		 this.generateMipmaps = false;
		 this.flipY = false;
		 this.unpackAlignment = 1;

		 this.needsUpdate = true;

	 }

 }

 DataTexture2DArray.prototype.isDataTexture2DArray = true;

 class DataTexture3D extends Texture {

	 constructor( data = null, width = 1, height = 1, depth = 1 ) {

		 // We're going to add .setXXX() methods for setting properties later.
		 // Users can still set in DataTexture3D directly.
		 //
		 //	const texture = new THREE.DataTexture3D( data, width, height, depth );
		 // 	texture.anisotropy = 16;
		 //
		 // See #14839

		 super( null );

		 this.image = { data, width, height, depth };

		 this.magFilter = NearestFilter;
		 this.minFilter = NearestFilter;

		 this.wrapR = ClampToEdgeWrapping;

		 this.generateMipmaps = false;
		 this.flipY = false;
		 this.unpackAlignment = 1;

		 this.needsUpdate = true;

	 }

 }

 DataTexture3D.prototype.isDataTexture3D = true;

 /**
	* Uniforms of a program.
	* Those form a tree structure with a special top-level container for the root,
	* which you get by calling 'new WebGLUniforms( gl, program )'.
	*
	*
	* Properties of inner nodes including the top-level container:
	*
	* .seq - array of nested uniforms
	* .map - nested uniforms by name
	*
	*
	* Methods of all nodes except the top-level container:
	*
	* .setValue( gl, value, [textures] )
	*
	* 		uploads a uniform value(s)
	*  	the 'textures' parameter is needed for sampler uniforms
	*
	*
	* Static methods of the top-level container (textures factorizations):
	*
	* .upload( gl, seq, values, textures )
	*
	* 		sets uniforms in 'seq' to 'values[id].value'
	*
	* .seqWithValue( seq, values ) : filteredSeq
	*
	* 		filters 'seq' entries with corresponding entry in values
	*
	*
	* Methods of the top-level container (textures factorizations):
	*
	* .setValue( gl, name, value, textures )
	*
	* 		sets uniform with  name 'name' to 'value'
	*
	* .setOptional( gl, obj, prop )
	*
	* 		like .set for an optional property of the object
	*
	*/

 const emptyTexture = new Texture();
 const emptyTexture2dArray = new DataTexture2DArray();
 const emptyTexture3d = new DataTexture3D();
 const emptyCubeTexture = new CubeTexture();

 // --- Utilities ---

 // Array Caches (provide typed arrays for temporary by size)

 const arrayCacheF32 = [];
 const arrayCacheI32 = [];

 // Float32Array caches used for uploading Matrix uniforms

 const mat4array = new Float32Array( 16 );
 const mat3array = new Float32Array( 9 );
 const mat2array = new Float32Array( 4 );

 // Flattening for arrays of vectors and matrices

 function flatten( array, nBlocks, blockSize ) {

	 const firstElem = array[ 0 ];

	 if ( firstElem <= 0 || firstElem > 0 ) return array;
	 // unoptimized: ! isNaN( firstElem )
	 // see http://jacksondunstan.com/articles/983

	 const n = nBlocks * blockSize;
	 let r = arrayCacheF32[ n ];

	 if ( r === undefined ) {

		 r = new Float32Array( n );
		 arrayCacheF32[ n ] = r;

	 }

	 if ( nBlocks !== 0 ) {

		 firstElem.toArray( r, 0 );

		 for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			 offset += blockSize;
			 array[ i ].toArray( r, offset );

		 }

	 }

	 return r;

 }

 function arraysEqual( a, b ) {

	 if ( a.length !== b.length ) return false;

	 for ( let i = 0, l = a.length; i < l; i ++ ) {

		 if ( a[ i ] !== b[ i ] ) return false;

	 }

	 return true;

 }

 function copyArray( a, b ) {

	 for ( let i = 0, l = b.length; i < l; i ++ ) {

		 a[ i ] = b[ i ];

	 }

 }

 // Texture unit allocation

 function allocTexUnits( textures, n ) {

	 let r = arrayCacheI32[ n ];

	 if ( r === undefined ) {

		 r = new Int32Array( n );
		 arrayCacheI32[ n ] = r;

	 }

	 for ( let i = 0; i !== n; ++ i ) {

		 r[ i ] = textures.allocateTextureUnit();

	 }

	 return r;

 }

 // --- Setters ---

 // Note: Defining these methods externally, because they come in a bunch
 // and this way their names minify.

 // Single scalar

 function setValueV1f( gl, v ) {

	 const cache = this.cache;

	 if ( cache[ 0 ] === v ) return;

	 gl.uniform1f( this.addr, v );

	 cache[ 0 ] = v;

 }

 // Single float vector (from flat array or THREE.VectorN)

 function setValueV2f( gl, v ) {

	 const cache = this.cache;

	 if ( v.x !== undefined ) {

		 if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			 gl.uniform2f( this.addr, v.x, v.y );

			 cache[ 0 ] = v.x;
			 cache[ 1 ] = v.y;

		 }

	 } else {

		 if ( arraysEqual( cache, v ) ) return;

		 gl.uniform2fv( this.addr, v );

		 copyArray( cache, v );

	 }

 }

 function setValueV3f( gl, v ) {

	 const cache = this.cache;

	 if ( v.x !== undefined ) {

		 if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			 gl.uniform3f( this.addr, v.x, v.y, v.z );

			 cache[ 0 ] = v.x;
			 cache[ 1 ] = v.y;
			 cache[ 2 ] = v.z;

		 }

	 } else if ( v.r !== undefined ) {

		 if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			 gl.uniform3f( this.addr, v.r, v.g, v.b );

			 cache[ 0 ] = v.r;
			 cache[ 1 ] = v.g;
			 cache[ 2 ] = v.b;

		 }

	 } else {

		 if ( arraysEqual( cache, v ) ) return;

		 gl.uniform3fv( this.addr, v );

		 copyArray( cache, v );

	 }

 }

 function setValueV4f( gl, v ) {

	 const cache = this.cache;

	 if ( v.x !== undefined ) {

		 if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			 gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			 cache[ 0 ] = v.x;
			 cache[ 1 ] = v.y;
			 cache[ 2 ] = v.z;
			 cache[ 3 ] = v.w;

		 }

	 } else {

		 if ( arraysEqual( cache, v ) ) return;

		 gl.uniform4fv( this.addr, v );

		 copyArray( cache, v );

	 }

 }

 // Single matrix (from flat array or THREE.MatrixN)

 function setValueM2( gl, v ) {

	 const cache = this.cache;
	 const elements = v.elements;

	 if ( elements === undefined ) {

		 if ( arraysEqual( cache, v ) ) return;

		 gl.uniformMatrix2fv( this.addr, false, v );

		 copyArray( cache, v );

	 } else {

		 if ( arraysEqual( cache, elements ) ) return;

		 mat2array.set( elements );

		 gl.uniformMatrix2fv( this.addr, false, mat2array );

		 copyArray( cache, elements );

	 }

 }

 function setValueM3( gl, v ) {

	 const cache = this.cache;
	 const elements = v.elements;

	 if ( elements === undefined ) {

		 if ( arraysEqual( cache, v ) ) return;

		 gl.uniformMatrix3fv( this.addr, false, v );

		 copyArray( cache, v );

	 } else {

		 if ( arraysEqual( cache, elements ) ) return;

		 mat3array.set( elements );

		 gl.uniformMatrix3fv( this.addr, false, mat3array );

		 copyArray( cache, elements );

	 }

 }

 function setValueM4( gl, v ) {

	 const cache = this.cache;
	 const elements = v.elements;

	 if ( elements === undefined ) {

		 if ( arraysEqual( cache, v ) ) return;

		 gl.uniformMatrix4fv( this.addr, false, v );

		 copyArray( cache, v );

	 } else {

		 if ( arraysEqual( cache, elements ) ) return;

		 mat4array.set( elements );

		 gl.uniformMatrix4fv( this.addr, false, mat4array );

		 copyArray( cache, elements );

	 }

 }

 // Single integer / boolean

 function setValueV1i( gl, v ) {

	 const cache = this.cache;

	 if ( cache[ 0 ] === v ) return;

	 gl.uniform1i( this.addr, v );

	 cache[ 0 ] = v;

 }

 // Single integer / boolean vector (from flat array)

 function setValueV2i( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual( cache, v ) ) return;

	 gl.uniform2iv( this.addr, v );

	 copyArray( cache, v );

 }

 function setValueV3i( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual( cache, v ) ) return;

	 gl.uniform3iv( this.addr, v );

	 copyArray( cache, v );

 }

 function setValueV4i( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual( cache, v ) ) return;

	 gl.uniform4iv( this.addr, v );

	 copyArray( cache, v );

 }

 // Single unsigned integer

 function setValueV1ui( gl, v ) {

	 const cache = this.cache;

	 if ( cache[ 0 ] === v ) return;

	 gl.uniform1ui( this.addr, v );

	 cache[ 0 ] = v;

 }

 // Single unsigned integer vector (from flat array)

 function setValueV2ui( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual( cache, v ) ) return;

	 gl.uniform2uiv( this.addr, v );

	 copyArray( cache, v );

 }

 function setValueV3ui( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual( cache, v ) ) return;

	 gl.uniform3uiv( this.addr, v );

	 copyArray( cache, v );

 }

 function setValueV4ui( gl, v ) {

	 const cache = this.cache;

	 if ( arraysEqual( cache, v ) ) return;

	 gl.uniform4uiv( this.addr, v );

	 copyArray( cache, v );

 }


 // Single texture (2D / Cube)

 function setValueT1( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.safeSetTexture2D( v || emptyTexture, unit );

 }

 function setValueT3D1( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.setTexture3D( v || emptyTexture3d, unit );

 }

 function setValueT6( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.safeSetTextureCube( v || emptyCubeTexture, unit );

 }

 function setValueT2DArray1( gl, v, textures ) {

	 const cache = this.cache;
	 const unit = textures.allocateTextureUnit();

	 if ( cache[ 0 ] !== unit ) {

		 gl.uniform1i( this.addr, unit );
		 cache[ 0 ] = unit;

	 }

	 textures.setTexture2DArray( v || emptyTexture2dArray, unit );

 }

 // Helper to pick the right setter for the singular case

 function getSingularSetter( type ) {

	 switch ( type ) {

		 case 0x1406: return setValueV1f; // FLOAT
		 case 0x8b50: return setValueV2f; // _VEC2
		 case 0x8b51: return setValueV3f; // _VEC3
		 case 0x8b52: return setValueV4f; // _VEC4

		 case 0x8b5a: return setValueM2; // _MAT2
		 case 0x8b5b: return setValueM3; // _MAT3
		 case 0x8b5c: return setValueM4; // _MAT4

		 case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		 case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		 case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		 case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		 case 0x1405: return setValueV1ui; // UINT
		 case 0x8dc6: return setValueV2ui; // _VEC2
		 case 0x8dc7: return setValueV3ui; // _VEC3
		 case 0x8dc8: return setValueV4ui; // _VEC4

		 case 0x8b5e: // SAMPLER_2D
		 case 0x8d66: // SAMPLER_EXTERNAL_OES
		 case 0x8dca: // INT_SAMPLER_2D
		 case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		 case 0x8b62: // SAMPLER_2D_SHADOW
			 return setValueT1;

		 case 0x8b5f: // SAMPLER_3D
		 case 0x8dcb: // INT_SAMPLER_3D
		 case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			 return setValueT3D1;

		 case 0x8b60: // SAMPLER_CUBE
		 case 0x8dcc: // INT_SAMPLER_CUBE
		 case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		 case 0x8dc5: // SAMPLER_CUBE_SHADOW
			 return setValueT6;

		 case 0x8dc1: // SAMPLER_2D_ARRAY
		 case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		 case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		 case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			 return setValueT2DArray1;

	 }

 }


 // Array of scalars

 function setValueV1fArray( gl, v ) {

	 gl.uniform1fv( this.addr, v );

 }

 // Array of vectors (from flat array or array of THREE.VectorN)

 function setValueV2fArray( gl, v ) {

	 const data = flatten( v, this.size, 2 );

	 gl.uniform2fv( this.addr, data );

 }

 function setValueV3fArray( gl, v ) {

	 const data = flatten( v, this.size, 3 );

	 gl.uniform3fv( this.addr, data );

 }

 function setValueV4fArray( gl, v ) {

	 const data = flatten( v, this.size, 4 );

	 gl.uniform4fv( this.addr, data );

 }

 // Array of matrices (from flat array or array of THREE.MatrixN)

 function setValueM2Array( gl, v ) {

	 const data = flatten( v, this.size, 4 );

	 gl.uniformMatrix2fv( this.addr, false, data );

 }

 function setValueM3Array( gl, v ) {

	 const data = flatten( v, this.size, 9 );

	 gl.uniformMatrix3fv( this.addr, false, data );

 }

 function setValueM4Array( gl, v ) {

	 const data = flatten( v, this.size, 16 );

	 gl.uniformMatrix4fv( this.addr, false, data );

 }

 // Array of integer / boolean

 function setValueV1iArray( gl, v ) {

	 gl.uniform1iv( this.addr, v );

 }

 // Array of integer / boolean vectors (from flat array)

 function setValueV2iArray( gl, v ) {

	 gl.uniform2iv( this.addr, v );

 }

 function setValueV3iArray( gl, v ) {

	 gl.uniform3iv( this.addr, v );

 }

 function setValueV4iArray( gl, v ) {

	 gl.uniform4iv( this.addr, v );

 }

 // Array of unsigned integer

 function setValueV1uiArray( gl, v ) {

	 gl.uniform1uiv( this.addr, v );

 }

 // Array of unsigned integer vectors (from flat array)

 function setValueV2uiArray( gl, v ) {

	 gl.uniform2uiv( this.addr, v );

 }

 function setValueV3uiArray( gl, v ) {

	 gl.uniform3uiv( this.addr, v );

 }

 function setValueV4uiArray( gl, v ) {

	 gl.uniform4uiv( this.addr, v );

 }


 // Array of textures (2D / Cube)

 function setValueT1Array( gl, v, textures ) {

	 const n = v.length;

	 const units = allocTexUnits( textures, n );

	 gl.uniform1iv( this.addr, units );

	 for ( let i = 0; i !== n; ++ i ) {

		 textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	 }

 }

 function setValueT6Array( gl, v, textures ) {

	 const n = v.length;

	 const units = allocTexUnits( textures, n );

	 gl.uniform1iv( this.addr, units );

	 for ( let i = 0; i !== n; ++ i ) {

		 textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	 }

 }

 // Helper to pick the right setter for a pure (bottom-level) array

 function getPureArraySetter( type ) {

	 switch ( type ) {

		 case 0x1406: return setValueV1fArray; // FLOAT
		 case 0x8b50: return setValueV2fArray; // _VEC2
		 case 0x8b51: return setValueV3fArray; // _VEC3
		 case 0x8b52: return setValueV4fArray; // _VEC4

		 case 0x8b5a: return setValueM2Array; // _MAT2
		 case 0x8b5b: return setValueM3Array; // _MAT3
		 case 0x8b5c: return setValueM4Array; // _MAT4

		 case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		 case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		 case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		 case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		 case 0x1405: return setValueV1uiArray; // UINT
		 case 0x8dc6: return setValueV2uiArray; // _VEC2
		 case 0x8dc7: return setValueV3uiArray; // _VEC3
		 case 0x8dc8: return setValueV4uiArray; // _VEC4

		 case 0x8b5e: // SAMPLER_2D
		 case 0x8d66: // SAMPLER_EXTERNAL_OES
		 case 0x8dca: // INT_SAMPLER_2D
		 case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		 case 0x8b62: // SAMPLER_2D_SHADOW
			 return setValueT1Array;

		 case 0x8b60: // SAMPLER_CUBE
		 case 0x8dcc: // INT_SAMPLER_CUBE
		 case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		 case 0x8dc5: // SAMPLER_CUBE_SHADOW
			 return setValueT6Array;

	 }

 }

 // --- Uniform Classes ---

 function SingleUniform( id, activeInfo, addr ) {

	 this.id = id;
	 this.addr = addr;
	 this.cache = [];
	 this.setValue = getSingularSetter( activeInfo.type );

	 // this.path = activeInfo.name; // DEBUG

 }

 function PureArrayUniform( id, activeInfo, addr ) {

	 this.id = id;
	 this.addr = addr;
	 this.cache = [];
	 this.size = activeInfo.size;
	 this.setValue = getPureArraySetter( activeInfo.type );

	 // this.path = activeInfo.name; // DEBUG

 }

 PureArrayUniform.prototype.updateCache = function ( data ) {

	 const cache = this.cache;

	 if ( data instanceof Float32Array && cache.length !== data.length ) {

		 this.cache = new Float32Array( data.length );

	 }

	 copyArray( cache, data );

 };

 function StructuredUniform( id ) {

	 this.id = id;

	 this.seq = [];
	 this.map = {};

 }

 StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	 const seq = this.seq;

	 for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		 const u = seq[ i ];
		 u.setValue( gl, value[ u.id ], textures );

	 }

 };

 // --- Top-level ---

 // Parser - builds up the property tree from the path strings

 const RePathPart = /(\w+)(\])?(\[|\.)?/g;

 // extracts
 // 	- the identifier (member name or array index)
 //  - followed by an optional right bracket (found when array index)
 //  - followed by an optional left bracket or dot (type of subscript)
 //
 // Note: These portions can be read in a non-overlapping fashion and
 // allow straightforward parsing of the hierarchy that WebGL encodes
 // in the uniform names.

 function addUniform( container, uniformObject ) {

	 container.seq.push( uniformObject );
	 container.map[ uniformObject.id ] = uniformObject;

 }

 function parseUniform( activeInfo, addr, container ) {

	 const path = activeInfo.name,
		 pathLength = path.length;

	 // reset RegExp object, because of the early exit of a previous run
	 RePathPart.lastIndex = 0;

	 while ( true ) {

		 const match = RePathPart.exec( path ),
			 matchEnd = RePathPart.lastIndex;

		 let id = match[ 1 ];
		 const idIsIndex = match[ 2 ] === ']',
			 subscript = match[ 3 ];

		 if ( idIsIndex ) id = id | 0; // convert to integer

		 if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			 // bare name or "pure" bottom-level array "[0]" suffix

			 addUniform( container, subscript === undefined ?
				 new SingleUniform( id, activeInfo, addr ) :
				 new PureArrayUniform( id, activeInfo, addr ) );

			 break;

		 } else {

			 // step into inner node / create it in case it doesn't exist

			 const map = container.map;
			 let next = map[ id ];

			 if ( next === undefined ) {

				 next = new StructuredUniform( id );
				 addUniform( container, next );

			 }

			 container = next;

		 }

	 }

 }

 // Root Container

 function WebGLUniforms( gl, program ) {

	 this.seq = [];
	 this.map = {};

	 const n = gl.getProgramParameter( program, 35718 );

	 for ( let i = 0; i < n; ++ i ) {

		 const info = gl.getActiveUniform( program, i ),
			 addr = gl.getUniformLocation( program, info.name );

		 parseUniform( info, addr, this );

	 }

 }

 WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	 const u = this.map[ name ];

	 if ( u !== undefined ) u.setValue( gl, value, textures );

 };

 WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	 const v = object[ name ];

	 if ( v !== undefined ) this.setValue( gl, name, v );

 };


 // Static interface

 WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	 for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		 const u = seq[ i ],
			 v = values[ u.id ];

		 if ( v.needsUpdate !== false ) {

			 // note: always updating when .needsUpdate is undefined
			 u.setValue( gl, v.value, textures );

		 }

	 }

 };

 WebGLUniforms.seqWithValue = function ( seq, values ) {

	 const r = [];

	 for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		 const u = seq[ i ];
		 if ( u.id in values ) r.push( u );

	 }

	 return r;

 };

 function WebGLShader( gl, type, string ) {

	 const shader = gl.createShader( type );

	 gl.shaderSource( shader, string );
	 gl.compileShader( shader );

	 return shader;

 }

 let programIdCount = 0;

 function addLineNumbers( string ) {

	 const lines = string.split( '\n' );

	 for ( let i = 0; i < lines.length; i ++ ) {

		 lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	 }

	 return lines.join( '\n' );

 }

 function getEncodingComponents( encoding ) {

	 switch ( encoding ) {

		 case LinearEncoding:
			 return [ 'Linear', '( value )' ];
		 case sRGBEncoding:
			 return [ 'sRGB', '( value )' ];
		 case RGBEEncoding:
			 return [ 'RGBE', '( value )' ];
		 case RGBM7Encoding:
			 return [ 'RGBM', '( value, 7.0 )' ];
		 case RGBM16Encoding:
			 return [ 'RGBM', '( value, 16.0 )' ];
		 case RGBDEncoding:
			 return [ 'RGBD', '( value, 256.0 )' ];
		 case GammaEncoding:
			 return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		 case LogLuvEncoding:
			 return [ 'LogLuv', '( value )' ];
		 default:
			 console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			 return [ 'Linear', '( value )' ];

	 }

 }

 function getShaderErrors( gl, shader, type ) {

	 const status = gl.getShaderParameter( shader, 35713 );
	 const log = gl.getShaderInfoLog( shader ).trim();

	 if ( status && log === '' ) return '';

	 // --enable-privileged-webgl-extension
	 // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	 const source = gl.getShaderSource( shader );

	 return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

 }

 function getTexelDecodingFunction( functionName, encoding ) {

	 const components = getEncodingComponents( encoding );
	 return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

 }

 function getTexelEncodingFunction( functionName, encoding ) {

	 const components = getEncodingComponents( encoding );
	 return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

 }

 function getToneMappingFunction( functionName, toneMapping ) {

	 let toneMappingName;

	 switch ( toneMapping ) {

		 case LinearToneMapping:
			 toneMappingName = 'Linear';
			 break;

		 case ReinhardToneMapping:
			 toneMappingName = 'Reinhard';
			 break;

		 case CineonToneMapping:
			 toneMappingName = 'OptimizedCineon';
			 break;

		 case ACESFilmicToneMapping:
			 toneMappingName = 'ACESFilmic';
			 break;

		 case CustomToneMapping:
			 toneMappingName = 'Custom';
			 break;

		 default:
			 console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			 toneMappingName = 'Linear';

	 }

	 return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

 }

 function generateExtensions( parameters ) {

	 const chunks = [
		 ( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		 ( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		 ( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		 ( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0 ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	 ];

	 return chunks.filter( filterEmptyLine ).join( '\n' );

 }

 function generateDefines( defines ) {

	 const chunks = [];

	 for ( const name in defines ) {

		 const value = defines[ name ];

		 if ( value === false ) continue;

		 chunks.push( '#define ' + name + ' ' + value );

	 }

	 return chunks.join( '\n' );

 }

 function fetchAttributeLocations( gl, program ) {

	 const attributes = {};

	 const n = gl.getProgramParameter( program, 35721 );

	 for ( let i = 0; i < n; i ++ ) {

		 const info = gl.getActiveAttrib( program, i );
		 const name = info.name;

		 // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		 attributes[ name ] = gl.getAttribLocation( program, name );

	 }

	 return attributes;

 }

 function filterEmptyLine( string ) {

	 return string !== '';

 }

 function replaceLightNums( string, parameters ) {

	 return string
		 .replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		 .replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		 .replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		 .replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		 .replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		 .replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		 .replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		 .replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

 }

 function replaceClippingPlaneNums( string, parameters ) {

	 return string
		 .replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		 .replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

 }

 // Resolve Includes

 const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

 function resolveIncludes( string ) {

	 return string.replace( includePattern, includeReplacer );

 }

 function includeReplacer( match, include ) {

	 const string = ShaderChunk[ include ];

	 if ( string === undefined ) {

		 throw new Error( 'Can not resolve #include <' + include + '>' );

	 }

	 return resolveIncludes( string );

 }

 // Unroll Loops

 const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
 const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

 function unrollLoops( string ) {

	 return string
		 .replace( unrollLoopPattern, loopReplacer )
		 .replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

 }

 function deprecatedLoopReplacer( match, start, end, snippet ) {

	 console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	 return loopReplacer( match, start, end, snippet );

 }

 function loopReplacer( match, start, end, snippet ) {

	 let string = '';

	 for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		 string += snippet
			 .replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			 .replace( /UNROLLED_LOOP_INDEX/g, i );

	 }

	 return string;

 }

 //

 function generatePrecision( parameters ) {

	 let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	 if ( parameters.precision === 'highp' ) {

		 precisionstring += '\n#define HIGH_PRECISION';

	 } else if ( parameters.precision === 'mediump' ) {

		 precisionstring += '\n#define MEDIUM_PRECISION';

	 } else if ( parameters.precision === 'lowp' ) {

		 precisionstring += '\n#define LOW_PRECISION';

	 }

	 return precisionstring;

 }

 function generateShadowMapTypeDefine( parameters ) {

	 let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	 if ( parameters.shadowMapType === PCFShadowMap ) {

		 shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	 } else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		 shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	 } else if ( parameters.shadowMapType === VSMShadowMap ) {

		 shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	 }

	 return shadowMapTypeDefine;

 }

 function generateEnvMapTypeDefine( parameters ) {

	 let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	 if ( parameters.envMap ) {

		 switch ( parameters.envMapMode ) {

			 case CubeReflectionMapping:
			 case CubeRefractionMapping:
				 envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				 break;

			 case CubeUVReflectionMapping:
			 case CubeUVRefractionMapping:
				 envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				 break;

		 }

	 }

	 return envMapTypeDefine;

 }

 function generateEnvMapModeDefine( parameters ) {

	 let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	 if ( parameters.envMap ) {

		 switch ( parameters.envMapMode ) {

			 case CubeRefractionMapping:
			 case CubeUVRefractionMapping:

				 envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				 break;

		 }

	 }

	 return envMapModeDefine;

 }

 function generateEnvMapBlendingDefine( parameters ) {

	 let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	 if ( parameters.envMap ) {

		 switch ( parameters.combine ) {

			 case MultiplyOperation:
				 envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				 break;

			 case MixOperation:
				 envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				 break;

			 case AddOperation:
				 envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				 break;

		 }

	 }

	 return envMapBlendingDefine;

 }

 function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	 const gl = renderer.getContext();

	 const defines = parameters.defines;

	 let vertexShader = parameters.vertexShader;
	 let fragmentShader = parameters.fragmentShader;

	 const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	 const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	 const envMapModeDefine = generateEnvMapModeDefine( parameters );
	 const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	 const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	 const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	 const customDefines = generateDefines( defines );

	 const program = gl.createProgram();

	 let prefixVertex, prefixFragment;
	 let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	 if ( parameters.isRawShaderMaterial ) {

		 prefixVertex = [

			 customDefines

		 ].filter( filterEmptyLine ).join( '\n' );

		 if ( prefixVertex.length > 0 ) {

			 prefixVertex += '\n';

		 }

		 prefixFragment = [

			 customExtensions,
			 customDefines

		 ].filter( filterEmptyLine ).join( '\n' );

		 if ( prefixFragment.length > 0 ) {

			 prefixFragment += '\n';

		 }

	 } else {

		 prefixVertex = [

			 generatePrecision( parameters ),

			 '#define SHADER_NAME ' + parameters.shaderName,

			 customDefines,

			 parameters.instancing ? '#define USE_INSTANCING' : '',
			 parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			 parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			 '#define GAMMA_FACTOR ' + gammaFactorDefine,

			 '#define MAX_BONES ' + parameters.maxBones,
			 ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			 ( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			 parameters.map ? '#define USE_MAP' : '',
			 parameters.envMap ? '#define USE_ENVMAP' : '',
			 parameters.envMap ? '#define ' + envMapModeDefine : '',
			 parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			 parameters.aoMap ? '#define USE_AOMAP' : '',
			 parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			 parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			 parameters.normalMap ? '#define USE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			 parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			 parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			 parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			 parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			 parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			 parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			 parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			 parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			 parameters.transmission ? '#define USE_TRANSMISSION' : '',
			 parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			 parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			 parameters.vertexTangents ? '#define USE_TANGENT' : '',
			 parameters.vertexColors ? '#define USE_COLOR' : '',
			 parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			 parameters.vertexUvs ? '#define USE_UV' : '',
			 parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			 parameters.flatShading ? '#define FLAT_SHADED' : '',

			 parameters.skinning ? '#define USE_SKINNING' : '',
			 parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			 parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			 parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			 parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			 parameters.flipSided ? '#define FLIP_SIDED' : '',

			 parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			 parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			 parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			 parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			 ( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			 'uniform mat4 modelMatrix;',
			 'uniform mat4 modelViewMatrix;',
			 'uniform mat4 projectionMatrix;',
			 'uniform mat4 viewMatrix;',
			 'uniform mat3 normalMatrix;',
			 'uniform vec3 cameraPosition;',
			 'uniform bool isOrthographic;',

			 '#ifdef USE_INSTANCING',

			 '	attribute mat4 instanceMatrix;',

			 '#endif',

			 '#ifdef USE_INSTANCING_COLOR',

			 '	attribute vec3 instanceColor;',

			 '#endif',

			 'attribute vec3 position;',
			 'attribute vec3 normal;',
			 'attribute vec2 uv;',

			 '#ifdef USE_TANGENT',

			 '	attribute vec4 tangent;',

			 '#endif',

			 '#if defined( USE_COLOR_ALPHA )',

			 '	attribute vec4 color;',

			 '#elif defined( USE_COLOR )',

			 '	attribute vec3 color;',

			 '#endif',

			 '#ifdef USE_MORPHTARGETS',

			 '	attribute vec3 morphTarget0;',
			 '	attribute vec3 morphTarget1;',
			 '	attribute vec3 morphTarget2;',
			 '	attribute vec3 morphTarget3;',

			 '	#ifdef USE_MORPHNORMALS',

			 '		attribute vec3 morphNormal0;',
			 '		attribute vec3 morphNormal1;',
			 '		attribute vec3 morphNormal2;',
			 '		attribute vec3 morphNormal3;',

			 '	#else',

			 '		attribute vec3 morphTarget4;',
			 '		attribute vec3 morphTarget5;',
			 '		attribute vec3 morphTarget6;',
			 '		attribute vec3 morphTarget7;',

			 '	#endif',

			 '#endif',

			 '#ifdef USE_SKINNING',

			 '	attribute vec4 skinIndex;',
			 '	attribute vec4 skinWeight;',

			 '#endif',

			 '\n'

		 ].filter( filterEmptyLine ).join( '\n' );

		 prefixFragment = [

			 customExtensions,

			 generatePrecision( parameters ),

			 '#define SHADER_NAME ' + parameters.shaderName,

			 customDefines,

			 parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			 '#define GAMMA_FACTOR ' + gammaFactorDefine,

			 ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			 ( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			 parameters.map ? '#define USE_MAP' : '',
			 parameters.matcap ? '#define USE_MATCAP' : '',
			 parameters.envMap ? '#define USE_ENVMAP' : '',
			 parameters.envMap ? '#define ' + envMapTypeDefine : '',
			 parameters.envMap ? '#define ' + envMapModeDefine : '',
			 parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			 parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			 parameters.aoMap ? '#define USE_AOMAP' : '',
			 parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			 parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			 parameters.normalMap ? '#define USE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			 ( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			 parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			 parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			 parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			 parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			 parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			 parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			 parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			 parameters.sheen ? '#define USE_SHEEN' : '',
			 parameters.transmission ? '#define USE_TRANSMISSION' : '',
			 parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			 parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			 parameters.vertexTangents ? '#define USE_TANGENT' : '',
			 parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			 parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			 parameters.vertexUvs ? '#define USE_UV' : '',
			 parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			 parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			 parameters.flatShading ? '#define FLAT_SHADED' : '',

			 parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			 parameters.flipSided ? '#define FLIP_SIDED' : '',

			 parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			 parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			 parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			 parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			 parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			 ( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			 ( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			 'uniform mat4 viewMatrix;',
			 'uniform vec3 cameraPosition;',
			 'uniform bool isOrthographic;',

			 ( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			 ( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			 ( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			 parameters.dithering ? '#define DITHERING' : '',

			 ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			 parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			 parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			 parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			 parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			 parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			 getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			 parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			 '\n'

		 ].filter( filterEmptyLine ).join( '\n' );

	 }

	 vertexShader = resolveIncludes( vertexShader );
	 vertexShader = replaceLightNums( vertexShader, parameters );
	 vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	 fragmentShader = resolveIncludes( fragmentShader );
	 fragmentShader = replaceLightNums( fragmentShader, parameters );
	 fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	 vertexShader = unrollLoops( vertexShader );
	 fragmentShader = unrollLoops( fragmentShader );

	 if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		 // GLSL 3.0 conversion for built-in materials and ShaderMaterial

		 versionString = '#version 300 es\n';

		 prefixVertex = [
			 '#define attribute in',
			 '#define varying out',
			 '#define texture2D texture'
		 ].join( '\n' ) + '\n' + prefixVertex;

		 prefixFragment = [
			 '#define varying in',
			 ( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
			 ( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			 '#define gl_FragDepthEXT gl_FragDepth',
			 '#define texture2D texture',
			 '#define textureCube texture',
			 '#define texture2DProj textureProj',
			 '#define texture2DLodEXT textureLod',
			 '#define texture2DProjLodEXT textureProjLod',
			 '#define textureCubeLodEXT textureLod',
			 '#define texture2DGradEXT textureGrad',
			 '#define texture2DProjGradEXT textureProjGrad',
			 '#define textureCubeGradEXT textureGrad'
		 ].join( '\n' ) + '\n' + prefixFragment;

	 }

	 const vertexGlsl = versionString + prefixVertex + vertexShader;
	 const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	 // console.log( '*VERTEX*', vertexGlsl );
	 // console.log( '*FRAGMENT*', fragmentGlsl );

	 const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	 const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	 gl.attachShader( program, glVertexShader );
	 gl.attachShader( program, glFragmentShader );

	 // Force a particular attribute to index 0.

	 if ( parameters.index0AttributeName !== undefined ) {

		 gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	 } else if ( parameters.morphTargets === true ) {

		 // programs with morphTargets displace position out of attribute 0
		 gl.bindAttribLocation( program, 0, 'position' );

	 }

	 gl.linkProgram( program );

	 // check for link errors
	 if ( renderer.debug.checkShaderErrors ) {

		 const programLog = gl.getProgramInfoLog( program ).trim();
		 const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		 const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		 let runnable = true;
		 let haveDiagnostics = true;

		 if ( gl.getProgramParameter( program, 35714 ) === false ) {

			 runnable = false;

			 const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			 const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			 console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		 } else if ( programLog !== '' ) {

			 console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		 } else if ( vertexLog === '' || fragmentLog === '' ) {

			 haveDiagnostics = false;

		 }

		 if ( haveDiagnostics ) {

			 this.diagnostics = {

				 runnable: runnable,

				 programLog: programLog,

				 vertexShader: {

					 log: vertexLog,
					 prefix: prefixVertex

				 },

				 fragmentShader: {

					 log: fragmentLog,
					 prefix: prefixFragment

				 }

			 };

		 }

	 }

	 // Clean up

	 // Crashes in iOS9 and iOS10. #18402
	 // gl.detachShader( program, glVertexShader );
	 // gl.detachShader( program, glFragmentShader );

	 gl.deleteShader( glVertexShader );
	 gl.deleteShader( glFragmentShader );

	 // set up caching for uniform locations

	 let cachedUniforms;

	 this.getUniforms = function () {

		 if ( cachedUniforms === undefined ) {

			 cachedUniforms = new WebGLUniforms( gl, program );

		 }

		 return cachedUniforms;

	 };

	 // set up caching for attribute locations

	 let cachedAttributes;

	 this.getAttributes = function () {

		 if ( cachedAttributes === undefined ) {

			 cachedAttributes = fetchAttributeLocations( gl, program );

		 }

		 return cachedAttributes;

	 };

	 // free resource

	 this.destroy = function () {

		 bindingStates.releaseStatesOfProgram( this );

		 gl.deleteProgram( program );
		 this.program = undefined;

	 };

	 //

	 this.name = parameters.shaderName;
	 this.id = programIdCount ++;
	 this.cacheKey = cacheKey;
	 this.usedTimes = 1;
	 this.program = program;
	 this.vertexShader = glVertexShader;
	 this.fragmentShader = glFragmentShader;

	 return this;

 }

 function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

	 const programs = [];

	 const isWebGL2 = capabilities.isWebGL2;
	 const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	 const floatVertexTextures = capabilities.floatVertexTextures;
	 const maxVertexUniforms = capabilities.maxVertexUniforms;
	 const vertexTextures = capabilities.vertexTextures;

	 let precision = capabilities.precision;

	 const shaderIDs = {
		 MeshDepthMaterial: 'depth',
		 MeshDistanceMaterial: 'distanceRGBA',
		 MeshNormalMaterial: 'normal',
		 MeshBasicMaterial: 'basic',
		 MeshLambertMaterial: 'lambert',
		 MeshPhongMaterial: 'phong',
		 MeshToonMaterial: 'toon',
		 MeshStandardMaterial: 'physical',
		 MeshPhysicalMaterial: 'physical',
		 MeshMatcapMaterial: 'matcap',
		 LineBasicMaterial: 'basic',
		 LineDashedMaterial: 'dashed',
		 PointsMaterial: 'points',
		 ShadowMaterial: 'shadow',
		 SpriteMaterial: 'sprite'
	 };

	 const parameterNames = [
		 'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
		 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
		 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
		 'roughnessMap', 'metalnessMap', 'gradientMap',
		 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
		 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
		 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',
		 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
		 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
		 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
		 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
		 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'
	 ];

	 function getMaxBones( object ) {

		 const skeleton = object.skeleton;
		 const bones = skeleton.bones;

		 if ( floatVertexTextures ) {

			 return 1024;

		 } else {

			 // default for when object is not specified
			 // ( for example when prebuilding shader to be used with multiple objects )
			 //
			 //  - leave some extra space for other uniforms
			 //  - limit here is ANGLE's 254 max uniform vectors
			 //    (up to 54 should be safe)

			 const nVertexUniforms = maxVertexUniforms;
			 const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			 const maxBones = Math.min( nVertexMatrices, bones.length );

			 if ( maxBones < bones.length ) {

				 console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				 return 0;

			 }

			 return maxBones;

		 }

	 }

	 function getTextureEncodingFromMap( map ) {

		 let encoding;

		 if ( map && map.isTexture ) {

			 encoding = map.encoding;

		 } else if ( map && map.isWebGLRenderTarget ) {

			 console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
			 encoding = map.texture.encoding;

		 } else {

			 encoding = LinearEncoding;

		 }

		 return encoding;

	 }

	 function getParameters( material, lights, shadows, scene, object ) {

		 const fog = scene.fog;
		 const environment = material.isMeshStandardMaterial ? scene.environment : null;

		 const envMap = cubemaps.get( material.envMap || environment );

		 const shaderID = shaderIDs[ material.type ];

		 // heuristics to create shader parameters according to lights in the scene
		 // (not to blow over maxLights budget)

		 const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		 if ( material.precision !== null ) {

			 precision = capabilities.getMaxPrecision( material.precision );

			 if ( precision !== material.precision ) {

				 console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			 }

		 }

		 let vertexShader, fragmentShader;

		 if ( shaderID ) {

			 const shader = ShaderLib[ shaderID ];

			 vertexShader = shader.vertexShader;
			 fragmentShader = shader.fragmentShader;

		 } else {

			 vertexShader = material.vertexShader;
			 fragmentShader = material.fragmentShader;

		 }

		 const currentRenderTarget = renderer.getRenderTarget();

		 const parameters = {

			 isWebGL2: isWebGL2,

			 shaderID: shaderID,
			 shaderName: material.type,

			 vertexShader: vertexShader,
			 fragmentShader: fragmentShader,
			 defines: material.defines,

			 isRawShaderMaterial: material.isRawShaderMaterial === true,
			 glslVersion: material.glslVersion,

			 precision: precision,

			 instancing: object.isInstancedMesh === true,
			 instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			 supportsVertexTextures: vertexTextures,
			 outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			 map: !! material.map,
			 mapEncoding: getTextureEncodingFromMap( material.map ),
			 matcap: !! material.matcap,
			 matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			 envMap: !! envMap,
			 envMapMode: envMap && envMap.mapping,
			 envMapEncoding: getTextureEncodingFromMap( envMap ),
			 envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
			 lightMap: !! material.lightMap,
			 lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			 aoMap: !! material.aoMap,
			 emissiveMap: !! material.emissiveMap,
			 emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			 bumpMap: !! material.bumpMap,
			 normalMap: !! material.normalMap,
			 objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			 tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			 clearcoatMap: !! material.clearcoatMap,
			 clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			 clearcoatNormalMap: !! material.clearcoatNormalMap,
			 displacementMap: !! material.displacementMap,
			 roughnessMap: !! material.roughnessMap,
			 metalnessMap: !! material.metalnessMap,
			 specularMap: !! material.specularMap,
			 alphaMap: !! material.alphaMap,

			 gradientMap: !! material.gradientMap,

			 sheen: !! material.sheen,

			 transmission: !! material.transmission,
			 transmissionMap: !! material.transmissionMap,
			 thicknessMap: !! material.thicknessMap,

			 combine: material.combine,

			 vertexTangents: ( material.normalMap && material.vertexTangents ),
			 vertexColors: material.vertexColors,
			 vertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
			 vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap,
			 uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmission || !! material.transmissionMap || !! material.thicknessMap ) && !! material.displacementMap,

			 fog: !! fog,
			 useFog: material.fog,
			 fogExp2: ( fog && fog.isFogExp2 ),

			 flatShading: !! material.flatShading,

			 sizeAttenuation: material.sizeAttenuation,
			 logarithmicDepthBuffer: logarithmicDepthBuffer,

			 skinning: object.isSkinnedMesh === true && maxBones > 0,
			 maxBones: maxBones,
			 useVertexTexture: floatVertexTextures,

			 morphTargets: material.morphTargets,
			 morphNormals: material.morphNormals,

			 numDirLights: lights.directional.length,
			 numPointLights: lights.point.length,
			 numSpotLights: lights.spot.length,
			 numRectAreaLights: lights.rectArea.length,
			 numHemiLights: lights.hemi.length,

			 numDirLightShadows: lights.directionalShadowMap.length,
			 numPointLightShadows: lights.pointShadowMap.length,
			 numSpotLightShadows: lights.spotShadowMap.length,

			 numClippingPlanes: clipping.numPlanes,
			 numClipIntersection: clipping.numIntersection,

			 dithering: material.dithering,

			 shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			 shadowMapType: renderer.shadowMap.type,

			 toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			 physicallyCorrectLights: renderer.physicallyCorrectLights,

			 premultipliedAlpha: material.premultipliedAlpha,

			 alphaTest: material.alphaTest,
			 doubleSided: material.side === DoubleSide,
			 flipSided: material.side === BackSide,

			 depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			 index0AttributeName: material.index0AttributeName,

			 extensionDerivatives: material.extensions && material.extensions.derivatives,
			 extensionFragDepth: material.extensions && material.extensions.fragDepth,
			 extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			 extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			 rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			 rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			 rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			 customProgramCacheKey: material.customProgramCacheKey()

		 };

		 return parameters;

	 }

	 function getProgramCacheKey( parameters ) {

		 const array = [];

		 if ( parameters.shaderID ) {

			 array.push( parameters.shaderID );

		 } else {

			 array.push( parameters.fragmentShader );
			 array.push( parameters.vertexShader );

		 }

		 if ( parameters.defines !== undefined ) {

			 for ( const name in parameters.defines ) {

				 array.push( name );
				 array.push( parameters.defines[ name ] );

			 }

		 }

		 if ( parameters.isRawShaderMaterial === false ) {

			 for ( let i = 0; i < parameterNames.length; i ++ ) {

				 array.push( parameters[ parameterNames[ i ] ] );

			 }

			 array.push( renderer.outputEncoding );
			 array.push( renderer.gammaFactor );

		 }

		 array.push( parameters.customProgramCacheKey );

		 return array.join();

	 }

	 function getUniforms( material ) {

		 const shaderID = shaderIDs[ material.type ];
		 let uniforms;

		 if ( shaderID ) {

			 const shader = ShaderLib[ shaderID ];
			 uniforms = UniformsUtils.clone( shader.uniforms );

		 } else {

			 uniforms = material.uniforms;

		 }

		 return uniforms;

	 }

	 function acquireProgram( parameters, cacheKey ) {

		 let program;

		 // Check if code has been already compiled
		 for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			 const preexistingProgram = programs[ p ];

			 if ( preexistingProgram.cacheKey === cacheKey ) {

				 program = preexistingProgram;
				 ++ program.usedTimes;

				 break;

			 }

		 }

		 if ( program === undefined ) {

			 program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			 programs.push( program );

		 }

		 return program;

	 }

	 function releaseProgram( program ) {

		 if ( -- program.usedTimes === 0 ) {

			 // Remove from unordered set
			 const i = programs.indexOf( program );
			 programs[ i ] = programs[ programs.length - 1 ];
			 programs.pop();

			 // Free WebGL resources
			 program.destroy();

		 }

	 }

	 return {
		 getParameters: getParameters,
		 getProgramCacheKey: getProgramCacheKey,
		 getUniforms: getUniforms,
		 acquireProgram: acquireProgram,
		 releaseProgram: releaseProgram,
		 // Exposed for resource monitoring & error feedback via renderer.info:
		 programs: programs
	 };

 }

 function WebGLProperties() {

	 let properties = new WeakMap();

	 function get( object ) {

		 let map = properties.get( object );

		 if ( map === undefined ) {

			 map = {};
			 properties.set( object, map );

		 }

		 return map;

	 }

	 function remove( object ) {

		 properties.delete( object );

	 }

	 function update( object, key, value ) {

		 properties.get( object )[ key ] = value;

	 }

	 function dispose() {

		 properties = new WeakMap();

	 }

	 return {
		 get: get,
		 remove: remove,
		 update: update,
		 dispose: dispose
	 };

 }

 function painterSortStable( a, b ) {

	 if ( a.groupOrder !== b.groupOrder ) {

		 return a.groupOrder - b.groupOrder;

	 } else if ( a.renderOrder !== b.renderOrder ) {

		 return a.renderOrder - b.renderOrder;

	 } else if ( a.program !== b.program ) {

		 return a.program.id - b.program.id;

	 } else if ( a.material.id !== b.material.id ) {

		 return a.material.id - b.material.id;

	 } else if ( a.z !== b.z ) {

		 return a.z - b.z;

	 } else {

		 return a.id - b.id;

	 }

 }

 function reversePainterSortStable( a, b ) {

	 if ( a.groupOrder !== b.groupOrder ) {

		 return a.groupOrder - b.groupOrder;

	 } else if ( a.renderOrder !== b.renderOrder ) {

		 return a.renderOrder - b.renderOrder;

	 } else if ( a.z !== b.z ) {

		 return b.z - a.z;

	 } else {

		 return a.id - b.id;

	 }

 }


 function WebGLRenderList( properties ) {

	 const renderItems = [];
	 let renderItemsIndex = 0;

	 const opaque = [];
	 const transmissive = [];
	 const transparent = [];

	 const defaultProgram = { id: - 1 };

	 function init() {

		 renderItemsIndex = 0;

		 opaque.length = 0;
		 transmissive.length = 0;
		 transparent.length = 0;

	 }

	 function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		 let renderItem = renderItems[ renderItemsIndex ];
		 const materialProperties = properties.get( material );

		 if ( renderItem === undefined ) {

			 renderItem = {
				 id: object.id,
				 object: object,
				 geometry: geometry,
				 material: material,
				 program: materialProperties.program || defaultProgram,
				 groupOrder: groupOrder,
				 renderOrder: object.renderOrder,
				 z: z,
				 group: group
			 };

			 renderItems[ renderItemsIndex ] = renderItem;

		 } else {

			 renderItem.id = object.id;
			 renderItem.object = object;
			 renderItem.geometry = geometry;
			 renderItem.material = material;
			 renderItem.program = materialProperties.program || defaultProgram;
			 renderItem.groupOrder = groupOrder;
			 renderItem.renderOrder = object.renderOrder;
			 renderItem.z = z;
			 renderItem.group = group;

		 }

		 renderItemsIndex ++;

		 return renderItem;

	 }

	 function push( object, geometry, material, groupOrder, z, group ) {

		 const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		 if ( material.transmission > 0.0 ) {

			 transmissive.push( renderItem );

		 } else if ( material.transparent === true ) {

			 transparent.push( renderItem );

		 } else {

			 opaque.push( renderItem );

		 }

	 }

	 function unshift( object, geometry, material, groupOrder, z, group ) {

		 const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		 if ( material.transmission > 0.0 ) {

			 transmissive.unshift( renderItem );

		 } else if ( material.transparent === true ) {

			 transparent.unshift( renderItem );

		 } else {

			 opaque.unshift( renderItem );

		 }

	 }

	 function sort( customOpaqueSort, customTransparentSort ) {

		 if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		 if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		 if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	 }

	 function finish() {

		 // Clear references from inactive renderItems in the list

		 for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			 const renderItem = renderItems[ i ];

			 if ( renderItem.id === null ) break;

			 renderItem.id = null;
			 renderItem.object = null;
			 renderItem.geometry = null;
			 renderItem.material = null;
			 renderItem.program = null;
			 renderItem.group = null;

		 }

	 }

	 return {

		 opaque: opaque,
		 transmissive: transmissive,
		 transparent: transparent,

		 init: init,
		 push: push,
		 unshift: unshift,
		 finish: finish,

		 sort: sort
	 };

 }

 function WebGLRenderLists( properties ) {

	 let lists = new WeakMap();

	 function get( scene, renderCallDepth ) {

		 let list;

		 if ( lists.has( scene ) === false ) {

			 list = new WebGLRenderList( properties );
			 lists.set( scene, [ list ] );

		 } else {

			 if ( renderCallDepth >= lists.get( scene ).length ) {

				 list = new WebGLRenderList( properties );
				 lists.get( scene ).push( list );

			 } else {

				 list = lists.get( scene )[ renderCallDepth ];

			 }

		 }

		 return list;

	 }

	 function dispose() {

		 lists = new WeakMap();

	 }

	 return {
		 get: get,
		 dispose: dispose
	 };

 }

 function UniformsCache() {

	 const lights = {};

	 return {

		 get: function ( light ) {

			 if ( lights[ light.id ] !== undefined ) {

				 return lights[ light.id ];

			 }

			 let uniforms;

			 switch ( light.type ) {

				 case 'DirectionalLight':
					 uniforms = {
						 direction: new Vector3(),
						 color: new Color$1()
					 };
					 break;

				 case 'SpotLight':
					 uniforms = {
						 position: new Vector3(),
						 direction: new Vector3(),
						 color: new Color$1(),
						 distance: 0,
						 coneCos: 0,
						 penumbraCos: 0,
						 decay: 0
					 };
					 break;

				 case 'PointLight':
					 uniforms = {
						 position: new Vector3(),
						 color: new Color$1(),
						 distance: 0,
						 decay: 0
					 };
					 break;

				 case 'HemisphereLight':
					 uniforms = {
						 direction: new Vector3(),
						 skyColor: new Color$1(),
						 groundColor: new Color$1()
					 };
					 break;

				 case 'RectAreaLight':
					 uniforms = {
						 color: new Color$1(),
						 position: new Vector3(),
						 halfWidth: new Vector3(),
						 halfHeight: new Vector3()
					 };
					 break;

			 }

			 lights[ light.id ] = uniforms;

			 return uniforms;

		 }

	 };

 }

 function ShadowUniformsCache() {

	 const lights = {};

	 return {

		 get: function ( light ) {

			 if ( lights[ light.id ] !== undefined ) {

				 return lights[ light.id ];

			 }

			 let uniforms;

			 switch ( light.type ) {

				 case 'DirectionalLight':
					 uniforms = {
						 shadowBias: 0,
						 shadowNormalBias: 0,
						 shadowRadius: 1,
						 shadowMapSize: new Vector2()
					 };
					 break;

				 case 'SpotLight':
					 uniforms = {
						 shadowBias: 0,
						 shadowNormalBias: 0,
						 shadowRadius: 1,
						 shadowMapSize: new Vector2()
					 };
					 break;

				 case 'PointLight':
					 uniforms = {
						 shadowBias: 0,
						 shadowNormalBias: 0,
						 shadowRadius: 1,
						 shadowMapSize: new Vector2(),
						 shadowCameraNear: 1,
						 shadowCameraFar: 1000
					 };
					 break;

				 // TODO (abelnation): set RectAreaLight shadow uniforms

			 }

			 lights[ light.id ] = uniforms;

			 return uniforms;

		 }

	 };

 }



 let nextVersion = 0;

 function shadowCastingLightsFirst( lightA, lightB ) {

	 return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

 }

 function WebGLLights( extensions, capabilities ) {

	 const cache = new UniformsCache();

	 const shadowCache = ShadowUniformsCache();

	 const state = {

		 version: 0,

		 hash: {
			 directionalLength: - 1,
			 pointLength: - 1,
			 spotLength: - 1,
			 rectAreaLength: - 1,
			 hemiLength: - 1,

			 numDirectionalShadows: - 1,
			 numPointShadows: - 1,
			 numSpotShadows: - 1
		 },

		 ambient: [ 0, 0, 0 ],
		 probe: [],
		 directional: [],
		 directionalShadow: [],
		 directionalShadowMap: [],
		 directionalShadowMatrix: [],
		 spot: [],
		 spotShadow: [],
		 spotShadowMap: [],
		 spotShadowMatrix: [],
		 rectArea: [],
		 rectAreaLTC1: null,
		 rectAreaLTC2: null,
		 point: [],
		 pointShadow: [],
		 pointShadowMap: [],
		 pointShadowMatrix: [],
		 hemi: []

	 };

	 for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	 const vector3 = new Vector3();
	 const matrix4 = new Matrix4();
	 const matrix42 = new Matrix4();

	 function setup( lights ) {

		 let r = 0, g = 0, b = 0;

		 for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		 let directionalLength = 0;
		 let pointLength = 0;
		 let spotLength = 0;
		 let rectAreaLength = 0;
		 let hemiLength = 0;

		 let numDirectionalShadows = 0;
		 let numPointShadows = 0;
		 let numSpotShadows = 0;

		 lights.sort( shadowCastingLightsFirst );

		 for ( let i = 0, l = lights.length; i < l; i ++ ) {

			 const light = lights[ i ];

			 const color = light.color;
			 const intensity = light.intensity;
			 const distance = light.distance;

			 const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			 if ( light.isAmbientLight ) {

				 r += color.r * intensity;
				 g += color.g * intensity;
				 b += color.b * intensity;

			 } else if ( light.isLightProbe ) {

				 for ( let j = 0; j < 9; j ++ ) {

					 state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				 }

			 } else if ( light.isDirectionalLight ) {

				 const uniforms = cache.get( light );

				 uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

				 if ( light.castShadow ) {

					 const shadow = light.shadow;

					 const shadowUniforms = shadowCache.get( light );

					 shadowUniforms.shadowBias = shadow.bias;
					 shadowUniforms.shadowNormalBias = shadow.normalBias;
					 shadowUniforms.shadowRadius = shadow.radius;
					 shadowUniforms.shadowMapSize = shadow.mapSize;

					 state.directionalShadow[ directionalLength ] = shadowUniforms;
					 state.directionalShadowMap[ directionalLength ] = shadowMap;
					 state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					 numDirectionalShadows ++;

				 }

				 state.directional[ directionalLength ] = uniforms;

				 directionalLength ++;

			 } else if ( light.isSpotLight ) {

				 const uniforms = cache.get( light );

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );

				 uniforms.color.copy( color ).multiplyScalar( intensity );
				 uniforms.distance = distance;

				 uniforms.coneCos = Math.cos( light.angle );
				 uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				 uniforms.decay = light.decay;

				 if ( light.castShadow ) {

					 const shadow = light.shadow;

					 const shadowUniforms = shadowCache.get( light );

					 shadowUniforms.shadowBias = shadow.bias;
					 shadowUniforms.shadowNormalBias = shadow.normalBias;
					 shadowUniforms.shadowRadius = shadow.radius;
					 shadowUniforms.shadowMapSize = shadow.mapSize;

					 state.spotShadow[ spotLength ] = shadowUniforms;
					 state.spotShadowMap[ spotLength ] = shadowMap;
					 state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					 numSpotShadows ++;

				 }

				 state.spot[ spotLength ] = uniforms;

				 spotLength ++;

			 } else if ( light.isRectAreaLight ) {

				 const uniforms = cache.get( light );

				 // (a) intensity is the total visible light emitted
				 //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				 // (b) intensity is the brightness of the light
				 uniforms.color.copy( color ).multiplyScalar( intensity );

				 uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				 uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				 state.rectArea[ rectAreaLength ] = uniforms;

				 rectAreaLength ++;

			 } else if ( light.isPointLight ) {

				 const uniforms = cache.get( light );

				 uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				 uniforms.distance = light.distance;
				 uniforms.decay = light.decay;

				 if ( light.castShadow ) {

					 const shadow = light.shadow;

					 const shadowUniforms = shadowCache.get( light );

					 shadowUniforms.shadowBias = shadow.bias;
					 shadowUniforms.shadowNormalBias = shadow.normalBias;
					 shadowUniforms.shadowRadius = shadow.radius;
					 shadowUniforms.shadowMapSize = shadow.mapSize;
					 shadowUniforms.shadowCameraNear = shadow.camera.near;
					 shadowUniforms.shadowCameraFar = shadow.camera.far;

					 state.pointShadow[ pointLength ] = shadowUniforms;
					 state.pointShadowMap[ pointLength ] = shadowMap;
					 state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					 numPointShadows ++;

				 }

				 state.point[ pointLength ] = uniforms;

				 pointLength ++;

			 } else if ( light.isHemisphereLight ) {

				 const uniforms = cache.get( light );

				 uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				 uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				 state.hemi[ hemiLength ] = uniforms;

				 hemiLength ++;

			 }

		 }

		 if ( rectAreaLength > 0 ) {

			 if ( capabilities.isWebGL2 ) {

				 // WebGL 2

				 state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				 state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			 } else {

				 // WebGL 1

				 if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					 state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					 state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				 } else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					 state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					 state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				 } else {

					 console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				 }

			 }

		 }

		 state.ambient[ 0 ] = r;
		 state.ambient[ 1 ] = g;
		 state.ambient[ 2 ] = b;

		 const hash = state.hash;

		 if ( hash.directionalLength !== directionalLength ||
			 hash.pointLength !== pointLength ||
			 hash.spotLength !== spotLength ||
			 hash.rectAreaLength !== rectAreaLength ||
			 hash.hemiLength !== hemiLength ||
			 hash.numDirectionalShadows !== numDirectionalShadows ||
			 hash.numPointShadows !== numPointShadows ||
			 hash.numSpotShadows !== numSpotShadows ) {

			 state.directional.length = directionalLength;
			 state.spot.length = spotLength;
			 state.rectArea.length = rectAreaLength;
			 state.point.length = pointLength;
			 state.hemi.length = hemiLength;

			 state.directionalShadow.length = numDirectionalShadows;
			 state.directionalShadowMap.length = numDirectionalShadows;
			 state.pointShadow.length = numPointShadows;
			 state.pointShadowMap.length = numPointShadows;
			 state.spotShadow.length = numSpotShadows;
			 state.spotShadowMap.length = numSpotShadows;
			 state.directionalShadowMatrix.length = numDirectionalShadows;
			 state.pointShadowMatrix.length = numPointShadows;
			 state.spotShadowMatrix.length = numSpotShadows;

			 hash.directionalLength = directionalLength;
			 hash.pointLength = pointLength;
			 hash.spotLength = spotLength;
			 hash.rectAreaLength = rectAreaLength;
			 hash.hemiLength = hemiLength;

			 hash.numDirectionalShadows = numDirectionalShadows;
			 hash.numPointShadows = numPointShadows;
			 hash.numSpotShadows = numSpotShadows;

			 state.version = nextVersion ++;

		 }

	 }

	 function setupView( lights, camera ) {

		 let directionalLength = 0;
		 let pointLength = 0;
		 let spotLength = 0;
		 let rectAreaLength = 0;
		 let hemiLength = 0;

		 const viewMatrix = camera.matrixWorldInverse;

		 for ( let i = 0, l = lights.length; i < l; i ++ ) {

			 const light = lights[ i ];

			 if ( light.isDirectionalLight ) {

				 const uniforms = state.directional[ directionalLength ];

				 uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				 vector3.setFromMatrixPosition( light.target.matrixWorld );
				 uniforms.direction.sub( vector3 );
				 uniforms.direction.transformDirection( viewMatrix );

				 directionalLength ++;

			 } else if ( light.isSpotLight ) {

				 const uniforms = state.spot[ spotLength ];

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );
				 uniforms.position.applyMatrix4( viewMatrix );

				 uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				 vector3.setFromMatrixPosition( light.target.matrixWorld );
				 uniforms.direction.sub( vector3 );
				 uniforms.direction.transformDirection( viewMatrix );

				 spotLength ++;

			 } else if ( light.isRectAreaLight ) {

				 const uniforms = state.rectArea[ rectAreaLength ];

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );
				 uniforms.position.applyMatrix4( viewMatrix );

				 // extract local rotation of light to derive width/height half vectors
				 matrix42.identity();
				 matrix4.copy( light.matrixWorld );
				 matrix4.premultiply( viewMatrix );
				 matrix42.extractRotation( matrix4 );

				 uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				 uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				 uniforms.halfWidth.applyMatrix4( matrix42 );
				 uniforms.halfHeight.applyMatrix4( matrix42 );

				 rectAreaLength ++;

			 } else if ( light.isPointLight ) {

				 const uniforms = state.point[ pointLength ];

				 uniforms.position.setFromMatrixPosition( light.matrixWorld );
				 uniforms.position.applyMatrix4( viewMatrix );

				 pointLength ++;

			 } else if ( light.isHemisphereLight ) {

				 const uniforms = state.hemi[ hemiLength ];

				 uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				 uniforms.direction.transformDirection( viewMatrix );
				 uniforms.direction.normalize();

				 hemiLength ++;

			 }

		 }

	 }

	 return {
		 setup: setup,
		 setupView: setupView,
		 state: state
	 };

 }

 function WebGLRenderState( extensions, capabilities ) {

	 const lights = new WebGLLights( extensions, capabilities );

	 const lightsArray = [];
	 const shadowsArray = [];

	 function init() {

		 lightsArray.length = 0;
		 shadowsArray.length = 0;

	 }

	 function pushLight( light ) {

		 lightsArray.push( light );

	 }

	 function pushShadow( shadowLight ) {

		 shadowsArray.push( shadowLight );

	 }

	 function setupLights() {

		 lights.setup( lightsArray );

	 }

	 function setupLightsView( camera ) {

		 lights.setupView( lightsArray, camera );

	 }

	 const state = {
		 lightsArray: lightsArray,
		 shadowsArray: shadowsArray,

		 lights: lights
	 };

	 return {
		 init: init,
		 state: state,
		 setupLights: setupLights,
		 setupLightsView: setupLightsView,

		 pushLight: pushLight,
		 pushShadow: pushShadow
	 };

 }

 function WebGLRenderStates( extensions, capabilities ) {

	 let renderStates = new WeakMap();

	 function get( scene, renderCallDepth = 0 ) {

		 let renderState;

		 if ( renderStates.has( scene ) === false ) {

			 renderState = new WebGLRenderState( extensions, capabilities );
			 renderStates.set( scene, [ renderState ] );

		 } else {

			 if ( renderCallDepth >= renderStates.get( scene ).length ) {

				 renderState = new WebGLRenderState( extensions, capabilities );
				 renderStates.get( scene ).push( renderState );

			 } else {

				 renderState = renderStates.get( scene )[ renderCallDepth ];

			 }

		 }

		 return renderState;

	 }

	 function dispose() {

		 renderStates = new WeakMap();

	 }

	 return {
		 get: get,
		 dispose: dispose
	 };

 }

 /**
	* parameters = {
	*
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>
	* }
	*/

 class MeshDepthMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshDepthMaterial';

		 this.depthPacking = BasicDepthPacking;

		 this.morphTargets = false;

		 this.map = null;

		 this.alphaMap = null;

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;

		 this.fog = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.depthPacking = source.depthPacking;

		 this.morphTargets = source.morphTargets;

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;

		 return this;

	 }

 }

 MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

 /**
	* parameters = {
	*
	*  referencePosition: <float>,
	*  nearDistance: <float>,
	*  farDistance: <float>,
	*
	*  morphTargets: <bool>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>
	*
	* }
	*/

 class MeshDistanceMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshDistanceMaterial';

		 this.referencePosition = new Vector3();
		 this.nearDistance = 1;
		 this.farDistance = 1000;

		 this.morphTargets = false;

		 this.map = null;

		 this.alphaMap = null;

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.fog = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.referencePosition.copy( source.referencePosition );
		 this.nearDistance = source.nearDistance;
		 this.farDistance = source.farDistance;

		 this.morphTargets = source.morphTargets;

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 return this;

	 }

 }

 MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

 var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

 var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

 function WebGLShadowMap( _renderer, _objects, _capabilities ) {

	 let _frustum = new Frustum();

	 const _shadowMapSize = new Vector2(),
		 _viewportSize = new Vector2(),

		 _viewport = new Vector4(),

		 _depthMaterials = [],
		 _distanceMaterials = [],

		 _materialCache = {},

		 _maxTextureSize = _capabilities.maxTextureSize;

	 const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	 const shadowMaterialVertical = new ShaderMaterial( {

		 defines: {
			 SAMPLE_RATE: 2.0 / 8.0,
			 HALF_SAMPLE_RATE: 1.0 / 8.0
		 },

		 uniforms: {
			 shadow_pass: { value: null },
			 resolution: { value: new Vector2() },
			 radius: { value: 4.0 }
		 },

		 vertexShader: vsm_vert,

		 fragmentShader: vsm_frag

	 } );

	 const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	 shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	 const fullScreenTri = new BufferGeometry();
	 fullScreenTri.setAttribute(
		 'position',
		 new BufferAttribute(
			 new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			 3
		 )
	 );

	 const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	 const scope = this;

	 this.enabled = false;

	 this.autoUpdate = true;
	 this.needsUpdate = false;

	 this.type = PCFShadowMap;

	 this.render = function ( lights, scene, camera ) {

		 if ( scope.enabled === false ) return;
		 if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		 if ( lights.length === 0 ) return;

		 const currentRenderTarget = _renderer.getRenderTarget();
		 const activeCubeFace = _renderer.getActiveCubeFace();
		 const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		 const _state = _renderer.state;

		 // Set GL state for depth map.
		 _state.setBlending( NoBlending );
		 _state.buffers.color.setClear( 1, 1, 1, 1 );
		 _state.buffers.depth.setTest( true );
		 _state.setScissorTest( false );

		 // render depth map

		 for ( let i = 0, il = lights.length; i < il; i ++ ) {

			 const light = lights[ i ];
			 const shadow = light.shadow;

			 if ( shadow === undefined ) {

				 console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				 continue;

			 }

			 if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			 _shadowMapSize.copy( shadow.mapSize );

			 const shadowFrameExtents = shadow.getFrameExtents();

			 _shadowMapSize.multiply( shadowFrameExtents );

			 _viewportSize.copy( shadow.mapSize );

			 if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				 if ( _shadowMapSize.x > _maxTextureSize ) {

					 _viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					 _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					 shadow.mapSize.x = _viewportSize.x;

				 }

				 if ( _shadowMapSize.y > _maxTextureSize ) {

					 _viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					 _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					 shadow.mapSize.y = _viewportSize.y;

				 }

			 }

			 if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				 const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

				 shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				 shadow.map.texture.name = light.name + '.shadowMap';

				 shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				 shadow.camera.updateProjectionMatrix();

			 }

			 if ( shadow.map === null ) {

				 const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				 shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				 shadow.map.texture.name = light.name + '.shadowMap';

				 shadow.camera.updateProjectionMatrix();

			 }

			 _renderer.setRenderTarget( shadow.map );
			 _renderer.clear();

			 const viewportCount = shadow.getViewportCount();

			 for ( let vp = 0; vp < viewportCount; vp ++ ) {

				 const viewport = shadow.getViewport( vp );

				 _viewport.set(
					 _viewportSize.x * viewport.x,
					 _viewportSize.y * viewport.y,
					 _viewportSize.x * viewport.z,
					 _viewportSize.y * viewport.w
				 );

				 _state.viewport( _viewport );

				 shadow.updateMatrices( light, vp );

				 _frustum = shadow.getFrustum();

				 renderObject( scene, camera, shadow.camera, light, this.type );

			 }

			 // do blur pass for VSM

			 if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				 VSMPass( shadow, camera );

			 }

			 shadow.needsUpdate = false;

		 }

		 scope.needsUpdate = false;

		 _renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	 };

	 function VSMPass( shadow, camera ) {

		 const geometry = _objects.update( fullScreenMesh );

		 // vertical pass

		 shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		 shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		 shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		 _renderer.setRenderTarget( shadow.mapPass );
		 _renderer.clear();
		 _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		 // horizontal pass

		 shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		 shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		 shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		 _renderer.setRenderTarget( shadow.map );
		 _renderer.clear();
		 _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	 }

	 function getDepthMaterialVariant( useMorphing ) {

		 const index = useMorphing << 0;

		 let material = _depthMaterials[ index ];

		 if ( material === undefined ) {

			 material = new MeshDepthMaterial( {

				 depthPacking: RGBADepthPacking,

				 morphTargets: useMorphing

			 } );

			 _depthMaterials[ index ] = material;

		 }

		 return material;

	 }

	 function getDistanceMaterialVariant( useMorphing ) {

		 const index = useMorphing << 0;

		 let material = _distanceMaterials[ index ];

		 if ( material === undefined ) {

			 material = new MeshDistanceMaterial( {

				 morphTargets: useMorphing

			 } );

			 _distanceMaterials[ index ] = material;

		 }

		 return material;

	 }

	 function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		 let result = null;

		 let getMaterialVariant = getDepthMaterialVariant;
		 let customMaterial = object.customDepthMaterial;

		 if ( light.isPointLight === true ) {

			 getMaterialVariant = getDistanceMaterialVariant;
			 customMaterial = object.customDistanceMaterial;

		 }

		 if ( customMaterial === undefined ) {

			 let useMorphing = false;

			 if ( material.morphTargets === true ) {

				 useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			 }

			 result = getMaterialVariant( useMorphing );

		 } else {

			 result = customMaterial;

		 }

		 if ( _renderer.localClippingEnabled &&
				 material.clipShadows === true &&
				 material.clippingPlanes.length !== 0 ) {

			 // in this case we need a unique material instance reflecting the
			 // appropriate state

			 const keyA = result.uuid, keyB = material.uuid;

			 let materialsForVariant = _materialCache[ keyA ];

			 if ( materialsForVariant === undefined ) {

				 materialsForVariant = {};
				 _materialCache[ keyA ] = materialsForVariant;

			 }

			 let cachedMaterial = materialsForVariant[ keyB ];

			 if ( cachedMaterial === undefined ) {

				 cachedMaterial = result.clone();
				 materialsForVariant[ keyB ] = cachedMaterial;

			 }

			 result = cachedMaterial;

		 }

		 result.visible = material.visible;
		 result.wireframe = material.wireframe;

		 if ( type === VSMShadowMap ) {

			 result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		 } else {

			 result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		 }

		 result.clipShadows = material.clipShadows;
		 result.clippingPlanes = material.clippingPlanes;
		 result.clipIntersection = material.clipIntersection;

		 result.wireframeLinewidth = material.wireframeLinewidth;
		 result.linewidth = material.linewidth;

		 if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			 result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			 result.nearDistance = shadowCameraNear;
			 result.farDistance = shadowCameraFar;

		 }

		 return result;

	 }

	 function renderObject( object, camera, shadowCamera, light, type ) {

		 if ( object.visible === false ) return;

		 const visible = object.layers.test( camera.layers );

		 if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			 if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				 object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				 const geometry = _objects.update( object );
				 const material = object.material;

				 if ( Array.isArray( material ) ) {

					 const groups = geometry.groups;

					 for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						 const group = groups[ k ];
						 const groupMaterial = material[ group.materialIndex ];

						 if ( groupMaterial && groupMaterial.visible ) {

							 const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							 _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						 }

					 }

				 } else if ( material.visible ) {

					 const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					 _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				 }

			 }

		 }

		 const children = object.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 renderObject( children[ i ], camera, shadowCamera, light, type );

		 }

	 }

 }

 function WebGLState( gl, extensions, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 function ColorBuffer() {

		 let locked = false;

		 const color = new Vector4();
		 let currentColorMask = null;
		 const currentColorClear = new Vector4( 0, 0, 0, 0 );

		 return {

			 setMask: function ( colorMask ) {

				 if ( currentColorMask !== colorMask && ! locked ) {

					 gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					 currentColorMask = colorMask;

				 }

			 },

			 setLocked: function ( lock ) {

				 locked = lock;

			 },

			 setClear: function ( r, g, b, a, premultipliedAlpha ) {

				 if ( premultipliedAlpha === true ) {

					 r *= a; g *= a; b *= a;

				 }

				 color.set( r, g, b, a );

				 if ( currentColorClear.equals( color ) === false ) {

					 gl.clearColor( r, g, b, a );
					 currentColorClear.copy( color );

				 }

			 },

			 reset: function () {

				 locked = false;

				 currentColorMask = null;
				 currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			 }

		 };

	 }

	 function DepthBuffer() {

		 let locked = false;

		 let currentDepthMask = null;
		 let currentDepthFunc = null;
		 let currentDepthClear = null;

		 return {

			 setTest: function ( depthTest ) {

				 if ( depthTest ) {

					 enable( 2929 );

				 } else {

					 disable( 2929 );

				 }

			 },

			 setMask: function ( depthMask ) {

				 if ( currentDepthMask !== depthMask && ! locked ) {

					 gl.depthMask( depthMask );
					 currentDepthMask = depthMask;

				 }

			 },

			 setFunc: function ( depthFunc ) {

				 if ( currentDepthFunc !== depthFunc ) {

					 if ( depthFunc ) {

						 switch ( depthFunc ) {

							 case NeverDepth:

								 gl.depthFunc( 512 );
								 break;

							 case AlwaysDepth:

								 gl.depthFunc( 519 );
								 break;

							 case LessDepth:

								 gl.depthFunc( 513 );
								 break;

							 case LessEqualDepth:

								 gl.depthFunc( 515 );
								 break;

							 case EqualDepth:

								 gl.depthFunc( 514 );
								 break;

							 case GreaterEqualDepth:

								 gl.depthFunc( 518 );
								 break;

							 case GreaterDepth:

								 gl.depthFunc( 516 );
								 break;

							 case NotEqualDepth:

								 gl.depthFunc( 517 );
								 break;

							 default:

								 gl.depthFunc( 515 );

						 }

					 } else {

						 gl.depthFunc( 515 );

					 }

					 currentDepthFunc = depthFunc;

				 }

			 },

			 setLocked: function ( lock ) {

				 locked = lock;

			 },

			 setClear: function ( depth ) {

				 if ( currentDepthClear !== depth ) {

					 gl.clearDepth( depth );
					 currentDepthClear = depth;

				 }

			 },

			 reset: function () {

				 locked = false;

				 currentDepthMask = null;
				 currentDepthFunc = null;
				 currentDepthClear = null;

			 }

		 };

	 }

	 function StencilBuffer() {

		 let locked = false;

		 let currentStencilMask = null;
		 let currentStencilFunc = null;
		 let currentStencilRef = null;
		 let currentStencilFuncMask = null;
		 let currentStencilFail = null;
		 let currentStencilZFail = null;
		 let currentStencilZPass = null;
		 let currentStencilClear = null;

		 return {

			 setTest: function ( stencilTest ) {

				 if ( ! locked ) {

					 if ( stencilTest ) {

						 enable( 2960 );

					 } else {

						 disable( 2960 );

					 }

				 }

			 },

			 setMask: function ( stencilMask ) {

				 if ( currentStencilMask !== stencilMask && ! locked ) {

					 gl.stencilMask( stencilMask );
					 currentStencilMask = stencilMask;

				 }

			 },

			 setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				 if ( currentStencilFunc !== stencilFunc ||
							currentStencilRef !== stencilRef ||
							currentStencilFuncMask !== stencilMask ) {

					 gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					 currentStencilFunc = stencilFunc;
					 currentStencilRef = stencilRef;
					 currentStencilFuncMask = stencilMask;

				 }

			 },

			 setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				 if ( currentStencilFail !== stencilFail ||
							currentStencilZFail !== stencilZFail ||
							currentStencilZPass !== stencilZPass ) {

					 gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					 currentStencilFail = stencilFail;
					 currentStencilZFail = stencilZFail;
					 currentStencilZPass = stencilZPass;

				 }

			 },

			 setLocked: function ( lock ) {

				 locked = lock;

			 },

			 setClear: function ( stencil ) {

				 if ( currentStencilClear !== stencil ) {

					 gl.clearStencil( stencil );
					 currentStencilClear = stencil;

				 }

			 },

			 reset: function () {

				 locked = false;

				 currentStencilMask = null;
				 currentStencilFunc = null;
				 currentStencilRef = null;
				 currentStencilFuncMask = null;
				 currentStencilFail = null;
				 currentStencilZFail = null;
				 currentStencilZPass = null;
				 currentStencilClear = null;

			 }

		 };

	 }

	 //

	 const colorBuffer = new ColorBuffer();
	 const depthBuffer = new DepthBuffer();
	 const stencilBuffer = new StencilBuffer();

	 let enabledCapabilities = {};

	 let xrFramebuffer = null;
	 let currentBoundFramebuffers = {};

	 let currentProgram = null;

	 let currentBlendingEnabled = false;
	 let currentBlending = null;
	 let currentBlendEquation = null;
	 let currentBlendSrc = null;
	 let currentBlendDst = null;
	 let currentBlendEquationAlpha = null;
	 let currentBlendSrcAlpha = null;
	 let currentBlendDstAlpha = null;
	 let currentPremultipledAlpha = false;

	 let currentFlipSided = null;
	 let currentCullFace = null;

	 let currentLineWidth = null;

	 let currentPolygonOffsetFactor = null;
	 let currentPolygonOffsetUnits = null;

	 const maxTextures = gl.getParameter( 35661 );

	 let lineWidthAvailable = false;
	 let version = 0;
	 const glVersion = gl.getParameter( 7938 );

	 if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		 version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		 lineWidthAvailable = ( version >= 1.0 );

	 } else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		 version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		 lineWidthAvailable = ( version >= 2.0 );

	 }

	 let currentTextureSlot = null;
	 let currentBoundTextures = {};

	 const scissorParam = gl.getParameter( 3088 );
	 const viewportParam = gl.getParameter( 2978 );

	 const currentScissor = new Vector4().fromArray( scissorParam );
	 const currentViewport = new Vector4().fromArray( viewportParam );

	 function createTexture( type, target, count ) {

		 const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		 const texture = gl.createTexture();

		 gl.bindTexture( type, texture );
		 gl.texParameteri( type, 10241, 9728 );
		 gl.texParameteri( type, 10240, 9728 );

		 for ( let i = 0; i < count; i ++ ) {

			 gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		 }

		 return texture;

	 }

	 const emptyTextures = {};
	 emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	 emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	 // init

	 colorBuffer.setClear( 0, 0, 0, 1 );
	 depthBuffer.setClear( 1 );
	 stencilBuffer.setClear( 0 );

	 enable( 2929 );
	 depthBuffer.setFunc( LessEqualDepth );

	 setFlipSided( false );
	 setCullFace( CullFaceBack );
	 enable( 2884 );

	 setBlending( NoBlending );

	 //

	 function enable( id ) {

		 if ( enabledCapabilities[ id ] !== true ) {

			 gl.enable( id );
			 enabledCapabilities[ id ] = true;

		 }

	 }

	 function disable( id ) {

		 if ( enabledCapabilities[ id ] !== false ) {

			 gl.disable( id );
			 enabledCapabilities[ id ] = false;

		 }

	 }

	 function bindXRFramebuffer( framebuffer ) {

		 if ( framebuffer !== xrFramebuffer ) {

			 gl.bindFramebuffer( 36160, framebuffer );

			 xrFramebuffer = framebuffer;

		 }

	 }

	 function bindFramebuffer( target, framebuffer ) {

		 if ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available

		 if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			 gl.bindFramebuffer( target, framebuffer );

			 currentBoundFramebuffers[ target ] = framebuffer;

			 if ( isWebGL2 ) {

				 // 36009 is equivalent to 36160

				 if ( target === 36009 ) {

					 currentBoundFramebuffers[ 36160 ] = framebuffer;

				 }

				 if ( target === 36160 ) {

					 currentBoundFramebuffers[ 36009 ] = framebuffer;

				 }

			 }

			 return true;

		 }

		 return false;

	 }

	 function useProgram( program ) {

		 if ( currentProgram !== program ) {

			 gl.useProgram( program );

			 currentProgram = program;

			 return true;

		 }

		 return false;

	 }

	 const equationToGL = {
		 [ AddEquation ]: 32774,
		 [ SubtractEquation ]: 32778,
		 [ ReverseSubtractEquation ]: 32779
	 };

	 if ( isWebGL2 ) {

		 equationToGL[ MinEquation ] = 32775;
		 equationToGL[ MaxEquation ] = 32776;

	 } else {

		 const extension = extensions.get( 'EXT_blend_minmax' );

		 if ( extension !== null ) {

			 equationToGL[ MinEquation ] = extension.MIN_EXT;
			 equationToGL[ MaxEquation ] = extension.MAX_EXT;

		 }

	 }

	 const factorToGL = {
		 [ ZeroFactor ]: 0,
		 [ OneFactor ]: 1,
		 [ SrcColorFactor ]: 768,
		 [ SrcAlphaFactor ]: 770,
		 [ SrcAlphaSaturateFactor ]: 776,
		 [ DstColorFactor ]: 774,
		 [ DstAlphaFactor ]: 772,
		 [ OneMinusSrcColorFactor ]: 769,
		 [ OneMinusSrcAlphaFactor ]: 771,
		 [ OneMinusDstColorFactor ]: 775,
		 [ OneMinusDstAlphaFactor ]: 773
	 };

	 function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		 if ( blending === NoBlending ) {

			 if ( currentBlendingEnabled === true ) {

				 disable( 3042 );
				 currentBlendingEnabled = false;

			 }

			 return;

		 }

		 if ( currentBlendingEnabled === false ) {

			 enable( 3042 );
			 currentBlendingEnabled = true;

		 }

		 if ( blending !== CustomBlending ) {

			 if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				 if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					 gl.blendEquation( 32774 );

					 currentBlendEquation = AddEquation;
					 currentBlendEquationAlpha = AddEquation;

				 }

				 if ( premultipliedAlpha ) {

					 switch ( blending ) {

						 case NormalBlending:
							 gl.blendFuncSeparate( 1, 771, 1, 771 );
							 break;

						 case AdditiveBlending:
							 gl.blendFunc( 1, 1 );
							 break;

						 case SubtractiveBlending:
							 gl.blendFuncSeparate( 0, 0, 769, 771 );
							 break;

						 case MultiplyBlending:
							 gl.blendFuncSeparate( 0, 768, 0, 770 );
							 break;

						 default:
							 console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							 break;

					 }

				 } else {

					 switch ( blending ) {

						 case NormalBlending:
							 gl.blendFuncSeparate( 770, 771, 1, 771 );
							 break;

						 case AdditiveBlending:
							 gl.blendFunc( 770, 1 );
							 break;

						 case SubtractiveBlending:
							 gl.blendFunc( 0, 769 );
							 break;

						 case MultiplyBlending:
							 gl.blendFunc( 0, 768 );
							 break;

						 default:
							 console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							 break;

					 }

				 }

				 currentBlendSrc = null;
				 currentBlendDst = null;
				 currentBlendSrcAlpha = null;
				 currentBlendDstAlpha = null;

				 currentBlending = blending;
				 currentPremultipledAlpha = premultipliedAlpha;

			 }

			 return;

		 }

		 // custom blending

		 blendEquationAlpha = blendEquationAlpha || blendEquation;
		 blendSrcAlpha = blendSrcAlpha || blendSrc;
		 blendDstAlpha = blendDstAlpha || blendDst;

		 if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			 gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			 currentBlendEquation = blendEquation;
			 currentBlendEquationAlpha = blendEquationAlpha;

		 }

		 if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			 gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			 currentBlendSrc = blendSrc;
			 currentBlendDst = blendDst;
			 currentBlendSrcAlpha = blendSrcAlpha;
			 currentBlendDstAlpha = blendDstAlpha;

		 }

		 currentBlending = blending;
		 currentPremultipledAlpha = null;

	 }

	 function setMaterial( material, frontFaceCW ) {

		 material.side === DoubleSide
			 ? disable( 2884 )
			 : enable( 2884 );

		 let flipSided = ( material.side === BackSide );
		 if ( frontFaceCW ) flipSided = ! flipSided;

		 setFlipSided( flipSided );

		 ( material.blending === NormalBlending && material.transparent === false )
			 ? setBlending( NoBlending )
			 : setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		 depthBuffer.setFunc( material.depthFunc );
		 depthBuffer.setTest( material.depthTest );
		 depthBuffer.setMask( material.depthWrite );
		 colorBuffer.setMask( material.colorWrite );

		 const stencilWrite = material.stencilWrite;
		 stencilBuffer.setTest( stencilWrite );
		 if ( stencilWrite ) {

			 stencilBuffer.setMask( material.stencilWriteMask );
			 stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			 stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		 }

		 setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		 material.alphaToCoverage === true
			 ? enable( 32926 )
			 : disable( 32926 );

	 }

	 //

	 function setFlipSided( flipSided ) {

		 if ( currentFlipSided !== flipSided ) {

			 if ( flipSided ) {

				 gl.frontFace( 2304 );

			 } else {

				 gl.frontFace( 2305 );

			 }

			 currentFlipSided = flipSided;

		 }

	 }

	 function setCullFace( cullFace ) {

		 if ( cullFace !== CullFaceNone ) {

			 enable( 2884 );

			 if ( cullFace !== currentCullFace ) {

				 if ( cullFace === CullFaceBack ) {

					 gl.cullFace( 1029 );

				 } else if ( cullFace === CullFaceFront ) {

					 gl.cullFace( 1028 );

				 } else {

					 gl.cullFace( 1032 );

				 }

			 }

		 } else {

			 disable( 2884 );

		 }

		 currentCullFace = cullFace;

	 }

	 function setLineWidth( width ) {

		 if ( width !== currentLineWidth ) {

			 if ( lineWidthAvailable ) gl.lineWidth( width );

			 currentLineWidth = width;

		 }

	 }

	 function setPolygonOffset( polygonOffset, factor, units ) {

		 if ( polygonOffset ) {

			 enable( 32823 );

			 if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				 gl.polygonOffset( factor, units );

				 currentPolygonOffsetFactor = factor;
				 currentPolygonOffsetUnits = units;

			 }

		 } else {

			 disable( 32823 );

		 }

	 }

	 function setScissorTest( scissorTest ) {

		 if ( scissorTest ) {

			 enable( 3089 );

		 } else {

			 disable( 3089 );

		 }

	 }

	 // texture

	 function activeTexture( webglSlot ) {

		 if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		 if ( currentTextureSlot !== webglSlot ) {

			 gl.activeTexture( webglSlot );
			 currentTextureSlot = webglSlot;

		 }

	 }

	 function bindTexture( webglType, webglTexture ) {

		 if ( currentTextureSlot === null ) {

			 activeTexture();

		 }

		 let boundTexture = currentBoundTextures[ currentTextureSlot ];

		 if ( boundTexture === undefined ) {

			 boundTexture = { type: undefined, texture: undefined };
			 currentBoundTextures[ currentTextureSlot ] = boundTexture;

		 }

		 if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			 gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			 boundTexture.type = webglType;
			 boundTexture.texture = webglTexture;

		 }

	 }

	 function unbindTexture() {

		 const boundTexture = currentBoundTextures[ currentTextureSlot ];

		 if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			 gl.bindTexture( boundTexture.type, null );

			 boundTexture.type = undefined;
			 boundTexture.texture = undefined;

		 }

	 }

	 function compressedTexImage2D() {

		 try {

			 gl.compressedTexImage2D.apply( gl, arguments );

		 } catch ( error ) {

			 console.error( 'THREE.WebGLState:', error );

		 }

	 }

	 function texImage2D() {

		 try {

			 gl.texImage2D.apply( gl, arguments );

		 } catch ( error ) {

			 console.error( 'THREE.WebGLState:', error );

		 }

	 }

	 function texImage3D() {

		 try {

			 gl.texImage3D.apply( gl, arguments );

		 } catch ( error ) {

			 console.error( 'THREE.WebGLState:', error );

		 }

	 }

	 //

	 function scissor( scissor ) {

		 if ( currentScissor.equals( scissor ) === false ) {

			 gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			 currentScissor.copy( scissor );

		 }

	 }

	 function viewport( viewport ) {

		 if ( currentViewport.equals( viewport ) === false ) {

			 gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			 currentViewport.copy( viewport );

		 }

	 }

	 //

	 function reset() {

		 // reset state

		 gl.disable( 3042 );
		 gl.disable( 2884 );
		 gl.disable( 2929 );
		 gl.disable( 32823 );
		 gl.disable( 3089 );
		 gl.disable( 2960 );
		 gl.disable( 32926 );

		 gl.blendEquation( 32774 );
		 gl.blendFunc( 1, 0 );
		 gl.blendFuncSeparate( 1, 0, 1, 0 );

		 gl.colorMask( true, true, true, true );
		 gl.clearColor( 0, 0, 0, 0 );

		 gl.depthMask( true );
		 gl.depthFunc( 513 );
		 gl.clearDepth( 1 );

		 gl.stencilMask( 0xffffffff );
		 gl.stencilFunc( 519, 0, 0xffffffff );
		 gl.stencilOp( 7680, 7680, 7680 );
		 gl.clearStencil( 0 );

		 gl.cullFace( 1029 );
		 gl.frontFace( 2305 );

		 gl.polygonOffset( 0, 0 );

		 gl.activeTexture( 33984 );

		 gl.bindFramebuffer( 36160, null );

		 if ( isWebGL2 === true ) {

			 gl.bindFramebuffer( 36009, null );
			 gl.bindFramebuffer( 36008, null );

		 }

		 gl.useProgram( null );

		 gl.lineWidth( 1 );

		 gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		 gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		 // reset internals

		 enabledCapabilities = {};

		 currentTextureSlot = null;
		 currentBoundTextures = {};

		 xrFramebuffer = null;
		 currentBoundFramebuffers = {};

		 currentProgram = null;

		 currentBlendingEnabled = false;
		 currentBlending = null;
		 currentBlendEquation = null;
		 currentBlendSrc = null;
		 currentBlendDst = null;
		 currentBlendEquationAlpha = null;
		 currentBlendSrcAlpha = null;
		 currentBlendDstAlpha = null;
		 currentPremultipledAlpha = false;

		 currentFlipSided = null;
		 currentCullFace = null;

		 currentLineWidth = null;

		 currentPolygonOffsetFactor = null;
		 currentPolygonOffsetUnits = null;

		 currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		 currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		 colorBuffer.reset();
		 depthBuffer.reset();
		 stencilBuffer.reset();

	 }

	 return {

		 buffers: {
			 color: colorBuffer,
			 depth: depthBuffer,
			 stencil: stencilBuffer
		 },

		 enable: enable,
		 disable: disable,

		 bindFramebuffer: bindFramebuffer,
		 bindXRFramebuffer: bindXRFramebuffer,

		 useProgram: useProgram,

		 setBlending: setBlending,
		 setMaterial: setMaterial,

		 setFlipSided: setFlipSided,
		 setCullFace: setCullFace,

		 setLineWidth: setLineWidth,
		 setPolygonOffset: setPolygonOffset,

		 setScissorTest: setScissorTest,

		 activeTexture: activeTexture,
		 bindTexture: bindTexture,
		 unbindTexture: unbindTexture,
		 compressedTexImage2D: compressedTexImage2D,
		 texImage2D: texImage2D,
		 texImage3D: texImage3D,

		 scissor: scissor,
		 viewport: viewport,

		 reset: reset

	 };

 }

 function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	 const isWebGL2 = capabilities.isWebGL2;
	 const maxTextures = capabilities.maxTextures;
	 const maxCubemapSize = capabilities.maxCubemapSize;
	 const maxTextureSize = capabilities.maxTextureSize;
	 const maxSamples = capabilities.maxSamples;

	 const _videoTextures = new WeakMap();
	 let _canvas;

	 // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	 // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	 // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	 let useOffscreenCanvas = false;

	 try {

		 useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			 && ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	 } catch ( err ) {

		 // Ignore any errors

	 }

	 function createCanvas( width, height ) {

		 // Use OffscreenCanvas when available. Specially needed in web workers

		 return useOffscreenCanvas ?
			 new OffscreenCanvas( width, height ) :
			 document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	 }

	 function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		 let scale = 1;

		 // handle case if texture exceeds max size

		 if ( image.width > maxSize || image.height > maxSize ) {

			 scale = maxSize / Math.max( image.width, image.height );

		 }

		 // only perform resize if necessary

		 if ( scale < 1 || needsPowerOfTwo === true ) {

			 // only perform resize for certain image types

			 if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				 ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				 ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				 const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

				 const width = floor( scale * image.width );
				 const height = floor( scale * image.height );

				 if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				 // cube textures can't reuse the same canvas

				 const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				 canvas.width = width;
				 canvas.height = height;

				 const context = canvas.getContext( '2d' );
				 context.drawImage( image, 0, 0, width, height );

				 console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				 return canvas;

			 } else {

				 if ( 'data' in image ) {

					 console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				 }

				 return image;

			 }

		 }

		 return image;

	 }

	 function isPowerOfTwo$1( image ) {

		 return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

	 }

	 function textureNeedsPowerOfTwo( texture ) {

		 if ( isWebGL2 ) return false;

		 return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			 ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	 }

	 function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		 return texture.generateMipmaps && supportsMips &&
			 texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	 }

	 function generateMipmap( target, texture, width, height, depth = 1 ) {

		 _gl.generateMipmap( target );

		 const textureProperties = properties.get( texture );

		 textureProperties.__maxMipLevel = Math.log2( Math.max( width, height, depth ) );

	 }

	 function getInternalFormat( internalFormatName, glFormat, glType ) {

		 if ( isWebGL2 === false ) return glFormat;

		 if ( internalFormatName !== null ) {

			 if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			 console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		 }

		 let internalFormat = glFormat;

		 if ( glFormat === 6403 ) {

			 if ( glType === 5126 ) internalFormat = 33326;
			 if ( glType === 5131 ) internalFormat = 33325;
			 if ( glType === 5121 ) internalFormat = 33321;

		 }

		 if ( glFormat === 6407 ) {

			 if ( glType === 5126 ) internalFormat = 34837;
			 if ( glType === 5131 ) internalFormat = 34843;
			 if ( glType === 5121 ) internalFormat = 32849;

		 }

		 if ( glFormat === 6408 ) {

			 if ( glType === 5126 ) internalFormat = 34836;
			 if ( glType === 5131 ) internalFormat = 34842;
			 if ( glType === 5121 ) internalFormat = 32856;

		 }

		 if ( internalFormat === 33325 || internalFormat === 33326 ||
			 internalFormat === 34842 || internalFormat === 34836 ) {

			 extensions.get( 'EXT_color_buffer_float' );

		 }

		 return internalFormat;

	 }

	 // Fallback filters for non-power-of-2 textures

	 function filterFallback( f ) {

		 if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			 return 9728;

		 }

		 return 9729;

	 }

	 //

	 function onTextureDispose( event ) {

		 const texture = event.target;

		 texture.removeEventListener( 'dispose', onTextureDispose );

		 deallocateTexture( texture );

		 if ( texture.isVideoTexture ) {

			 _videoTextures.delete( texture );

		 }

		 info.memory.textures --;

	 }

	 function onRenderTargetDispose( event ) {

		 const renderTarget = event.target;

		 renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		 deallocateRenderTarget( renderTarget );

	 }

	 //

	 function deallocateTexture( texture ) {

		 const textureProperties = properties.get( texture );

		 if ( textureProperties.__webglInit === undefined ) return;

		 _gl.deleteTexture( textureProperties.__webglTexture );

		 properties.remove( texture );

	 }

	 function deallocateRenderTarget( renderTarget ) {

		 const texture = renderTarget.texture;

		 const renderTargetProperties = properties.get( renderTarget );
		 const textureProperties = properties.get( texture );

		 if ( ! renderTarget ) return;

		 if ( textureProperties.__webglTexture !== undefined ) {

			 _gl.deleteTexture( textureProperties.__webglTexture );

			 info.memory.textures --;

		 }

		 if ( renderTarget.depthTexture ) {

			 renderTarget.depthTexture.dispose();

		 }

		 if ( renderTarget.isWebGLCubeRenderTarget ) {

			 for ( let i = 0; i < 6; i ++ ) {

				 _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				 if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			 }

		 } else {

			 _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			 if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			 if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			 if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			 if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		 }

		 if ( renderTarget.isWebGLMultipleRenderTargets ) {

			 for ( let i = 0, il = texture.length; i < il; i ++ ) {

				 const attachmentProperties = properties.get( texture[ i ] );

				 if ( attachmentProperties.__webglTexture ) {

					 _gl.deleteTexture( attachmentProperties.__webglTexture );

					 info.memory.textures --;

				 }

				 properties.remove( texture[ i ] );

			 }

		 }

		 properties.remove( texture );
		 properties.remove( renderTarget );

	 }

	 //

	 let textureUnits = 0;

	 function resetTextureUnits() {

		 textureUnits = 0;

	 }

	 function allocateTextureUnit() {

		 const textureUnit = textureUnits;

		 if ( textureUnit >= maxTextures ) {

			 console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		 }

		 textureUnits += 1;

		 return textureUnit;

	 }

	 //

	 function setTexture2D( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.isVideoTexture ) updateVideoTexture( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 const image = texture.image;

			 if ( image === undefined ) {

				 console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			 } else if ( image.complete === false ) {

				 console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			 } else {

				 uploadTexture( textureProperties, texture, slot );
				 return;

			 }

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 3553, textureProperties.__webglTexture );

	 }

	 function setTexture2DArray( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 uploadTexture( textureProperties, texture, slot );
			 return;

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 35866, textureProperties.__webglTexture );

	 }

	 function setTexture3D( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 uploadTexture( textureProperties, texture, slot );
			 return;

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 32879, textureProperties.__webglTexture );

	 }

	 function setTextureCube( texture, slot ) {

		 const textureProperties = properties.get( texture );

		 if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			 uploadCubeTexture( textureProperties, texture, slot );
			 return;

		 }

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 34067, textureProperties.__webglTexture );

	 }

	 const wrappingToGL = {
		 [ RepeatWrapping ]: 10497,
		 [ ClampToEdgeWrapping ]: 33071,
		 [ MirroredRepeatWrapping ]: 33648
	 };

	 const filterToGL = {
		 [ NearestFilter ]: 9728,
		 [ NearestMipmapNearestFilter ]: 9984,
		 [ NearestMipmapLinearFilter ]: 9986,

		 [ LinearFilter ]: 9729,
		 [ LinearMipmapNearestFilter ]: 9985,
		 [ LinearMipmapLinearFilter ]: 9987
	 };

	 function setTextureParameters( textureType, texture, supportsMips ) {

		 if ( supportsMips ) {

			 _gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			 _gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			 if ( textureType === 32879 || textureType === 35866 ) {

				 _gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			 }

			 _gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			 _gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		 } else {

			 _gl.texParameteri( textureType, 10242, 33071 );
			 _gl.texParameteri( textureType, 10243, 33071 );

			 if ( textureType === 32879 || textureType === 35866 ) {

				 _gl.texParameteri( textureType, 32882, 33071 );

			 }

			 if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				 console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			 }

			 _gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			 _gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			 if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				 console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			 }

		 }

		 if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			 const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			 if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			 if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			 if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				 _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				 properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			 }

		 }

	 }

	 function initTexture( textureProperties, texture ) {

		 if ( textureProperties.__webglInit === undefined ) {

			 textureProperties.__webglInit = true;

			 texture.addEventListener( 'dispose', onTextureDispose );

			 textureProperties.__webglTexture = _gl.createTexture();

			 info.memory.textures ++;

		 }

	 }

	 function uploadTexture( textureProperties, texture, slot ) {

		 let textureType = 3553;

		 if ( texture.isDataTexture2DArray ) textureType = 35866;
		 if ( texture.isDataTexture3D ) textureType = 32879;

		 initTexture( textureProperties, texture );

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( textureType, textureProperties.__webglTexture );

		 _gl.pixelStorei( 37440, texture.flipY );
		 _gl.pixelStorei( 37441, texture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, texture.unpackAlignment );
		 _gl.pixelStorei( 37443, 0 );

		 const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
		 const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		 const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
			 glFormat = utils.convert( texture.format );

		 let glType = utils.convert( texture.type ),
			 glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		 setTextureParameters( textureType, texture, supportsMips );

		 let mipmap;
		 const mipmaps = texture.mipmaps;

		 if ( texture.isDepthTexture ) {

			 // populate depth texture with dummy data

			 glInternalFormat = 6402;

			 if ( isWebGL2 ) {

				 if ( texture.type === FloatType ) {

					 glInternalFormat = 36012;

				 } else if ( texture.type === UnsignedIntType ) {

					 glInternalFormat = 33190;

				 } else if ( texture.type === UnsignedInt248Type ) {

					 glInternalFormat = 35056;

				 } else {

					 glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				 }

			 } else {

				 if ( texture.type === FloatType ) {

					 console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				 }

			 }

			 // validation checks for WebGL 1

			 if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

				 // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				 // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				 // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				 if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					 console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					 texture.type = UnsignedShortType;
					 glType = utils.convert( texture.type );

				 }

			 }

			 if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

				 // Depth stencil textures need the DEPTH_STENCIL internal format
				 // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				 glInternalFormat = 34041;

				 // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				 // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				 // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				 if ( texture.type !== UnsignedInt248Type ) {

					 console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					 texture.type = UnsignedInt248Type;
					 glType = utils.convert( texture.type );

				 }

			 }

			 //

			 state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		 } else if ( texture.isDataTexture ) {

			 // use manually created mipmaps if available
			 // if there are no manual mipmaps
			 // set 0 level mipmap and then use GL to generate other mipmap levels

			 if ( mipmaps.length > 0 && supportsMips ) {

				 for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					 mipmap = mipmaps[ i ];
					 state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				 }

				 texture.generateMipmaps = false;
				 textureProperties.__maxMipLevel = mipmaps.length - 1;

			 } else {

				 state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				 textureProperties.__maxMipLevel = 0;

			 }

		 } else if ( texture.isCompressedTexture ) {

			 for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

				 mipmap = mipmaps[ i ];

				 if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					 if ( glFormat !== null ) {

						 state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					 } else {

						 console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					 }

				 } else {

					 state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				 }

			 }

			 textureProperties.__maxMipLevel = mipmaps.length - 1;

		 } else if ( texture.isDataTexture2DArray ) {

			 state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			 textureProperties.__maxMipLevel = 0;

		 } else if ( texture.isDataTexture3D ) {

			 state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			 textureProperties.__maxMipLevel = 0;

		 } else {

			 // regular Texture (image, video, canvas)

			 // use manually created mipmaps if available
			 // if there are no manual mipmaps
			 // set 0 level mipmap and then use GL to generate other mipmap levels

			 if ( mipmaps.length > 0 && supportsMips ) {

				 for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					 mipmap = mipmaps[ i ];
					 state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				 }

				 texture.generateMipmaps = false;
				 textureProperties.__maxMipLevel = mipmaps.length - 1;

			 } else {

				 state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				 textureProperties.__maxMipLevel = 0;

			 }

		 }

		 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			 generateMipmap( textureType, texture, image.width, image.height );

		 }

		 textureProperties.__version = texture.version;

		 if ( texture.onUpdate ) texture.onUpdate( texture );

	 }

	 function uploadCubeTexture( textureProperties, texture, slot ) {

		 if ( texture.image.length !== 6 ) return;

		 initTexture( textureProperties, texture );

		 state.activeTexture( 33984 + slot );
		 state.bindTexture( 34067, textureProperties.__webglTexture );

		 _gl.pixelStorei( 37440, texture.flipY );
		 _gl.pixelStorei( 37441, texture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, texture.unpackAlignment );
		 _gl.pixelStorei( 37443, 0 );

		 const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
		 const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

		 const cubeImage = [];

		 for ( let i = 0; i < 6; i ++ ) {

			 if ( ! isCompressed && ! isDataTexture ) {

				 cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

			 } else {

				 cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

			 }

		 }

		 const image = cubeImage[ 0 ],
			 supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
			 glFormat = utils.convert( texture.format ),
			 glType = utils.convert( texture.type ),
			 glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		 setTextureParameters( 34067, texture, supportsMips );

		 let mipmaps;

		 if ( isCompressed ) {

			 for ( let i = 0; i < 6; i ++ ) {

				 mipmaps = cubeImage[ i ].mipmaps;

				 for ( let j = 0; j < mipmaps.length; j ++ ) {

					 const mipmap = mipmaps[ j ];

					 if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						 if ( glFormat !== null ) {

							 state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						 } else {

							 console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

						 }

					 } else {

						 state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					 }

				 }

			 }

			 textureProperties.__maxMipLevel = mipmaps.length - 1;

		 } else {

			 mipmaps = texture.mipmaps;

			 for ( let i = 0; i < 6; i ++ ) {

				 if ( isDataTexture ) {

					 state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

					 for ( let j = 0; j < mipmaps.length; j ++ ) {

						 const mipmap = mipmaps[ j ];
						 const mipmapImage = mipmap.image[ i ].image;

						 state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

					 }

				 } else {

					 state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

					 for ( let j = 0; j < mipmaps.length; j ++ ) {

						 const mipmap = mipmaps[ j ];

						 state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

					 }

				 }

			 }

			 textureProperties.__maxMipLevel = mipmaps.length;

		 }

		 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			 // We assume images for cube map have the same size.
			 generateMipmap( 34067, texture, image.width, image.height );

		 }

		 textureProperties.__version = texture.version;

		 if ( texture.onUpdate ) texture.onUpdate( texture );

	 }

	 // Render targets

	 // Setup storage for target texture and bind it to correct framebuffer
	 function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

		 const glFormat = utils.convert( texture.format );
		 const glType = utils.convert( texture.type );
		 const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		 if ( textureTarget === 32879 || textureTarget === 35866 ) {

			 state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

		 } else {

			 state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

		 }

		 state.bindFramebuffer( 36160, framebuffer );
		 _gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
		 state.bindFramebuffer( 36160, null );

	 }

	 // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	 function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		 _gl.bindRenderbuffer( 36161, renderbuffer );

		 if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			 let glInternalFormat = 33189;

			 if ( isMultisample ) {

				 const depthTexture = renderTarget.depthTexture;

				 if ( depthTexture && depthTexture.isDepthTexture ) {

					 if ( depthTexture.type === FloatType ) {

						 glInternalFormat = 36012;

					 } else if ( depthTexture.type === UnsignedIntType ) {

						 glInternalFormat = 33190;

					 }

				 }

				 const samples = getRenderTargetSamples( renderTarget );

				 _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			 } else {

				 _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			 }

			 _gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		 } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			 if ( isMultisample ) {

				 const samples = getRenderTargetSamples( renderTarget );

				 _gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			 } else {

				 _gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			 }


			 _gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		 } else {

			 // Use the first texture for MRT so far
			 const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[ 0 ] : renderTarget.texture;

			 const glFormat = utils.convert( texture.format );
			 const glType = utils.convert( texture.type );
			 const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			 if ( isMultisample ) {

				 const samples = getRenderTargetSamples( renderTarget );

				 _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			 } else {

				 _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			 }

		 }

		 _gl.bindRenderbuffer( 36161, null );

	 }

	 // Setup resources for a Depth Texture for a FBO (needs an extension)
	 function setupDepthTexture( framebuffer, renderTarget ) {

		 const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		 if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		 state.bindFramebuffer( 36160, framebuffer );

		 if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			 throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		 }

		 // upload an empty depth texture with framebuffer size
		 if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				 renderTarget.depthTexture.image.width !== renderTarget.width ||
				 renderTarget.depthTexture.image.height !== renderTarget.height ) {

			 renderTarget.depthTexture.image.width = renderTarget.width;
			 renderTarget.depthTexture.image.height = renderTarget.height;
			 renderTarget.depthTexture.needsUpdate = true;

		 }

		 setTexture2D( renderTarget.depthTexture, 0 );

		 const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		 if ( renderTarget.depthTexture.format === DepthFormat ) {

			 _gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		 } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			 _gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		 } else {

			 throw new Error( 'Unknown depthTexture format' );

		 }

	 }

	 // Setup GL resources for a non-texture depth buffer
	 function setupDepthRenderbuffer( renderTarget ) {

		 const renderTargetProperties = properties.get( renderTarget );

		 const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		 if ( renderTarget.depthTexture ) {

			 if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			 setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		 } else {

			 if ( isCube ) {

				 renderTargetProperties.__webglDepthbuffer = [];

				 for ( let i = 0; i < 6; i ++ ) {

					 state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					 renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					 setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				 }

			 } else {

				 state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				 renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				 setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			 }

		 }

		 state.bindFramebuffer( 36160, null );

	 }

	 // Set up GL resources for the render target
	 function setupRenderTarget( renderTarget ) {

		 const texture = renderTarget.texture;

		 const renderTargetProperties = properties.get( renderTarget );
		 const textureProperties = properties.get( texture );

		 renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		 if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

			 textureProperties.__webglTexture = _gl.createTexture();
			 textureProperties.__version = texture.version;
			 info.memory.textures ++;

		 }

		 const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		 const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
		 const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		 const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
		 const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		 // Handles WebGL2 RGBFormat fallback - #18858

		 if ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {

			 texture.format = RGBAFormat;

			 console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		 }

		 // Setup framebuffer

		 if ( isCube ) {

			 renderTargetProperties.__webglFramebuffer = [];

			 for ( let i = 0; i < 6; i ++ ) {

				 renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			 }

		 } else {

			 renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			 if ( isMultipleRenderTargets ) {

				 if ( capabilities.drawBuffers ) {

					 const textures = renderTarget.texture;

					 for ( let i = 0, il = textures.length; i < il; i ++ ) {

						 const attachmentProperties = properties.get( textures[ i ] );

						 if ( attachmentProperties.__webglTexture === undefined ) {

							 attachmentProperties.__webglTexture = _gl.createTexture();

							 info.memory.textures ++;

						 }

					 }

				 } else {

					 console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

				 }

			 } else if ( isMultisample ) {

				 if ( isWebGL2 ) {

					 renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					 renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					 _gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					 const glFormat = utils.convert( texture.format );
					 const glType = utils.convert( texture.type );
					 const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
					 const samples = getRenderTargetSamples( renderTarget );
					 _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					 state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					 _gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					 _gl.bindRenderbuffer( 36161, null );

					 if ( renderTarget.depthBuffer ) {

						 renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						 setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					 }

					 state.bindFramebuffer( 36160, null );


				 } else {

					 console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				 }

			 }

		 }

		 // Setup color buffer

		 if ( isCube ) {

			 state.bindTexture( 34067, textureProperties.__webglTexture );
			 setTextureParameters( 34067, texture, supportsMips );

			 for ( let i = 0; i < 6; i ++ ) {

				 setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

			 }

			 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				 generateMipmap( 34067, texture, renderTarget.width, renderTarget.height );

			 }

			 state.bindTexture( 34067, null );

		 } else if ( isMultipleRenderTargets ) {

			 const textures = renderTarget.texture;

			 for ( let i = 0, il = textures.length; i < il; i ++ ) {

				 const attachment = textures[ i ];
				 const attachmentProperties = properties.get( attachment );

				 state.bindTexture( 3553, attachmentProperties.__webglTexture );
				 setTextureParameters( 3553, attachment, supportsMips );
				 setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

				 if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

					 generateMipmap( 3553, attachment, renderTarget.width, renderTarget.height );

				 }

			 }

			 state.bindTexture( 3553, null );

		 } else {

			 let glTextureType = 3553;

			 if ( isRenderTarget3D ) {

				 // Render targets containing layers, i.e: Texture 3D and 2d arrays

				 if ( isWebGL2 ) {

					 const isTexture3D = texture.isDataTexture3D;
					 glTextureType = isTexture3D ? 32879 : 35866;

				 } else {

					 console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

				 }

			 }

			 state.bindTexture( glTextureType, textureProperties.__webglTexture );
			 setTextureParameters( glTextureType, texture, supportsMips );
			 setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

			 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				 generateMipmap( glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth );

			 }

			 state.bindTexture( glTextureType, null );

		 }

		 // Setup depth and stencil buffers

		 if ( renderTarget.depthBuffer ) {

			 setupDepthRenderbuffer( renderTarget );

		 }

	 }

	 function updateRenderTargetMipmap( renderTarget ) {

		 const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		 const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

		 for ( let i = 0, il = textures.length; i < il; i ++ ) {

			 const texture = textures[ i ];

			 if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				 const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
				 const webglTexture = properties.get( texture ).__webglTexture;

				 state.bindTexture( target, webglTexture );
				 generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				 state.bindTexture( target, null );

			 }

		 }

	 }

	 function updateMultisampleRenderTarget( renderTarget ) {

		 if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			 if ( isWebGL2 ) {

				 const width = renderTarget.width;
				 const height = renderTarget.height;
				 let mask = 16384;

				 if ( renderTarget.depthBuffer ) mask |= 256;
				 if ( renderTarget.stencilBuffer ) mask |= 1024;

				 const renderTargetProperties = properties.get( renderTarget );

				 state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				 state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				 _gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				 state.bindFramebuffer( 36008, null );
				 state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

			 } else {

				 console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			 }

		 }

	 }

	 function getRenderTargetSamples( renderTarget ) {

		 return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			 Math.min( maxSamples, renderTarget.samples ) : 0;

	 }

	 function updateVideoTexture( texture ) {

		 const frame = info.render.frame;

		 // Check the last frame we updated the VideoTexture

		 if ( _videoTextures.get( texture ) !== frame ) {

			 _videoTextures.set( texture, frame );
			 texture.update();

		 }

	 }

	 // backwards compatibility

	 let warnedTexture2D = false;
	 let warnedTextureCube = false;

	 function safeSetTexture2D( texture, slot ) {

		 if ( texture && texture.isWebGLRenderTarget ) {

			 if ( warnedTexture2D === false ) {

				 console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
				 warnedTexture2D = true;

			 }

			 texture = texture.texture;

		 }

		 setTexture2D( texture, slot );

	 }

	 function safeSetTextureCube( texture, slot ) {

		 if ( texture && texture.isWebGLCubeRenderTarget ) {

			 if ( warnedTextureCube === false ) {

				 console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
				 warnedTextureCube = true;

			 }

			 texture = texture.texture;

		 }


		 setTextureCube( texture, slot );

	 }

	 //

	 this.allocateTextureUnit = allocateTextureUnit;
	 this.resetTextureUnits = resetTextureUnits;

	 this.setTexture2D = setTexture2D;
	 this.setTexture2DArray = setTexture2DArray;
	 this.setTexture3D = setTexture3D;
	 this.setTextureCube = setTextureCube;
	 this.setupRenderTarget = setupRenderTarget;
	 this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	 this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	 this.safeSetTexture2D = safeSetTexture2D;
	 this.safeSetTextureCube = safeSetTextureCube;

 }

 function WebGLUtils( gl, extensions, capabilities ) {

	 const isWebGL2 = capabilities.isWebGL2;

	 function convert( p ) {

		 let extension;

		 if ( p === UnsignedByteType ) return 5121;
		 if ( p === UnsignedShort4444Type ) return 32819;
		 if ( p === UnsignedShort5551Type ) return 32820;
		 if ( p === UnsignedShort565Type ) return 33635;

		 if ( p === ByteType ) return 5120;
		 if ( p === ShortType ) return 5122;
		 if ( p === UnsignedShortType ) return 5123;
		 if ( p === IntType ) return 5124;
		 if ( p === UnsignedIntType ) return 5125;
		 if ( p === FloatType ) return 5126;

		 if ( p === HalfFloatType ) {

			 if ( isWebGL2 ) return 5131;

			 extension = extensions.get( 'OES_texture_half_float' );

			 if ( extension !== null ) {

				 return extension.HALF_FLOAT_OES;

			 } else {

				 return null;

			 }

		 }

		 if ( p === AlphaFormat ) return 6406;
		 if ( p === RGBFormat ) return 6407;
		 if ( p === RGBAFormat ) return 6408;
		 if ( p === LuminanceFormat ) return 6409;
		 if ( p === LuminanceAlphaFormat ) return 6410;
		 if ( p === DepthFormat ) return 6402;
		 if ( p === DepthStencilFormat ) return 34041;
		 if ( p === RedFormat ) return 6403;

		 // WebGL2 formats.

		 if ( p === RedIntegerFormat ) return 36244;
		 if ( p === RGFormat ) return 33319;
		 if ( p === RGIntegerFormat ) return 33320;
		 if ( p === RGBIntegerFormat ) return 36248;
		 if ( p === RGBAIntegerFormat ) return 36249;

		 if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			 p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			 if ( extension !== null ) {

				 if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				 if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				 if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				 if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			 p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			 if ( extension !== null ) {

				 if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				 if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				 if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				 if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGB_ETC1_Format ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			 if ( extension !== null ) {

				 return extension.COMPRESSED_RGB_ETC1_WEBGL;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			 if ( extension !== null ) {

				 if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
				 if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			 }

		 }

		 if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			 p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			 p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			 p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			 p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
			 p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
			 p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
			 p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
			 p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
			 p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

			 extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			 if ( extension !== null ) {

				 // TODO Complete?

				 return p;

			 } else {

				 return null;

			 }

		 }

		 if ( p === RGBA_BPTC_Format ) {

			 extension = extensions.get( 'EXT_texture_compression_bptc' );

			 if ( extension !== null ) {

				 // TODO Complete?

				 return p;

			 } else {

				 return null;

			 }

		 }

		 if ( p === UnsignedInt248Type ) {

			 if ( isWebGL2 ) return 34042;

			 extension = extensions.get( 'WEBGL_depth_texture' );

			 if ( extension !== null ) {

				 return extension.UNSIGNED_INT_24_8_WEBGL;

			 } else {

				 return null;

			 }

		 }

	 }

	 return { convert: convert };

 }

 class ArrayCamera extends PerspectiveCamera {

	 constructor( array = [] ) {

		 super();

		 this.cameras = array;

	 }

 }

 ArrayCamera.prototype.isArrayCamera = true;

 class Group extends Object3D {

	 constructor() {

		 super();

		 this.type = 'Group';

	 }

 }

 Group.prototype.isGroup = true;

 const _moveEvent = { type: 'move' };

 class WebXRController {

	 constructor() {

		 this._targetRay = null;
		 this._grip = null;
		 this._hand = null;

	 }

	 getHandSpace() {

		 if ( this._hand === null ) {

			 this._hand = new Group();
			 this._hand.matrixAutoUpdate = false;
			 this._hand.visible = false;

			 this._hand.joints = {};
			 this._hand.inputState = { pinching: false };

		 }

		 return this._hand;

	 }

	 getTargetRaySpace() {

		 if ( this._targetRay === null ) {

			 this._targetRay = new Group();
			 this._targetRay.matrixAutoUpdate = false;
			 this._targetRay.visible = false;
			 this._targetRay.hasLinearVelocity = false;
			 this._targetRay.linearVelocity = new Vector3();
			 this._targetRay.hasAngularVelocity = false;
			 this._targetRay.angularVelocity = new Vector3();

		 }

		 return this._targetRay;

	 }

	 getGripSpace() {

		 if ( this._grip === null ) {

			 this._grip = new Group();
			 this._grip.matrixAutoUpdate = false;
			 this._grip.visible = false;
			 this._grip.hasLinearVelocity = false;
			 this._grip.linearVelocity = new Vector3();
			 this._grip.hasAngularVelocity = false;
			 this._grip.angularVelocity = new Vector3();

		 }

		 return this._grip;

	 }

	 dispatchEvent( event ) {

		 if ( this._targetRay !== null ) {

			 this._targetRay.dispatchEvent( event );

		 }

		 if ( this._grip !== null ) {

			 this._grip.dispatchEvent( event );

		 }

		 if ( this._hand !== null ) {

			 this._hand.dispatchEvent( event );

		 }

		 return this;

	 }

	 disconnect( inputSource ) {

		 this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		 if ( this._targetRay !== null ) {

			 this._targetRay.visible = false;

		 }

		 if ( this._grip !== null ) {

			 this._grip.visible = false;

		 }

		 if ( this._hand !== null ) {

			 this._hand.visible = false;

		 }

		 return this;

	 }

	 update( inputSource, frame, referenceSpace ) {

		 let inputPose = null;
		 let gripPose = null;
		 let handPose = null;

		 const targetRay = this._targetRay;
		 const grip = this._grip;
		 const hand = this._hand;

		 if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			 if ( targetRay !== null ) {

				 inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				 if ( inputPose !== null ) {

					 targetRay.matrix.fromArray( inputPose.transform.matrix );
					 targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					 if ( inputPose.linearVelocity ) {

						 targetRay.hasLinearVelocity = true;
						 targetRay.linearVelocity.copy( inputPose.linearVelocity );

					 } else {

						 targetRay.hasLinearVelocity = false;

					 }

					 if ( inputPose.angularVelocity ) {

						 targetRay.hasAngularVelocity = true;
						 targetRay.angularVelocity.copy( inputPose.angularVelocity );

					 } else {

						 targetRay.hasAngularVelocity = false;

					 }

					 this.dispatchEvent( _moveEvent );

				 }

			 }

			 if ( hand && inputSource.hand ) {

				 handPose = true;

				 for ( const inputjoint of inputSource.hand.values() ) {

					 // Update the joints groups with the XRJoint poses
					 const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					 if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						 // The transform of this joint will be updated with the joint pose on each frame
						 const joint = new Group();
						 joint.matrixAutoUpdate = false;
						 joint.visible = false;
						 hand.joints[ inputjoint.jointName ] = joint;
						 // ??
						 hand.add( joint );

					 }

					 const joint = hand.joints[ inputjoint.jointName ];

					 if ( jointPose !== null ) {

						 joint.matrix.fromArray( jointPose.transform.matrix );
						 joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						 joint.jointRadius = jointPose.radius;

					 }

					 joint.visible = jointPose !== null;

				 }

				 // Custom events

				 // Check pinchz
				 const indexTip = hand.joints[ 'index-finger-tip' ];
				 const thumbTip = hand.joints[ 'thumb-tip' ];
				 const distance = indexTip.position.distanceTo( thumbTip.position );

				 const distanceToPinch = 0.02;
				 const threshold = 0.005;

				 if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					 hand.inputState.pinching = false;
					 this.dispatchEvent( {
						 type: 'pinchend',
						 handedness: inputSource.handedness,
						 target: this
					 } );

				 } else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					 hand.inputState.pinching = true;
					 this.dispatchEvent( {
						 type: 'pinchstart',
						 handedness: inputSource.handedness,
						 target: this
					 } );

				 }

			 } else {

				 if ( grip !== null && inputSource.gripSpace ) {

					 gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					 if ( gripPose !== null ) {

						 grip.matrix.fromArray( gripPose.transform.matrix );
						 grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						 if ( gripPose.linearVelocity ) {

							 grip.hasLinearVelocity = true;
							 grip.linearVelocity.copy( gripPose.linearVelocity );

						 } else {

							 grip.hasLinearVelocity = false;

						 }

						 if ( gripPose.angularVelocity ) {

							 grip.hasAngularVelocity = true;
							 grip.angularVelocity.copy( gripPose.angularVelocity );

						 } else {

							 grip.hasAngularVelocity = false;

						 }

					 }

				 }

			 }

		 }

		 if ( targetRay !== null ) {

			 targetRay.visible = ( inputPose !== null );

		 }

		 if ( grip !== null ) {

			 grip.visible = ( gripPose !== null );

		 }

		 if ( hand !== null ) {

			 hand.visible = ( handPose !== null );

		 }

		 return this;

	 }

 }

 class WebXRManager extends EventDispatcher {

	 constructor( renderer, gl ) {

		 super();

		 const scope = this;
		 const state = renderer.state;

		 let session = null;
		 let framebufferScaleFactor = 1.0;

		 let referenceSpace = null;
		 let referenceSpaceType = 'local-floor';

		 let pose = null;
		 let glBinding = null;
		 let glFramebuffer = null;
		 let glProjLayer = null;

		 const controllers = [];
		 const inputSourcesMap = new Map();

		 //

		 const cameraL = new PerspectiveCamera();
		 cameraL.layers.enable( 1 );
		 cameraL.viewport = new Vector4();

		 const cameraR = new PerspectiveCamera();
		 cameraR.layers.enable( 2 );
		 cameraR.viewport = new Vector4();

		 const cameras = [ cameraL, cameraR ];

		 const cameraVR = new ArrayCamera();
		 cameraVR.layers.enable( 1 );
		 cameraVR.layers.enable( 2 );

		 let _currentDepthNear = null;
		 let _currentDepthFar = null;

		 //

		 this.cameraAutoUpdate = true;
		 this.enabled = false;

		 this.isPresenting = false;

		 this.getController = function ( index ) {

			 let controller = controllers[ index ];

			 if ( controller === undefined ) {

				 controller = new WebXRController();
				 controllers[ index ] = controller;

			 }

			 return controller.getTargetRaySpace();

		 };

		 this.getControllerGrip = function ( index ) {

			 let controller = controllers[ index ];

			 if ( controller === undefined ) {

				 controller = new WebXRController();
				 controllers[ index ] = controller;

			 }

			 return controller.getGripSpace();

		 };

		 this.getHand = function ( index ) {

			 let controller = controllers[ index ];

			 if ( controller === undefined ) {

				 controller = new WebXRController();
				 controllers[ index ] = controller;

			 }

			 return controller.getHandSpace();

		 };

		 //

		 function onSessionEvent( event ) {

			 const controller = inputSourcesMap.get( event.inputSource );

			 if ( controller ) {

				 controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			 }

		 }

		 function onSessionEnd() {

			 inputSourcesMap.forEach( function ( controller, inputSource ) {

				 controller.disconnect( inputSource );

			 } );

			 inputSourcesMap.clear();

			 _currentDepthNear = null;
			 _currentDepthFar = null;

			 // restore framebuffer/rendering state

			 state.bindXRFramebuffer( null );
			 renderer.setRenderTarget( renderer.getRenderTarget() );

			 //

			 animation.stop();

			 scope.isPresenting = false;

			 scope.dispatchEvent( { type: 'sessionend' } );

		 }

		 this.setFramebufferScaleFactor = function ( value ) {

			 framebufferScaleFactor = value;

			 if ( scope.isPresenting === true ) {

				 console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			 }

		 };

		 this.setReferenceSpaceType = function ( value ) {

			 referenceSpaceType = value;

			 if ( scope.isPresenting === true ) {

				 console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			 }

		 };

		 this.getReferenceSpace = function () {

			 return referenceSpace;

		 };

		 this.getSession = function () {

			 return session;

		 };

		 this.setSession = async function ( value ) {

			 session = value;

			 if ( session !== null ) {

				 session.addEventListener( 'select', onSessionEvent );
				 session.addEventListener( 'selectstart', onSessionEvent );
				 session.addEventListener( 'selectend', onSessionEvent );
				 session.addEventListener( 'squeeze', onSessionEvent );
				 session.addEventListener( 'squeezestart', onSessionEvent );
				 session.addEventListener( 'squeezeend', onSessionEvent );
				 session.addEventListener( 'end', onSessionEnd );
				 session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				 const attributes = gl.getContextAttributes();

				 if ( attributes.xrCompatible !== true ) {

					 await gl.makeXRCompatible();

				 }

				 if ( session.renderState.layers === undefined ) {

					 const layerInit = {
						 antialias: attributes.antialias,
						 alpha: attributes.alpha,
						 depth: attributes.depth,
						 stencil: attributes.stencil,
						 framebufferScaleFactor: framebufferScaleFactor
					 };

					 // eslint-disable-next-line no-undef
					 const baseLayer = new XRWebGLLayer( session, gl, layerInit );

					 session.updateRenderState( { baseLayer: baseLayer } );

				 } else {

					 let depthFormat = 0;

					 if ( attributes.depth ) {

						 depthFormat = attributes.stencil ? 34041 : 6402;

					 }

					 const projectionlayerInit = {
						 colorFormat: attributes.alpha ? 6408 : 6407,
						 depthFormat: depthFormat,
						 scaleFactor: framebufferScaleFactor
					 };

					 // eslint-disable-next-line no-undef
					 glBinding = new XRWebGLBinding( session, gl );

					 glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					 glFramebuffer = gl.createFramebuffer();

					 session.updateRenderState( { layers: [ glProjLayer ] } );

				 }

				 referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				 animation.setContext( session );
				 animation.start();

				 scope.isPresenting = true;

				 scope.dispatchEvent( { type: 'sessionstart' } );

			 }

		 };

		 function onInputSourcesChange( event ) {

			 const inputSources = session.inputSources;

			 // Assign inputSources to available controllers

			 for ( let i = 0; i < controllers.length; i ++ ) {

				 inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

			 }

			 // Notify disconnected

			 for ( let i = 0; i < event.removed.length; i ++ ) {

				 const inputSource = event.removed[ i ];
				 const controller = inputSourcesMap.get( inputSource );

				 if ( controller ) {

					 controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					 inputSourcesMap.delete( inputSource );

				 }

			 }

			 // Notify connected

			 for ( let i = 0; i < event.added.length; i ++ ) {

				 const inputSource = event.added[ i ];
				 const controller = inputSourcesMap.get( inputSource );

				 if ( controller ) {

					 controller.dispatchEvent( { type: 'connected', data: inputSource } );

				 }

			 }

		 }

		 //

		 const cameraLPos = new Vector3();
		 const cameraRPos = new Vector3();

		 /**
			* Assumes 2 cameras that are parallel and share an X-axis, and that
			* the cameras' projection and world matrices have already been set.
			* And that near and far planes are identical for both cameras.
			* Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			*/
		 function setProjectionFromUnion( camera, cameraL, cameraR ) {

			 cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			 cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			 const ipd = cameraLPos.distanceTo( cameraRPos );

			 const projL = cameraL.projectionMatrix.elements;
			 const projR = cameraR.projectionMatrix.elements;

			 // VR systems will have identical far and near planes, and
			 // most likely identical top and bottom frustum extents.
			 // Use the left camera for these values.
			 const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			 const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			 const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			 const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			 const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			 const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			 const left = near * leftFov;
			 const right = near * rightFov;

			 // Calculate the new camera's position offset from the
			 // left camera. xOffset should be roughly half `ipd`.
			 const zOffset = ipd / ( - leftFov + rightFov );
			 const xOffset = zOffset * - leftFov;

			 // TODO: Better way to apply this offset?
			 cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			 camera.translateX( xOffset );
			 camera.translateZ( zOffset );
			 camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			 camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			 // Find the union of the frustum values of the cameras and scale
			 // the values so that the near plane's position does not change in world space,
			 // although must now be relative to the new union camera.
			 const near2 = near + zOffset;
			 const far2 = far + zOffset;
			 const left2 = left - xOffset;
			 const right2 = right + ( ipd - xOffset );
			 const top2 = topFov * far / far2 * near2;
			 const bottom2 = bottomFov * far / far2 * near2;

			 camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		 }

		 function updateCamera( camera, parent ) {

			 if ( parent === null ) {

				 camera.matrixWorld.copy( camera.matrix );

			 } else {

				 camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			 }

			 camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		 }

		 this.updateCamera = function ( camera ) {

			 if ( session === null ) return;

			 cameraVR.near = cameraR.near = cameraL.near = camera.near;
			 cameraVR.far = cameraR.far = cameraL.far = camera.far;

			 if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				 // Note that the new renderState won't apply until the next frame. See #18320

				 session.updateRenderState( {
					 depthNear: cameraVR.near,
					 depthFar: cameraVR.far
				 } );

				 _currentDepthNear = cameraVR.near;
				 _currentDepthFar = cameraVR.far;

			 }

			 const parent = camera.parent;
			 const cameras = cameraVR.cameras;

			 updateCamera( cameraVR, parent );

			 for ( let i = 0; i < cameras.length; i ++ ) {

				 updateCamera( cameras[ i ], parent );

			 }

			 cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

			 // update user camera and its children

			 camera.position.copy( cameraVR.position );
			 camera.quaternion.copy( cameraVR.quaternion );
			 camera.scale.copy( cameraVR.scale );
			 camera.matrix.copy( cameraVR.matrix );
			 camera.matrixWorld.copy( cameraVR.matrixWorld );

			 const children = camera.children;

			 for ( let i = 0, l = children.length; i < l; i ++ ) {

				 children[ i ].updateMatrixWorld( true );

			 }

			 // update projection matrix for proper view frustum culling

			 if ( cameras.length === 2 ) {

				 setProjectionFromUnion( cameraVR, cameraL, cameraR );

			 } else {

				 // assume single camera setup (AR)

				 cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			 }

		 };

		 this.getCamera = function () {

			 return cameraVR;

		 };

		 // Animation Loop

		 let onAnimationFrameCallback = null;

		 function onAnimationFrame( time, frame ) {

			 pose = frame.getViewerPose( referenceSpace );

			 if ( pose !== null ) {

				 const views = pose.views;

				 const baseLayer = session.renderState.baseLayer;

				 if ( session.renderState.layers === undefined ) {

					 state.bindXRFramebuffer( baseLayer.framebuffer );

				 }

				 let cameraVRNeedsUpdate = false;

				 // check if it's necessary to rebuild cameraVR's camera list

				 if ( views.length !== cameraVR.cameras.length ) {

					 cameraVR.cameras.length = 0;

					 cameraVRNeedsUpdate = true;


				 }

				 for ( let i = 0; i < views.length; i ++ ) {

					 const view = views[ i ];

					 let viewport = null;

					 if ( session.renderState.layers === undefined ) {

						 viewport = baseLayer.getViewport( view );

					 } else {

						 const glSubImage = glBinding.getViewSubImage( glProjLayer, view );

						 state.bindXRFramebuffer( glFramebuffer );

						 gl.framebufferTexture2D( 36160, 36064, 3553, glSubImage.colorTexture, 0 );

						 if ( glSubImage.depthStencilTexture !== undefined ) {

							 gl.framebufferTexture2D( 36160, 36096, 3553, glSubImage.depthStencilTexture, 0 );

						 }

						 viewport = glSubImage.viewport;

					 }

					 const camera = cameras[ i ];

					 camera.matrix.fromArray( view.transform.matrix );

					 camera.projectionMatrix.fromArray( view.projectionMatrix );

					 camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					 if ( i === 0 ) {

						 cameraVR.matrix.copy( camera.matrix );

					 }

					 if ( cameraVRNeedsUpdate === true ) {

						 cameraVR.cameras.push( camera );

					 }

				 }

			 }

			 //

			 const inputSources = session.inputSources;

			 for ( let i = 0; i < controllers.length; i ++ ) {

				 const controller = controllers[ i ];
				 const inputSource = inputSources[ i ];

				 controller.update( inputSource, frame, referenceSpace );

			 }

			 if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

		 }

		 const animation = new WebGLAnimation();
		 animation.setAnimationLoop( onAnimationFrame );

		 this.setAnimationLoop = function ( callback ) {

			 onAnimationFrameCallback = callback;

		 };

		 this.dispose = function () {};

	 }

 }

 function WebGLMaterials( properties ) {

	 function refreshFogUniforms( uniforms, fog ) {

		 uniforms.fogColor.value.copy( fog.color );

		 if ( fog.isFog ) {

			 uniforms.fogNear.value = fog.near;
			 uniforms.fogFar.value = fog.far;

		 } else if ( fog.isFogExp2 ) {

			 uniforms.fogDensity.value = fog.density;

		 }

	 }

	 function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		 if ( material.isMeshBasicMaterial ) {

			 refreshUniformsCommon( uniforms, material );

		 } else if ( material.isMeshLambertMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsLambert( uniforms, material );

		 } else if ( material.isMeshToonMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsToon( uniforms, material );

		 } else if ( material.isMeshPhongMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsPhong( uniforms, material );

		 } else if ( material.isMeshStandardMaterial ) {

			 refreshUniformsCommon( uniforms, material );

			 if ( material.isMeshPhysicalMaterial ) {

				 refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			 } else {

				 refreshUniformsStandard( uniforms, material );

			 }

		 } else if ( material.isMeshMatcapMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsMatcap( uniforms, material );

		 } else if ( material.isMeshDepthMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsDepth( uniforms, material );

		 } else if ( material.isMeshDistanceMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsDistance( uniforms, material );

		 } else if ( material.isMeshNormalMaterial ) {

			 refreshUniformsCommon( uniforms, material );
			 refreshUniformsNormal( uniforms, material );

		 } else if ( material.isLineBasicMaterial ) {

			 refreshUniformsLine( uniforms, material );

			 if ( material.isLineDashedMaterial ) {

				 refreshUniformsDash( uniforms, material );

			 }

		 } else if ( material.isPointsMaterial ) {

			 refreshUniformsPoints( uniforms, material, pixelRatio, height );

		 } else if ( material.isSpriteMaterial ) {

			 refreshUniformsSprites( uniforms, material );

		 } else if ( material.isShadowMaterial ) {

			 uniforms.color.value.copy( material.color );
			 uniforms.opacity.value = material.opacity;

		 } else if ( material.isShaderMaterial ) {

			 material.uniformsNeedUpdate = false; // #15581

		 }

	 }

	 function refreshUniformsCommon( uniforms, material ) {

		 uniforms.opacity.value = material.opacity;

		 if ( material.color ) {

			 uniforms.diffuse.value.copy( material.color );

		 }

		 if ( material.emissive ) {

			 uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		 }

		 if ( material.map ) {

			 uniforms.map.value = material.map;

		 }

		 if ( material.alphaMap ) {

			 uniforms.alphaMap.value = material.alphaMap;

		 }

		 if ( material.specularMap ) {

			 uniforms.specularMap.value = material.specularMap;

		 }

		 const envMap = properties.get( material ).envMap;

		 if ( envMap ) {

			 uniforms.envMap.value = envMap;

			 uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

			 uniforms.reflectivity.value = material.reflectivity;
			 uniforms.refractionRatio.value = material.refractionRatio;

			 const maxMipLevel = properties.get( envMap ).__maxMipLevel;

			 if ( maxMipLevel !== undefined ) {

				 uniforms.maxMipLevel.value = maxMipLevel;

			 }

		 }

		 if ( material.lightMap ) {

			 uniforms.lightMap.value = material.lightMap;
			 uniforms.lightMapIntensity.value = material.lightMapIntensity;

		 }

		 if ( material.aoMap ) {

			 uniforms.aoMap.value = material.aoMap;
			 uniforms.aoMapIntensity.value = material.aoMapIntensity;

		 }

		 // uv repeat and offset setting priorities
		 // 1. color map
		 // 2. specular map
		 // 3. displacementMap map
		 // 4. normal map
		 // 5. bump map
		 // 6. roughnessMap map
		 // 7. metalnessMap map
		 // 8. alphaMap map
		 // 9. emissiveMap map
		 // 10. clearcoat map
		 // 11. clearcoat normal map
		 // 12. clearcoat roughnessMap map

		 let uvScaleMap;

		 if ( material.map ) {

			 uvScaleMap = material.map;

		 } else if ( material.specularMap ) {

			 uvScaleMap = material.specularMap;

		 } else if ( material.displacementMap ) {

			 uvScaleMap = material.displacementMap;

		 } else if ( material.normalMap ) {

			 uvScaleMap = material.normalMap;

		 } else if ( material.bumpMap ) {

			 uvScaleMap = material.bumpMap;

		 } else if ( material.roughnessMap ) {

			 uvScaleMap = material.roughnessMap;

		 } else if ( material.metalnessMap ) {

			 uvScaleMap = material.metalnessMap;

		 } else if ( material.alphaMap ) {

			 uvScaleMap = material.alphaMap;

		 } else if ( material.emissiveMap ) {

			 uvScaleMap = material.emissiveMap;

		 } else if ( material.clearcoatMap ) {

			 uvScaleMap = material.clearcoatMap;

		 } else if ( material.clearcoatNormalMap ) {

			 uvScaleMap = material.clearcoatNormalMap;

		 } else if ( material.clearcoatRoughnessMap ) {

			 uvScaleMap = material.clearcoatRoughnessMap;

		 }

		 if ( uvScaleMap !== undefined ) {

			 // backwards compatibility
			 if ( uvScaleMap.isWebGLRenderTarget ) {

				 uvScaleMap = uvScaleMap.texture;

			 }

			 if ( uvScaleMap.matrixAutoUpdate === true ) {

				 uvScaleMap.updateMatrix();

			 }

			 uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		 }

		 // uv repeat and offset setting priorities for uv2
		 // 1. ao map
		 // 2. light map

		 let uv2ScaleMap;

		 if ( material.aoMap ) {

			 uv2ScaleMap = material.aoMap;

		 } else if ( material.lightMap ) {

			 uv2ScaleMap = material.lightMap;

		 }

		 if ( uv2ScaleMap !== undefined ) {

			 // backwards compatibility
			 if ( uv2ScaleMap.isWebGLRenderTarget ) {

				 uv2ScaleMap = uv2ScaleMap.texture;

			 }

			 if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				 uv2ScaleMap.updateMatrix();

			 }

			 uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		 }

	 }

	 function refreshUniformsLine( uniforms, material ) {

		 uniforms.diffuse.value.copy( material.color );
		 uniforms.opacity.value = material.opacity;

	 }

	 function refreshUniformsDash( uniforms, material ) {

		 uniforms.dashSize.value = material.dashSize;
		 uniforms.totalSize.value = material.dashSize + material.gapSize;
		 uniforms.scale.value = material.scale;

	 }

	 function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		 uniforms.diffuse.value.copy( material.color );
		 uniforms.opacity.value = material.opacity;
		 uniforms.size.value = material.size * pixelRatio;
		 uniforms.scale.value = height * 0.5;

		 if ( material.map ) {

			 uniforms.map.value = material.map;

		 }

		 if ( material.alphaMap ) {

			 uniforms.alphaMap.value = material.alphaMap;

		 }

		 // uv repeat and offset setting priorities
		 // 1. color map
		 // 2. alpha map

		 let uvScaleMap;

		 if ( material.map ) {

			 uvScaleMap = material.map;

		 } else if ( material.alphaMap ) {

			 uvScaleMap = material.alphaMap;

		 }

		 if ( uvScaleMap !== undefined ) {

			 if ( uvScaleMap.matrixAutoUpdate === true ) {

				 uvScaleMap.updateMatrix();

			 }

			 uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		 }

	 }

	 function refreshUniformsSprites( uniforms, material ) {

		 uniforms.diffuse.value.copy( material.color );
		 uniforms.opacity.value = material.opacity;
		 uniforms.rotation.value = material.rotation;

		 if ( material.map ) {

			 uniforms.map.value = material.map;

		 }

		 if ( material.alphaMap ) {

			 uniforms.alphaMap.value = material.alphaMap;

		 }

		 // uv repeat and offset setting priorities
		 // 1. color map
		 // 2. alpha map

		 let uvScaleMap;

		 if ( material.map ) {

			 uvScaleMap = material.map;

		 } else if ( material.alphaMap ) {

			 uvScaleMap = material.alphaMap;

		 }

		 if ( uvScaleMap !== undefined ) {

			 if ( uvScaleMap.matrixAutoUpdate === true ) {

				 uvScaleMap.updateMatrix();

			 }

			 uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		 }

	 }

	 function refreshUniformsLambert( uniforms, material ) {

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

	 }

	 function refreshUniformsPhong( uniforms, material ) {

		 uniforms.specular.value.copy( material.specular );
		 uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsToon( uniforms, material ) {

		 if ( material.gradientMap ) {

			 uniforms.gradientMap.value = material.gradientMap;

		 }

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsStandard( uniforms, material ) {

		 uniforms.roughness.value = material.roughness;
		 uniforms.metalness.value = material.metalness;

		 if ( material.roughnessMap ) {

			 uniforms.roughnessMap.value = material.roughnessMap;

		 }

		 if ( material.metalnessMap ) {

			 uniforms.metalnessMap.value = material.metalnessMap;

		 }

		 if ( material.emissiveMap ) {

			 uniforms.emissiveMap.value = material.emissiveMap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

		 const envMap = properties.get( material ).envMap;

		 if ( envMap ) {

			 //uniforms.envMap.value = material.envMap; // part of uniforms common
			 uniforms.envMapIntensity.value = material.envMapIntensity;

		 }

	 }

	 function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		 refreshUniformsStandard( uniforms, material );

		 uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		 uniforms.clearcoat.value = material.clearcoat;
		 uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

		 if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		 if ( material.clearcoatMap ) {

			 uniforms.clearcoatMap.value = material.clearcoatMap;

		 }

		 if ( material.clearcoatRoughnessMap ) {

			 uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		 }

		 if ( material.clearcoatNormalMap ) {

			 uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			 uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			 if ( material.side === BackSide ) {

				 uniforms.clearcoatNormalScale.value.negate();

			 }

		 }

		 uniforms.transmission.value = material.transmission;

		 if ( material.transmissionMap ) {

			 uniforms.transmissionMap.value = material.transmissionMap;

		 }

		 if ( material.transmission > 0.0 ) {

			 uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			 uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

		 }

		 uniforms.thickness.value = material.thickness;

		 if ( material.thicknessMap ) {

			 uniforms.thicknessMap.value = material.thicknessMap;

		 }

		 uniforms.attenuationDistance.value = material.attenuationDistance;
		 uniforms.attenuationColor.value.copy( material.attenuationColor );

	 }

	 function refreshUniformsMatcap( uniforms, material ) {

		 if ( material.matcap ) {

			 uniforms.matcap.value = material.matcap;

		 }

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsDepth( uniforms, material ) {

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 function refreshUniformsDistance( uniforms, material ) {

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

		 uniforms.referencePosition.value.copy( material.referencePosition );
		 uniforms.nearDistance.value = material.nearDistance;
		 uniforms.farDistance.value = material.farDistance;

	 }

	 function refreshUniformsNormal( uniforms, material ) {

		 if ( material.bumpMap ) {

			 uniforms.bumpMap.value = material.bumpMap;
			 uniforms.bumpScale.value = material.bumpScale;
			 if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		 }

		 if ( material.normalMap ) {

			 uniforms.normalMap.value = material.normalMap;
			 uniforms.normalScale.value.copy( material.normalScale );
			 if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		 }

		 if ( material.displacementMap ) {

			 uniforms.displacementMap.value = material.displacementMap;
			 uniforms.displacementScale.value = material.displacementScale;
			 uniforms.displacementBias.value = material.displacementBias;

		 }

	 }

	 return {
		 refreshFogUniforms: refreshFogUniforms,
		 refreshMaterialUniforms: refreshMaterialUniforms
	 };

 }

 function createCanvasElement() {

	 const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	 canvas.style.display = 'block';
	 return canvas;

 }

 function WebGLRenderer( parameters = {} ) {

	 const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		 _context = parameters.context !== undefined ? parameters.context : null,

		 _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		 _depth = parameters.depth !== undefined ? parameters.depth : true,
		 _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		 _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		 _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		 _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		 _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		 _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	 let currentRenderList = null;
	 let currentRenderState = null;

	 // render() can be called from within a callback triggered by another render.
	 // We track this so that the nested render call gets its list and state isolated from the parent render call.

	 const renderListStack = [];
	 const renderStateStack = [];

	 // public properties

	 this.domElement = _canvas;

	 // Debug configuration container
	 this.debug = {

		 /**
			* Enables error checking and reporting when shader programs are being compiled
			* @type {boolean}
			*/
		 checkShaderErrors: true
	 };

	 // clearing

	 this.autoClear = true;
	 this.autoClearColor = true;
	 this.autoClearDepth = true;
	 this.autoClearStencil = true;

	 // scene graph

	 this.sortObjects = true;

	 // user-defined clipping

	 this.clippingPlanes = [];
	 this.localClippingEnabled = false;

	 // physically based shading

	 this.gammaFactor = 2.0;	// for backwards compatibility
	 this.outputEncoding = LinearEncoding;

	 // physical lights

	 this.physicallyCorrectLights = false;

	 // tone mapping

	 this.toneMapping = NoToneMapping;
	 this.toneMappingExposure = 1.0;

	 // internal properties

	 const _this = this;

	 let _isContextLost = false;

	 // internal state cache

	 let _currentActiveCubeFace = 0;
	 let _currentActiveMipmapLevel = 0;
	 let _currentRenderTarget = null;
	 let _currentMaterialId = - 1;

	 let _currentCamera = null;

	 const _currentViewport = new Vector4();
	 const _currentScissor = new Vector4();
	 let _currentScissorTest = null;

	 //

	 let _width = _canvas.width;
	 let _height = _canvas.height;

	 let _pixelRatio = 1;
	 let _opaqueSort = null;
	 let _transparentSort = null;

	 const _viewport = new Vector4( 0, 0, _width, _height );
	 const _scissor = new Vector4( 0, 0, _width, _height );
	 let _scissorTest = false;

	 //

	 const _currentDrawBuffers = [];

	 // frustum

	 const _frustum = new Frustum();

	 // clipping

	 let _clippingEnabled = false;
	 let _localClippingEnabled = false;

	 // transmission

	 let _transmissionRenderTarget = null;

	 // camera matrices cache

	 const _projScreenMatrix = new Matrix4();

	 const _vector3 = new Vector3();

	 const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	 function getTargetPixelRatio() {

		 return _currentRenderTarget === null ? _pixelRatio : 1;

	 }

	 // initialize

	 let _gl = _context;

	 function getContext( contextNames, contextAttributes ) {

		 for ( let i = 0; i < contextNames.length; i ++ ) {

			 const contextName = contextNames[ i ];
			 const context = _canvas.getContext( contextName, contextAttributes );
			 if ( context !== null ) return context;

		 }

		 return null;

	 }

	 try {

		 const contextAttributes = {
			 alpha: _alpha,
			 depth: _depth,
			 stencil: _stencil,
			 antialias: _antialias,
			 premultipliedAlpha: _premultipliedAlpha,
			 preserveDrawingBuffer: _preserveDrawingBuffer,
			 powerPreference: _powerPreference,
			 failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		 };

		 // event listeners must be registered before WebGL context is created, see #12753

		 _canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		 _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		 if ( _gl === null ) {

			 const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			 if ( _this.isWebGL1Renderer === true ) {

				 contextNames.shift();

			 }

			 _gl = getContext( contextNames, contextAttributes );

			 if ( _gl === null ) {

				 if ( getContext( contextNames ) ) {

					 throw new Error( 'Error creating WebGL context with your selected attributes.' );

				 } else {

					 throw new Error( 'Error creating WebGL context.' );

				 }

			 }

		 }

		 // Some experimental-webgl implementations do not have getShaderPrecisionFormat

		 if ( _gl.getShaderPrecisionFormat === undefined ) {

			 _gl.getShaderPrecisionFormat = function () {

				 return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			 };

		 }

	 } catch ( error ) {

		 console.error( 'THREE.WebGLRenderer: ' + error.message );
		 throw error;

	 }

	 let extensions, capabilities, state, info;
	 let properties, textures, cubemaps, attributes, geometries, objects;
	 let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	 let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	 let utils, bindingStates;

	 function initGLContext() {

		 extensions = new WebGLExtensions( _gl );

		 capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		 extensions.init( capabilities );

		 utils = new WebGLUtils( _gl, extensions, capabilities );

		 state = new WebGLState( _gl, extensions, capabilities );

		 _currentDrawBuffers[ 0 ] = 1029;

		 info = new WebGLInfo( _gl );
		 properties = new WebGLProperties();
		 textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		 cubemaps = new WebGLCubeMaps( _this );
		 attributes = new WebGLAttributes( _gl, capabilities );
		 bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		 geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		 objects = new WebGLObjects( _gl, geometries, attributes, info );
		 morphtargets = new WebGLMorphtargets( _gl );
		 clipping = new WebGLClipping( properties );
		 programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
		 materials = new WebGLMaterials( properties );
		 renderLists = new WebGLRenderLists( properties );
		 renderStates = new WebGLRenderStates( extensions, capabilities );
		 background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );
		 shadowMap = new WebGLShadowMap( _this, objects, capabilities );

		 bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		 indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		 info.programs = programCache.programs;

		 _this.capabilities = capabilities;
		 _this.extensions = extensions;
		 _this.properties = properties;
		 _this.renderLists = renderLists;
		 _this.shadowMap = shadowMap;
		 _this.state = state;
		 _this.info = info;

	 }

	 initGLContext();

	 // xr

	 const xr = new WebXRManager( _this, _gl );

	 this.xr = xr;

	 // API

	 this.getContext = function () {

		 return _gl;

	 };

	 this.getContextAttributes = function () {

		 return _gl.getContextAttributes();

	 };

	 this.forceContextLoss = function () {

		 const extension = extensions.get( 'WEBGL_lose_context' );
		 if ( extension ) extension.loseContext();

	 };

	 this.forceContextRestore = function () {

		 const extension = extensions.get( 'WEBGL_lose_context' );
		 if ( extension ) extension.restoreContext();

	 };

	 this.getPixelRatio = function () {

		 return _pixelRatio;

	 };

	 this.setPixelRatio = function ( value ) {

		 if ( value === undefined ) return;

		 _pixelRatio = value;

		 this.setSize( _width, _height, false );

	 };

	 this.getSize = function ( target ) {

		 return target.set( _width, _height );

	 };

	 this.setSize = function ( width, height, updateStyle ) {

		 if ( xr.isPresenting ) {

			 console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			 return;

		 }

		 _width = width;
		 _height = height;

		 _canvas.width = Math.floor( width * _pixelRatio );
		 _canvas.height = Math.floor( height * _pixelRatio );

		 if ( updateStyle !== false ) {

			 _canvas.style.width = width + 'px';
			 _canvas.style.height = height + 'px';

		 }

		 this.setViewport( 0, 0, width, height );

	 };

	 this.getDrawingBufferSize = function ( target ) {

		 return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	 };

	 this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		 _width = width;
		 _height = height;

		 _pixelRatio = pixelRatio;

		 _canvas.width = Math.floor( width * pixelRatio );
		 _canvas.height = Math.floor( height * pixelRatio );

		 this.setViewport( 0, 0, width, height );

	 };

	 this.getCurrentViewport = function ( target ) {

		 return target.copy( _currentViewport );

	 };

	 this.getViewport = function ( target ) {

		 return target.copy( _viewport );

	 };

	 this.setViewport = function ( x, y, width, height ) {

		 if ( x.isVector4 ) {

			 _viewport.set( x.x, x.y, x.z, x.w );

		 } else {

			 _viewport.set( x, y, width, height );

		 }

		 state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	 };

	 this.getScissor = function ( target ) {

		 return target.copy( _scissor );

	 };

	 this.setScissor = function ( x, y, width, height ) {

		 if ( x.isVector4 ) {

			 _scissor.set( x.x, x.y, x.z, x.w );

		 } else {

			 _scissor.set( x, y, width, height );

		 }

		 state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	 };

	 this.getScissorTest = function () {

		 return _scissorTest;

	 };

	 this.setScissorTest = function ( boolean ) {

		 state.setScissorTest( _scissorTest = boolean );

	 };

	 this.setOpaqueSort = function ( method ) {

		 _opaqueSort = method;

	 };

	 this.setTransparentSort = function ( method ) {

		 _transparentSort = method;

	 };

	 // Clearing

	 this.getClearColor = function ( target ) {

		 return target.copy( background.getClearColor() );

	 };

	 this.setClearColor = function () {

		 background.setClearColor.apply( background, arguments );

	 };

	 this.getClearAlpha = function () {

		 return background.getClearAlpha();

	 };

	 this.setClearAlpha = function () {

		 background.setClearAlpha.apply( background, arguments );

	 };

	 this.clear = function ( color, depth, stencil ) {

		 let bits = 0;

		 if ( color === undefined || color ) bits |= 16384;
		 if ( depth === undefined || depth ) bits |= 256;
		 if ( stencil === undefined || stencil ) bits |= 1024;

		 _gl.clear( bits );

	 };

	 this.clearColor = function () {

		 this.clear( true, false, false );

	 };

	 this.clearDepth = function () {

		 this.clear( false, true, false );

	 };

	 this.clearStencil = function () {

		 this.clear( false, false, true );

	 };

	 //

	 this.dispose = function () {

		 _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		 _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		 renderLists.dispose();
		 renderStates.dispose();
		 properties.dispose();
		 cubemaps.dispose();
		 objects.dispose();
		 bindingStates.dispose();

		 xr.dispose();

		 xr.removeEventListener( 'sessionstart', onXRSessionStart );
		 xr.removeEventListener( 'sessionend', onXRSessionEnd );

		 if ( _transmissionRenderTarget ) {

			 _transmissionRenderTarget.dispose();
			 _transmissionRenderTarget = null;

		 }

		 animation.stop();

	 };

	 // Events

	 function onContextLost( event ) {

		 event.preventDefault();

		 console.log( 'THREE.WebGLRenderer: Context Lost.' );

		 _isContextLost = true;

	 }

	 function onContextRestore( /* event */ ) {

		 console.log( 'THREE.WebGLRenderer: Context Restored.' );

		 _isContextLost = false;

		 const infoAutoReset = info.autoReset;
		 const shadowMapEnabled = shadowMap.enabled;
		 const shadowMapAutoUpdate = shadowMap.autoUpdate;
		 const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		 const shadowMapType = shadowMap.type;

		 initGLContext();

		 info.autoReset = infoAutoReset;
		 shadowMap.enabled = shadowMapEnabled;
		 shadowMap.autoUpdate = shadowMapAutoUpdate;
		 shadowMap.needsUpdate = shadowMapNeedsUpdate;
		 shadowMap.type = shadowMapType;

	 }

	 function onMaterialDispose( event ) {

		 const material = event.target;

		 material.removeEventListener( 'dispose', onMaterialDispose );

		 deallocateMaterial( material );

	 }

	 // Buffer deallocation

	 function deallocateMaterial( material ) {

		 releaseMaterialProgramReferences( material );

		 properties.remove( material );

	 }


	 function releaseMaterialProgramReferences( material ) {

		 const programs = properties.get( material ).programs;

		 if ( programs !== undefined ) {

			 programs.forEach( function ( program ) {

				 programCache.releaseProgram( program );

			 } );

		 }

	 }

	 // Buffer rendering

	 function renderObjectImmediate( object, program ) {

		 object.render( function ( object ) {

			 _this.renderBufferImmediate( object, program );

		 } );

	 }

	 this.renderBufferImmediate = function ( object, program ) {

		 bindingStates.initAttributes();

		 const buffers = properties.get( object );

		 if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		 if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		 if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		 if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		 const programAttributes = program.getAttributes();

		 if ( object.hasPositions ) {

			 _gl.bindBuffer( 34962, buffers.position );
			 _gl.bufferData( 34962, object.positionArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.position );
			 _gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

		 }

		 if ( object.hasNormals ) {

			 _gl.bindBuffer( 34962, buffers.normal );
			 _gl.bufferData( 34962, object.normalArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.normal );
			 _gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

		 }

		 if ( object.hasUvs ) {

			 _gl.bindBuffer( 34962, buffers.uv );
			 _gl.bufferData( 34962, object.uvArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.uv );
			 _gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

		 }

		 if ( object.hasColors ) {

			 _gl.bindBuffer( 34962, buffers.color );
			 _gl.bufferData( 34962, object.colorArray, 35048 );

			 bindingStates.enableAttribute( programAttributes.color );
			 _gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

		 }

		 bindingStates.disableUnusedAttributes();

		 _gl.drawArrays( 4, 0, object.count );

		 object.count = 0;

	 };

	 this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		 if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		 const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		 const program = setProgram( camera, scene, material, object );

		 state.setMaterial( material, frontFaceCW );

		 //

		 let index = geometry.index;
		 const position = geometry.attributes.position;

		 //

		 if ( index === null ) {

			 if ( position === undefined || position.count === 0 ) return;

		 } else if ( index.count === 0 ) {

			 return;

		 }

		 //

		 let rangeFactor = 1;

		 if ( material.wireframe === true ) {

			 index = geometries.getWireframeAttribute( geometry );
			 rangeFactor = 2;

		 }

		 if ( material.morphTargets || material.morphNormals ) {

			 morphtargets.update( object, geometry, material, program );

		 }

		 bindingStates.setup( object, material, program, geometry, index );

		 let attribute;
		 let renderer = bufferRenderer;

		 if ( index !== null ) {

			 attribute = attributes.get( index );

			 renderer = indexedBufferRenderer;
			 renderer.setIndex( attribute );

		 }

		 //

		 const dataCount = ( index !== null ) ? index.count : position.count;

		 const rangeStart = geometry.drawRange.start * rangeFactor;
		 const rangeCount = geometry.drawRange.count * rangeFactor;

		 const groupStart = group !== null ? group.start * rangeFactor : 0;
		 const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		 const drawStart = Math.max( rangeStart, groupStart );
		 const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		 const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		 if ( drawCount === 0 ) return;

		 //

		 if ( object.isMesh ) {

			 if ( material.wireframe === true ) {

				 state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				 renderer.setMode( 1 );

			 } else {

				 renderer.setMode( 4 );

			 }

		 } else if ( object.isLine ) {

			 let lineWidth = material.linewidth;

			 if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			 state.setLineWidth( lineWidth * getTargetPixelRatio() );

			 if ( object.isLineSegments ) {

				 renderer.setMode( 1 );

			 } else if ( object.isLineLoop ) {

				 renderer.setMode( 2 );

			 } else {

				 renderer.setMode( 3 );

			 }

		 } else if ( object.isPoints ) {

			 renderer.setMode( 0 );

		 } else if ( object.isSprite ) {

			 renderer.setMode( 4 );

		 }

		 if ( object.isInstancedMesh ) {

			 renderer.renderInstances( drawStart, drawCount, object.count );

		 } else if ( geometry.isInstancedBufferGeometry ) {

			 const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			 renderer.renderInstances( drawStart, drawCount, instanceCount );

		 } else {

			 renderer.render( drawStart, drawCount );

		 }

	 };

	 // Compile

	 this.compile = function ( scene, camera ) {

		 currentRenderState = renderStates.get( scene );
		 currentRenderState.init();

		 scene.traverseVisible( function ( object ) {

			 if ( object.isLight && object.layers.test( camera.layers ) ) {

				 currentRenderState.pushLight( object );

				 if ( object.castShadow ) {

					 currentRenderState.pushShadow( object );

				 }

			 }

		 } );

		 currentRenderState.setupLights();

		 scene.traverse( function ( object ) {

			 const material = object.material;

			 if ( material ) {

				 if ( Array.isArray( material ) ) {

					 for ( let i = 0; i < material.length; i ++ ) {

						 const material2 = material[ i ];

						 getProgram( material2, scene, object );

					 }

				 } else {

					 getProgram( material, scene, object );

				 }

			 }

		 } );

	 };

	 // Animation Loop

	 let onAnimationFrameCallback = null;

	 function onAnimationFrame( time ) {

		 if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	 }

	 function onXRSessionStart() {

		 animation.stop();

	 }

	 function onXRSessionEnd() {

		 animation.start();

	 }

	 const animation = new WebGLAnimation();
	 animation.setAnimationLoop( onAnimationFrame );

	 if ( typeof window !== 'undefined' ) animation.setContext( window );

	 this.setAnimationLoop = function ( callback ) {

		 onAnimationFrameCallback = callback;
		 xr.setAnimationLoop( callback );

		 ( callback === null ) ? animation.stop() : animation.start();

	 };

	 xr.addEventListener( 'sessionstart', onXRSessionStart );
	 xr.addEventListener( 'sessionend', onXRSessionEnd );

	 // Rendering

	 this.render = function ( scene, camera ) {

		 if ( camera !== undefined && camera.isCamera !== true ) {

			 console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			 return;

		 }

		 if ( _isContextLost === true ) return;

		 // update scene graph

		 if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		 // update camera matrices and frustum

		 if ( camera.parent === null ) camera.updateMatrixWorld();

		 if ( xr.enabled === true && xr.isPresenting === true ) {

			 if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

			 camera = xr.getCamera(); // use XR camera for rendering

		 }

		 //
		 if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

		 currentRenderState = renderStates.get( scene, renderStateStack.length );
		 currentRenderState.init();

		 renderStateStack.push( currentRenderState );

		 _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		 _frustum.setFromProjectionMatrix( _projScreenMatrix );

		 _localClippingEnabled = this.localClippingEnabled;
		 _clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		 currentRenderList = renderLists.get( scene, renderListStack.length );
		 currentRenderList.init();

		 renderListStack.push( currentRenderList );

		 projectObject( scene, camera, 0, _this.sortObjects );

		 currentRenderList.finish();

		 if ( _this.sortObjects === true ) {

			 currentRenderList.sort( _opaqueSort, _transparentSort );

		 }

		 //

		 if ( _clippingEnabled === true ) clipping.beginShadows();

		 const shadowsArray = currentRenderState.state.shadowsArray;

		 shadowMap.render( shadowsArray, scene, camera );

		 currentRenderState.setupLights();
		 currentRenderState.setupLightsView( camera );

		 if ( _clippingEnabled === true ) clipping.endShadows();

		 //

		 if ( this.info.autoReset === true ) this.info.reset();

		 //

		 background.render( currentRenderList, scene );

		 // render scene

		 const opaqueObjects = currentRenderList.opaque;
		 const transmissiveObjects = currentRenderList.transmissive;
		 const transparentObjects = currentRenderList.transparent;

		 if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		 if ( transmissiveObjects.length > 0 ) renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera );
		 if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		 //

		 if ( _currentRenderTarget !== null ) {

			 // resolve multisample renderbuffers to a single-sample texture if necessary

			 textures.updateMultisampleRenderTarget( _currentRenderTarget );

			 // Generate mipmap if we're using any kind of mipmap filtering

			 textures.updateRenderTargetMipmap( _currentRenderTarget );

		 }

		 //

		 if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		 // Ensure depth buffer writing is enabled so it can be cleared on next render

		 state.buffers.depth.setTest( true );
		 state.buffers.depth.setMask( true );
		 state.buffers.color.setMask( true );

		 state.setPolygonOffset( false );

		 // _gl.finish();

		 bindingStates.resetDefaultState();
		 _currentMaterialId = - 1;
		 _currentCamera = null;

		 renderStateStack.pop();

		 if ( renderStateStack.length > 0 ) {

			 currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		 } else {

			 currentRenderState = null;

		 }

		 renderListStack.pop();

		 if ( renderListStack.length > 0 ) {

			 currentRenderList = renderListStack[ renderListStack.length - 1 ];

		 } else {

			 currentRenderList = null;

		 }

	 };

	 function projectObject( object, camera, groupOrder, sortObjects ) {

		 if ( object.visible === false ) return;

		 const visible = object.layers.test( camera.layers );

		 if ( visible ) {

			 if ( object.isGroup ) {

				 groupOrder = object.renderOrder;

			 } else if ( object.isLOD ) {

				 if ( object.autoUpdate === true ) object.update( camera );

			 } else if ( object.isLight ) {

				 currentRenderState.pushLight( object );

				 if ( object.castShadow ) {

					 currentRenderState.pushShadow( object );

				 }

			 } else if ( object.isSprite ) {

				 if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					 if ( sortObjects ) {

						 _vector3.setFromMatrixPosition( object.matrixWorld )
							 .applyMatrix4( _projScreenMatrix );

					 }

					 const geometry = objects.update( object );
					 const material = object.material;

					 if ( material.visible ) {

						 currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					 }

				 }

			 } else if ( object.isImmediateRenderObject ) {

				 if ( sortObjects ) {

					 _vector3.setFromMatrixPosition( object.matrixWorld )
						 .applyMatrix4( _projScreenMatrix );

				 }

				 currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			 } else if ( object.isMesh || object.isLine || object.isPoints ) {

				 if ( object.isSkinnedMesh ) {

					 // update skeleton only once in a frame

					 if ( object.skeleton.frame !== info.render.frame ) {

						 object.skeleton.update();
						 object.skeleton.frame = info.render.frame;

					 }

				 }

				 if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					 if ( sortObjects ) {

						 _vector3.setFromMatrixPosition( object.matrixWorld )
							 .applyMatrix4( _projScreenMatrix );

					 }

					 const geometry = objects.update( object );
					 const material = object.material;

					 if ( Array.isArray( material ) ) {

						 const groups = geometry.groups;

						 for ( let i = 0, l = groups.length; i < l; i ++ ) {

							 const group = groups[ i ];
							 const groupMaterial = material[ group.materialIndex ];

							 if ( groupMaterial && groupMaterial.visible ) {

								 currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							 }

						 }

					 } else if ( material.visible ) {

						 currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					 }

				 }

			 }

		 }

		 const children = object.children;

		 for ( let i = 0, l = children.length; i < l; i ++ ) {

			 projectObject( children[ i ], camera, groupOrder, sortObjects );

		 }

	 }

	 function renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera ) {

		 if ( _transmissionRenderTarget === null ) {

			 const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
			 const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;

			 _transmissionRenderTarget = new renderTargetType( 1024, 1024, {
				 generateMipmaps: true,
				 type: utils.convert( HalfFloatType ) !== null ? HalfFloatType : UnsignedByteType,
				 minFilter: LinearMipmapLinearFilter,
				 magFilter: NearestFilter,
				 wrapS: ClampToEdgeWrapping,
				 wrapT: ClampToEdgeWrapping
			 } );

		 }

		 const currentRenderTarget = _this.getRenderTarget();
		 _this.setRenderTarget( _transmissionRenderTarget );
		 _this.clear();

		 // Turn off the features which can affect the frag color for opaque objects pass.
		 // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		 const currentToneMapping = _this.toneMapping;
		 _this.toneMapping = NoToneMapping;

		 renderObjects( opaqueObjects, scene, camera );

		 _this.toneMapping = currentToneMapping;

		 textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
		 textures.updateRenderTargetMipmap( _transmissionRenderTarget );

		 _this.setRenderTarget( currentRenderTarget );

		 renderObjects( transmissiveObjects, scene, camera );

	 }

	 function renderObjects( renderList, scene, camera ) {

		 const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		 for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			 const renderItem = renderList[ i ];

			 const object = renderItem.object;
			 const geometry = renderItem.geometry;
			 const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			 const group = renderItem.group;

			 if ( camera.isArrayCamera ) {

				 const cameras = camera.cameras;

				 for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					 const camera2 = cameras[ j ];

					 if ( object.layers.test( camera2.layers ) ) {

						 state.viewport( _currentViewport.copy( camera2.viewport ) );

						 currentRenderState.setupLightsView( camera2 );

						 renderObject( object, scene, camera2, geometry, material, group );

					 }

				 }

			 } else {

				 renderObject( object, scene, camera, geometry, material, group );

			 }

		 }

	 }

	 function renderObject( object, scene, camera, geometry, material, group ) {

		 object.onBeforeRender( _this, scene, camera, geometry, material, group );

		 object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		 object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		 if ( object.isImmediateRenderObject ) {

			 const program = setProgram( camera, scene, material, object );

			 state.setMaterial( material );

			 bindingStates.reset();

			 renderObjectImmediate( object, program );

		 } else {

			 if ( material.transparent === true && material.side === DoubleSide ) {

				 material.side = BackSide;
				 material.needsUpdate = true;
				 _this.renderBufferDirect( camera, scene, geometry, material, object, group );

				 material.side = FrontSide;
				 material.needsUpdate = true;
				 _this.renderBufferDirect( camera, scene, geometry, material, object, group );

				 material.side = DoubleSide;

			 } else {

				 _this.renderBufferDirect( camera, scene, geometry, material, object, group );

			 }

		 }

		 object.onAfterRender( _this, scene, camera, geometry, material, group );

	 }

	 function getProgram( material, scene, object ) {

		 if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		 const materialProperties = properties.get( material );

		 const lights = currentRenderState.state.lights;
		 const shadowsArray = currentRenderState.state.shadowsArray;

		 const lightsStateVersion = lights.state.version;

		 const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		 const programCacheKey = programCache.getProgramCacheKey( parameters );

		 let programs = materialProperties.programs;

		 // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		 materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		 materialProperties.fog = scene.fog;
		 materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

		 if ( programs === undefined ) {

			 // new material

			 material.addEventListener( 'dispose', onMaterialDispose );

			 programs = new Map();
			 materialProperties.programs = programs;

		 }

		 let program = programs.get( programCacheKey );

		 if ( program !== undefined ) {

			 // early out if program and light state is identical

			 if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				 updateCommonMaterialProperties( material, parameters );

				 return program;

			 }

		 } else {

			 parameters.uniforms = programCache.getUniforms( material );

			 material.onBuild( parameters, _this );

			 material.onBeforeCompile( parameters, _this );

			 program = programCache.acquireProgram( parameters, programCacheKey );
			 programs.set( programCacheKey, program );

			 materialProperties.uniforms = parameters.uniforms;

		 }

		 const uniforms = materialProperties.uniforms;

		 if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			 uniforms.clippingPlanes = clipping.uniform;

		 }

		 updateCommonMaterialProperties( material, parameters );

		 // store the light setup it was created for

		 materialProperties.needsLights = materialNeedsLights( material );
		 materialProperties.lightsStateVersion = lightsStateVersion;

		 if ( materialProperties.needsLights ) {

			 // wire up the material to this renderer's lighting state

			 uniforms.ambientLightColor.value = lights.state.ambient;
			 uniforms.lightProbe.value = lights.state.probe;
			 uniforms.directionalLights.value = lights.state.directional;
			 uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			 uniforms.spotLights.value = lights.state.spot;
			 uniforms.spotLightShadows.value = lights.state.spotShadow;
			 uniforms.rectAreaLights.value = lights.state.rectArea;
			 uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			 uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			 uniforms.pointLights.value = lights.state.point;
			 uniforms.pointLightShadows.value = lights.state.pointShadow;
			 uniforms.hemisphereLights.value = lights.state.hemi;

			 uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			 uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			 uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			 uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			 uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			 uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			 // TODO (abelnation): add area lights shadow info to uniforms

		 }

		 const progUniforms = program.getUniforms();
		 const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		 materialProperties.currentProgram = program;
		 materialProperties.uniformsList = uniformsList;

		 return program;

	 }

	 function updateCommonMaterialProperties( material, parameters ) {

		 const materialProperties = properties.get( material );

		 materialProperties.outputEncoding = parameters.outputEncoding;
		 materialProperties.instancing = parameters.instancing;
		 materialProperties.skinning = parameters.skinning;
		 materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		 materialProperties.numIntersection = parameters.numClipIntersection;
		 materialProperties.vertexAlphas = parameters.vertexAlphas;

	 }

	 function setProgram( camera, scene, material, object ) {

		 if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		 textures.resetTextureUnits();

		 const fog = scene.fog;
		 const environment = material.isMeshStandardMaterial ? scene.environment : null;
		 const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
		 const envMap = cubemaps.get( material.envMap || environment );
		 const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;

		 const materialProperties = properties.get( material );
		 const lights = currentRenderState.state.lights;

		 if ( _clippingEnabled === true ) {

			 if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				 const useCache =
					 camera === _currentCamera &&
					 material.id === _currentMaterialId;

				 // we might want to call this function with some ClippingGroup
				 // object instead of the material, once it becomes feasible
				 // (#8465, #8379)
				 clipping.setState( material, camera, useCache );

			 }

		 }

		 //

		 let needsProgramChange = false;

		 if ( material.version === materialProperties.__version ) {

			 if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.outputEncoding !== encoding ) {

				 needsProgramChange = true;

			 } else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				 needsProgramChange = true;

			 } else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				 needsProgramChange = true;

			 } else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

				 needsProgramChange = true;

			 } else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.envMap !== envMap ) {

				 needsProgramChange = true;

			 } else if ( material.fog && materialProperties.fog !== fog ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.numClippingPlanes !== undefined &&
				 ( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				 materialProperties.numIntersection !== clipping.numIntersection ) ) {

				 needsProgramChange = true;

			 } else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				 needsProgramChange = true;

			 }

		 } else {

			 needsProgramChange = true;
			 materialProperties.__version = material.version;

		 }

		 //

		 let program = materialProperties.currentProgram;

		 if ( needsProgramChange === true ) {

			 program = getProgram( material, scene, object );

		 }

		 let refreshProgram = false;
		 let refreshMaterial = false;
		 let refreshLights = false;

		 const p_uniforms = program.getUniforms(),
			 m_uniforms = materialProperties.uniforms;

		 if ( state.useProgram( program.program ) ) {

			 refreshProgram = true;
			 refreshMaterial = true;
			 refreshLights = true;

		 }

		 if ( material.id !== _currentMaterialId ) {

			 _currentMaterialId = material.id;

			 refreshMaterial = true;

		 }

		 if ( refreshProgram || _currentCamera !== camera ) {

			 p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			 if ( capabilities.logarithmicDepthBuffer ) {

				 p_uniforms.setValue( _gl, 'logDepthBufFC',
					 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			 }

			 if ( _currentCamera !== camera ) {

				 _currentCamera = camera;

				 // lighting uniforms depend on the camera so enforce an update
				 // now, in case this material supports lights - or later, when
				 // the next material that does gets activated:

				 refreshMaterial = true;		// set to true on material change
				 refreshLights = true;		// remains set until update done

			 }

			 // load material specific uniforms
			 // (shader material also gets them for the sake of genericity)

			 if ( material.isShaderMaterial ||
				 material.isMeshPhongMaterial ||
				 material.isMeshToonMaterial ||
				 material.isMeshStandardMaterial ||
				 material.envMap ) {

				 const uCamPos = p_uniforms.map.cameraPosition;

				 if ( uCamPos !== undefined ) {

					 uCamPos.setValue( _gl,
						 _vector3.setFromMatrixPosition( camera.matrixWorld ) );

				 }

			 }

			 if ( material.isMeshPhongMaterial ||
				 material.isMeshToonMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isMeshBasicMaterial ||
				 material.isMeshStandardMaterial ||
				 material.isShaderMaterial ) {

				 p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			 }

			 if ( material.isMeshPhongMaterial ||
				 material.isMeshToonMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isMeshBasicMaterial ||
				 material.isMeshStandardMaterial ||
				 material.isShaderMaterial ||
				 material.isShadowMaterial ||
				 object.isSkinnedMesh ) {

				 p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			 }

		 }

		 // skinning uniforms must be set even if material didn't change
		 // auto-setting of texture unit for bone texture must go before other textures
		 // otherwise textures used for skinning can take over texture units reserved for other material textures

		 if ( object.isSkinnedMesh ) {

			 p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			 p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			 const skeleton = object.skeleton;

			 if ( skeleton ) {

				 if ( capabilities.floatVertexTextures ) {

					 if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					 p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					 p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				 } else {

					 p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				 }

			 }

		 }

		 if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			 materialProperties.receiveShadow = object.receiveShadow;
			 p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		 }

		 if ( refreshMaterial ) {

			 p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			 if ( materialProperties.needsLights ) {

				 // the current material requires lighting info

				 // note: all lighting uniforms are always set correctly
				 // they simply reference the renderer's state for their
				 // values
				 //
				 // use the current material's .needsUpdate flags to set
				 // the GL state when required

				 markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			 }

			 // refresh uniforms common to several materials

			 if ( fog && material.fog ) {

				 materials.refreshFogUniforms( m_uniforms, fog );

			 }

			 materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

			 WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		 }

		 if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			 WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			 material.uniformsNeedUpdate = false;

		 }

		 if ( material.isSpriteMaterial ) {

			 p_uniforms.setValue( _gl, 'center', object.center );

		 }

		 // common matrices

		 p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		 p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		 p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		 return program;

	 }

	 // If uniforms are marked as clean, they don't need to be loaded to the GPU.

	 function markUniformsLightsNeedsUpdate( uniforms, value ) {

		 uniforms.ambientLightColor.needsUpdate = value;
		 uniforms.lightProbe.needsUpdate = value;

		 uniforms.directionalLights.needsUpdate = value;
		 uniforms.directionalLightShadows.needsUpdate = value;
		 uniforms.pointLights.needsUpdate = value;
		 uniforms.pointLightShadows.needsUpdate = value;
		 uniforms.spotLights.needsUpdate = value;
		 uniforms.spotLightShadows.needsUpdate = value;
		 uniforms.rectAreaLights.needsUpdate = value;
		 uniforms.hemisphereLights.needsUpdate = value;

	 }

	 function materialNeedsLights( material ) {

		 return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			 material.isMeshStandardMaterial || material.isShadowMaterial ||
			 ( material.isShaderMaterial && material.lights === true );

	 }

	 this.getActiveCubeFace = function () {

		 return _currentActiveCubeFace;

	 };

	 this.getActiveMipmapLevel = function () {

		 return _currentActiveMipmapLevel;

	 };

	 this.getRenderTarget = function () {

		 return _currentRenderTarget;

	 };

	 this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		 _currentRenderTarget = renderTarget;
		 _currentActiveCubeFace = activeCubeFace;
		 _currentActiveMipmapLevel = activeMipmapLevel;

		 if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			 textures.setupRenderTarget( renderTarget );

		 }

		 let framebuffer = null;
		 let isCube = false;
		 let isRenderTarget3D = false;

		 if ( renderTarget ) {

			 const texture = renderTarget.texture;

			 if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

				 isRenderTarget3D = true;

			 }

			 const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			 if ( renderTarget.isWebGLCubeRenderTarget ) {

				 framebuffer = __webglFramebuffer[ activeCubeFace ];
				 isCube = true;

			 } else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				 framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			 } else {

				 framebuffer = __webglFramebuffer;

			 }

			 _currentViewport.copy( renderTarget.viewport );
			 _currentScissor.copy( renderTarget.scissor );
			 _currentScissorTest = renderTarget.scissorTest;

		 } else {

			 _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			 _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			 _currentScissorTest = _scissorTest;

		 }

		 const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

		 if ( framebufferBound && capabilities.drawBuffers ) {

			 let needsUpdate = false;

			 if ( renderTarget ) {

				 if ( renderTarget.isWebGLMultipleRenderTargets ) {

					 const textures = renderTarget.texture;

					 if ( _currentDrawBuffers.length !== textures.length || _currentDrawBuffers[ 0 ] !== 36064 ) {

						 for ( let i = 0, il = textures.length; i < il; i ++ ) {

							 _currentDrawBuffers[ i ] = 36064 + i;

						 }

						 _currentDrawBuffers.length = textures.length;

						 needsUpdate = true;

					 }

				 } else {

					 if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 36064 ) {

						 _currentDrawBuffers[ 0 ] = 36064;
						 _currentDrawBuffers.length = 1;

						 needsUpdate = true;

					 }

				 }

			 } else {

				 if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 1029 ) {

					 _currentDrawBuffers[ 0 ] = 1029;
					 _currentDrawBuffers.length = 1;

					 needsUpdate = true;

				 }

			 }

			 if ( needsUpdate ) {

				 if ( capabilities.isWebGL2 ) {

					 _gl.drawBuffers( _currentDrawBuffers );

				 } else {

					 extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( _currentDrawBuffers );

				 }

			 }

		 }

		 state.viewport( _currentViewport );
		 state.scissor( _currentScissor );
		 state.setScissorTest( _currentScissorTest );

		 if ( isCube ) {

			 const textureProperties = properties.get( renderTarget.texture );
			 _gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		 } else if ( isRenderTarget3D ) {

			 const textureProperties = properties.get( renderTarget.texture );
			 const layer = activeCubeFace || 0;
			 _gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		 }

	 };

	 this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		 if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			 return;

		 }

		 let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		 if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			 framebuffer = framebuffer[ activeCubeFaceIndex ];

		 }

		 if ( framebuffer ) {

			 state.bindFramebuffer( 36160, framebuffer );

			 try {

				 const texture = renderTarget.texture;
				 const textureFormat = texture.format;
				 const textureType = texture.type;

				 if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					 return;

				 }

				 const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				 if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					 ! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					 ! halfFloatSupportedByExt ) {

					 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					 return;

				 }

				 if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					 // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					 if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						 _gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					 }

				 } else {

					 console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				 }

			 } finally {

				 // restore framebuffer of current render target if necessary

				 const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				 state.bindFramebuffer( 36160, framebuffer );

			 }

		 }

	 };

	 this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		 const levelScale = Math.pow( 2, - level );
		 const width = Math.floor( texture.image.width * levelScale );
		 const height = Math.floor( texture.image.height * levelScale );

		 let glFormat = utils.convert( texture.format );

		 if ( capabilities.isWebGL2 ) {

			 // Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
			 // Not needed in Chrome 93+

			 if ( glFormat === 6407 ) glFormat = 32849;
			 if ( glFormat === 6408 ) glFormat = 32856;

		 }

		 textures.setTexture2D( texture, 0 );

		 _gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		 state.unbindTexture();

	 };

	 this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		 const width = srcTexture.image.width;
		 const height = srcTexture.image.height;
		 const glFormat = utils.convert( dstTexture.format );
		 const glType = utils.convert( dstTexture.type );

		 textures.setTexture2D( dstTexture, 0 );

		 // As another texture upload may have changed pixelStorei
		 // parameters, make sure they are correct for the dstTexture
		 _gl.pixelStorei( 37440, dstTexture.flipY );
		 _gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		 if ( srcTexture.isDataTexture ) {

			 _gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		 } else {

			 if ( srcTexture.isCompressedTexture ) {

				 _gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			 } else {

				 _gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			 }

		 }

		 // Generate mipmaps only when copying level 0
		 if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		 state.unbindTexture();

	 };

	 this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		 if ( _this.isWebGL1Renderer ) {

			 console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			 return;

		 }

		 const width = sourceBox.max.x - sourceBox.min.x + 1;
		 const height = sourceBox.max.y - sourceBox.min.y + 1;
		 const depth = sourceBox.max.z - sourceBox.min.z + 1;
		 const glFormat = utils.convert( dstTexture.format );
		 const glType = utils.convert( dstTexture.type );
		 let glTarget;

		 if ( dstTexture.isDataTexture3D ) {

			 textures.setTexture3D( dstTexture, 0 );
			 glTarget = 32879;

		 } else if ( dstTexture.isDataTexture2DArray ) {

			 textures.setTexture2DArray( dstTexture, 0 );
			 glTarget = 35866;

		 } else {

			 console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			 return;

		 }

		 _gl.pixelStorei( 37440, dstTexture.flipY );
		 _gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		 _gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		 const unpackRowLen = _gl.getParameter( 3314 );
		 const unpackImageHeight = _gl.getParameter( 32878 );
		 const unpackSkipPixels = _gl.getParameter( 3316 );
		 const unpackSkipRows = _gl.getParameter( 3315 );
		 const unpackSkipImages = _gl.getParameter( 32877 );

		 const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

		 _gl.pixelStorei( 3314, image.width );
		 _gl.pixelStorei( 32878, image.height );
		 _gl.pixelStorei( 3316, sourceBox.min.x );
		 _gl.pixelStorei( 3315, sourceBox.min.y );
		 _gl.pixelStorei( 32877, sourceBox.min.z );

		 if ( srcTexture.isDataTexture || srcTexture.isDataTexture3D ) {

			 _gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

		 } else {

			 if ( srcTexture.isCompressedTexture ) {

				 console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
				 _gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

			 } else {

				 _gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

			 }

		 }

		 _gl.pixelStorei( 3314, unpackRowLen );
		 _gl.pixelStorei( 32878, unpackImageHeight );
		 _gl.pixelStorei( 3316, unpackSkipPixels );
		 _gl.pixelStorei( 3315, unpackSkipRows );
		 _gl.pixelStorei( 32877, unpackSkipImages );

		 // Generate mipmaps only when copying level 0
		 if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		 state.unbindTexture();

	 };

	 this.initTexture = function ( texture ) {

		 textures.setTexture2D( texture, 0 );

		 state.unbindTexture();

	 };

	 this.resetState = function () {

		 _currentActiveCubeFace = 0;
		 _currentActiveMipmapLevel = 0;
		 _currentRenderTarget = null;

		 state.reset();
		 bindingStates.reset();

	 };

	 if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		 __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	 }

 }

 class WebGL1Renderer extends WebGLRenderer {}

 WebGL1Renderer.prototype.isWebGL1Renderer = true;

 class Scene extends Object3D {

	 constructor() {

		 super();

		 this.type = 'Scene';

		 this.background = null;
		 this.environment = null;
		 this.fog = null;

		 this.overrideMaterial = null;

		 this.autoUpdate = true; // checked by the renderer

		 if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			 __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		 }

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 if ( source.background !== null ) this.background = source.background.clone();
		 if ( source.environment !== null ) this.environment = source.environment.clone();
		 if ( source.fog !== null ) this.fog = source.fog.clone();

		 if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		 this.autoUpdate = source.autoUpdate;
		 this.matrixAutoUpdate = source.matrixAutoUpdate;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		 return data;

	 }

 }

 Scene.prototype.isScene = true;

 class InterleavedBuffer {

	 constructor( array, stride ) {

		 this.array = array;
		 this.stride = stride;
		 this.count = array !== undefined ? array.length / stride : 0;

		 this.usage = StaticDrawUsage;
		 this.updateRange = { offset: 0, count: - 1 };

		 this.version = 0;

		 this.uuid = generateUUID();

	 }

	 onUploadCallback() {}

	 set needsUpdate( value ) {

		 if ( value === true ) this.version ++;

	 }

	 setUsage( value ) {

		 this.usage = value;

		 return this;

	 }

	 copy( source ) {

		 this.array = new source.array.constructor( source.array );
		 this.count = source.count;
		 this.stride = source.stride;
		 this.usage = source.usage;

		 return this;

	 }

	 copyAt( index1, attribute, index2 ) {

		 index1 *= this.stride;
		 index2 *= attribute.stride;

		 for ( let i = 0, l = this.stride; i < l; i ++ ) {

			 this.array[ index1 + i ] = attribute.array[ index2 + i ];

		 }

		 return this;

	 }

	 set( value, offset = 0 ) {

		 this.array.set( value, offset );

		 return this;

	 }

	 clone( data ) {

		 if ( data.arrayBuffers === undefined ) {

			 data.arrayBuffers = {};

		 }

		 if ( this.array.buffer._uuid === undefined ) {

			 this.array.buffer._uuid = generateUUID();

		 }

		 if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			 data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		 }

		 const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		 const ib = new this.constructor( array, this.stride );
		 ib.setUsage( this.usage );

		 return ib;

	 }

	 onUpload( callback ) {

		 this.onUploadCallback = callback;

		 return this;

	 }

	 toJSON( data ) {

		 if ( data.arrayBuffers === undefined ) {

			 data.arrayBuffers = {};

		 }

		 // generate UUID for array buffer if necessary

		 if ( this.array.buffer._uuid === undefined ) {

			 this.array.buffer._uuid = generateUUID();

		 }

		 if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			 data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		 }

		 //

		 return {
			 uuid: this.uuid,
			 buffer: this.array.buffer._uuid,
			 type: this.array.constructor.name,
			 stride: this.stride
		 };

	 }

 }

 InterleavedBuffer.prototype.isInterleavedBuffer = true;

 const _vector$6 = /*@__PURE__*/ new Vector3();

 class InterleavedBufferAttribute {

	 constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		 this.name = '';

		 this.data = interleavedBuffer;
		 this.itemSize = itemSize;
		 this.offset = offset;

		 this.normalized = normalized === true;

	 }

	 get count() {

		 return this.data.count;

	 }

	 get array() {

		 return this.data.array;

	 }

	 set needsUpdate( value ) {

		 this.data.needsUpdate = value;

	 }

	 applyMatrix4( m ) {

		 for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			 _vector$6.x = this.getX( i );
			 _vector$6.y = this.getY( i );
			 _vector$6.z = this.getZ( i );

			 _vector$6.applyMatrix4( m );

			 this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		 }

		 return this;

	 }

	 applyNormalMatrix( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$6.x = this.getX( i );
			 _vector$6.y = this.getY( i );
			 _vector$6.z = this.getZ( i );

			 _vector$6.applyNormalMatrix( m );

			 this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		 }

		 return this;

	 }

	 transformDirection( m ) {

		 for ( let i = 0, l = this.count; i < l; i ++ ) {

			 _vector$6.x = this.getX( i );
			 _vector$6.y = this.getY( i );
			 _vector$6.z = this.getZ( i );

			 _vector$6.transformDirection( m );

			 this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		 }

		 return this;

	 }

	 setX( index, x ) {

		 this.data.array[ index * this.data.stride + this.offset ] = x;

		 return this;

	 }

	 setY( index, y ) {

		 this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		 return this;

	 }

	 setZ( index, z ) {

		 this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		 return this;

	 }

	 setW( index, w ) {

		 this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		 return this;

	 }

	 getX( index ) {

		 return this.data.array[ index * this.data.stride + this.offset ];

	 }

	 getY( index ) {

		 return this.data.array[ index * this.data.stride + this.offset + 1 ];

	 }

	 getZ( index ) {

		 return this.data.array[ index * this.data.stride + this.offset + 2 ];

	 }

	 getW( index ) {

		 return this.data.array[ index * this.data.stride + this.offset + 3 ];

	 }

	 setXY( index, x, y ) {

		 index = index * this.data.stride + this.offset;

		 this.data.array[ index + 0 ] = x;
		 this.data.array[ index + 1 ] = y;

		 return this;

	 }

	 setXYZ( index, x, y, z ) {

		 index = index * this.data.stride + this.offset;

		 this.data.array[ index + 0 ] = x;
		 this.data.array[ index + 1 ] = y;
		 this.data.array[ index + 2 ] = z;

		 return this;

	 }

	 setXYZW( index, x, y, z, w ) {

		 index = index * this.data.stride + this.offset;

		 this.data.array[ index + 0 ] = x;
		 this.data.array[ index + 1 ] = y;
		 this.data.array[ index + 2 ] = z;
		 this.data.array[ index + 3 ] = w;

		 return this;

	 }

	 clone( data ) {

		 if ( data === undefined ) {

			 console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			 const array = [];

			 for ( let i = 0; i < this.count; i ++ ) {

				 const index = i * this.data.stride + this.offset;

				 for ( let j = 0; j < this.itemSize; j ++ ) {

					 array.push( this.data.array[ index + j ] );

				 }

			 }

			 return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		 } else {

			 if ( data.interleavedBuffers === undefined ) {

				 data.interleavedBuffers = {};

			 }

			 if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				 data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			 }

			 return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		 }

	 }

	 toJSON( data ) {

		 if ( data === undefined ) {

			 console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			 const array = [];

			 for ( let i = 0; i < this.count; i ++ ) {

				 const index = i * this.data.stride + this.offset;

				 for ( let j = 0; j < this.itemSize; j ++ ) {

					 array.push( this.data.array[ index + j ] );

				 }

			 }

			 // deinterleave data and save it as an ordinary buffer attribute for now

			 return {
				 itemSize: this.itemSize,
				 type: this.array.constructor.name,
				 array: array,
				 normalized: this.normalized
			 };

		 } else {

			 // save as true interlaved attribtue

			 if ( data.interleavedBuffers === undefined ) {

				 data.interleavedBuffers = {};

			 }

			 if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				 data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			 }

			 return {
				 isInterleavedBufferAttribute: true,
				 itemSize: this.itemSize,
				 data: this.data.uuid,
				 offset: this.offset,
				 normalized: this.normalized
			 };

		 }

	 }

 }

 InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  map: new THREE.Texture( <Image> ),
	*  alphaMap: new THREE.Texture( <Image> ),
	*  rotation: <float>,
	*  sizeAttenuation: <bool>
	* }
	*/

 class SpriteMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'SpriteMaterial';

		 this.color = new Color$1( 0xffffff );

		 this.map = null;

		 this.alphaMap = null;

		 this.rotation = 0;

		 this.sizeAttenuation = true;

		 this.transparent = true;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.rotation = source.rotation;

		 this.sizeAttenuation = source.sizeAttenuation;

		 return this;

	 }

 }

 SpriteMaterial.prototype.isSpriteMaterial = true;

 let _geometry;

 const _intersectPoint = /*@__PURE__*/ new Vector3();
 const _worldScale = /*@__PURE__*/ new Vector3();
 const _mvPosition = /*@__PURE__*/ new Vector3();

 const _alignedPosition = /*@__PURE__*/ new Vector2();
 const _rotatedPosition = /*@__PURE__*/ new Vector2();
 const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

 const _vA = /*@__PURE__*/ new Vector3();
 const _vB = /*@__PURE__*/ new Vector3();
 const _vC = /*@__PURE__*/ new Vector3();

 const _uvA = /*@__PURE__*/ new Vector2();
 const _uvB = /*@__PURE__*/ new Vector2();
 const _uvC = /*@__PURE__*/ new Vector2();

 class Sprite extends Object3D {

	 constructor( material ) {

		 super();

		 this.type = 'Sprite';

		 if ( _geometry === undefined ) {

			 _geometry = new BufferGeometry();

			 const float32Array = new Float32Array( [
				 - 0.5, - 0.5, 0, 0, 0,
				 0.5, - 0.5, 0, 1, 0,
				 0.5, 0.5, 0, 1, 1,
				 - 0.5, 0.5, 0, 0, 1
			 ] );

			 const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			 _geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			 _geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			 _geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		 }

		 this.geometry = _geometry;
		 this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		 this.center = new Vector2( 0.5, 0.5 );

	 }

	 raycast( raycaster, intersects ) {

		 if ( raycaster.camera === null ) {

			 console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		 }

		 _worldScale.setFromMatrixScale( this.matrixWorld );

		 _viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		 this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		 _mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		 if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			 _worldScale.multiplyScalar( - _mvPosition.z );

		 }

		 const rotation = this.material.rotation;
		 let sin, cos;

		 if ( rotation !== 0 ) {

			 cos = Math.cos( rotation );
			 sin = Math.sin( rotation );

		 }

		 const center = this.center;

		 transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		 transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		 transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		 _uvA.set( 0, 0 );
		 _uvB.set( 1, 0 );
		 _uvC.set( 1, 1 );

		 // check first triangle
		 let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		 if ( intersect === null ) {

			 // check second triangle
			 transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			 _uvB.set( 0, 1 );

			 intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			 if ( intersect === null ) {

				 return;

			 }

		 }

		 const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		 if ( distance < raycaster.near || distance > raycaster.far ) return;

		 intersects.push( {

			 distance: distance,
			 point: _intersectPoint.clone(),
			 uv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			 face: null,
			 object: this

		 } );

	 }

	 copy( source ) {

		 super.copy( source );

		 if ( source.center !== undefined ) this.center.copy( source.center );

		 this.material = source.material;

		 return this;

	 }

 }

 Sprite.prototype.isSprite = true;

 function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	 // compute position in camera space
	 _alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	 // to check if rotation is not zero
	 if ( sin !== undefined ) {

		 _rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		 _rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	 } else {

		 _rotatedPosition.copy( _alignedPosition );

	 }


	 vertexPosition.copy( mvPosition );
	 vertexPosition.x += _rotatedPosition.x;
	 vertexPosition.y += _rotatedPosition.y;

	 // transform to world space
	 vertexPosition.applyMatrix4( _viewWorldMatrix );

 }

 const _basePosition = /*@__PURE__*/ new Vector3();

 const _skinIndex = /*@__PURE__*/ new Vector4();
 const _skinWeight = /*@__PURE__*/ new Vector4();

 const _vector$5 = /*@__PURE__*/ new Vector3();
 const _matrix = /*@__PURE__*/ new Matrix4();

 class SkinnedMesh extends Mesh {

	 constructor( geometry, material ) {

		 super( geometry, material );

		 this.type = 'SkinnedMesh';

		 this.bindMode = 'attached';
		 this.bindMatrix = new Matrix4();
		 this.bindMatrixInverse = new Matrix4();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.bindMode = source.bindMode;
		 this.bindMatrix.copy( source.bindMatrix );
		 this.bindMatrixInverse.copy( source.bindMatrixInverse );

		 this.skeleton = source.skeleton;

		 return this;

	 }

	 bind( skeleton, bindMatrix ) {

		 this.skeleton = skeleton;

		 if ( bindMatrix === undefined ) {

			 this.updateMatrixWorld( true );

			 this.skeleton.calculateInverses();

			 bindMatrix = this.matrixWorld;

		 }

		 this.bindMatrix.copy( bindMatrix );
		 this.bindMatrixInverse.copy( bindMatrix ).invert();

	 }

	 pose() {

		 this.skeleton.pose();

	 }

	 normalizeSkinWeights() {

		 const vector = new Vector4();

		 const skinWeight = this.geometry.attributes.skinWeight;

		 for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			 vector.x = skinWeight.getX( i );
			 vector.y = skinWeight.getY( i );
			 vector.z = skinWeight.getZ( i );
			 vector.w = skinWeight.getW( i );

			 const scale = 1.0 / vector.manhattanLength();

			 if ( scale !== Infinity ) {

				 vector.multiplyScalar( scale );

			 } else {

				 vector.set( 1, 0, 0, 0 ); // do something reasonable

			 }

			 skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		 }

	 }

	 updateMatrixWorld( force ) {

		 super.updateMatrixWorld( force );

		 if ( this.bindMode === 'attached' ) {

			 this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		 } else if ( this.bindMode === 'detached' ) {

			 this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		 } else {

			 console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		 }

	 }

	 boneTransform( index, target ) {

		 const skeleton = this.skeleton;
		 const geometry = this.geometry;

		 _skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		 _skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		 _basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

		 target.set( 0, 0, 0 );

		 for ( let i = 0; i < 4; i ++ ) {

			 const weight = _skinWeight.getComponent( i );

			 if ( weight !== 0 ) {

				 const boneIndex = _skinIndex.getComponent( i );

				 _matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				 target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

			 }

		 }

		 return target.applyMatrix4( this.bindMatrixInverse );

	 }

 }

 SkinnedMesh.prototype.isSkinnedMesh = true;

 class Bone extends Object3D {

	 constructor() {

		 super();

		 this.type = 'Bone';

	 }

 }

 Bone.prototype.isBone = true;

 class DataTexture extends Texture {

	 constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

		 super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		 this.image = { data: data, width: width, height: height };

		 this.magFilter = magFilter;
		 this.minFilter = minFilter;

		 this.generateMipmaps = false;
		 this.flipY = false;
		 this.unpackAlignment = 1;

		 this.needsUpdate = true;

	 }

 }

 DataTexture.prototype.isDataTexture = true;

 const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
 const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

 const _instanceIntersects = [];

 const _mesh = /*@__PURE__*/ new Mesh();

 class InstancedMesh extends Mesh {

	 constructor( geometry, material, count ) {

		 super( geometry, material );

		 this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
		 this.instanceColor = null;

		 this.count = count;

		 this.frustumCulled = false;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.instanceMatrix.copy( source.instanceMatrix );

		 if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		 this.count = source.count;

		 return this;

	 }

	 getColorAt( index, color ) {

		 color.fromArray( this.instanceColor.array, index * 3 );

	 }

	 getMatrixAt( index, matrix ) {

		 matrix.fromArray( this.instanceMatrix.array, index * 16 );

	 }

	 raycast( raycaster, intersects ) {

		 const matrixWorld = this.matrixWorld;
		 const raycastTimes = this.count;

		 _mesh.geometry = this.geometry;
		 _mesh.material = this.material;

		 if ( _mesh.material === undefined ) return;

		 for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			 // calculate the world matrix for each instance

			 this.getMatrixAt( instanceId, _instanceLocalMatrix );

			 _instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			 // the mesh represents this single instance

			 _mesh.matrixWorld = _instanceWorldMatrix;

			 _mesh.raycast( raycaster, _instanceIntersects );

			 // process the result of raycast

			 for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				 const intersect = _instanceIntersects[ i ];
				 intersect.instanceId = instanceId;
				 intersect.object = this;
				 intersects.push( intersect );

			 }

			 _instanceIntersects.length = 0;

		 }

	 }

	 setColorAt( index, color ) {

		 if ( this.instanceColor === null ) {

			 this.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );

		 }

		 color.toArray( this.instanceColor.array, index * 3 );

	 }

	 setMatrixAt( index, matrix ) {

		 matrix.toArray( this.instanceMatrix.array, index * 16 );

	 }

	 updateMorphTargets() {

	 }

	 dispose() {

		 this.dispatchEvent( { type: 'dispose' } );

	 }

 }

 InstancedMesh.prototype.isInstancedMesh = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  linewidth: <float>,
	*  linecap: "round",
	*  linejoin: "round"
	* }
	*/

 class LineBasicMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'LineBasicMaterial';

		 this.color = new Color$1( 0xffffff );

		 this.linewidth = 1;
		 this.linecap = 'round';
		 this.linejoin = 'round';

		 this.morphTargets = false;

		 this.setValues( parameters );

	 }


	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.linewidth = source.linewidth;
		 this.linecap = source.linecap;
		 this.linejoin = source.linejoin;

		 this.morphTargets = source.morphTargets;

		 return this;

	 }

 }

 LineBasicMaterial.prototype.isLineBasicMaterial = true;

 const _start$1 = /*@__PURE__*/ new Vector3();
 const _end$1 = /*@__PURE__*/ new Vector3();
 const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
 const _ray$1 = /*@__PURE__*/ new Ray();
 const _sphere$1 = /*@__PURE__*/ new Sphere();

 class Line extends Object3D {

	 constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		 super();

		 this.type = 'Line';

		 this.geometry = geometry;
		 this.material = material;

		 this.updateMorphTargets();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.material = source.material;
		 this.geometry = source.geometry;

		 return this;

	 }

	 computeLineDistances() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 // we assume non-indexed geometry

			 if ( geometry.index === null ) {

				 const positionAttribute = geometry.attributes.position;
				 const lineDistances = [ 0 ];

				 for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					 _start$1.fromBufferAttribute( positionAttribute, i - 1 );
					 _end$1.fromBufferAttribute( positionAttribute, i );

					 lineDistances[ i ] = lineDistances[ i - 1 ];
					 lineDistances[ i ] += _start$1.distanceTo( _end$1 );

				 }

				 geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			 } else {

				 console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

		 return this;

	 }

	 raycast( raycaster, intersects ) {

		 const geometry = this.geometry;
		 const matrixWorld = this.matrixWorld;
		 const threshold = raycaster.params.Line.threshold;
		 const drawRange = geometry.drawRange;

		 // Checking boundingSphere distance to ray

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere$1.copy( geometry.boundingSphere );
		 _sphere$1.applyMatrix4( matrixWorld );
		 _sphere$1.radius += threshold;

		 if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		 //

		 _inverseMatrix$1.copy( matrixWorld ).invert();
		 _ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		 const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		 const localThresholdSq = localThreshold * localThreshold;

		 const vStart = new Vector3();
		 const vEnd = new Vector3();
		 const interSegment = new Vector3();
		 const interRay = new Vector3();
		 const step = this.isLineSegments ? 2 : 1;

		 if ( geometry.isBufferGeometry ) {

			 const index = geometry.index;
			 const attributes = geometry.attributes;
			 const positionAttribute = attributes.position;

			 if ( index !== null ) {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, l = end - 1; i < l; i += step ) {

					 const a = index.getX( i );
					 const b = index.getX( i + 1 );

					 vStart.fromBufferAttribute( positionAttribute, a );
					 vEnd.fromBufferAttribute( positionAttribute, b );

					 const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					 if ( distSq > localThresholdSq ) continue;

					 interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					 const distance = raycaster.ray.origin.distanceTo( interRay );

					 if ( distance < raycaster.near || distance > raycaster.far ) continue;

					 intersects.push( {

						 distance: distance,
						 // What do we want? intersection point on the ray or on the segment??
						 // point: raycaster.ray.at( distance ),
						 point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						 index: i,
						 face: null,
						 faceIndex: null,
						 object: this

					 } );

				 }

			 } else {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, l = end - 1; i < l; i += step ) {

					 vStart.fromBufferAttribute( positionAttribute, i );
					 vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					 const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					 if ( distSq > localThresholdSq ) continue;

					 interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					 const distance = raycaster.ray.origin.distanceTo( interRay );

					 if ( distance < raycaster.near || distance > raycaster.far ) continue;

					 intersects.push( {

						 distance: distance,
						 // What do we want? intersection point on the ray or on the segment??
						 // point: raycaster.ray.at( distance ),
						 point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						 index: i,
						 face: null,
						 faceIndex: null,
						 object: this

					 } );

				 }

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

	 }

	 updateMorphTargets() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 const morphAttributes = geometry.morphAttributes;
			 const keys = Object.keys( morphAttributes );

			 if ( keys.length > 0 ) {

				 const morphAttribute = morphAttributes[ keys[ 0 ] ];

				 if ( morphAttribute !== undefined ) {

					 this.morphTargetInfluences = [];
					 this.morphTargetDictionary = {};

					 for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						 const name = morphAttribute[ m ].name || String( m );

						 this.morphTargetInfluences.push( 0 );
						 this.morphTargetDictionary[ name ] = m;

					 }

				 }

			 }

		 } else {

			 const morphTargets = geometry.morphTargets;

			 if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				 console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			 }

		 }

	 }

 }

 Line.prototype.isLine = true;

 const _start = /*@__PURE__*/ new Vector3();
 const _end = /*@__PURE__*/ new Vector3();

 class LineSegments extends Line {

	 constructor( geometry, material ) {

		 super( geometry, material );

		 this.type = 'LineSegments';

	 }

	 computeLineDistances() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 // we assume non-indexed geometry

			 if ( geometry.index === null ) {

				 const positionAttribute = geometry.attributes.position;
				 const lineDistances = [];

				 for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					 _start.fromBufferAttribute( positionAttribute, i );
					 _end.fromBufferAttribute( positionAttribute, i + 1 );

					 lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					 lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

				 }

				 geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			 } else {

				 console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			 }

		 } else if ( geometry.isGeometry ) {

			 console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

		 return this;

	 }

 }

 LineSegments.prototype.isLineSegments = true;

 class LineLoop extends Line {

	 constructor( geometry, material ) {

		 super( geometry, material );

		 this.type = 'LineLoop';

	 }

 }

 LineLoop.prototype.isLineLoop = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*  map: new THREE.Texture( <Image> ),
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  size: <float>,
	*  sizeAttenuation: <bool>
	*
	*  morphTargets: <bool>
	* }
	*/

 class PointsMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'PointsMaterial';

		 this.color = new Color$1( 0xffffff );

		 this.map = null;

		 this.alphaMap = null;

		 this.size = 1;
		 this.sizeAttenuation = true;

		 this.morphTargets = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.alphaMap = source.alphaMap;

		 this.size = source.size;
		 this.sizeAttenuation = source.sizeAttenuation;

		 this.morphTargets = source.morphTargets;

		 return this;

	 }

 }

 PointsMaterial.prototype.isPointsMaterial = true;

 const _inverseMatrix = /*@__PURE__*/ new Matrix4();
 const _ray = /*@__PURE__*/ new Ray();
 const _sphere = /*@__PURE__*/ new Sphere();
 const _position$2 = /*@__PURE__*/ new Vector3();

 class Points extends Object3D {

	 constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		 super();

		 this.type = 'Points';

		 this.geometry = geometry;
		 this.material = material;

		 this.updateMorphTargets();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.material = source.material;
		 this.geometry = source.geometry;

		 return this;

	 }

	 raycast( raycaster, intersects ) {

		 const geometry = this.geometry;
		 const matrixWorld = this.matrixWorld;
		 const threshold = raycaster.params.Points.threshold;
		 const drawRange = geometry.drawRange;

		 // Checking boundingSphere distance to ray

		 if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		 _sphere.copy( geometry.boundingSphere );
		 _sphere.applyMatrix4( matrixWorld );
		 _sphere.radius += threshold;

		 if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		 //

		 _inverseMatrix.copy( matrixWorld ).invert();
		 _ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		 const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		 const localThresholdSq = localThreshold * localThreshold;

		 if ( geometry.isBufferGeometry ) {

			 const index = geometry.index;
			 const attributes = geometry.attributes;
			 const positionAttribute = attributes.position;

			 if ( index !== null ) {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, il = end; i < il; i ++ ) {

					 const a = index.getX( i );

					 _position$2.fromBufferAttribute( positionAttribute, a );

					 testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				 }

			 } else {

				 const start = Math.max( 0, drawRange.start );
				 const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				 for ( let i = start, l = end; i < l; i ++ ) {

					 _position$2.fromBufferAttribute( positionAttribute, i );

					 testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				 }

			 }

		 } else {

			 console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		 }

	 }

	 updateMorphTargets() {

		 const geometry = this.geometry;

		 if ( geometry.isBufferGeometry ) {

			 const morphAttributes = geometry.morphAttributes;
			 const keys = Object.keys( morphAttributes );

			 if ( keys.length > 0 ) {

				 const morphAttribute = morphAttributes[ keys[ 0 ] ];

				 if ( morphAttribute !== undefined ) {

					 this.morphTargetInfluences = [];
					 this.morphTargetDictionary = {};

					 for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						 const name = morphAttribute[ m ].name || String( m );

						 this.morphTargetInfluences.push( 0 );
						 this.morphTargetDictionary[ name ] = m;

					 }

				 }

			 }

		 } else {

			 const morphTargets = geometry.morphTargets;

			 if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				 console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			 }

		 }

	 }

 }

 Points.prototype.isPoints = true;

 function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	 const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	 if ( rayPointDistanceSq < localThresholdSq ) {

		 const intersectPoint = new Vector3();

		 _ray.closestPointToPoint( point, intersectPoint );
		 intersectPoint.applyMatrix4( matrixWorld );

		 const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		 if ( distance < raycaster.near || distance > raycaster.far ) return;

		 intersects.push( {

			 distance: distance,
			 distanceToRay: Math.sqrt( rayPointDistanceSq ),
			 point: intersectPoint,
			 index: index,
			 face: null,
			 object: object

		 } );

	 }

 }

 class VideoTexture extends Texture {

	 constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		 super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		 this.format = format !== undefined ? format : RGBFormat;

		 this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		 this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		 this.generateMipmaps = false;

		 const scope = this;

		 function updateVideo() {

			 scope.needsUpdate = true;
			 video.requestVideoFrameCallback( updateVideo );

		 }

		 if ( 'requestVideoFrameCallback' in video ) {

			 video.requestVideoFrameCallback( updateVideo );

		 }

	 }

	 clone() {

		 return new this.constructor( this.image ).copy( this );

	 }

	 update() {

		 const video = this.image;
		 const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		 if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			 this.needsUpdate = true;

		 }

	 }

 }

 VideoTexture.prototype.isVideoTexture = true;

 class CompressedTexture extends Texture {

	 constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		 super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		 this.image = { width: width, height: height };
		 this.mipmaps = mipmaps;

		 // no flipping for cube textures
		 // (also flipping doesn't work for compressed textures )

		 this.flipY = false;

		 // can't generate mipmaps for compressed textures
		 // mips must be embedded in DDS files

		 this.generateMipmaps = false;

	 }

 }

 CompressedTexture.prototype.isCompressedTexture = true;

 class CanvasTexture extends Texture {

	 constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		 super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		 this.needsUpdate = true;

	 }

 }

 CanvasTexture.prototype.isCanvasTexture = true;

 class DepthTexture extends Texture {

	 constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		 format = format !== undefined ? format : DepthFormat;

		 if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			 throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		 }

		 if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		 if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		 super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		 this.image = { width: width, height: height };

		 this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		 this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		 this.flipY = false;
		 this.generateMipmaps	= false;

	 }


 }

 DepthTexture.prototype.isDepthTexture = true;

 new Vector3();
 new Vector3();
 new Vector3();
 new Triangle();

 /**
	* Extensible curve object.
	*
	* Some common of curve methods:
	* .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	* .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	* .getPoints(), .getSpacedPoints()
	* .getLength()
	* .updateArcLengths()
	*
	* This following curves inherit from THREE.Curve:
	*
	* -- 2D curves --
	* THREE.ArcCurve
	* THREE.CubicBezierCurve
	* THREE.EllipseCurve
	* THREE.LineCurve
	* THREE.QuadraticBezierCurve
	* THREE.SplineCurve
	*
	* -- 3D curves --
	* THREE.CatmullRomCurve3
	* THREE.CubicBezierCurve3
	* THREE.LineCurve3
	* THREE.QuadraticBezierCurve3
	*
	* A series of curves can be represented as a THREE.CurvePath.
	*
	**/

 class Curve {

	 constructor() {

		 this.type = 'Curve';

		 this.arcLengthDivisions = 200;

	 }

	 // Virtual base class method to overwrite and implement in subclasses
	 //	- t [0 .. 1]

	 getPoint( /* t, optionalTarget */ ) {

		 console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		 return null;

	 }

	 // Get point at relative position in curve according to arc length
	 // - u [0 .. 1]

	 getPointAt( u, optionalTarget ) {

		 const t = this.getUtoTmapping( u );
		 return this.getPoint( t, optionalTarget );

	 }

	 // Get sequence of points using getPoint( t )

	 getPoints( divisions = 5 ) {

		 const points = [];

		 for ( let d = 0; d <= divisions; d ++ ) {

			 points.push( this.getPoint( d / divisions ) );

		 }

		 return points;

	 }

	 // Get sequence of points using getPointAt( u )

	 getSpacedPoints( divisions = 5 ) {

		 const points = [];

		 for ( let d = 0; d <= divisions; d ++ ) {

			 points.push( this.getPointAt( d / divisions ) );

		 }

		 return points;

	 }

	 // Get total curve arc length

	 getLength() {

		 const lengths = this.getLengths();
		 return lengths[ lengths.length - 1 ];

	 }

	 // Get list of cumulative segment lengths

	 getLengths( divisions = this.arcLengthDivisions ) {

		 if ( this.cacheArcLengths &&
			 ( this.cacheArcLengths.length === divisions + 1 ) &&
			 ! this.needsUpdate ) {

			 return this.cacheArcLengths;

		 }

		 this.needsUpdate = false;

		 const cache = [];
		 let current, last = this.getPoint( 0 );
		 let sum = 0;

		 cache.push( 0 );

		 for ( let p = 1; p <= divisions; p ++ ) {

			 current = this.getPoint( p / divisions );
			 sum += current.distanceTo( last );
			 cache.push( sum );
			 last = current;

		 }

		 this.cacheArcLengths = cache;

		 return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	 }

	 updateArcLengths() {

		 this.needsUpdate = true;
		 this.getLengths();

	 }

	 // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	 getUtoTmapping( u, distance ) {

		 const arcLengths = this.getLengths();

		 let i = 0;
		 const il = arcLengths.length;

		 let targetArcLength; // The targeted u distance value to get

		 if ( distance ) {

			 targetArcLength = distance;

		 } else {

			 targetArcLength = u * arcLengths[ il - 1 ];

		 }

		 // binary search for the index with largest value smaller than target u distance

		 let low = 0, high = il - 1, comparison;

		 while ( low <= high ) {

			 i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			 comparison = arcLengths[ i ] - targetArcLength;

			 if ( comparison < 0 ) {

				 low = i + 1;

			 } else if ( comparison > 0 ) {

				 high = i - 1;

			 } else {

				 high = i;
				 break;

				 // DONE

			 }

		 }

		 i = high;

		 if ( arcLengths[ i ] === targetArcLength ) {

			 return i / ( il - 1 );

		 }

		 // we could get finer grain at lengths, or use simple interpolation between two points

		 const lengthBefore = arcLengths[ i ];
		 const lengthAfter = arcLengths[ i + 1 ];

		 const segmentLength = lengthAfter - lengthBefore;

		 // determine where we are between the 'before' and 'after' points

		 const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		 // add that fractional amount to t

		 const t = ( i + segmentFraction ) / ( il - 1 );

		 return t;

	 }

	 // Returns a unit vector tangent at t
	 // In case any sub curve does not implement its tangent derivation,
	 // 2 points a small delta apart will be used to find its gradient
	 // which seems to give a reasonable approximation

	 getTangent( t, optionalTarget ) {

		 const delta = 0.0001;
		 let t1 = t - delta;
		 let t2 = t + delta;

		 // Capping in case of danger

		 if ( t1 < 0 ) t1 = 0;
		 if ( t2 > 1 ) t2 = 1;

		 const pt1 = this.getPoint( t1 );
		 const pt2 = this.getPoint( t2 );

		 const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		 tangent.copy( pt2 ).sub( pt1 ).normalize();

		 return tangent;

	 }

	 getTangentAt( u, optionalTarget ) {

		 const t = this.getUtoTmapping( u );
		 return this.getTangent( t, optionalTarget );

	 }

	 computeFrenetFrames( segments, closed ) {

		 // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		 const normal = new Vector3();

		 const tangents = [];
		 const normals = [];
		 const binormals = [];

		 const vec = new Vector3();
		 const mat = new Matrix4();

		 // compute the tangent vectors for each segment on the curve

		 for ( let i = 0; i <= segments; i ++ ) {

			 const u = i / segments;

			 tangents[ i ] = this.getTangentAt( u, new Vector3() );
			 tangents[ i ].normalize();

		 }

		 // select an initial normal vector perpendicular to the first tangent vector,
		 // and in the direction of the minimum tangent xyz component

		 normals[ 0 ] = new Vector3();
		 binormals[ 0 ] = new Vector3();
		 let min = Number.MAX_VALUE;
		 const tx = Math.abs( tangents[ 0 ].x );
		 const ty = Math.abs( tangents[ 0 ].y );
		 const tz = Math.abs( tangents[ 0 ].z );

		 if ( tx <= min ) {

			 min = tx;
			 normal.set( 1, 0, 0 );

		 }

		 if ( ty <= min ) {

			 min = ty;
			 normal.set( 0, 1, 0 );

		 }

		 if ( tz <= min ) {

			 normal.set( 0, 0, 1 );

		 }

		 vec.crossVectors( tangents[ 0 ], normal ).normalize();

		 normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		 binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		 // compute the slowly-varying normal and binormal vectors for each segment on the curve

		 for ( let i = 1; i <= segments; i ++ ) {

			 normals[ i ] = normals[ i - 1 ].clone();

			 binormals[ i ] = binormals[ i - 1 ].clone();

			 vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			 if ( vec.length() > Number.EPSILON ) {

				 vec.normalize();

				 const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				 normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			 }

			 binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		 }

		 // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		 if ( closed === true ) {

			 let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			 theta /= segments;

			 if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				 theta = - theta;

			 }

			 for ( let i = 1; i <= segments; i ++ ) {

				 // twist a little...
				 normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				 binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			 }

		 }

		 return {
			 tangents: tangents,
			 normals: normals,
			 binormals: binormals
		 };

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 copy( source ) {

		 this.arcLengthDivisions = source.arcLengthDivisions;

		 return this;

	 }

	 toJSON() {

		 const data = {
			 metadata: {
				 version: 4.5,
				 type: 'Curve',
				 generator: 'Curve.toJSON'
			 }
		 };

		 data.arcLengthDivisions = this.arcLengthDivisions;
		 data.type = this.type;

		 return data;

	 }

	 fromJSON( json ) {

		 this.arcLengthDivisions = json.arcLengthDivisions;

		 return this;

	 }

 }

 class EllipseCurve extends Curve {

	 constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		 super();

		 this.type = 'EllipseCurve';

		 this.aX = aX;
		 this.aY = aY;

		 this.xRadius = xRadius;
		 this.yRadius = yRadius;

		 this.aStartAngle = aStartAngle;
		 this.aEndAngle = aEndAngle;

		 this.aClockwise = aClockwise;

		 this.aRotation = aRotation;

	 }

	 getPoint( t, optionalTarget ) {

		 const point = optionalTarget || new Vector2();

		 const twoPi = Math.PI * 2;
		 let deltaAngle = this.aEndAngle - this.aStartAngle;
		 const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		 // ensures that deltaAngle is 0 .. 2 PI
		 while ( deltaAngle < 0 ) deltaAngle += twoPi;
		 while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		 if ( deltaAngle < Number.EPSILON ) {

			 if ( samePoints ) {

				 deltaAngle = 0;

			 } else {

				 deltaAngle = twoPi;

			 }

		 }

		 if ( this.aClockwise === true && ! samePoints ) {

			 if ( deltaAngle === twoPi ) {

				 deltaAngle = - twoPi;

			 } else {

				 deltaAngle = deltaAngle - twoPi;

			 }

		 }

		 const angle = this.aStartAngle + t * deltaAngle;
		 let x = this.aX + this.xRadius * Math.cos( angle );
		 let y = this.aY + this.yRadius * Math.sin( angle );

		 if ( this.aRotation !== 0 ) {

			 const cos = Math.cos( this.aRotation );
			 const sin = Math.sin( this.aRotation );

			 const tx = x - this.aX;
			 const ty = y - this.aY;

			 // Rotate the point about the center of the ellipse.
			 x = tx * cos - ty * sin + this.aX;
			 y = tx * sin + ty * cos + this.aY;

		 }

		 return point.set( x, y );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.aX = source.aX;
		 this.aY = source.aY;

		 this.xRadius = source.xRadius;
		 this.yRadius = source.yRadius;

		 this.aStartAngle = source.aStartAngle;
		 this.aEndAngle = source.aEndAngle;

		 this.aClockwise = source.aClockwise;

		 this.aRotation = source.aRotation;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.aX = this.aX;
		 data.aY = this.aY;

		 data.xRadius = this.xRadius;
		 data.yRadius = this.yRadius;

		 data.aStartAngle = this.aStartAngle;
		 data.aEndAngle = this.aEndAngle;

		 data.aClockwise = this.aClockwise;

		 data.aRotation = this.aRotation;

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.aX = json.aX;
		 this.aY = json.aY;

		 this.xRadius = json.xRadius;
		 this.yRadius = json.yRadius;

		 this.aStartAngle = json.aStartAngle;
		 this.aEndAngle = json.aEndAngle;

		 this.aClockwise = json.aClockwise;

		 this.aRotation = json.aRotation;

		 return this;

	 }

 }

 EllipseCurve.prototype.isEllipseCurve = true;

 class ArcCurve extends EllipseCurve {

	 constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		 super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		 this.type = 'ArcCurve';

	 }

 }

 ArcCurve.prototype.isArcCurve = true;

 /**
	* Centripetal CatmullRom Curve - which is useful for avoiding
	* cusps and self-intersections in non-uniform catmull rom curves.
	* http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	*
	* curve.type accepts centripetal(default), chordal and catmullrom
	* curve.tension is used for catmullrom which defaults to 0.5
	*/


 /*
 Based on an optimized c++ solution in
	- http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	- http://ideone.com/NoEbVM

 This CubicPoly class could be used for reusing some variables and calculations,
 but for three.js curve use, it could be possible inlined and flatten into a single function call
 which can be placed in CurveUtils.
 */

 function CubicPoly() {

	 let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	 /*
		* Compute coefficients for a cubic polynomial
		*   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		* such that
		*   p(0) = x0, p(1) = x1
		*  and
		*   p'(0) = t0, p'(1) = t1.
		*/
	 function init( x0, x1, t0, t1 ) {

		 c0 = x0;
		 c1 = t0;
		 c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		 c3 = 2 * x0 - 2 * x1 + t0 + t1;

	 }

	 return {

		 initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			 init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		 },

		 initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			 // compute tangents when parameterized in [t1,t2]
			 let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			 let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			 // rescale tangents for parametrization in [0,1]
			 t1 *= dt1;
			 t2 *= dt1;

			 init( x1, x2, t1, t2 );

		 },

		 calc: function ( t ) {

			 const t2 = t * t;
			 const t3 = t2 * t;
			 return c0 + c1 * t + c2 * t2 + c3 * t3;

		 }

	 };

 }

 //

 const tmp = new Vector3();
 const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

 class CatmullRomCurve3 extends Curve {

	 constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		 super();

		 this.type = 'CatmullRomCurve3';

		 this.points = points;
		 this.closed = closed;
		 this.curveType = curveType;
		 this.tension = tension;

	 }

	 getPoint( t, optionalTarget = new Vector3() ) {

		 const point = optionalTarget;

		 const points = this.points;
		 const l = points.length;

		 const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		 let intPoint = Math.floor( p );
		 let weight = p - intPoint;

		 if ( this.closed ) {

			 intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		 } else if ( weight === 0 && intPoint === l - 1 ) {

			 intPoint = l - 2;
			 weight = 1;

		 }

		 let p0, p3; // 4 points (p1 & p2 defined below)

		 if ( this.closed || intPoint > 0 ) {

			 p0 = points[ ( intPoint - 1 ) % l ];

		 } else {

			 // extrapolate first point
			 tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			 p0 = tmp;

		 }

		 const p1 = points[ intPoint % l ];
		 const p2 = points[ ( intPoint + 1 ) % l ];

		 if ( this.closed || intPoint + 2 < l ) {

			 p3 = points[ ( intPoint + 2 ) % l ];

		 } else {

			 // extrapolate last point
			 tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			 p3 = tmp;

		 }

		 if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			 // init Centripetal / Chordal Catmull-Rom
			 const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			 let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			 let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			 let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			 // safety check for repeated points
			 if ( dt1 < 1e-4 ) dt1 = 1.0;
			 if ( dt0 < 1e-4 ) dt0 = dt1;
			 if ( dt2 < 1e-4 ) dt2 = dt1;

			 px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			 py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			 pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		 } else if ( this.curveType === 'catmullrom' ) {

			 px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			 py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			 pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		 }

		 point.set(
			 px.calc( weight ),
			 py.calc( weight ),
			 pz.calc( weight )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.points = [];

		 for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			 const point = source.points[ i ];

			 this.points.push( point.clone() );

		 }

		 this.closed = source.closed;
		 this.curveType = source.curveType;
		 this.tension = source.tension;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.points = [];

		 for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			 const point = this.points[ i ];
			 data.points.push( point.toArray() );

		 }

		 data.closed = this.closed;
		 data.curveType = this.curveType;
		 data.tension = this.tension;

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.points = [];

		 for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			 const point = json.points[ i ];
			 this.points.push( new Vector3().fromArray( point ) );

		 }

		 this.closed = json.closed;
		 this.curveType = json.curveType;
		 this.tension = json.tension;

		 return this;

	 }

 }

 CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

 /**
	* Bezier Curves formulas obtained from
	* http://en.wikipedia.org/wiki/Bézier_curve
	*/

 function CatmullRom( t, p0, p1, p2, p3 ) {

	 const v0 = ( p2 - p0 ) * 0.5;
	 const v1 = ( p3 - p1 ) * 0.5;
	 const t2 = t * t;
	 const t3 = t * t2;
	 return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

 }

 //

 function QuadraticBezierP0( t, p ) {

	 const k = 1 - t;
	 return k * k * p;

 }

 function QuadraticBezierP1( t, p ) {

	 return 2 * ( 1 - t ) * t * p;

 }

 function QuadraticBezierP2( t, p ) {

	 return t * t * p;

 }

 function QuadraticBezier( t, p0, p1, p2 ) {

	 return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		 QuadraticBezierP2( t, p2 );

 }

 //

 function CubicBezierP0( t, p ) {

	 const k = 1 - t;
	 return k * k * k * p;

 }

 function CubicBezierP1( t, p ) {

	 const k = 1 - t;
	 return 3 * k * k * t * p;

 }

 function CubicBezierP2( t, p ) {

	 return 3 * ( 1 - t ) * t * t * p;

 }

 function CubicBezierP3( t, p ) {

	 return t * t * t * p;

 }

 function CubicBezier( t, p0, p1, p2, p3 ) {

	 return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		 CubicBezierP3( t, p3 );

 }

 class CubicBezierCurve extends Curve {

	 constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		 super();

		 this.type = 'CubicBezierCurve';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;
		 this.v3 = v3;

	 }

	 getPoint( t, optionalTarget = new Vector2() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		 point.set(
			 CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			 CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );
		 this.v3.copy( source.v3 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();
		 data.v3 = this.v3.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );
		 this.v3.fromArray( json.v3 );

		 return this;

	 }

 }

 CubicBezierCurve.prototype.isCubicBezierCurve = true;

 class CubicBezierCurve3 extends Curve {

	 constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		 super();

		 this.type = 'CubicBezierCurve3';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;
		 this.v3 = v3;

	 }

	 getPoint( t, optionalTarget = new Vector3() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		 point.set(
			 CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			 CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			 CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );
		 this.v3.copy( source.v3 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();
		 data.v3 = this.v3.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );
		 this.v3.fromArray( json.v3 );

		 return this;

	 }

 }

 CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

 class LineCurve extends Curve {

	 constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		 super();

		 this.type = 'LineCurve';

		 this.v1 = v1;
		 this.v2 = v2;

	 }

	 getPoint( t, optionalTarget = new Vector2() ) {

		 const point = optionalTarget;

		 if ( t === 1 ) {

			 point.copy( this.v2 );

		 } else {

			 point.copy( this.v2 ).sub( this.v1 );
			 point.multiplyScalar( t ).add( this.v1 );

		 }

		 return point;

	 }

	 // Line curve is linear, so we can overwrite default getPointAt
	 getPointAt( u, optionalTarget ) {

		 return this.getPoint( u, optionalTarget );

	 }

	 getTangent( t, optionalTarget ) {

		 const tangent = optionalTarget || new Vector2();

		 tangent.copy( this.v2 ).sub( this.v1 ).normalize();

		 return tangent;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 LineCurve.prototype.isLineCurve = true;

 class LineCurve3 extends Curve {

	 constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		 super();

		 this.type = 'LineCurve3';
		 this.isLineCurve3 = true;

		 this.v1 = v1;
		 this.v2 = v2;

	 }
	 getPoint( t, optionalTarget = new Vector3() ) {

		 const point = optionalTarget;

		 if ( t === 1 ) {

			 point.copy( this.v2 );

		 } else {

			 point.copy( this.v2 ).sub( this.v1 );
			 point.multiplyScalar( t ).add( this.v1 );

		 }

		 return point;

	 }
	 // Line curve is linear, so we can overwrite default getPointAt
	 getPointAt( u, optionalTarget ) {

		 return this.getPoint( u, optionalTarget );

	 }
	 copy( source ) {

		 super.copy( source );

		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }
	 toJSON() {

		 const data = super.toJSON();

		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }
	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 class QuadraticBezierCurve extends Curve {

	 constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		 super();

		 this.type = 'QuadraticBezierCurve';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;

	 }

	 getPoint( t, optionalTarget = new Vector2() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		 point.set(
			 QuadraticBezier( t, v0.x, v1.x, v2.x ),
			 QuadraticBezier( t, v0.y, v1.y, v2.y )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

 class QuadraticBezierCurve3 extends Curve {

	 constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		 super();

		 this.type = 'QuadraticBezierCurve3';

		 this.v0 = v0;
		 this.v1 = v1;
		 this.v2 = v2;

	 }

	 getPoint( t, optionalTarget = new Vector3() ) {

		 const point = optionalTarget;

		 const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		 point.set(
			 QuadraticBezier( t, v0.x, v1.x, v2.x ),
			 QuadraticBezier( t, v0.y, v1.y, v2.y ),
			 QuadraticBezier( t, v0.z, v1.z, v2.z )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.v0.copy( source.v0 );
		 this.v1.copy( source.v1 );
		 this.v2.copy( source.v2 );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.v0 = this.v0.toArray();
		 data.v1 = this.v1.toArray();
		 data.v2 = this.v2.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.v0.fromArray( json.v0 );
		 this.v1.fromArray( json.v1 );
		 this.v2.fromArray( json.v2 );

		 return this;

	 }

 }

 QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

 class SplineCurve extends Curve {

	 constructor( points = [] ) {

		 super();

		 this.type = 'SplineCurve';

		 this.points = points;

	 }

	 getPoint( t, optionalTarget = new Vector2() ) {

		 const point = optionalTarget;

		 const points = this.points;
		 const p = ( points.length - 1 ) * t;

		 const intPoint = Math.floor( p );
		 const weight = p - intPoint;

		 const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		 const p1 = points[ intPoint ];
		 const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		 const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		 point.set(
			 CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			 CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		 );

		 return point;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.points = [];

		 for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			 const point = source.points[ i ];

			 this.points.push( point.clone() );

		 }

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.points = [];

		 for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			 const point = this.points[ i ];
			 data.points.push( point.toArray() );

		 }

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.points = [];

		 for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			 const point = json.points[ i ];
			 this.points.push( new Vector2().fromArray( point ) );

		 }

		 return this;

	 }

 }

 SplineCurve.prototype.isSplineCurve = true;

 var Curves = /*#__PURE__*/Object.freeze({
	 __proto__: null,
	 ArcCurve: ArcCurve,
	 CatmullRomCurve3: CatmullRomCurve3,
	 CubicBezierCurve: CubicBezierCurve,
	 CubicBezierCurve3: CubicBezierCurve3,
	 EllipseCurve: EllipseCurve,
	 LineCurve: LineCurve,
	 LineCurve3: LineCurve3,
	 QuadraticBezierCurve: QuadraticBezierCurve,
	 QuadraticBezierCurve3: QuadraticBezierCurve3,
	 SplineCurve: SplineCurve
 });

 /**
	* Port from https://github.com/mapbox/earcut (v2.2.2)
	*/

 const Earcut = {

	 triangulate: function ( data, holeIndices, dim = 2 ) {

		 const hasHoles = holeIndices && holeIndices.length;
		 const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		 let outerNode = linkedList( data, 0, outerLen, dim, true );
		 const triangles = [];

		 if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		 let minX, minY, maxX, maxY, x, y, invSize;

		 if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		 // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		 if ( data.length > 80 * dim ) {

			 minX = maxX = data[ 0 ];
			 minY = maxY = data[ 1 ];

			 for ( let i = dim; i < outerLen; i += dim ) {

				 x = data[ i ];
				 y = data[ i + 1 ];
				 if ( x < minX ) minX = x;
				 if ( y < minY ) minY = y;
				 if ( x > maxX ) maxX = x;
				 if ( y > maxY ) maxY = y;

			 }

			 // minX, minY and invSize are later used to transform coords into integers for z-order calculation
			 invSize = Math.max( maxX - minX, maxY - minY );
			 invSize = invSize !== 0 ? 1 / invSize : 0;

		 }

		 earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		 return triangles;

	 }

 };

 // create a circular doubly linked list from polygon points in the specified winding order
 function linkedList( data, start, end, dim, clockwise ) {

	 let i, last;

	 if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		 for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	 } else {

		 for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	 }

	 if ( last && equals( last, last.next ) ) {

		 removeNode( last );
		 last = last.next;

	 }

	 return last;

 }

 // eliminate colinear or duplicate points
 function filterPoints( start, end ) {

	 if ( ! start ) return start;
	 if ( ! end ) end = start;

	 let p = start,
		 again;
	 do {

		 again = false;

		 if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			 removeNode( p );
			 p = end = p.prev;
			 if ( p === p.next ) break;
			 again = true;

		 } else {

			 p = p.next;

		 }

	 } while ( again || p !== end );

	 return end;

 }

 // main ear slicing loop which triangulates a polygon (given as a linked list)
 function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	 if ( ! ear ) return;

	 // interlink polygon nodes in z-order
	 if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	 let stop = ear,
		 prev, next;

	 // iterate through ears, slicing them one by one
	 while ( ear.prev !== ear.next ) {

		 prev = ear.prev;
		 next = ear.next;

		 if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			 // cut off the triangle
			 triangles.push( prev.i / dim );
			 triangles.push( ear.i / dim );
			 triangles.push( next.i / dim );

			 removeNode( ear );

			 // skipping the next vertex leads to less sliver triangles
			 ear = next.next;
			 stop = next.next;

			 continue;

		 }

		 ear = next;

		 // if we looped through the whole remaining polygon and can't find any more ears
		 if ( ear === stop ) {

			 // try filtering points and slicing again
			 if ( ! pass ) {

				 earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				 // if this didn't work, try curing all small self-intersections locally

			 } else if ( pass === 1 ) {

				 ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				 earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				 // as a last resort, try splitting the remaining polygon into two

			 } else if ( pass === 2 ) {

				 splitEarcut( ear, triangles, dim, minX, minY, invSize );

			 }

			 break;

		 }

	 }

 }

 // check whether a polygon node forms a valid ear with adjacent nodes
 function isEar( ear ) {

	 const a = ear.prev,
		 b = ear,
		 c = ear.next;

	 if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	 // now make sure we don't have other points inside the potential ear
	 let p = ear.next.next;

	 while ( p !== ear.prev ) {

		 if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			 area( p.prev, p, p.next ) >= 0 ) return false;
		 p = p.next;

	 }

	 return true;

 }

 function isEarHashed( ear, minX, minY, invSize ) {

	 const a = ear.prev,
		 b = ear,
		 c = ear.next;

	 if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	 // triangle bbox; min & max are calculated like this for speed
	 const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		 minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		 maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		 maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	 // z-order range for the current triangle bbox;
	 const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		 maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	 let p = ear.prevZ,
		 n = ear.nextZ;

	 // look for points inside the triangle in both directions
	 while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		 if ( p !== ear.prev && p !== ear.next &&
			 pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			 area( p.prev, p, p.next ) >= 0 ) return false;
		 p = p.prevZ;

		 if ( n !== ear.prev && n !== ear.next &&
			 pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			 area( n.prev, n, n.next ) >= 0 ) return false;
		 n = n.nextZ;

	 }

	 // look for remaining points in decreasing z-order
	 while ( p && p.z >= minZ ) {

		 if ( p !== ear.prev && p !== ear.next &&
			 pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			 area( p.prev, p, p.next ) >= 0 ) return false;
		 p = p.prevZ;

	 }

	 // look for remaining points in increasing z-order
	 while ( n && n.z <= maxZ ) {

		 if ( n !== ear.prev && n !== ear.next &&
			 pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			 area( n.prev, n, n.next ) >= 0 ) return false;
		 n = n.nextZ;

	 }

	 return true;

 }

 // go through all polygon nodes and cure small local self-intersections
 function cureLocalIntersections( start, triangles, dim ) {

	 let p = start;
	 do {

		 const a = p.prev,
			 b = p.next.next;

		 if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			 triangles.push( a.i / dim );
			 triangles.push( p.i / dim );
			 triangles.push( b.i / dim );

			 // remove two nodes involved
			 removeNode( p );
			 removeNode( p.next );

			 p = start = b;

		 }

		 p = p.next;

	 } while ( p !== start );

	 return filterPoints( p );

 }

 // try splitting polygon into two and triangulate them independently
 function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	 // look for a valid diagonal that divides the polygon into two
	 let a = start;
	 do {

		 let b = a.next.next;
		 while ( b !== a.prev ) {

			 if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				 // split the polygon in two by the diagonal
				 let c = splitPolygon( a, b );

				 // filter colinear points around the cuts
				 a = filterPoints( a, a.next );
				 c = filterPoints( c, c.next );

				 // run earcut on each half
				 earcutLinked( a, triangles, dim, minX, minY, invSize );
				 earcutLinked( c, triangles, dim, minX, minY, invSize );
				 return;

			 }

			 b = b.next;

		 }

		 a = a.next;

	 } while ( a !== start );

 }

 // link every hole into the outer loop, producing a single-ring polygon without holes
 function eliminateHoles( data, holeIndices, outerNode, dim ) {

	 const queue = [];
	 let i, len, start, end, list;

	 for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		 start = holeIndices[ i ] * dim;
		 end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		 list = linkedList( data, start, end, dim, false );
		 if ( list === list.next ) list.steiner = true;
		 queue.push( getLeftmost( list ) );

	 }

	 queue.sort( compareX );

	 // process holes from left to right
	 for ( i = 0; i < queue.length; i ++ ) {

		 eliminateHole( queue[ i ], outerNode );
		 outerNode = filterPoints( outerNode, outerNode.next );

	 }

	 return outerNode;

 }

 function compareX( a, b ) {

	 return a.x - b.x;

 }

 // find a bridge between vertices that connects hole with an outer ring and and link it
 function eliminateHole( hole, outerNode ) {

	 outerNode = findHoleBridge( hole, outerNode );
	 if ( outerNode ) {

		 const b = splitPolygon( outerNode, hole );

		 // filter collinear points around the cuts
		 filterPoints( outerNode, outerNode.next );
		 filterPoints( b, b.next );

	 }

 }

 // David Eberly's algorithm for finding a bridge between hole and outer polygon
 function findHoleBridge( hole, outerNode ) {

	 let p = outerNode;
	 const hx = hole.x;
	 const hy = hole.y;
	 let qx = - Infinity, m;

	 // find a segment intersected by a ray from the hole's leftmost point to the left;
	 // segment's endpoint with lesser x will be potential connection point
	 do {

		 if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			 const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			 if ( x <= hx && x > qx ) {

				 qx = x;
				 if ( x === hx ) {

					 if ( hy === p.y ) return p;
					 if ( hy === p.next.y ) return p.next;

				 }

				 m = p.x < p.next.x ? p : p.next;

			 }

		 }

		 p = p.next;

	 } while ( p !== outerNode );

	 if ( ! m ) return null;

	 if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	 // look for points inside the triangle of hole point, segment intersection and endpoint;
	 // if there are no points found, we have a valid connection;
	 // otherwise choose the point of the minimum angle with the ray as connection point

	 const stop = m,
		 mx = m.x,
		 my = m.y;
	 let tanMin = Infinity, tan;

	 p = m;

	 do {

		 if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				 pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			 tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			 if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				 m = p;
				 tanMin = tan;

			 }

		 }

		 p = p.next;

	 } while ( p !== stop );

	 return m;

 }

 // whether sector in vertex m contains sector in vertex p in the same coordinates
 function sectorContainsSector( m, p ) {

	 return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

 }

 // interlink polygon nodes in z-order
 function indexCurve( start, minX, minY, invSize ) {

	 let p = start;
	 do {

		 if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		 p.prevZ = p.prev;
		 p.nextZ = p.next;
		 p = p.next;

	 } while ( p !== start );

	 p.prevZ.nextZ = null;
	 p.prevZ = null;

	 sortLinked( p );

 }

 // Simon Tatham's linked list merge sort algorithm
 // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
 function sortLinked( list ) {

	 let i, p, q, e, tail, numMerges, pSize, qSize,
		 inSize = 1;

	 do {

		 p = list;
		 list = null;
		 tail = null;
		 numMerges = 0;

		 while ( p ) {

			 numMerges ++;
			 q = p;
			 pSize = 0;
			 for ( i = 0; i < inSize; i ++ ) {

				 pSize ++;
				 q = q.nextZ;
				 if ( ! q ) break;

			 }

			 qSize = inSize;

			 while ( pSize > 0 || ( qSize > 0 && q ) ) {

				 if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					 e = p;
					 p = p.nextZ;
					 pSize --;

				 } else {

					 e = q;
					 q = q.nextZ;
					 qSize --;

				 }

				 if ( tail ) tail.nextZ = e;
				 else list = e;

				 e.prevZ = tail;
				 tail = e;

			 }

			 p = q;

		 }

		 tail.nextZ = null;
		 inSize *= 2;

	 } while ( numMerges > 1 );

	 return list;

 }

 // z-order of a point given coords and inverse of the longer side of data bbox
 function zOrder( x, y, minX, minY, invSize ) {

	 // coords are transformed into non-negative 15-bit integer range
	 x = 32767 * ( x - minX ) * invSize;
	 y = 32767 * ( y - minY ) * invSize;

	 x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	 x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	 x = ( x | ( x << 2 ) ) & 0x33333333;
	 x = ( x | ( x << 1 ) ) & 0x55555555;

	 y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	 y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	 y = ( y | ( y << 2 ) ) & 0x33333333;
	 y = ( y | ( y << 1 ) ) & 0x55555555;

	 return x | ( y << 1 );

 }

 // find the leftmost node of a polygon ring
 function getLeftmost( start ) {

	 let p = start,
		 leftmost = start;
	 do {

		 if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		 p = p.next;

	 } while ( p !== start );

	 return leftmost;

 }

 // check if a point lies within a convex triangle
 function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	 return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

 }

 // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
 function isValidDiagonal( a, b ) {

	 return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
		 ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		 ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		 equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

 }

 // signed area of a triangle
 function area( p, q, r ) {

	 return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

 }

 // check if two points are equal
 function equals( p1, p2 ) {

	 return p1.x === p2.x && p1.y === p2.y;

 }

 // check if two segments intersect
 function intersects( p1, q1, p2, q2 ) {

	 const o1 = sign( area( p1, q1, p2 ) );
	 const o2 = sign( area( p1, q1, q2 ) );
	 const o3 = sign( area( p2, q2, p1 ) );
	 const o4 = sign( area( p2, q2, q1 ) );

	 if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	 if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	 if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	 if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	 if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	 return false;

 }

 // for collinear points p, q, r, check if point q lies on segment pr
 function onSegment( p, q, r ) {

	 return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

 }

 function sign( num ) {

	 return num > 0 ? 1 : num < 0 ? - 1 : 0;

 }

 // check if a polygon diagonal intersects any polygon segments
 function intersectsPolygon( a, b ) {

	 let p = a;
	 do {

		 if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				 intersects( p, p.next, a, b ) ) return true;
		 p = p.next;

	 } while ( p !== a );

	 return false;

 }

 // check if a polygon diagonal is locally inside the polygon
 function locallyInside( a, b ) {

	 return area( a.prev, a, a.next ) < 0 ?
		 area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		 area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

 }

 // check if the middle point of a polygon diagonal is inside the polygon
 function middleInside( a, b ) {

	 let p = a,
		 inside = false;
	 const px = ( a.x + b.x ) / 2,
		 py = ( a.y + b.y ) / 2;
	 do {

		 if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				 ( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			 inside = ! inside;
		 p = p.next;

	 } while ( p !== a );

	 return inside;

 }

 // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
 // if one belongs to the outer ring and another to a hole, it merges it into a single ring
 function splitPolygon( a, b ) {

	 const a2 = new Node( a.i, a.x, a.y ),
		 b2 = new Node( b.i, b.x, b.y ),
		 an = a.next,
		 bp = b.prev;

	 a.next = b;
	 b.prev = a;

	 a2.next = an;
	 an.prev = a2;

	 b2.next = a2;
	 a2.prev = b2;

	 bp.next = b2;
	 b2.prev = bp;

	 return b2;

 }

 // create a node and optionally link it with previous one (in a circular doubly linked list)
 function insertNode( i, x, y, last ) {

	 const p = new Node( i, x, y );

	 if ( ! last ) {

		 p.prev = p;
		 p.next = p;

	 } else {

		 p.next = last.next;
		 p.prev = last;
		 last.next.prev = p;
		 last.next = p;

	 }

	 return p;

 }

 function removeNode( p ) {

	 p.next.prev = p.prev;
	 p.prev.next = p.next;

	 if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	 if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

 }

 function Node( i, x, y ) {

	 // vertex index in coordinates array
	 this.i = i;

	 // vertex coordinates
	 this.x = x;
	 this.y = y;

	 // previous and next vertex nodes in a polygon ring
	 this.prev = null;
	 this.next = null;

	 // z-order curve value
	 this.z = null;

	 // previous and next nodes in z-order
	 this.prevZ = null;
	 this.nextZ = null;

	 // indicates whether this is a steiner point
	 this.steiner = false;

 }

 function signedArea( data, start, end, dim ) {

	 let sum = 0;
	 for ( let i = start, j = end - dim; i < end; i += dim ) {

		 sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		 j = i;

	 }

	 return sum;

 }

 class ShapeUtils {

	 // calculate area of the contour polygon

	 static area( contour ) {

		 const n = contour.length;
		 let a = 0.0;

		 for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			 a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		 }

		 return a * 0.5;

	 }

	 static isClockWise( pts ) {

		 return ShapeUtils.area( pts ) < 0;

	 }

	 static triangulateShape( contour, holes ) {

		 const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		 const holeIndices = []; // array of hole indices
		 const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		 removeDupEndPts( contour );
		 addContour( vertices, contour );

		 //

		 let holeIndex = contour.length;

		 holes.forEach( removeDupEndPts );

		 for ( let i = 0; i < holes.length; i ++ ) {

			 holeIndices.push( holeIndex );
			 holeIndex += holes[ i ].length;
			 addContour( vertices, holes[ i ] );

		 }

		 //

		 const triangles = Earcut.triangulate( vertices, holeIndices );

		 //

		 for ( let i = 0; i < triangles.length; i += 3 ) {

			 faces.push( triangles.slice( i, i + 3 ) );

		 }

		 return faces;

	 }

 }

 function removeDupEndPts( points ) {

	 const l = points.length;

	 if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		 points.pop();

	 }

 }

 function addContour( vertices, contour ) {

	 for ( let i = 0; i < contour.length; i ++ ) {

		 vertices.push( contour[ i ].x );
		 vertices.push( contour[ i ].y );

	 }

 }

 /**
	* Creates extruded geometry from a path shape.
	*
	* parameters = {
	*
	*  curveSegments: <int>, // number of points on the curves
	*  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	*  depth: <float>, // Depth to extrude the shape
	*
	*  bevelEnabled: <bool>, // turn on bevel
	*  bevelThickness: <float>, // how deep into the original shape bevel goes
	*  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	*  bevelOffset: <float>, // how far from shape outline does bevel start
	*  bevelSegments: <int>, // number of bevel layers
	*
	*  extrudePath: <THREE.Curve> // curve to extrude shape along
	*
	*  UVGenerator: <Object> // object that provides UV generator functions
	*
	* }
	*/

 class ExtrudeGeometry extends BufferGeometry {

	 constructor( shapes, options ) {

		 super();

		 this.type = 'ExtrudeGeometry';

		 this.parameters = {
			 shapes: shapes,
			 options: options
		 };

		 shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		 const scope = this;

		 const verticesArray = [];
		 const uvArray = [];

		 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			 const shape = shapes[ i ];
			 addShape( shape );

		 }

		 // build geometry

		 this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		 this.computeVertexNormals();

		 // functions

		 function addShape( shape ) {

			 const placeholder = [];

			 // options

			 const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			 const steps = options.steps !== undefined ? options.steps : 1;
			 let depth = options.depth !== undefined ? options.depth : 100;

			 let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			 let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			 let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			 let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			 let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			 const extrudePath = options.extrudePath;

			 const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			 // deprecated options

			 if ( options.amount !== undefined ) {

				 console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				 depth = options.amount;

			 }

			 //

			 let extrudePts, extrudeByPath = false;
			 let splineTube, binormal, normal, position2;

			 if ( extrudePath ) {

				 extrudePts = extrudePath.getSpacedPoints( steps );

				 extrudeByPath = true;
				 bevelEnabled = false; // bevels not supported for path extrusion

				 // SETUP TNB variables

				 // TODO1 - have a .isClosed in spline?

				 splineTube = extrudePath.computeFrenetFrames( steps, false );

				 // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				 binormal = new Vector3();
				 normal = new Vector3();
				 position2 = new Vector3();

			 }

			 // Safeguards if bevels are not enabled

			 if ( ! bevelEnabled ) {

				 bevelSegments = 0;
				 bevelThickness = 0;
				 bevelSize = 0;
				 bevelOffset = 0;

			 }

			 // Variables initialization

			 const shapePoints = shape.extractPoints( curveSegments );

			 let vertices = shapePoints.shape;
			 const holes = shapePoints.holes;

			 const reverse = ! ShapeUtils.isClockWise( vertices );

			 if ( reverse ) {

				 vertices = vertices.reverse();

				 // Maybe we should also check if holes are in the opposite direction, just to be safe ...

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];

					 if ( ShapeUtils.isClockWise( ahole ) ) {

						 holes[ h ] = ahole.reverse();

					 }

				 }

			 }


			 const faces = ShapeUtils.triangulateShape( vertices, holes );

			 /* Vertices */

			 const contour = vertices; // vertices has all points but contour has only points of circumference

			 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				 const ahole = holes[ h ];

				 vertices = vertices.concat( ahole );

			 }


			 function scalePt2( pt, vec, size ) {

				 if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				 return vec.clone().multiplyScalar( size ).add( pt );

			 }

			 const vlen = vertices.length, flen = faces.length;


			 // Find directions for point movement


			 function getBevelVec( inPt, inPrev, inNext ) {

				 // computes for inPt the corresponding point inPt' on a new contour
				 //   shifted by 1 unit (length of normalized vector) to the left
				 // if we walk along contour clockwise, this new contour is outside the old one
				 //
				 // inPt' is the intersection of the two lines parallel to the two
				 //  adjacent edges of inPt at a distance of 1 unit on the left side.

				 let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				 // good reading for geometry algorithms (here: line-line intersection)
				 // http://geomalgorithms.com/a05-_intersect-1.html

				 const v_prev_x = inPt.x - inPrev.x,
					 v_prev_y = inPt.y - inPrev.y;
				 const v_next_x = inNext.x - inPt.x,
					 v_next_y = inNext.y - inPt.y;

				 const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				 // check for collinear edges
				 const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				 if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					 // not collinear

					 // length of vectors for normalizing

					 const v_prev_len = Math.sqrt( v_prev_lensq );
					 const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					 // shift adjacent points by unit vectors to the left

					 const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					 const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					 const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					 const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					 // scaling factor for v_prev to intersection point

					 const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							 ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						 ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					 // vector from inPt to intersection point

					 v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					 v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					 // Don't normalize!, otherwise sharp corners become ugly
					 //  but prevent crazy spikes
					 const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					 if ( v_trans_lensq <= 2 ) {

						 return new Vector2( v_trans_x, v_trans_y );

					 } else {

						 shrink_by = Math.sqrt( v_trans_lensq / 2 );

					 }

				 } else {

					 // handle special case of collinear edges

					 let direction_eq = false; // assumes: opposite

					 if ( v_prev_x > Number.EPSILON ) {

						 if ( v_next_x > Number.EPSILON ) {

							 direction_eq = true;

						 }

					 } else {

						 if ( v_prev_x < - Number.EPSILON ) {

							 if ( v_next_x < - Number.EPSILON ) {

								 direction_eq = true;

							 }

						 } else {

							 if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								 direction_eq = true;

							 }

						 }

					 }

					 if ( direction_eq ) {

						 // console.log("Warning: lines are a straight sequence");
						 v_trans_x = - v_prev_y;
						 v_trans_y = v_prev_x;
						 shrink_by = Math.sqrt( v_prev_lensq );

					 } else {

						 // console.log("Warning: lines are a straight spike");
						 v_trans_x = v_prev_x;
						 v_trans_y = v_prev_y;
						 shrink_by = Math.sqrt( v_prev_lensq / 2 );

					 }

				 }

				 return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			 }


			 const contourMovements = [];

			 for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				 if ( j === il ) j = 0;
				 if ( k === il ) k = 0;

				 //  (j)---(i)---(k)
				 // console.log('i,j,k', i, j , k)

				 contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			 }

			 const holesMovements = [];
			 let oneHoleMovements, verticesMovements = contourMovements.concat();

			 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				 const ahole = holes[ h ];

				 oneHoleMovements = [];

				 for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					 if ( j === il ) j = 0;
					 if ( k === il ) k = 0;

					 //  (j)---(i)---(k)
					 oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				 }

				 holesMovements.push( oneHoleMovements );
				 verticesMovements = verticesMovements.concat( oneHoleMovements );

			 }


			 // Loop bevelSegments, 1 for the front, 1 for the back

			 for ( let b = 0; b < bevelSegments; b ++ ) {

				 //for ( b = bevelSegments; b > 0; b -- ) {

				 const t = b / bevelSegments;
				 const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				 const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				 // contract shape

				 for ( let i = 0, il = contour.length; i < il; i ++ ) {

					 const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					 v( vert.x, vert.y, - z );

				 }

				 // expand holes

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];
					 oneHoleMovements = holesMovements[ h ];

					 for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						 const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						 v( vert.x, vert.y, - z );

					 }

				 }

			 }

			 const bs = bevelSize + bevelOffset;

			 // Back facing vertices

			 for ( let i = 0; i < vlen; i ++ ) {

				 const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				 if ( ! extrudeByPath ) {

					 v( vert.x, vert.y, 0 );

				 } else {

					 // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					 normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					 binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					 position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					 v( position2.x, position2.y, position2.z );

				 }

			 }

			 // Add stepped vertices...
			 // Including front facing vertices

			 for ( let s = 1; s <= steps; s ++ ) {

				 for ( let i = 0; i < vlen; i ++ ) {

					 const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					 if ( ! extrudeByPath ) {

						 v( vert.x, vert.y, depth / steps * s );

					 } else {

						 // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						 normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						 binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						 position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						 v( position2.x, position2.y, position2.z );

					 }

				 }

			 }


			 // Add bevel segments planes

			 //for ( b = 1; b <= bevelSegments; b ++ ) {
			 for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				 const t = b / bevelSegments;
				 const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				 const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				 // contract shape

				 for ( let i = 0, il = contour.length; i < il; i ++ ) {

					 const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					 v( vert.x, vert.y, depth + z );

				 }

				 // expand holes

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];
					 oneHoleMovements = holesMovements[ h ];

					 for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						 const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						 if ( ! extrudeByPath ) {

							 v( vert.x, vert.y, depth + z );

						 } else {

							 v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						 }

					 }

				 }

			 }

			 /* Faces */

			 // Top and bottom faces

			 buildLidFaces();

			 // Sides faces

			 buildSideFaces();


			 /////  Internal functions

			 function buildLidFaces() {

				 const start = verticesArray.length / 3;

				 if ( bevelEnabled ) {

					 let layer = 0; // steps + 1
					 let offset = vlen * layer;

					 // Bottom faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					 }

					 layer = steps + bevelSegments * 2;
					 offset = vlen * layer;

					 // Top faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					 }

				 } else {

					 // Bottom faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					 }

					 // Top faces

					 for ( let i = 0; i < flen; i ++ ) {

						 const face = faces[ i ];
						 f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					 }

				 }

				 scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			 }

			 // Create faces for the z-sides of the shape

			 function buildSideFaces() {

				 const start = verticesArray.length / 3;
				 let layeroffset = 0;
				 sidewalls( contour, layeroffset );
				 layeroffset += contour.length;

				 for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					 const ahole = holes[ h ];
					 sidewalls( ahole, layeroffset );

					 //, true
					 layeroffset += ahole.length;

				 }


				 scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			 }

			 function sidewalls( contour, layeroffset ) {

				 let i = contour.length;

				 while ( -- i >= 0 ) {

					 const j = i;
					 let k = i - 1;
					 if ( k < 0 ) k = contour.length - 1;

					 //console.log('b', i,j, i-1, k,vertices.length);

					 for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						 const slen1 = vlen * s;
						 const slen2 = vlen * ( s + 1 );

						 const a = layeroffset + j + slen1,
							 b = layeroffset + k + slen1,
							 c = layeroffset + k + slen2,
							 d = layeroffset + j + slen2;

						 f4( a, b, c, d );

					 }

				 }

			 }

			 function v( x, y, z ) {

				 placeholder.push( x );
				 placeholder.push( y );
				 placeholder.push( z );

			 }


			 function f3( a, b, c ) {

				 addVertex( a );
				 addVertex( b );
				 addVertex( c );

				 const nextIndex = verticesArray.length / 3;
				 const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				 addUV( uvs[ 0 ] );
				 addUV( uvs[ 1 ] );
				 addUV( uvs[ 2 ] );

			 }

			 function f4( a, b, c, d ) {

				 addVertex( a );
				 addVertex( b );
				 addVertex( d );

				 addVertex( b );
				 addVertex( c );
				 addVertex( d );


				 const nextIndex = verticesArray.length / 3;
				 const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				 addUV( uvs[ 0 ] );
				 addUV( uvs[ 1 ] );
				 addUV( uvs[ 3 ] );

				 addUV( uvs[ 1 ] );
				 addUV( uvs[ 2 ] );
				 addUV( uvs[ 3 ] );

			 }

			 function addVertex( index ) {

				 verticesArray.push( placeholder[ index * 3 + 0 ] );
				 verticesArray.push( placeholder[ index * 3 + 1 ] );
				 verticesArray.push( placeholder[ index * 3 + 2 ] );

			 }


			 function addUV( vector2 ) {

				 uvArray.push( vector2.x );
				 uvArray.push( vector2.y );

			 }

		 }

	 }

	 toJSON() {

		 const data = super.toJSON();

		 const shapes = this.parameters.shapes;
		 const options = this.parameters.options;

		 return toJSON$1( shapes, options, data );

	 }

	 static fromJSON( data, shapes ) {

		 const geometryShapes = [];

		 for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			 const shape = shapes[ data.shapes[ j ] ];

			 geometryShapes.push( shape );

		 }

		 const extrudePath = data.options.extrudePath;

		 if ( extrudePath !== undefined ) {

			 data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

		 }

		 return new ExtrudeGeometry( geometryShapes, data.options );

	 }

 }

 const WorldUVGenerator = {

	 generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		 const a_x = vertices[ indexA * 3 ];
		 const a_y = vertices[ indexA * 3 + 1 ];
		 const b_x = vertices[ indexB * 3 ];
		 const b_y = vertices[ indexB * 3 + 1 ];
		 const c_x = vertices[ indexC * 3 ];
		 const c_y = vertices[ indexC * 3 + 1 ];

		 return [
			 new Vector2( a_x, a_y ),
			 new Vector2( b_x, b_y ),
			 new Vector2( c_x, c_y )
		 ];

	 },

	 generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		 const a_x = vertices[ indexA * 3 ];
		 const a_y = vertices[ indexA * 3 + 1 ];
		 const a_z = vertices[ indexA * 3 + 2 ];
		 const b_x = vertices[ indexB * 3 ];
		 const b_y = vertices[ indexB * 3 + 1 ];
		 const b_z = vertices[ indexB * 3 + 2 ];
		 const c_x = vertices[ indexC * 3 ];
		 const c_y = vertices[ indexC * 3 + 1 ];
		 const c_z = vertices[ indexC * 3 + 2 ];
		 const d_x = vertices[ indexD * 3 ];
		 const d_y = vertices[ indexD * 3 + 1 ];
		 const d_z = vertices[ indexD * 3 + 2 ];

		 if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			 return [
				 new Vector2( a_x, 1 - a_z ),
				 new Vector2( b_x, 1 - b_z ),
				 new Vector2( c_x, 1 - c_z ),
				 new Vector2( d_x, 1 - d_z )
			 ];

		 } else {

			 return [
				 new Vector2( a_y, 1 - a_z ),
				 new Vector2( b_y, 1 - b_z ),
				 new Vector2( c_y, 1 - c_z ),
				 new Vector2( d_y, 1 - d_z )
			 ];

		 }

	 }

 };

 function toJSON$1( shapes, options, data ) {

	 data.shapes = [];

	 if ( Array.isArray( shapes ) ) {

		 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			 const shape = shapes[ i ];

			 data.shapes.push( shape.uuid );

		 }

	 } else {

		 data.shapes.push( shapes.uuid );

	 }

	 if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	 return data;

 }

 class ShapeGeometry extends BufferGeometry {

	 constructor( shapes, curveSegments = 12 ) {

		 super();
		 this.type = 'ShapeGeometry';

		 this.parameters = {
			 shapes: shapes,
			 curveSegments: curveSegments
		 };

		 // buffers

		 const indices = [];
		 const vertices = [];
		 const normals = [];
		 const uvs = [];

		 // helper variables

		 let groupStart = 0;
		 let groupCount = 0;

		 // allow single and array values for "shapes" parameter

		 if ( Array.isArray( shapes ) === false ) {

			 addShape( shapes );

		 } else {

			 for ( let i = 0; i < shapes.length; i ++ ) {

				 addShape( shapes[ i ] );

				 this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				 groupStart += groupCount;
				 groupCount = 0;

			 }

		 }

		 // build geometry

		 this.setIndex( indices );
		 this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		 this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		 this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		 // helper functions

		 function addShape( shape ) {

			 const indexOffset = vertices.length / 3;
			 const points = shape.extractPoints( curveSegments );

			 let shapeVertices = points.shape;
			 const shapeHoles = points.holes;

			 // check direction of vertices

			 if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				 shapeVertices = shapeVertices.reverse();

			 }

			 for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				 const shapeHole = shapeHoles[ i ];

				 if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					 shapeHoles[ i ] = shapeHole.reverse();

				 }

			 }

			 const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			 // join vertices of inner and outer paths to a single array

			 for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				 const shapeHole = shapeHoles[ i ];
				 shapeVertices = shapeVertices.concat( shapeHole );

			 }

			 // vertices, normals, uvs

			 for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				 const vertex = shapeVertices[ i ];

				 vertices.push( vertex.x, vertex.y, 0 );
				 normals.push( 0, 0, 1 );
				 uvs.push( vertex.x, vertex.y ); // world uvs

			 }

			 // incides

			 for ( let i = 0, l = faces.length; i < l; i ++ ) {

				 const face = faces[ i ];

				 const a = face[ 0 ] + indexOffset;
				 const b = face[ 1 ] + indexOffset;
				 const c = face[ 2 ] + indexOffset;

				 indices.push( a, b, c );
				 groupCount += 3;

			 }

		 }

	 }

	 toJSON() {

		 const data = super.toJSON();

		 const shapes = this.parameters.shapes;

		 return toJSON( shapes, data );

	 }

	 static fromJSON( data, shapes ) {

		 const geometryShapes = [];

		 for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			 const shape = shapes[ data.shapes[ j ] ];

			 geometryShapes.push( shape );

		 }

		 return new ShapeGeometry( geometryShapes, data.curveSegments );

	 }

 }

 function toJSON( shapes, data ) {

	 data.shapes = [];

	 if ( Array.isArray( shapes ) ) {

		 for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			 const shape = shapes[ i ];

			 data.shapes.push( shape.uuid );

		 }

	 } else {

		 data.shapes.push( shapes.uuid );

	 }

	 return data;

 }

 /**
	* parameters = {
	*  color: <THREE.Color>
	* }
	*/

 class ShadowMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'ShadowMaterial';

		 this.color = new Color$1( 0x000000 );
		 this.transparent = true;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 return this;

	 }

 }

 ShadowMaterial.prototype.isShadowMaterial = true;

 class RawShaderMaterial extends ShaderMaterial {

	 constructor( parameters ) {

		 super( parameters );

		 this.type = 'RawShaderMaterial';

	 }

 }

 RawShaderMaterial.prototype.isRawShaderMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  roughness: <float>,
	*  metalness: <float>,
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  roughnessMap: new THREE.Texture( <Image> ),
	*
	*  metalnessMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  envMapIntensity: <float>
	*
	*  refractionRatio: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>,
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshStandardMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.defines = { 'STANDARD': '' };

		 this.type = 'MeshStandardMaterial';

		 this.color = new Color$1( 0xffffff ); // diffuse
		 this.roughness = 1.0;
		 this.metalness = 0.0;

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$1( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap;
		 this.normalScale = new Vector2( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.roughnessMap = null;

		 this.metalnessMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.envMapIntensity = 1.0;

		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.vertexTangents = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.defines = { 'STANDARD': '' };

		 this.color.copy( source.color );
		 this.roughness = source.roughness;
		 this.metalness = source.metalness;

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.roughnessMap = source.roughnessMap;

		 this.metalnessMap = source.metalnessMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.envMapIntensity = source.envMapIntensity;

		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 this.vertexTangents = source.vertexTangents;

		 return this;

	 }

 }

 MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

 /**
	* parameters = {
	*  clearcoat: <float>,
	*  clearcoatMap: new THREE.Texture( <Image> ),
	*  clearcoatRoughness: <float>,
	*  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	*  clearcoatNormalScale: <Vector2>,
	*  clearcoatNormalMap: new THREE.Texture( <Image> ),
	*
	*  reflectivity: <float>,
	*  ior: <float>,
	*
	*  sheen: <Color>,
	*
	*  transmission: <float>,
	*  transmissionMap: new THREE.Texture( <Image> ),
	*
	*  thickness: <float>,
	*  thicknessMap: new THREE.Texture( <Image> ),
	*  attenuationDistance: <float>,
	*  attenuationColor: <Color>
	* }
	*/

 class MeshPhysicalMaterial extends MeshStandardMaterial {

	 constructor( parameters ) {

		 super();

		 this.defines = {

			 'STANDARD': '',
			 'PHYSICAL': ''

		 };

		 this.type = 'MeshPhysicalMaterial';

		 this.clearcoat = 0.0;
		 this.clearcoatMap = null;
		 this.clearcoatRoughness = 0.0;
		 this.clearcoatRoughnessMap = null;
		 this.clearcoatNormalScale = new Vector2( 1, 1 );
		 this.clearcoatNormalMap = null;

		 this.reflectivity = 0.5; // maps to F0 = 0.04

		 Object.defineProperty( this, 'ior', {
			 get: function () {

				 return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

			 },
			 set: function ( ior ) {

				 this.reflectivity = clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

			 }
		 } );

		 this.sheen = null; // null will disable sheen bsdf

		 this.transmission = 0.0;
		 this.transmissionMap = null;

		 this.thickness = 0.01;
		 this.thicknessMap = null;
		 this.attenuationDistance = 0.0;
		 this.attenuationColor = new Color$1( 1, 1, 1 );

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.defines = {

			 'STANDARD': '',
			 'PHYSICAL': ''

		 };

		 this.clearcoat = source.clearcoat;
		 this.clearcoatMap = source.clearcoatMap;
		 this.clearcoatRoughness = source.clearcoatRoughness;
		 this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		 this.clearcoatNormalMap = source.clearcoatNormalMap;
		 this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		 this.reflectivity = source.reflectivity;

		 if ( source.sheen ) {

			 this.sheen = ( this.sheen || new Color$1() ).copy( source.sheen );

		 } else {

			 this.sheen = null;

		 }

		 this.transmission = source.transmission;
		 this.transmissionMap = source.transmissionMap;

		 this.thickness = source.thickness;
		 this.thicknessMap = source.thicknessMap;
		 this.attenuationDistance = source.attenuationDistance;
		 this.attenuationColor.copy( source.attenuationColor );

		 return this;

	 }

 }

 MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  specular: <hex>,
	*  shininess: <float>,
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  specularMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  combine: THREE.MultiplyOperation,
	*  reflectivity: <float>,
	*  refractionRatio: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>,
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshPhongMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshPhongMaterial';

		 this.color = new Color$1( 0xffffff ); // diffuse
		 this.specular = new Color$1( 0x111111 );
		 this.shininess = 30;

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$1( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap;
		 this.normalScale = new Vector2( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.specularMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.combine = MultiplyOperation;
		 this.reflectivity = 1;
		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );
		 this.specular.copy( source.specular );
		 this.shininess = source.shininess;

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.specularMap = source.specularMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.combine = source.combine;
		 this.reflectivity = source.reflectivity;
		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 return this;

	 }

 }

 MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*
	*  map: new THREE.Texture( <Image> ),
	*  gradientMap: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	* }
	*/

 class MeshToonMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.defines = { 'TOON': '' };

		 this.type = 'MeshToonMaterial';

		 this.color = new Color$1( 0xffffff );

		 this.map = null;
		 this.gradientMap = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$1( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap;
		 this.normalScale = new Vector2( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.alphaMap = null;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;
		 this.gradientMap = source.gradientMap;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.alphaMap = source.alphaMap;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 return this;

	 }

 }

 MeshToonMaterial.prototype.isMeshToonMaterial = true;

 /**
	* parameters = {
	*  opacity: <float>,
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>,
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshNormalMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshNormalMaterial';

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap;
		 this.normalScale = new Vector2( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;

		 this.fog = false;

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 return this;

	 }

 }

 MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  lightMap: new THREE.Texture( <Image> ),
	*  lightMapIntensity: <float>
	*
	*  aoMap: new THREE.Texture( <Image> ),
	*  aoMapIntensity: <float>
	*
	*  emissive: <hex>,
	*  emissiveIntensity: <float>
	*  emissiveMap: new THREE.Texture( <Image> ),
	*
	*  specularMap: new THREE.Texture( <Image> ),
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	*  combine: THREE.Multiply,
	*  reflectivity: <float>,
	*  refractionRatio: <float>,
	*
	*  wireframe: <boolean>,
	*  wireframeLinewidth: <float>,
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	* }
	*/

 class MeshLambertMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.type = 'MeshLambertMaterial';

		 this.color = new Color$1( 0xffffff ); // diffuse

		 this.map = null;

		 this.lightMap = null;
		 this.lightMapIntensity = 1.0;

		 this.aoMap = null;
		 this.aoMapIntensity = 1.0;

		 this.emissive = new Color$1( 0x000000 );
		 this.emissiveIntensity = 1.0;
		 this.emissiveMap = null;

		 this.specularMap = null;

		 this.alphaMap = null;

		 this.envMap = null;
		 this.combine = MultiplyOperation;
		 this.reflectivity = 1;
		 this.refractionRatio = 0.98;

		 this.wireframe = false;
		 this.wireframeLinewidth = 1;
		 this.wireframeLinecap = 'round';
		 this.wireframeLinejoin = 'round';

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );

		 this.map = source.map;

		 this.lightMap = source.lightMap;
		 this.lightMapIntensity = source.lightMapIntensity;

		 this.aoMap = source.aoMap;
		 this.aoMapIntensity = source.aoMapIntensity;

		 this.emissive.copy( source.emissive );
		 this.emissiveMap = source.emissiveMap;
		 this.emissiveIntensity = source.emissiveIntensity;

		 this.specularMap = source.specularMap;

		 this.alphaMap = source.alphaMap;

		 this.envMap = source.envMap;
		 this.combine = source.combine;
		 this.reflectivity = source.reflectivity;
		 this.refractionRatio = source.refractionRatio;

		 this.wireframe = source.wireframe;
		 this.wireframeLinewidth = source.wireframeLinewidth;
		 this.wireframeLinecap = source.wireframeLinecap;
		 this.wireframeLinejoin = source.wireframeLinejoin;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 return this;

	 }

 }

 MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  matcap: new THREE.Texture( <Image> ),
	*
	*  map: new THREE.Texture( <Image> ),
	*
	*  bumpMap: new THREE.Texture( <Image> ),
	*  bumpScale: <float>,
	*
	*  normalMap: new THREE.Texture( <Image> ),
	*  normalMapType: THREE.TangentSpaceNormalMap,
	*  normalScale: <Vector2>,
	*
	*  displacementMap: new THREE.Texture( <Image> ),
	*  displacementScale: <float>,
	*  displacementBias: <float>,
	*
	*  alphaMap: new THREE.Texture( <Image> ),
	*
	*  morphTargets: <bool>,
	*  morphNormals: <bool>
	*
	*  flatShading: <bool>
	* }
	*/

 class MeshMatcapMaterial extends Material {

	 constructor( parameters ) {

		 super();

		 this.defines = { 'MATCAP': '' };

		 this.type = 'MeshMatcapMaterial';

		 this.color = new Color$1( 0xffffff ); // diffuse

		 this.matcap = null;

		 this.map = null;

		 this.bumpMap = null;
		 this.bumpScale = 1;

		 this.normalMap = null;
		 this.normalMapType = TangentSpaceNormalMap;
		 this.normalScale = new Vector2( 1, 1 );

		 this.displacementMap = null;
		 this.displacementScale = 1;
		 this.displacementBias = 0;

		 this.alphaMap = null;

		 this.morphTargets = false;
		 this.morphNormals = false;

		 this.flatShading = false;

		 this.setValues( parameters );

	 }


	 copy( source ) {

		 super.copy( source );

		 this.defines = { 'MATCAP': '' };

		 this.color.copy( source.color );

		 this.matcap = source.matcap;

		 this.map = source.map;

		 this.bumpMap = source.bumpMap;
		 this.bumpScale = source.bumpScale;

		 this.normalMap = source.normalMap;
		 this.normalMapType = source.normalMapType;
		 this.normalScale.copy( source.normalScale );

		 this.displacementMap = source.displacementMap;
		 this.displacementScale = source.displacementScale;
		 this.displacementBias = source.displacementBias;

		 this.alphaMap = source.alphaMap;

		 this.morphTargets = source.morphTargets;
		 this.morphNormals = source.morphNormals;

		 this.flatShading = source.flatShading;

		 return this;

	 }

 }

 MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

 /**
	* parameters = {
	*  color: <hex>,
	*  opacity: <float>,
	*
	*  linewidth: <float>,
	*
	*  scale: <float>,
	*  dashSize: <float>,
	*  gapSize: <float>
	* }
	*/

 class LineDashedMaterial extends LineBasicMaterial {

	 constructor( parameters ) {

		 super();

		 this.type = 'LineDashedMaterial';

		 this.scale = 1;
		 this.dashSize = 3;
		 this.gapSize = 1;

		 this.setValues( parameters );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.scale = source.scale;
		 this.dashSize = source.dashSize;
		 this.gapSize = source.gapSize;

		 return this;

	 }

 }

 LineDashedMaterial.prototype.isLineDashedMaterial = true;

 const AnimationUtils = {

	 // same as Array.prototype.slice, but also works on typed arrays
	 arraySlice: function ( array, from, to ) {

		 if ( AnimationUtils.isTypedArray( array ) ) {

			 // in ios9 array.subarray(from, undefined) will return empty array
			 // but array.subarray(from) or array.subarray(from, len) is correct
			 return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		 }

		 return array.slice( from, to );

	 },

	 // converts an array to a specific type
	 convertArray: function ( array, type, forceClone ) {

		 if ( ! array || // let 'undefined' and 'null' pass
			 ! forceClone && array.constructor === type ) return array;

		 if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			 return new type( array ); // create typed array

		 }

		 return Array.prototype.slice.call( array ); // create Array

	 },

	 isTypedArray: function ( object ) {

		 return ArrayBuffer.isView( object ) &&
			 ! ( object instanceof DataView );

	 },

	 // returns an array by which times and values can be sorted
	 getKeyframeOrder: function ( times ) {

		 function compareTime( i, j ) {

			 return times[ i ] - times[ j ];

		 }

		 const n = times.length;
		 const result = new Array( n );
		 for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		 result.sort( compareTime );

		 return result;

	 },

	 // uses the array previously returned by 'getKeyframeOrder' to sort data
	 sortedArray: function ( values, stride, order ) {

		 const nValues = values.length;
		 const result = new values.constructor( nValues );

		 for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			 const srcOffset = order[ i ] * stride;

			 for ( let j = 0; j !== stride; ++ j ) {

				 result[ dstOffset ++ ] = values[ srcOffset + j ];

			 }

		 }

		 return result;

	 },

	 // function for parsing AOS keyframe formats
	 flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		 let i = 1, key = jsonKeys[ 0 ];

		 while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			 key = jsonKeys[ i ++ ];

		 }

		 if ( key === undefined ) return; // no data

		 let value = key[ valuePropertyName ];
		 if ( value === undefined ) return; // no data

		 if ( Array.isArray( value ) ) {

			 do {

				 value = key[ valuePropertyName ];

				 if ( value !== undefined ) {

					 times.push( key.time );
					 values.push.apply( values, value ); // push all elements

				 }

				 key = jsonKeys[ i ++ ];

			 } while ( key !== undefined );

		 } else if ( value.toArray !== undefined ) {

			 // ...assume THREE.Math-ish

			 do {

				 value = key[ valuePropertyName ];

				 if ( value !== undefined ) {

					 times.push( key.time );
					 value.toArray( values, values.length );

				 }

				 key = jsonKeys[ i ++ ];

			 } while ( key !== undefined );

		 } else {

			 // otherwise push as-is

			 do {

				 value = key[ valuePropertyName ];

				 if ( value !== undefined ) {

					 times.push( key.time );
					 values.push( value );

				 }

				 key = jsonKeys[ i ++ ];

			 } while ( key !== undefined );

		 }

	 },

	 subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		 const clip = sourceClip.clone();

		 clip.name = name;

		 const tracks = [];

		 for ( let i = 0; i < clip.tracks.length; ++ i ) {

			 const track = clip.tracks[ i ];
			 const valueSize = track.getValueSize();

			 const times = [];
			 const values = [];

			 for ( let j = 0; j < track.times.length; ++ j ) {

				 const frame = track.times[ j ] * fps;

				 if ( frame < startFrame || frame >= endFrame ) continue;

				 times.push( track.times[ j ] );

				 for ( let k = 0; k < valueSize; ++ k ) {

					 values.push( track.values[ j * valueSize + k ] );

				 }

			 }

			 if ( times.length === 0 ) continue;

			 track.times = AnimationUtils.convertArray( times, track.times.constructor );
			 track.values = AnimationUtils.convertArray( values, track.values.constructor );

			 tracks.push( track );

		 }

		 clip.tracks = tracks;

		 // find minimum .times value across all tracks in the trimmed clip

		 let minStartTime = Infinity;

		 for ( let i = 0; i < clip.tracks.length; ++ i ) {

			 if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				 minStartTime = clip.tracks[ i ].times[ 0 ];

			 }

		 }

		 // shift all tracks such that clip begins at t=0

		 for ( let i = 0; i < clip.tracks.length; ++ i ) {

			 clip.tracks[ i ].shift( - 1 * minStartTime );

		 }

		 clip.resetDuration();

		 return clip;

	 },

	 makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		 if ( fps <= 0 ) fps = 30;

		 const numTracks = referenceClip.tracks.length;
		 const referenceTime = referenceFrame / fps;

		 // Make each track's values relative to the values at the reference frame
		 for ( let i = 0; i < numTracks; ++ i ) {

			 const referenceTrack = referenceClip.tracks[ i ];
			 const referenceTrackType = referenceTrack.ValueTypeName;

			 // Skip this track if it's non-numeric
			 if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			 // Find the track in the target clip whose name and type matches the reference track
			 const targetTrack = targetClip.tracks.find( function ( track ) {

				 return track.name === referenceTrack.name
					 && track.ValueTypeName === referenceTrackType;

			 } );

			 if ( targetTrack === undefined ) continue;

			 let referenceOffset = 0;
			 const referenceValueSize = referenceTrack.getValueSize();

			 if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				 referenceOffset = referenceValueSize / 3;

			 }

			 let targetOffset = 0;
			 const targetValueSize = targetTrack.getValueSize();

			 if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				 targetOffset = targetValueSize / 3;

			 }

			 const lastIndex = referenceTrack.times.length - 1;
			 let referenceValue;

			 // Find the value to subtract out of the track
			 if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				 // Reference frame is earlier than the first keyframe, so just use the first keyframe
				 const startIndex = referenceOffset;
				 const endIndex = referenceValueSize - referenceOffset;
				 referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			 } else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				 // Reference frame is after the last keyframe, so just use the last keyframe
				 const startIndex = lastIndex * referenceValueSize + referenceOffset;
				 const endIndex = startIndex + referenceValueSize - referenceOffset;
				 referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			 } else {

				 // Interpolate to the reference value
				 const interpolant = referenceTrack.createInterpolant();
				 const startIndex = referenceOffset;
				 const endIndex = referenceValueSize - referenceOffset;
				 interpolant.evaluate( referenceTime );
				 referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			 }

			 // Conjugate the quaternion
			 if ( referenceTrackType === 'quaternion' ) {

				 const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				 referenceQuat.toArray( referenceValue );

			 }

			 // Subtract the reference value from all of the track values

			 const numTimes = targetTrack.times.length;
			 for ( let j = 0; j < numTimes; ++ j ) {

				 const valueStart = j * targetValueSize + targetOffset;

				 if ( referenceTrackType === 'quaternion' ) {

					 // Multiply the conjugate for quaternion track types
					 Quaternion.multiplyQuaternionsFlat(
						 targetTrack.values,
						 valueStart,
						 referenceValue,
						 0,
						 targetTrack.values,
						 valueStart
					 );

				 } else {

					 const valueEnd = targetValueSize - targetOffset * 2;

					 // Subtract each value for all other numeric track types
					 for ( let k = 0; k < valueEnd; ++ k ) {

						 targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					 }

				 }

			 }

		 }

		 targetClip.blendMode = AdditiveAnimationBlendMode;

		 return targetClip;

	 }

 };

 /**
	* Abstract base class of interpolants over parametric samples.
	*
	* The parameter domain is one dimensional, typically the time or a path
	* along a curve defined by the data.
	*
	* The sample values can have any dimensionality and derived classes may
	* apply special interpretations to the data.
	*
	* This class provides the interval seek in a Template Method, deferring
	* the actual interpolation to derived classes.
	*
	* Time complexity is O(1) for linear access crossing at most two points
	* and O(log N) for random access, where N is the number of positions.
	*
	* References:
	*
	* 		http://www.oodesign.com/template-method-pattern.html
	*
	*/

 class Interpolant {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 this.parameterPositions = parameterPositions;
		 this._cachedIndex = 0;

		 this.resultBuffer = resultBuffer !== undefined ?
			 resultBuffer : new sampleValues.constructor( sampleSize );
		 this.sampleValues = sampleValues;
		 this.valueSize = sampleSize;

		 this.settings = null;
		 this.DefaultSettings_ = {};

	 }

	 evaluate( t ) {

		 const pp = this.parameterPositions;
		 let i1 = this._cachedIndex,
			 t1 = pp[ i1 ],
			 t0 = pp[ i1 - 1 ];

		 validate_interval: {

			 seek: {

				 let right;

				 linear_scan: {

					 //- See http://jsperf.com/comparison-to-undefined/3
					 //- slower code:
					 //-
					 //- 				if ( t >= t1 || t1 === undefined ) {
					 forward_scan: if ( ! ( t < t1 ) ) {

						 for ( let giveUpAt = i1 + 2; ; ) {

							 if ( t1 === undefined ) {

								 if ( t < t0 ) break forward_scan;

								 // after end

								 i1 = pp.length;
								 this._cachedIndex = i1;
								 return this.afterEnd_( i1 - 1, t, t0 );

							 }

							 if ( i1 === giveUpAt ) break; // this loop

							 t0 = t1;
							 t1 = pp[ ++ i1 ];

							 if ( t < t1 ) {

								 // we have arrived at the sought interval
								 break seek;

							 }

						 }

						 // prepare binary search on the right side of the index
						 right = pp.length;
						 break linear_scan;

					 }

					 //- slower code:
					 //-					if ( t < t0 || t0 === undefined ) {
					 if ( ! ( t >= t0 ) ) {

						 // looping?

						 const t1global = pp[ 1 ];

						 if ( t < t1global ) {

							 i1 = 2; // + 1, using the scan for the details
							 t0 = t1global;

						 }

						 // linear reverse scan

						 for ( let giveUpAt = i1 - 2; ; ) {

							 if ( t0 === undefined ) {

								 // before start

								 this._cachedIndex = 0;
								 return this.beforeStart_( 0, t, t1 );

							 }

							 if ( i1 === giveUpAt ) break; // this loop

							 t1 = t0;
							 t0 = pp[ -- i1 - 1 ];

							 if ( t >= t0 ) {

								 // we have arrived at the sought interval
								 break seek;

							 }

						 }

						 // prepare binary search on the left side of the index
						 right = i1;
						 i1 = 0;
						 break linear_scan;

					 }

					 // the interval is valid

					 break validate_interval;

				 } // linear scan

				 // binary search

				 while ( i1 < right ) {

					 const mid = ( i1 + right ) >>> 1;

					 if ( t < pp[ mid ] ) {

						 right = mid;

					 } else {

						 i1 = mid + 1;

					 }

				 }

				 t1 = pp[ i1 ];
				 t0 = pp[ i1 - 1 ];

				 // check boundary cases, again

				 if ( t0 === undefined ) {

					 this._cachedIndex = 0;
					 return this.beforeStart_( 0, t, t1 );

				 }

				 if ( t1 === undefined ) {

					 i1 = pp.length;
					 this._cachedIndex = i1;
					 return this.afterEnd_( i1 - 1, t0, t );

				 }

			 } // seek

			 this._cachedIndex = i1;

			 this.intervalChanged_( i1, t0, t1 );

		 } // validate_interval

		 return this.interpolate_( i1, t0, t, t1 );

	 }

	 getSettings_() {

		 return this.settings || this.DefaultSettings_;

	 }

	 copySampleValue_( index ) {

		 // copies a sample value to the result buffer

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,
			 offset = index * stride;

		 for ( let i = 0; i !== stride; ++ i ) {

			 result[ i ] = values[ offset + i ];

		 }

		 return result;

	 }

	 // Template methods for derived classes:

	 interpolate_( /* i1, t0, t, t1 */ ) {

		 throw new Error( 'call to abstract method' );
		 // implementations shall return this.resultBuffer

	 }

	 intervalChanged_( /* i1, t0, t1 */ ) {

		 // empty

	 }

 }

 // ALIAS DEFINITIONS

 Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
 Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

 /**
	* Fast and simple cubic spline interpolant.
	*
	* It was derived from a Hermitian construction setting the first derivative
	* at each sample position to the linear slope between neighboring positions
	* over their parameter interval.
	*/

 class CubicInterpolant extends Interpolant {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		 this._weightPrev = - 0;
		 this._offsetPrev = - 0;
		 this._weightNext = - 0;
		 this._offsetNext = - 0;

		 this.DefaultSettings_ = {

			 endingStart: ZeroCurvatureEnding,
			 endingEnd: ZeroCurvatureEnding

		 };

	 }

	 intervalChanged_( i1, t0, t1 ) {

		 const pp = this.parameterPositions;
		 let iPrev = i1 - 2,
			 iNext = i1 + 1,

			 tPrev = pp[ iPrev ],
			 tNext = pp[ iNext ];

		 if ( tPrev === undefined ) {

			 switch ( this.getSettings_().endingStart ) {

				 case ZeroSlopeEnding:

					 // f'(t0) = 0
					 iPrev = i1;
					 tPrev = 2 * t0 - t1;

					 break;

				 case WrapAroundEnding:

					 // use the other end of the curve
					 iPrev = pp.length - 2;
					 tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					 break;

				 default: // ZeroCurvatureEnding

					 // f''(t0) = 0 a.k.a. Natural Spline
					 iPrev = i1;
					 tPrev = t1;

			 }

		 }

		 if ( tNext === undefined ) {

			 switch ( this.getSettings_().endingEnd ) {

				 case ZeroSlopeEnding:

					 // f'(tN) = 0
					 iNext = i1;
					 tNext = 2 * t1 - t0;

					 break;

				 case WrapAroundEnding:

					 // use the other end of the curve
					 iNext = 1;
					 tNext = t1 + pp[ 1 ] - pp[ 0 ];

					 break;

				 default: // ZeroCurvatureEnding

					 // f''(tN) = 0, a.k.a. Natural Spline
					 iNext = i1 - 1;
					 tNext = t0;

			 }

		 }

		 const halfDt = ( t1 - t0 ) * 0.5,
			 stride = this.valueSize;

		 this._weightPrev = halfDt / ( t0 - tPrev );
		 this._weightNext = halfDt / ( tNext - t1 );
		 this._offsetPrev = iPrev * stride;
		 this._offsetNext = iNext * stride;

	 }

	 interpolate_( i1, t0, t, t1 ) {

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,

			 o1 = i1 * stride,		o0 = o1 - stride,
			 oP = this._offsetPrev, 	oN = this._offsetNext,
			 wP = this._weightPrev,	wN = this._weightNext,

			 p = ( t - t0 ) / ( t1 - t0 ),
			 pp = p * p,
			 ppp = pp * p;

		 // evaluate polynomials

		 const sP = - wP * ppp + 2 * wP * pp - wP * p;
		 const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		 const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		 const sN = wN * ppp - wN * pp;

		 // combine data linearly

		 for ( let i = 0; i !== stride; ++ i ) {

			 result[ i ] =
					 sP * values[ oP + i ] +
					 s0 * values[ o0 + i ] +
					 s1 * values[ o1 + i ] +
					 sN * values[ oN + i ];

		 }

		 return result;

	 }

 }

 class LinearInterpolant extends Interpolant {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	 }

	 interpolate_( i1, t0, t, t1 ) {

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,

			 offset1 = i1 * stride,
			 offset0 = offset1 - stride,

			 weight1 = ( t - t0 ) / ( t1 - t0 ),
			 weight0 = 1 - weight1;

		 for ( let i = 0; i !== stride; ++ i ) {

			 result[ i ] =
					 values[ offset0 + i ] * weight0 +
					 values[ offset1 + i ] * weight1;

		 }

		 return result;

	 }

 }

 /**
	*
	* Interpolant that evaluates to the sample value at the position preceeding
	* the parameter.
	*/

 class DiscreteInterpolant extends Interpolant {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	 }

	 interpolate_( i1 /*, t0, t, t1 */ ) {

		 return this.copySampleValue_( i1 - 1 );

	 }

 }

 class KeyframeTrack {

	 constructor( name, times, values, interpolation ) {

		 if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		 if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		 this.name = name;

		 this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		 this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		 this.setInterpolation( interpolation || this.DefaultInterpolation );

	 }

	 // Serialization (in static context, because of constructor invocation
	 // and automatic invocation of .toJSON):

	 static toJSON( track ) {

		 const trackType = track.constructor;

		 let json;

		 // derived classes can define a static toJSON method
		 if ( trackType.toJSON !== this.toJSON ) {

			 json = trackType.toJSON( track );

		 } else {

			 // by default, we assume the data can be serialized as-is
			 json = {

				 'name': track.name,
				 'times': AnimationUtils.convertArray( track.times, Array ),
				 'values': AnimationUtils.convertArray( track.values, Array )

			 };

			 const interpolation = track.getInterpolation();

			 if ( interpolation !== track.DefaultInterpolation ) {

				 json.interpolation = interpolation;

			 }

		 }

		 json.type = track.ValueTypeName; // mandatory

		 return json;

	 }

	 InterpolantFactoryMethodDiscrete( result ) {

		 return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	 }

	 InterpolantFactoryMethodLinear( result ) {

		 return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	 }

	 InterpolantFactoryMethodSmooth( result ) {

		 return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	 }

	 setInterpolation( interpolation ) {

		 let factoryMethod;

		 switch ( interpolation ) {

			 case InterpolateDiscrete:

				 factoryMethod = this.InterpolantFactoryMethodDiscrete;

				 break;

			 case InterpolateLinear:

				 factoryMethod = this.InterpolantFactoryMethodLinear;

				 break;

			 case InterpolateSmooth:

				 factoryMethod = this.InterpolantFactoryMethodSmooth;

				 break;

		 }

		 if ( factoryMethod === undefined ) {

			 const message = 'unsupported interpolation for ' +
				 this.ValueTypeName + ' keyframe track named ' + this.name;

			 if ( this.createInterpolant === undefined ) {

				 // fall back to default, unless the default itself is messed up
				 if ( interpolation !== this.DefaultInterpolation ) {

					 this.setInterpolation( this.DefaultInterpolation );

				 } else {

					 throw new Error( message ); // fatal, in this case

				 }

			 }

			 console.warn( 'THREE.KeyframeTrack:', message );
			 return this;

		 }

		 this.createInterpolant = factoryMethod;

		 return this;

	 }

	 getInterpolation() {

		 switch ( this.createInterpolant ) {

			 case this.InterpolantFactoryMethodDiscrete:

				 return InterpolateDiscrete;

			 case this.InterpolantFactoryMethodLinear:

				 return InterpolateLinear;

			 case this.InterpolantFactoryMethodSmooth:

				 return InterpolateSmooth;

		 }

	 }

	 getValueSize() {

		 return this.values.length / this.times.length;

	 }

	 // move all keyframes either forwards or backwards in time
	 shift( timeOffset ) {

		 if ( timeOffset !== 0.0 ) {

			 const times = this.times;

			 for ( let i = 0, n = times.length; i !== n; ++ i ) {

				 times[ i ] += timeOffset;

			 }

		 }

		 return this;

	 }

	 // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	 scale( timeScale ) {

		 if ( timeScale !== 1.0 ) {

			 const times = this.times;

			 for ( let i = 0, n = times.length; i !== n; ++ i ) {

				 times[ i ] *= timeScale;

			 }

		 }

		 return this;

	 }

	 // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	 // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	 trim( startTime, endTime ) {

		 const times = this.times,
			 nKeys = times.length;

		 let from = 0,
			 to = nKeys - 1;

		 while ( from !== nKeys && times[ from ] < startTime ) {

			 ++ from;

		 }

		 while ( to !== - 1 && times[ to ] > endTime ) {

			 -- to;

		 }

		 ++ to; // inclusive -> exclusive bound

		 if ( from !== 0 || to !== nKeys ) {

			 // empty tracks are forbidden, so keep at least one keyframe
			 if ( from >= to ) {

				 to = Math.max( to, 1 );
				 from = to - 1;

			 }

			 const stride = this.getValueSize();
			 this.times = AnimationUtils.arraySlice( times, from, to );
			 this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		 }

		 return this;

	 }

	 // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	 validate() {

		 let valid = true;

		 const valueSize = this.getValueSize();
		 if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			 console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			 valid = false;

		 }

		 const times = this.times,
			 values = this.values,

			 nKeys = times.length;

		 if ( nKeys === 0 ) {

			 console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			 valid = false;

		 }

		 let prevTime = null;

		 for ( let i = 0; i !== nKeys; i ++ ) {

			 const currTime = times[ i ];

			 if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				 console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				 valid = false;
				 break;

			 }

			 if ( prevTime !== null && prevTime > currTime ) {

				 console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				 valid = false;
				 break;

			 }

			 prevTime = currTime;

		 }

		 if ( values !== undefined ) {

			 if ( AnimationUtils.isTypedArray( values ) ) {

				 for ( let i = 0, n = values.length; i !== n; ++ i ) {

					 const value = values[ i ];

					 if ( isNaN( value ) ) {

						 console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						 valid = false;
						 break;

					 }

				 }

			 }

		 }

		 return valid;

	 }

	 // removes equivalent sequential keys as common in morph target sequences
	 // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	 optimize() {

		 // times or values may be shared with other tracks, so overwriting is unsafe
		 const times = AnimationUtils.arraySlice( this.times ),
			 values = AnimationUtils.arraySlice( this.values ),
			 stride = this.getValueSize(),

			 smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			 lastIndex = times.length - 1;

		 let writeIndex = 1;

		 for ( let i = 1; i < lastIndex; ++ i ) {

			 let keep = false;

			 const time = times[ i ];
			 const timeNext = times[ i + 1 ];

			 // remove adjacent keyframes scheduled at the same time

			 if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				 if ( ! smoothInterpolation ) {

					 // remove unnecessary keyframes same as their neighbors

					 const offset = i * stride,
						 offsetP = offset - stride,
						 offsetN = offset + stride;

					 for ( let j = 0; j !== stride; ++ j ) {

						 const value = values[ offset + j ];

						 if ( value !== values[ offsetP + j ] ||
							 value !== values[ offsetN + j ] ) {

							 keep = true;
							 break;

						 }

					 }

				 } else {

					 keep = true;

				 }

			 }

			 // in-place compaction

			 if ( keep ) {

				 if ( i !== writeIndex ) {

					 times[ writeIndex ] = times[ i ];

					 const readOffset = i * stride,
						 writeOffset = writeIndex * stride;

					 for ( let j = 0; j !== stride; ++ j ) {

						 values[ writeOffset + j ] = values[ readOffset + j ];

					 }

				 }

				 ++ writeIndex;

			 }

		 }

		 // flush last keyframe (compaction looks ahead)

		 if ( lastIndex > 0 ) {

			 times[ writeIndex ] = times[ lastIndex ];

			 for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				 values[ writeOffset + j ] = values[ readOffset + j ];

			 }

			 ++ writeIndex;

		 }

		 if ( writeIndex !== times.length ) {

			 this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			 this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		 } else {

			 this.times = times;
			 this.values = values;

		 }

		 return this;

	 }

	 clone() {

		 const times = AnimationUtils.arraySlice( this.times, 0 );
		 const values = AnimationUtils.arraySlice( this.values, 0 );

		 const TypedKeyframeTrack = this.constructor;
		 const track = new TypedKeyframeTrack( this.name, times, values );

		 // Interpolant argument to constructor is not saved, so copy the factory method directly.
		 track.createInterpolant = this.createInterpolant;

		 return track;

	 }

 }

 KeyframeTrack.prototype.TimeBufferType = Float32Array;
 KeyframeTrack.prototype.ValueBufferType = Float32Array;
 KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

 /**
	* A Track of Boolean keyframe values.
	*/
 class BooleanKeyframeTrack extends KeyframeTrack {}

 BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
 BooleanKeyframeTrack.prototype.ValueBufferType = Array;
 BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
 BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
 BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

 /**
	* A Track of keyframe values that represent color.
	*/
 class ColorKeyframeTrack extends KeyframeTrack {}

 ColorKeyframeTrack.prototype.ValueTypeName = 'color';

 /**
	* A Track of numeric keyframe values.
	*/
 class NumberKeyframeTrack extends KeyframeTrack {}

 NumberKeyframeTrack.prototype.ValueTypeName = 'number';

 /**
	* Spherical linear unit quaternion interpolant.
	*/

 class QuaternionLinearInterpolant extends Interpolant {

	 constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		 super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	 }

	 interpolate_( i1, t0, t, t1 ) {

		 const result = this.resultBuffer,
			 values = this.sampleValues,
			 stride = this.valueSize,

			 alpha = ( t - t0 ) / ( t1 - t0 );

		 let offset = i1 * stride;

		 for ( let end = offset + stride; offset !== end; offset += 4 ) {

			 Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		 }

		 return result;

	 }

 }

 /**
	* A Track of quaternion keyframe values.
	*/
 class QuaternionKeyframeTrack extends KeyframeTrack {

	 InterpolantFactoryMethodLinear( result ) {

		 return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	 }

 }

 QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
 // ValueBufferType is inherited
 QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
 QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

 /**
	* A Track that interpolates Strings
	*/
 class StringKeyframeTrack extends KeyframeTrack {}

 StringKeyframeTrack.prototype.ValueTypeName = 'string';
 StringKeyframeTrack.prototype.ValueBufferType = Array;
 StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
 StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
 StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

 /**
	* A Track of vectored keyframe values.
	*/
 class VectorKeyframeTrack extends KeyframeTrack {}

 VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

 class AnimationClip {

	 constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		 this.name = name;
		 this.tracks = tracks;
		 this.duration = duration;
		 this.blendMode = blendMode;

		 this.uuid = generateUUID();

		 // this means it should figure out its duration by scanning the tracks
		 if ( this.duration < 0 ) {

			 this.resetDuration();

		 }

	 }


	 static parse( json ) {

		 const tracks = [],
			 jsonTracks = json.tracks,
			 frameTime = 1.0 / ( json.fps || 1.0 );

		 for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			 tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		 }

		 const clip = new this( json.name, json.duration, tracks, json.blendMode );
		 clip.uuid = json.uuid;

		 return clip;

	 }

	 static toJSON( clip ) {

		 const tracks = [],
			 clipTracks = clip.tracks;

		 const json = {

			 'name': clip.name,
			 'duration': clip.duration,
			 'tracks': tracks,
			 'uuid': clip.uuid,
			 'blendMode': clip.blendMode

		 };

		 for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			 tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		 }

		 return json;

	 }

	 static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		 const numMorphTargets = morphTargetSequence.length;
		 const tracks = [];

		 for ( let i = 0; i < numMorphTargets; i ++ ) {

			 let times = [];
			 let values = [];

			 times.push(
				 ( i + numMorphTargets - 1 ) % numMorphTargets,
				 i,
				 ( i + 1 ) % numMorphTargets );

			 values.push( 0, 1, 0 );

			 const order = AnimationUtils.getKeyframeOrder( times );
			 times = AnimationUtils.sortedArray( times, 1, order );
			 values = AnimationUtils.sortedArray( values, 1, order );

			 // if there is a key at the first frame, duplicate it as the
			 // last frame as well for perfect loop.
			 if ( ! noLoop && times[ 0 ] === 0 ) {

				 times.push( numMorphTargets );
				 values.push( values[ 0 ] );

			 }

			 tracks.push(
				 new NumberKeyframeTrack(
					 '.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					 times, values
				 ).scale( 1.0 / fps ) );

		 }

		 return new this( name, - 1, tracks );

	 }

	 static findByName( objectOrClipArray, name ) {

		 let clipArray = objectOrClipArray;

		 if ( ! Array.isArray( objectOrClipArray ) ) {

			 const o = objectOrClipArray;
			 clipArray = o.geometry && o.geometry.animations || o.animations;

		 }

		 for ( let i = 0; i < clipArray.length; i ++ ) {

			 if ( clipArray[ i ].name === name ) {

				 return clipArray[ i ];

			 }

		 }

		 return null;

	 }

	 static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		 const animationToMorphTargets = {};

		 // tested with https://regex101.com/ on trick sequences
		 // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		 const pattern = /^([\w-]*?)([\d]+)$/;

		 // sort morph target names into animation groups based
		 // patterns like Walk_001, Walk_002, Run_001, Run_002
		 for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			 const morphTarget = morphTargets[ i ];
			 const parts = morphTarget.name.match( pattern );

			 if ( parts && parts.length > 1 ) {

				 const name = parts[ 1 ];

				 let animationMorphTargets = animationToMorphTargets[ name ];

				 if ( ! animationMorphTargets ) {

					 animationToMorphTargets[ name ] = animationMorphTargets = [];

				 }

				 animationMorphTargets.push( morphTarget );

			 }

		 }

		 const clips = [];

		 for ( const name in animationToMorphTargets ) {

			 clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		 }

		 return clips;

	 }

	 // parse the animation.hierarchy format
	 static parseAnimation( animation, bones ) {

		 if ( ! animation ) {

			 console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			 return null;

		 }

		 const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			 // only return track if there are actually keys.
			 if ( animationKeys.length !== 0 ) {

				 const times = [];
				 const values = [];

				 AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				 // empty keys are filtered out, so check again
				 if ( times.length !== 0 ) {

					 destTracks.push( new trackType( trackName, times, values ) );

				 }

			 }

		 };

		 const tracks = [];

		 const clipName = animation.name || 'default';
		 const fps = animation.fps || 30;
		 const blendMode = animation.blendMode;

		 // automatic length determination in AnimationClip.
		 let duration = animation.length || - 1;

		 const hierarchyTracks = animation.hierarchy || [];

		 for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			 const animationKeys = hierarchyTracks[ h ].keys;

			 // skip empty tracks
			 if ( ! animationKeys || animationKeys.length === 0 ) continue;

			 // process morph targets
			 if ( animationKeys[ 0 ].morphTargets ) {

				 // figure out all morph targets used in this track
				 const morphTargetNames = {};

				 let k;

				 for ( k = 0; k < animationKeys.length; k ++ ) {

					 if ( animationKeys[ k ].morphTargets ) {

						 for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							 morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						 }

					 }

				 }

				 // create a track for each morph target with all zero
				 // morphTargetInfluences except for the keys in which
				 // the morphTarget is named.
				 for ( const morphTargetName in morphTargetNames ) {

					 const times = [];
					 const values = [];

					 for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						 const animationKey = animationKeys[ k ];

						 times.push( animationKey.time );
						 values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					 }

					 tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				 }

				 duration = morphTargetNames.length * ( fps || 1.0 );

			 } else {

				 // ...assume skeletal animation

				 const boneName = '.bones[' + bones[ h ].name + ']';

				 addNonemptyTrack(
					 VectorKeyframeTrack, boneName + '.position',
					 animationKeys, 'pos', tracks );

				 addNonemptyTrack(
					 QuaternionKeyframeTrack, boneName + '.quaternion',
					 animationKeys, 'rot', tracks );

				 addNonemptyTrack(
					 VectorKeyframeTrack, boneName + '.scale',
					 animationKeys, 'scl', tracks );

			 }

		 }

		 if ( tracks.length === 0 ) {

			 return null;

		 }

		 const clip = new this( clipName, duration, tracks, blendMode );

		 return clip;

	 }

	 resetDuration() {

		 const tracks = this.tracks;
		 let duration = 0;

		 for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			 const track = this.tracks[ i ];

			 duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		 }

		 this.duration = duration;

		 return this;

	 }

	 trim() {

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 this.tracks[ i ].trim( 0, this.duration );

		 }

		 return this;

	 }

	 validate() {

		 let valid = true;

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 valid = valid && this.tracks[ i ].validate();

		 }

		 return valid;

	 }

	 optimize() {

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 this.tracks[ i ].optimize();

		 }

		 return this;

	 }

	 clone() {

		 const tracks = [];

		 for ( let i = 0; i < this.tracks.length; i ++ ) {

			 tracks.push( this.tracks[ i ].clone() );

		 }

		 return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	 }

	 toJSON() {

		 return this.constructor.toJSON( this );

	 }

 }

 function getTrackTypeForValueTypeName( typeName ) {

	 switch ( typeName.toLowerCase() ) {

		 case 'scalar':
		 case 'double':
		 case 'float':
		 case 'number':
		 case 'integer':

			 return NumberKeyframeTrack;

		 case 'vector':
		 case 'vector2':
		 case 'vector3':
		 case 'vector4':

			 return VectorKeyframeTrack;

		 case 'color':

			 return ColorKeyframeTrack;

		 case 'quaternion':

			 return QuaternionKeyframeTrack;

		 case 'bool':
		 case 'boolean':

			 return BooleanKeyframeTrack;

		 case 'string':

			 return StringKeyframeTrack;

	 }

	 throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

 }

 function parseKeyframeTrack( json ) {

	 if ( json.type === undefined ) {

		 throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	 }

	 const trackType = getTrackTypeForValueTypeName( json.type );

	 if ( json.times === undefined ) {

		 const times = [], values = [];

		 AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		 json.times = times;
		 json.values = values;

	 }

	 // derived classes can define a static parse method
	 if ( trackType.parse !== undefined ) {

		 return trackType.parse( json );

	 } else {

		 // by default, we assume a constructor compatible with the base
		 return new trackType( json.name, json.times, json.values, json.interpolation );

	 }

 }

 const Cache = {

	 enabled: false,

	 files: {},

	 add: function ( key, file ) {

		 if ( this.enabled === false ) return;

		 // console.log( 'THREE.Cache', 'Adding key:', key );

		 this.files[ key ] = file;

	 },

	 get: function ( key ) {

		 if ( this.enabled === false ) return;

		 // console.log( 'THREE.Cache', 'Checking key:', key );

		 return this.files[ key ];

	 },

	 remove: function ( key ) {

		 delete this.files[ key ];

	 },

	 clear: function () {

		 this.files = {};

	 }

 };

 class LoadingManager {

	 constructor( onLoad, onProgress, onError ) {

		 const scope = this;

		 let isLoading = false;
		 let itemsLoaded = 0;
		 let itemsTotal = 0;
		 let urlModifier = undefined;
		 const handlers = [];

		 // Refer to #5689 for the reason why we don't set .onStart
		 // in the constructor

		 this.onStart = undefined;
		 this.onLoad = onLoad;
		 this.onProgress = onProgress;
		 this.onError = onError;

		 this.itemStart = function ( url ) {

			 itemsTotal ++;

			 if ( isLoading === false ) {

				 if ( scope.onStart !== undefined ) {

					 scope.onStart( url, itemsLoaded, itemsTotal );

				 }

			 }

			 isLoading = true;

		 };

		 this.itemEnd = function ( url ) {

			 itemsLoaded ++;

			 if ( scope.onProgress !== undefined ) {

				 scope.onProgress( url, itemsLoaded, itemsTotal );

			 }

			 if ( itemsLoaded === itemsTotal ) {

				 isLoading = false;

				 if ( scope.onLoad !== undefined ) {

					 scope.onLoad();

				 }

			 }

		 };

		 this.itemError = function ( url ) {

			 if ( scope.onError !== undefined ) {

				 scope.onError( url );

			 }

		 };

		 this.resolveURL = function ( url ) {

			 if ( urlModifier ) {

				 return urlModifier( url );

			 }

			 return url;

		 };

		 this.setURLModifier = function ( transform ) {

			 urlModifier = transform;

			 return this;

		 };

		 this.addHandler = function ( regex, loader ) {

			 handlers.push( regex, loader );

			 return this;

		 };

		 this.removeHandler = function ( regex ) {

			 const index = handlers.indexOf( regex );

			 if ( index !== - 1 ) {

				 handlers.splice( index, 2 );

			 }

			 return this;

		 };

		 this.getHandler = function ( file ) {

			 for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				 const regex = handlers[ i ];
				 const loader = handlers[ i + 1 ];

				 if ( regex.global ) regex.lastIndex = 0; // see #17920

				 if ( regex.test( file ) ) {

					 return loader;

				 }

			 }

			 return null;

		 };

	 }

 }

 const DefaultLoadingManager = new LoadingManager();

 class Loader {

	 constructor( manager ) {

		 this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		 this.crossOrigin = 'anonymous';
		 this.withCredentials = false;
		 this.path = '';
		 this.resourcePath = '';
		 this.requestHeader = {};

	 }

	 load( /* url, onLoad, onProgress, onError */ ) {}

	 loadAsync( url, onProgress ) {

		 const scope = this;

		 return new Promise( function ( resolve, reject ) {

			 scope.load( url, resolve, onProgress, reject );

		 } );

	 }

	 parse( /* data */ ) {}

	 setCrossOrigin( crossOrigin ) {

		 this.crossOrigin = crossOrigin;
		 return this;

	 }

	 setWithCredentials( value ) {

		 this.withCredentials = value;
		 return this;

	 }

	 setPath( path ) {

		 this.path = path;
		 return this;

	 }

	 setResourcePath( resourcePath ) {

		 this.resourcePath = resourcePath;
		 return this;

	 }

	 setRequestHeader( requestHeader ) {

		 this.requestHeader = requestHeader;
		 return this;

	 }

 }

 const loading = {};

 class FileLoader extends Loader {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 if ( url === undefined ) url = '';

		 if ( this.path !== undefined ) url = this.path + url;

		 url = this.manager.resolveURL( url );

		 const scope = this;

		 const cached = Cache.get( url );

		 if ( cached !== undefined ) {

			 scope.manager.itemStart( url );

			 setTimeout( function () {

				 if ( onLoad ) onLoad( cached );

				 scope.manager.itemEnd( url );

			 }, 0 );

			 return cached;

		 }

		 // Check if request is duplicate

		 if ( loading[ url ] !== undefined ) {

			 loading[ url ].push( {

				 onLoad: onLoad,
				 onProgress: onProgress,
				 onError: onError

			 } );

			 return;

		 }

		 // Check for data: URI
		 const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		 const dataUriRegexResult = url.match( dataUriRegex );
		 let request;

		 // Safari can not handle Data URIs through XMLHttpRequest so process manually
		 if ( dataUriRegexResult ) {

			 const mimeType = dataUriRegexResult[ 1 ];
			 const isBase64 = !! dataUriRegexResult[ 2 ];

			 let data = dataUriRegexResult[ 3 ];
			 data = decodeURIComponent( data );

			 if ( isBase64 ) data = atob( data );

			 try {

				 let response;
				 const responseType = ( this.responseType || '' ).toLowerCase();

				 switch ( responseType ) {

					 case 'arraybuffer':
					 case 'blob':

						 const view = new Uint8Array( data.length );

						 for ( let i = 0; i < data.length; i ++ ) {

							 view[ i ] = data.charCodeAt( i );

						 }

						 if ( responseType === 'blob' ) {

							 response = new Blob( [ view.buffer ], { type: mimeType } );

						 } else {

							 response = view.buffer;

						 }

						 break;

					 case 'document':

						 const parser = new DOMParser();
						 response = parser.parseFromString( data, mimeType );

						 break;

					 case 'json':

						 response = JSON.parse( data );

						 break;

					 default: // 'text' or other

						 response = data;

						 break;

				 }

				 // Wait for next browser tick like standard XMLHttpRequest event dispatching does
				 setTimeout( function () {

					 if ( onLoad ) onLoad( response );

					 scope.manager.itemEnd( url );

				 }, 0 );

			 } catch ( error ) {

				 // Wait for next browser tick like standard XMLHttpRequest event dispatching does
				 setTimeout( function () {

					 if ( onError ) onError( error );

					 scope.manager.itemError( url );
					 scope.manager.itemEnd( url );

				 }, 0 );

			 }

		 } else {

			 // Initialise array for duplicate requests

			 loading[ url ] = [];

			 loading[ url ].push( {

				 onLoad: onLoad,
				 onProgress: onProgress,
				 onError: onError

			 } );

			 request = new XMLHttpRequest();

			 request.open( 'GET', url, true );

			 request.addEventListener( 'load', function ( event ) {

				 const response = this.response;

				 const callbacks = loading[ url ];

				 delete loading[ url ];

				 if ( this.status === 200 || this.status === 0 ) {

					 // Some browsers return HTTP Status 0 when using non-http protocol
					 // e.g. 'file://' or 'data://'. Handle as success.

					 if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					 // Add to cache only on HTTP success, so that we do not cache
					 // error response bodies as proper responses to requests.
					 Cache.add( url, response );

					 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						 const callback = callbacks[ i ];
						 if ( callback.onLoad ) callback.onLoad( response );

					 }

					 scope.manager.itemEnd( url );

				 } else {

					 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						 const callback = callbacks[ i ];
						 if ( callback.onError ) callback.onError( event );

					 }

					 scope.manager.itemError( url );
					 scope.manager.itemEnd( url );

				 }

			 }, false );

			 request.addEventListener( 'progress', function ( event ) {

				 const callbacks = loading[ url ];

				 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					 const callback = callbacks[ i ];
					 if ( callback.onProgress ) callback.onProgress( event );

				 }

			 }, false );

			 request.addEventListener( 'error', function ( event ) {

				 const callbacks = loading[ url ];

				 delete loading[ url ];

				 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					 const callback = callbacks[ i ];
					 if ( callback.onError ) callback.onError( event );

				 }

				 scope.manager.itemError( url );
				 scope.manager.itemEnd( url );

			 }, false );

			 request.addEventListener( 'abort', function ( event ) {

				 const callbacks = loading[ url ];

				 delete loading[ url ];

				 for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					 const callback = callbacks[ i ];
					 if ( callback.onError ) callback.onError( event );

				 }

				 scope.manager.itemError( url );
				 scope.manager.itemEnd( url );

			 }, false );

			 if ( this.responseType !== undefined ) request.responseType = this.responseType;
			 if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			 if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			 for ( const header in this.requestHeader ) {

				 request.setRequestHeader( header, this.requestHeader[ header ] );

			 }

			 request.send( null );

		 }

		 scope.manager.itemStart( url );

		 return request;

	 }

	 setResponseType( value ) {

		 this.responseType = value;
		 return this;

	 }

	 setMimeType( value ) {

		 this.mimeType = value;
		 return this;

	 }

 }

 class ImageLoader extends Loader {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 if ( this.path !== undefined ) url = this.path + url;

		 url = this.manager.resolveURL( url );

		 const scope = this;

		 const cached = Cache.get( url );

		 if ( cached !== undefined ) {

			 scope.manager.itemStart( url );

			 setTimeout( function () {

				 if ( onLoad ) onLoad( cached );

				 scope.manager.itemEnd( url );

			 }, 0 );

			 return cached;

		 }

		 const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		 function onImageLoad() {

			 image.removeEventListener( 'load', onImageLoad, false );
			 image.removeEventListener( 'error', onImageError, false );

			 Cache.add( url, this );

			 if ( onLoad ) onLoad( this );

			 scope.manager.itemEnd( url );

		 }

		 function onImageError( event ) {

			 image.removeEventListener( 'load', onImageLoad, false );
			 image.removeEventListener( 'error', onImageError, false );

			 if ( onError ) onError( event );

			 scope.manager.itemError( url );
			 scope.manager.itemEnd( url );

		 }

		 image.addEventListener( 'load', onImageLoad, false );
		 image.addEventListener( 'error', onImageError, false );

		 if ( url.substr( 0, 5 ) !== 'data:' ) {

			 if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		 }

		 scope.manager.itemStart( url );

		 image.src = url;

		 return image;

	 }

 }

 class CubeTextureLoader extends Loader {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( urls, onLoad, onProgress, onError ) {

		 const texture = new CubeTexture();

		 const loader = new ImageLoader( this.manager );
		 loader.setCrossOrigin( this.crossOrigin );
		 loader.setPath( this.path );

		 let loaded = 0;

		 function loadTexture( i ) {

			 loader.load( urls[ i ], function ( image ) {

				 texture.images[ i ] = image;

				 loaded ++;

				 if ( loaded === 6 ) {

					 texture.needsUpdate = true;

					 if ( onLoad ) onLoad( texture );

				 }

			 }, undefined, onError );

		 }

		 for ( let i = 0; i < urls.length; ++ i ) {

			 loadTexture( i );

		 }

		 return texture;

	 }

 }

 class TextureLoader extends Loader {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 const texture = new Texture();

		 const loader = new ImageLoader( this.manager );
		 loader.setCrossOrigin( this.crossOrigin );
		 loader.setPath( this.path );

		 loader.load( url, function ( image ) {

			 texture.image = image;

			 // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			 const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			 texture.format = isJPEG ? RGBFormat : RGBAFormat;
			 texture.needsUpdate = true;

			 if ( onLoad !== undefined ) {

				 onLoad( texture );

			 }

		 }, onProgress, onError );

		 return texture;

	 }

 }

 /**************************************************************
	*	Curved Path - a curve path is simply a array of connected
	*  curves, but retains the api of a curve
	**************************************************************/

 class CurvePath extends Curve {

	 constructor() {

		 super();

		 this.type = 'CurvePath';

		 this.curves = [];
		 this.autoClose = false; // Automatically closes the path

	 }

	 add( curve ) {

		 this.curves.push( curve );

	 }

	 closePath() {

		 // Add a line curve if start and end of lines are not connected
		 const startPoint = this.curves[ 0 ].getPoint( 0 );
		 const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		 if ( ! startPoint.equals( endPoint ) ) {

			 this.curves.push( new LineCurve( endPoint, startPoint ) );

		 }

	 }

	 // To get accurate point with reference to
	 // entire path distance at time t,
	 // following has to be done:

	 // 1. Length of each sub path have to be known
	 // 2. Locate and identify type of curve
	 // 3. Get t for the curve
	 // 4. Return curve.getPointAt(t')

	 getPoint( t ) {

		 const d = t * this.getLength();
		 const curveLengths = this.getCurveLengths();
		 let i = 0;

		 // To think about boundaries points.

		 while ( i < curveLengths.length ) {

			 if ( curveLengths[ i ] >= d ) {

				 const diff = curveLengths[ i ] - d;
				 const curve = this.curves[ i ];

				 const segmentLength = curve.getLength();
				 const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				 return curve.getPointAt( u );

			 }

			 i ++;

		 }

		 return null;

		 // loop where sum != 0, sum > d , sum+1 <d

	 }

	 // We cannot use the default THREE.Curve getPoint() with getLength() because in
	 // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	 // getPoint() depends on getLength

	 getLength() {

		 const lens = this.getCurveLengths();
		 return lens[ lens.length - 1 ];

	 }

	 // cacheLengths must be recalculated.
	 updateArcLengths() {

		 this.needsUpdate = true;
		 this.cacheLengths = null;
		 this.getCurveLengths();

	 }

	 // Compute lengths and cache them
	 // We cannot overwrite getLengths() because UtoT mapping uses it.

	 getCurveLengths() {

		 // We use cache values if curves and cache array are same length

		 if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			 return this.cacheLengths;

		 }

		 // Get length of sub-curve
		 // Push sums into cached array

		 const lengths = [];
		 let sums = 0;

		 for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			 sums += this.curves[ i ].getLength();
			 lengths.push( sums );

		 }

		 this.cacheLengths = lengths;

		 return lengths;

	 }

	 getSpacedPoints( divisions = 40 ) {

		 const points = [];

		 for ( let i = 0; i <= divisions; i ++ ) {

			 points.push( this.getPoint( i / divisions ) );

		 }

		 if ( this.autoClose ) {

			 points.push( points[ 0 ] );

		 }

		 return points;

	 }

	 getPoints( divisions = 12 ) {

		 const points = [];
		 let last;

		 for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			 const curve = curves[ i ];
			 const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				 : ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					 : ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						 : divisions;

			 const pts = curve.getPoints( resolution );

			 for ( let j = 0; j < pts.length; j ++ ) {

				 const point = pts[ j ];

				 if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				 points.push( point );
				 last = point;

			 }

		 }

		 if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			 points.push( points[ 0 ] );

		 }

		 return points;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.curves = [];

		 for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			 const curve = source.curves[ i ];

			 this.curves.push( curve.clone() );

		 }

		 this.autoClose = source.autoClose;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.autoClose = this.autoClose;
		 data.curves = [];

		 for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			 const curve = this.curves[ i ];
			 data.curves.push( curve.toJSON() );

		 }

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.autoClose = json.autoClose;
		 this.curves = [];

		 for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			 const curve = json.curves[ i ];
			 this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		 }

		 return this;

	 }

 }

 class Path extends CurvePath {

	 constructor( points ) {

		 super();
		 this.type = 'Path';

		 this.currentPoint = new Vector2();

		 if ( points ) {

			 this.setFromPoints( points );

		 }

	 }

	 setFromPoints( points ) {

		 this.moveTo( points[ 0 ].x, points[ 0 ].y );

		 for ( let i = 1, l = points.length; i < l; i ++ ) {

			 this.lineTo( points[ i ].x, points[ i ].y );

		 }

		 return this;

	 }

	 moveTo( x, y ) {

		 this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		 return this;

	 }

	 lineTo( x, y ) {

		 const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		 this.curves.push( curve );

		 this.currentPoint.set( x, y );

		 return this;

	 }

	 quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		 const curve = new QuadraticBezierCurve(
			 this.currentPoint.clone(),
			 new Vector2( aCPx, aCPy ),
			 new Vector2( aX, aY )
		 );

		 this.curves.push( curve );

		 this.currentPoint.set( aX, aY );

		 return this;

	 }

	 bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		 const curve = new CubicBezierCurve(
			 this.currentPoint.clone(),
			 new Vector2( aCP1x, aCP1y ),
			 new Vector2( aCP2x, aCP2y ),
			 new Vector2( aX, aY )
		 );

		 this.curves.push( curve );

		 this.currentPoint.set( aX, aY );

		 return this;

	 }

	 splineThru( pts /*Array of Vector*/ ) {

		 const npts = [ this.currentPoint.clone() ].concat( pts );

		 const curve = new SplineCurve( npts );
		 this.curves.push( curve );

		 this.currentPoint.copy( pts[ pts.length - 1 ] );

		 return this;

	 }

	 arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		 const x0 = this.currentPoint.x;
		 const y0 = this.currentPoint.y;

		 this.absarc( aX + x0, aY + y0, aRadius,
			 aStartAngle, aEndAngle, aClockwise );

		 return this;

	 }

	 absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		 this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		 return this;

	 }

	 ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		 const x0 = this.currentPoint.x;
		 const y0 = this.currentPoint.y;

		 this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		 return this;

	 }

	 absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		 const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		 if ( this.curves.length > 0 ) {

			 // if a previous curve is present, attempt to join
			 const firstPoint = curve.getPoint( 0 );

			 if ( ! firstPoint.equals( this.currentPoint ) ) {

				 this.lineTo( firstPoint.x, firstPoint.y );

			 }

		 }

		 this.curves.push( curve );

		 const lastPoint = curve.getPoint( 1 );
		 this.currentPoint.copy( lastPoint );

		 return this;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.currentPoint.copy( source.currentPoint );

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.currentPoint = this.currentPoint.toArray();

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.currentPoint.fromArray( json.currentPoint );

		 return this;

	 }

 }

 class Shape extends Path {

	 constructor( points ) {

		 super( points );

		 this.uuid = generateUUID();

		 this.type = 'Shape';

		 this.holes = [];

	 }

	 getPointsHoles( divisions ) {

		 const holesPts = [];

		 for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			 holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		 }

		 return holesPts;

	 }

	 // get points of shape and holes (keypoints based on segments parameter)

	 extractPoints( divisions ) {

		 return {

			 shape: this.getPoints( divisions ),
			 holes: this.getPointsHoles( divisions )

		 };

	 }

	 copy( source ) {

		 super.copy( source );

		 this.holes = [];

		 for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			 const hole = source.holes[ i ];

			 this.holes.push( hole.clone() );

		 }

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.uuid = this.uuid;
		 data.holes = [];

		 for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			 const hole = this.holes[ i ];
			 data.holes.push( hole.toJSON() );

		 }

		 return data;

	 }

	 fromJSON( json ) {

		 super.fromJSON( json );

		 this.uuid = json.uuid;
		 this.holes = [];

		 for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			 const hole = json.holes[ i ];
			 this.holes.push( new Path().fromJSON( hole ) );

		 }

		 return this;

	 }

 }

 class Light extends Object3D {

	 constructor( color, intensity = 1 ) {

		 super();

		 this.type = 'Light';

		 this.color = new Color$1( color );
		 this.intensity = intensity;

	 }

	 dispose() {

		 // Empty here in base class; some subclasses override.

	 }

	 copy( source ) {

		 super.copy( source );

		 this.color.copy( source.color );
		 this.intensity = source.intensity;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.color = this.color.getHex();
		 data.object.intensity = this.intensity;

		 if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		 if ( this.distance !== undefined ) data.object.distance = this.distance;
		 if ( this.angle !== undefined ) data.object.angle = this.angle;
		 if ( this.decay !== undefined ) data.object.decay = this.decay;
		 if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		 if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		 return data;

	 }

 }

 Light.prototype.isLight = true;

 class HemisphereLight extends Light {

	 constructor( skyColor, groundColor, intensity ) {

		 super( skyColor, intensity );

		 this.type = 'HemisphereLight';

		 this.position.copy( Object3D.DefaultUp );
		 this.updateMatrix();

		 this.groundColor = new Color$1( groundColor );

	 }

	 copy( source ) {

		 Light.prototype.copy.call( this, source );

		 this.groundColor.copy( source.groundColor );

		 return this;

	 }

 }

 HemisphereLight.prototype.isHemisphereLight = true;

 const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
 const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
 const _lookTarget$1 = /*@__PURE__*/ new Vector3();

 class LightShadow {

	 constructor( camera ) {

		 this.camera = camera;

		 this.bias = 0;
		 this.normalBias = 0;
		 this.radius = 1;

		 this.mapSize = new Vector2( 512, 512 );

		 this.map = null;
		 this.mapPass = null;
		 this.matrix = new Matrix4();

		 this.autoUpdate = true;
		 this.needsUpdate = false;

		 this._frustum = new Frustum();
		 this._frameExtents = new Vector2( 1, 1 );

		 this._viewportCount = 1;

		 this._viewports = [

			 new Vector4( 0, 0, 1, 1 )

		 ];

	 }

	 getViewportCount() {

		 return this._viewportCount;

	 }

	 getFrustum() {

		 return this._frustum;

	 }

	 updateMatrices( light ) {

		 const shadowCamera = this.camera;
		 const shadowMatrix = this.matrix;

		 _lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		 shadowCamera.position.copy( _lightPositionWorld$1 );

		 _lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		 shadowCamera.lookAt( _lookTarget$1 );
		 shadowCamera.updateMatrixWorld();

		 _projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		 this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		 shadowMatrix.set(
			 0.5, 0.0, 0.0, 0.5,
			 0.0, 0.5, 0.0, 0.5,
			 0.0, 0.0, 0.5, 0.5,
			 0.0, 0.0, 0.0, 1.0
		 );

		 shadowMatrix.multiply( shadowCamera.projectionMatrix );
		 shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	 }

	 getViewport( viewportIndex ) {

		 return this._viewports[ viewportIndex ];

	 }

	 getFrameExtents() {

		 return this._frameExtents;

	 }

	 dispose() {

		 if ( this.map ) {

			 this.map.dispose();

		 }

		 if ( this.mapPass ) {

			 this.mapPass.dispose();

		 }

	 }

	 copy( source ) {

		 this.camera = source.camera.clone();

		 this.bias = source.bias;
		 this.radius = source.radius;

		 this.mapSize.copy( source.mapSize );

		 return this;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 toJSON() {

		 const object = {};

		 if ( this.bias !== 0 ) object.bias = this.bias;
		 if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		 if ( this.radius !== 1 ) object.radius = this.radius;
		 if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		 object.camera = this.camera.toJSON( false ).object;
		 delete object.camera.matrix;

		 return object;

	 }

 }

 class SpotLightShadow extends LightShadow {

	 constructor() {

		 super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		 this.focus = 1;

	 }

	 updateMatrices( light ) {

		 const camera = this.camera;

		 const fov = RAD2DEG * 2 * light.angle * this.focus;
		 const aspect = this.mapSize.width / this.mapSize.height;
		 const far = light.distance || camera.far;

		 if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			 camera.fov = fov;
			 camera.aspect = aspect;
			 camera.far = far;
			 camera.updateProjectionMatrix();

		 }

		 super.updateMatrices( light );

	 }

	 copy( source ) {

		 super.copy( source );

		 this.focus = source.focus;

		 return this;

	 }

 }

 SpotLightShadow.prototype.isSpotLightShadow = true;

 class SpotLight extends Light {

	 constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		 super( color, intensity );

		 this.type = 'SpotLight';

		 this.position.copy( Object3D.DefaultUp );
		 this.updateMatrix();

		 this.target = new Object3D();

		 this.distance = distance;
		 this.angle = angle;
		 this.penumbra = penumbra;
		 this.decay = decay; // for physically correct lights, should be 2.

		 this.shadow = new SpotLightShadow();

	 }

	 get power() {

		 // intensity = power per solid angle.
		 // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 return this.intensity * Math.PI;

	 }

	 set power( power ) {

		 // intensity = power per solid angle.
		 // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 this.intensity = power / Math.PI;

	 }

	 dispose() {

		 this.shadow.dispose();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.distance = source.distance;
		 this.angle = source.angle;
		 this.penumbra = source.penumbra;
		 this.decay = source.decay;

		 this.target = source.target.clone();

		 this.shadow = source.shadow.clone();

		 return this;

	 }

 }

 SpotLight.prototype.isSpotLight = true;

 const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
 const _lightPositionWorld = /*@__PURE__*/ new Vector3();
 const _lookTarget = /*@__PURE__*/ new Vector3();

 class PointLightShadow extends LightShadow {

	 constructor() {

		 super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		 this._frameExtents = new Vector2( 4, 2 );

		 this._viewportCount = 6;

		 this._viewports = [
			 // These viewports map a cube-map onto a 2D texture with the
			 // following orientation:
			 //
			 //  xzXZ
			 //   y Y
			 //
			 // X - Positive x direction
			 // x - Negative x direction
			 // Y - Positive y direction
			 // y - Negative y direction
			 // Z - Positive z direction
			 // z - Negative z direction

			 // positive X
			 new Vector4( 2, 1, 1, 1 ),
			 // negative X
			 new Vector4( 0, 1, 1, 1 ),
			 // positive Z
			 new Vector4( 3, 1, 1, 1 ),
			 // negative Z
			 new Vector4( 1, 1, 1, 1 ),
			 // positive Y
			 new Vector4( 3, 0, 1, 1 ),
			 // negative Y
			 new Vector4( 1, 0, 1, 1 )
		 ];

		 this._cubeDirections = [
			 new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			 new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		 ];

		 this._cubeUps = [
			 new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			 new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		 ];

	 }

	 updateMatrices( light, viewportIndex = 0 ) {

		 const camera = this.camera;
		 const shadowMatrix = this.matrix;

		 const far = light.distance || camera.far;

		 if ( far !== camera.far ) {

			 camera.far = far;
			 camera.updateProjectionMatrix();

		 }

		 _lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		 camera.position.copy( _lightPositionWorld );

		 _lookTarget.copy( camera.position );
		 _lookTarget.add( this._cubeDirections[ viewportIndex ] );
		 camera.up.copy( this._cubeUps[ viewportIndex ] );
		 camera.lookAt( _lookTarget );
		 camera.updateMatrixWorld();

		 shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		 _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		 this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	 }

 }

 PointLightShadow.prototype.isPointLightShadow = true;

 class PointLight extends Light {

	 constructor( color, intensity, distance = 0, decay = 1 ) {

		 super( color, intensity );

		 this.type = 'PointLight';

		 this.distance = distance;
		 this.decay = decay; // for physically correct lights, should be 2.

		 this.shadow = new PointLightShadow();

	 }

	 get power() {

		 // intensity = power per solid angle.
		 // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 return this.intensity * 4 * Math.PI;

	 }

	 set power( power ) {

		 // intensity = power per solid angle.
		 // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		 this.intensity = power / ( 4 * Math.PI );

	 }

	 dispose() {

		 this.shadow.dispose();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.distance = source.distance;
		 this.decay = source.decay;

		 this.shadow = source.shadow.clone();

		 return this;

	 }

 }

 PointLight.prototype.isPointLight = true;

 class OrthographicCamera extends Camera {

	 constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		 super();

		 this.type = 'OrthographicCamera';

		 this.zoom = 1;
		 this.view = null;

		 this.left = left;
		 this.right = right;
		 this.top = top;
		 this.bottom = bottom;

		 this.near = near;
		 this.far = far;

		 this.updateProjectionMatrix();

	 }

	 copy( source, recursive ) {

		 super.copy( source, recursive );

		 this.left = source.left;
		 this.right = source.right;
		 this.top = source.top;
		 this.bottom = source.bottom;
		 this.near = source.near;
		 this.far = source.far;

		 this.zoom = source.zoom;
		 this.view = source.view === null ? null : Object.assign( {}, source.view );

		 return this;

	 }

	 setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		 if ( this.view === null ) {

			 this.view = {
				 enabled: true,
				 fullWidth: 1,
				 fullHeight: 1,
				 offsetX: 0,
				 offsetY: 0,
				 width: 1,
				 height: 1
			 };

		 }

		 this.view.enabled = true;
		 this.view.fullWidth = fullWidth;
		 this.view.fullHeight = fullHeight;
		 this.view.offsetX = x;
		 this.view.offsetY = y;
		 this.view.width = width;
		 this.view.height = height;

		 this.updateProjectionMatrix();

	 }

	 clearViewOffset() {

		 if ( this.view !== null ) {

			 this.view.enabled = false;

		 }

		 this.updateProjectionMatrix();

	 }

	 updateProjectionMatrix() {

		 const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		 const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		 const cx = ( this.right + this.left ) / 2;
		 const cy = ( this.top + this.bottom ) / 2;

		 let left = cx - dx;
		 let right = cx + dx;
		 let top = cy + dy;
		 let bottom = cy - dy;

		 if ( this.view !== null && this.view.enabled ) {

			 const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			 const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			 left += scaleW * this.view.offsetX;
			 right = left + scaleW * this.view.width;
			 top -= scaleH * this.view.offsetY;
			 bottom = top - scaleH * this.view.height;

		 }

		 this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		 this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.zoom = this.zoom;
		 data.object.left = this.left;
		 data.object.right = this.right;
		 data.object.top = this.top;
		 data.object.bottom = this.bottom;
		 data.object.near = this.near;
		 data.object.far = this.far;

		 if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		 return data;

	 }

 }

 OrthographicCamera.prototype.isOrthographicCamera = true;

 class DirectionalLightShadow extends LightShadow {

	 constructor() {

		 super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	 }

 }

 DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

 class DirectionalLight extends Light {

	 constructor( color, intensity ) {

		 super( color, intensity );

		 this.type = 'DirectionalLight';

		 this.position.copy( Object3D.DefaultUp );
		 this.updateMatrix();

		 this.target = new Object3D();

		 this.shadow = new DirectionalLightShadow();

	 }

	 dispose() {

		 this.shadow.dispose();

	 }

	 copy( source ) {

		 super.copy( source );

		 this.target = source.target.clone();
		 this.shadow = source.shadow.clone();

		 return this;

	 }

 }

 DirectionalLight.prototype.isDirectionalLight = true;

 class AmbientLight extends Light {

	 constructor( color, intensity ) {

		 super( color, intensity );

		 this.type = 'AmbientLight';

	 }

 }

 AmbientLight.prototype.isAmbientLight = true;

 class RectAreaLight extends Light {

	 constructor( color, intensity, width = 10, height = 10 ) {

		 super( color, intensity );

		 this.type = 'RectAreaLight';

		 this.width = width;
		 this.height = height;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.width = source.width;
		 this.height = source.height;

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.width = this.width;
		 data.object.height = this.height;

		 return data;

	 }

 }

 RectAreaLight.prototype.isRectAreaLight = true;

 /**
	* Primary reference:
	*   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	*
	* Secondary reference:
	*   https://www.ppsloan.org/publications/StupidSH36.pdf
	*/

 // 3-band SH defined by 9 coefficients

 class SphericalHarmonics3 {

	 constructor() {

		 this.coefficients = [];

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients.push( new Vector3() );

		 }

	 }

	 set( coefficients ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].copy( coefficients[ i ] );

		 }

		 return this;

	 }

	 zero() {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].set( 0, 0, 0 );

		 }

		 return this;

	 }

	 // get the radiance in the direction of the normal
	 // target is a Vector3
	 getAt( normal, target ) {

		 // normal is assumed to be unit length

		 const x = normal.x, y = normal.y, z = normal.z;

		 const coeff = this.coefficients;

		 // band 0
		 target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		 // band 1
		 target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		 target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		 target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		 // band 2
		 target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		 target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		 target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		 target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		 target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		 return target;

	 }

	 // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	 // target is a Vector3
	 // https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 getIrradianceAt( normal, target ) {

		 // normal is assumed to be unit length

		 const x = normal.x, y = normal.y, z = normal.z;

		 const coeff = this.coefficients;

		 // band 0
		 target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		 // band 1
		 target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		 target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		 target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		 // band 2
		 target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		 target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		 target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		 target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		 target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		 return target;

	 }

	 add( sh ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].add( sh.coefficients[ i ] );

		 }

		 return this;

	 }

	 addScaledSH( sh, s ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		 }

		 return this;

	 }

	 scale( s ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].multiplyScalar( s );

		 }

		 return this;

	 }

	 lerp( sh, alpha ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		 }

		 return this;

	 }

	 equals( sh ) {

		 for ( let i = 0; i < 9; i ++ ) {

			 if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				 return false;

			 }

		 }

		 return true;

	 }

	 copy( sh ) {

		 return this.set( sh.coefficients );

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 fromArray( array, offset = 0 ) {

		 const coefficients = this.coefficients;

		 for ( let i = 0; i < 9; i ++ ) {

			 coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		 }

		 return this;

	 }

	 toArray( array = [], offset = 0 ) {

		 const coefficients = this.coefficients;

		 for ( let i = 0; i < 9; i ++ ) {

			 coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		 }

		 return array;

	 }

	 // evaluate the basis functions
	 // shBasis is an Array[ 9 ]
	 static getBasisAt( normal, shBasis ) {

		 // normal is assumed to be unit length

		 const x = normal.x, y = normal.y, z = normal.z;

		 // band 0
		 shBasis[ 0 ] = 0.282095;

		 // band 1
		 shBasis[ 1 ] = 0.488603 * y;
		 shBasis[ 2 ] = 0.488603 * z;
		 shBasis[ 3 ] = 0.488603 * x;

		 // band 2
		 shBasis[ 4 ] = 1.092548 * x * y;
		 shBasis[ 5 ] = 1.092548 * y * z;
		 shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		 shBasis[ 7 ] = 1.092548 * x * z;
		 shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	 }

 }

 SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

 class LightProbe extends Light {

	 constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		 super( undefined, intensity );

		 this.sh = sh;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.sh.copy( source.sh );

		 return this;

	 }

	 fromJSON( json ) {

		 this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		 this.sh.fromArray( json.sh );

		 return this;

	 }

	 toJSON( meta ) {

		 const data = super.toJSON( meta );

		 data.object.sh = this.sh.toArray();

		 return data;

	 }

 }

 LightProbe.prototype.isLightProbe = true;

 class LoaderUtils {

	 static decodeText( array ) {

		 if ( typeof TextDecoder !== 'undefined' ) {

			 return new TextDecoder().decode( array );

		 }

		 // Avoid the String.fromCharCode.apply(null, array) shortcut, which
		 // throws a "maximum call stack size exceeded" error for large arrays.

		 let s = '';

		 for ( let i = 0, il = array.length; i < il; i ++ ) {

			 // Implicitly assumes little-endian.
			 s += String.fromCharCode( array[ i ] );

		 }

		 try {

			 // merges multi-byte utf-8 characters.

			 return decodeURIComponent( escape( s ) );

		 } catch ( e ) { // see #16358

			 return s;

		 }

	 }

	 static extractUrlBase( url ) {

		 const index = url.lastIndexOf( '/' );

		 if ( index === - 1 ) return './';

		 return url.substr( 0, index + 1 );

	 }

 }

 class InstancedBufferGeometry extends BufferGeometry {

	 constructor() {

		 super();

		 this.type = 'InstancedBufferGeometry';
		 this.instanceCount = Infinity;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.instanceCount = source.instanceCount;

		 return this;

	 }

	 clone() {

		 return new this.constructor().copy( this );

	 }

	 toJSON() {

		 const data = super.toJSON( this );

		 data.instanceCount = this.instanceCount;

		 data.isInstancedBufferGeometry = true;

		 return data;

	 }

 }

 InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

 class InstancedBufferAttribute extends BufferAttribute {

	 constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		 if ( typeof normalized === 'number' ) {

			 meshPerAttribute = normalized;

			 normalized = false;

			 console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		 }

		 super( array, itemSize, normalized );

		 this.meshPerAttribute = meshPerAttribute;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.meshPerAttribute = source.meshPerAttribute;

		 return this;

	 }

	 toJSON() {

		 const data = super.toJSON();

		 data.meshPerAttribute = this.meshPerAttribute;

		 data.isInstancedBufferAttribute = true;

		 return data;

	 }

 }

 InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

 class ImageBitmapLoader extends Loader {

	 constructor( manager ) {

		 super( manager );

		 if ( typeof createImageBitmap === 'undefined' ) {

			 console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		 }

		 if ( typeof fetch === 'undefined' ) {

			 console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		 }

		 this.options = { premultiplyAlpha: 'none' };

	 }

	 setOptions( options ) {

		 this.options = options;

		 return this;

	 }

	 load( url, onLoad, onProgress, onError ) {

		 if ( url === undefined ) url = '';

		 if ( this.path !== undefined ) url = this.path + url;

		 url = this.manager.resolveURL( url );

		 const scope = this;

		 const cached = Cache.get( url );

		 if ( cached !== undefined ) {

			 scope.manager.itemStart( url );

			 setTimeout( function () {

				 if ( onLoad ) onLoad( cached );

				 scope.manager.itemEnd( url );

			 }, 0 );

			 return cached;

		 }

		 const fetchOptions = {};
		 fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		 fetchOptions.headers = this.requestHeader;

		 fetch( url, fetchOptions ).then( function ( res ) {

			 return res.blob();

		 } ).then( function ( blob ) {

			 return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		 } ).then( function ( imageBitmap ) {

			 Cache.add( url, imageBitmap );

			 if ( onLoad ) onLoad( imageBitmap );

			 scope.manager.itemEnd( url );

		 } ).catch( function ( e ) {

			 if ( onError ) onError( e );

			 scope.manager.itemError( url );
			 scope.manager.itemEnd( url );

		 } );

		 scope.manager.itemStart( url );

	 }

 }

 ImageBitmapLoader.prototype.isImageBitmapLoader = true;

 let _context;

 const AudioContext = {

	 getContext: function () {

		 if ( _context === undefined ) {

			 _context = new ( window.AudioContext || window.webkitAudioContext )();

		 }

		 return _context;

	 },

	 setContext: function ( value ) {

		 _context = value;

	 }

 };

 class AudioLoader extends Loader {

	 constructor( manager ) {

		 super( manager );

	 }

	 load( url, onLoad, onProgress, onError ) {

		 const scope = this;

		 const loader = new FileLoader( this.manager );
		 loader.setResponseType( 'arraybuffer' );
		 loader.setPath( this.path );
		 loader.setRequestHeader( this.requestHeader );
		 loader.setWithCredentials( this.withCredentials );
		 loader.load( url, function ( buffer ) {

			 try {

				 // Create a copy of the buffer. The `decodeAudioData` method
				 // detaches the buffer when complete, preventing reuse.
				 const bufferCopy = buffer.slice( 0 );

				 const context = AudioContext.getContext();
				 context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					 onLoad( audioBuffer );

				 } );

			 } catch ( e ) {

				 if ( onError ) {

					 onError( e );

				 } else {

					 console.error( e );

				 }

				 scope.manager.itemError( url );

			 }

		 }, onProgress, onError );

	 }

 }

 class HemisphereLightProbe extends LightProbe {

	 constructor( skyColor, groundColor, intensity = 1 ) {

		 super( undefined, intensity );

		 const color1 = new Color$1().set( skyColor );
		 const color2 = new Color$1().set( groundColor );

		 const sky = new Vector3( color1.r, color1.g, color1.b );
		 const ground = new Vector3( color2.r, color2.g, color2.b );

		 // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		 const c0 = Math.sqrt( Math.PI );
		 const c1 = c0 * Math.sqrt( 0.75 );

		 this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		 this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	 }

 }

 HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

 class AmbientLightProbe extends LightProbe {

	 constructor( color, intensity = 1 ) {

		 super( undefined, intensity );

		 const color1 = new Color$1().set( color );

		 // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		 this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	 }

 }

 AmbientLightProbe.prototype.isAmbientLightProbe = true;

 class Audio extends Object3D {

	 constructor( listener ) {

		 super();

		 this.type = 'Audio';

		 this.listener = listener;
		 this.context = listener.context;

		 this.gain = this.context.createGain();
		 this.gain.connect( listener.getInput() );

		 this.autoplay = false;

		 this.buffer = null;
		 this.detune = 0;
		 this.loop = false;
		 this.loopStart = 0;
		 this.loopEnd = 0;
		 this.offset = 0;
		 this.duration = undefined;
		 this.playbackRate = 1;
		 this.isPlaying = false;
		 this.hasPlaybackControl = true;
		 this.source = null;
		 this.sourceType = 'empty';

		 this._startedAt = 0;
		 this._progress = 0;
		 this._connected = false;

		 this.filters = [];

	 }

	 getOutput() {

		 return this.gain;

	 }

	 setNodeSource( audioNode ) {

		 this.hasPlaybackControl = false;
		 this.sourceType = 'audioNode';
		 this.source = audioNode;
		 this.connect();

		 return this;

	 }

	 setMediaElementSource( mediaElement ) {

		 this.hasPlaybackControl = false;
		 this.sourceType = 'mediaNode';
		 this.source = this.context.createMediaElementSource( mediaElement );
		 this.connect();

		 return this;

	 }

	 setMediaStreamSource( mediaStream ) {

		 this.hasPlaybackControl = false;
		 this.sourceType = 'mediaStreamNode';
		 this.source = this.context.createMediaStreamSource( mediaStream );
		 this.connect();

		 return this;

	 }

	 setBuffer( audioBuffer ) {

		 this.buffer = audioBuffer;
		 this.sourceType = 'buffer';

		 if ( this.autoplay ) this.play();

		 return this;

	 }

	 play( delay = 0 ) {

		 if ( this.isPlaying === true ) {

			 console.warn( 'THREE.Audio: Audio is already playing.' );
			 return;

		 }

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this._startedAt = this.context.currentTime + delay;

		 const source = this.context.createBufferSource();
		 source.buffer = this.buffer;
		 source.loop = this.loop;
		 source.loopStart = this.loopStart;
		 source.loopEnd = this.loopEnd;
		 source.onended = this.onEnded.bind( this );
		 source.start( this._startedAt, this._progress + this.offset, this.duration );

		 this.isPlaying = true;

		 this.source = source;

		 this.setDetune( this.detune );
		 this.setPlaybackRate( this.playbackRate );

		 return this.connect();

	 }

	 pause() {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 if ( this.isPlaying === true ) {

			 // update current progress

			 this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			 if ( this.loop === true ) {

				 // ensure _progress does not exceed duration with looped audios

				 this._progress = this._progress % ( this.duration || this.buffer.duration );

			 }

			 this.source.stop();
			 this.source.onended = null;

			 this.isPlaying = false;

		 }

		 return this;

	 }

	 stop() {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this._progress = 0;

		 this.source.stop();
		 this.source.onended = null;
		 this.isPlaying = false;

		 return this;

	 }

	 connect() {

		 if ( this.filters.length > 0 ) {

			 this.source.connect( this.filters[ 0 ] );

			 for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				 this.filters[ i - 1 ].connect( this.filters[ i ] );

			 }

			 this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		 } else {

			 this.source.connect( this.getOutput() );

		 }

		 this._connected = true;

		 return this;

	 }

	 disconnect() {

		 if ( this.filters.length > 0 ) {

			 this.source.disconnect( this.filters[ 0 ] );

			 for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				 this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			 }

			 this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		 } else {

			 this.source.disconnect( this.getOutput() );

		 }

		 this._connected = false;

		 return this;

	 }

	 getFilters() {

		 return this.filters;

	 }

	 setFilters( value ) {

		 if ( ! value ) value = [];

		 if ( this._connected === true ) {

			 this.disconnect();
			 this.filters = value.slice();
			 this.connect();

		 } else {

			 this.filters = value.slice();

		 }

		 return this;

	 }

	 setDetune( value ) {

		 this.detune = value;

		 if ( this.source.detune === undefined ) return; // only set detune when available

		 if ( this.isPlaying === true ) {

			 this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		 }

		 return this;

	 }

	 getDetune() {

		 return this.detune;

	 }

	 getFilter() {

		 return this.getFilters()[ 0 ];

	 }

	 setFilter( filter ) {

		 return this.setFilters( filter ? [ filter ] : [] );

	 }

	 setPlaybackRate( value ) {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this.playbackRate = value;

		 if ( this.isPlaying === true ) {

			 this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		 }

		 return this;

	 }

	 getPlaybackRate() {

		 return this.playbackRate;

	 }

	 onEnded() {

		 this.isPlaying = false;

	 }

	 getLoop() {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return false;

		 }

		 return this.loop;

	 }

	 setLoop( value ) {

		 if ( this.hasPlaybackControl === false ) {

			 console.warn( 'THREE.Audio: this Audio has no playback control.' );
			 return;

		 }

		 this.loop = value;

		 if ( this.isPlaying === true ) {

			 this.source.loop = this.loop;

		 }

		 return this;

	 }

	 setLoopStart( value ) {

		 this.loopStart = value;

		 return this;

	 }

	 setLoopEnd( value ) {

		 this.loopEnd = value;

		 return this;

	 }

	 getVolume() {

		 return this.gain.gain.value;

	 }

	 setVolume( value ) {

		 this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		 return this;

	 }

 }

 class PropertyMixer {

	 constructor( binding, typeName, valueSize ) {

		 this.binding = binding;
		 this.valueSize = valueSize;

		 let mixFunction,
			 mixFunctionAdditive,
			 setIdentity;

		 // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		 //
		 // interpolators can use .buffer as their .result
		 // the data then goes to 'incoming'
		 //
		 // 'accu0' and 'accu1' are used frame-interleaved for
		 // the cumulative result and are compared to detect
		 // changes
		 //
		 // 'orig' stores the original state of the property
		 //
		 // 'add' is used for additive cumulative results
		 //
		 // 'work' is optional and is only present for quaternion types. It is used
		 // to store intermediate quaternion multiplication results

		 switch ( typeName ) {

			 case 'quaternion':
				 mixFunction = this._slerp;
				 mixFunctionAdditive = this._slerpAdditive;
				 setIdentity = this._setAdditiveIdentityQuaternion;

				 this.buffer = new Float64Array( valueSize * 6 );
				 this._workIndex = 5;
				 break;

			 case 'string':
			 case 'bool':
				 mixFunction = this._select;

				 // Use the regular mix function and for additive on these types,
				 // additive is not relevant for non-numeric types
				 mixFunctionAdditive = this._select;

				 setIdentity = this._setAdditiveIdentityOther;

				 this.buffer = new Array( valueSize * 5 );
				 break;

			 default:
				 mixFunction = this._lerp;
				 mixFunctionAdditive = this._lerpAdditive;
				 setIdentity = this._setAdditiveIdentityNumeric;

				 this.buffer = new Float64Array( valueSize * 5 );

		 }

		 this._mixBufferRegion = mixFunction;
		 this._mixBufferRegionAdditive = mixFunctionAdditive;
		 this._setIdentity = setIdentity;
		 this._origIndex = 3;
		 this._addIndex = 4;

		 this.cumulativeWeight = 0;
		 this.cumulativeWeightAdditive = 0;

		 this.useCount = 0;
		 this.referenceCount = 0;

	 }

	 // accumulate data in the 'incoming' region into 'accu<i>'
	 accumulate( accuIndex, weight ) {

		 // note: happily accumulating nothing when weight = 0, the caller knows
		 // the weight and shouldn't have made the call in the first place

		 const buffer = this.buffer,
			 stride = this.valueSize,
			 offset = accuIndex * stride + stride;

		 let currentWeight = this.cumulativeWeight;

		 if ( currentWeight === 0 ) {

			 // accuN := incoming * weight

			 for ( let i = 0; i !== stride; ++ i ) {

				 buffer[ offset + i ] = buffer[ i ];

			 }

			 currentWeight = weight;

		 } else {

			 // accuN := accuN + incoming * weight

			 currentWeight += weight;
			 const mix = weight / currentWeight;
			 this._mixBufferRegion( buffer, offset, 0, mix, stride );

		 }

		 this.cumulativeWeight = currentWeight;

	 }

	 // accumulate data in the 'incoming' region into 'add'
	 accumulateAdditive( weight ) {

		 const buffer = this.buffer,
			 stride = this.valueSize,
			 offset = stride * this._addIndex;

		 if ( this.cumulativeWeightAdditive === 0 ) {

			 // add = identity

			 this._setIdentity();

		 }

		 // add := add + incoming * weight

		 this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		 this.cumulativeWeightAdditive += weight;

	 }

	 // apply the state of 'accu<i>' to the binding when accus differ
	 apply( accuIndex ) {

		 const stride = this.valueSize,
			 buffer = this.buffer,
			 offset = accuIndex * stride + stride,

			 weight = this.cumulativeWeight,
			 weightAdditive = this.cumulativeWeightAdditive,

			 binding = this.binding;

		 this.cumulativeWeight = 0;
		 this.cumulativeWeightAdditive = 0;

		 if ( weight < 1 ) {

			 // accuN := accuN + original * ( 1 - cumulativeWeight )

			 const originalValueOffset = stride * this._origIndex;

			 this._mixBufferRegion(
				 buffer, offset, originalValueOffset, 1 - weight, stride );

		 }

		 if ( weightAdditive > 0 ) {

			 // accuN := accuN + additive accuN

			 this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		 }

		 for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			 if ( buffer[ i ] !== buffer[ i + stride ] ) {

				 // value has changed -> update scene graph

				 binding.setValue( buffer, offset );
				 break;

			 }

		 }

	 }

	 // remember the state of the bound property and copy it to both accus
	 saveOriginalState() {

		 const binding = this.binding;

		 const buffer = this.buffer,
			 stride = this.valueSize,

			 originalValueOffset = stride * this._origIndex;

		 binding.getValue( buffer, originalValueOffset );

		 // accu[0..1] := orig -- initially detect changes against the original
		 for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			 buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		 }

		 // Add to identity for additive
		 this._setIdentity();

		 this.cumulativeWeight = 0;
		 this.cumulativeWeightAdditive = 0;

	 }

	 // apply the state previously taken via 'saveOriginalState' to the binding
	 restoreOriginalState() {

		 const originalValueOffset = this.valueSize * 3;
		 this.binding.setValue( this.buffer, originalValueOffset );

	 }

	 _setAdditiveIdentityNumeric() {

		 const startIndex = this._addIndex * this.valueSize;
		 const endIndex = startIndex + this.valueSize;

		 for ( let i = startIndex; i < endIndex; i ++ ) {

			 this.buffer[ i ] = 0;

		 }

	 }

	 _setAdditiveIdentityQuaternion() {

		 this._setAdditiveIdentityNumeric();
		 this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	 }

	 _setAdditiveIdentityOther() {

		 const startIndex = this._origIndex * this.valueSize;
		 const targetIndex = this._addIndex * this.valueSize;

		 for ( let i = 0; i < this.valueSize; i ++ ) {

			 this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		 }

	 }


	 // mix functions

	 _select( buffer, dstOffset, srcOffset, t, stride ) {

		 if ( t >= 0.5 ) {

			 for ( let i = 0; i !== stride; ++ i ) {

				 buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			 }

		 }

	 }

	 _slerp( buffer, dstOffset, srcOffset, t ) {

		 Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	 }

	 _slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		 const workOffset = this._workIndex * stride;

		 // Store result in intermediate buffer offset
		 Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		 // Slerp to the intermediate result
		 Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	 }

	 _lerp( buffer, dstOffset, srcOffset, t, stride ) {

		 const s = 1 - t;

		 for ( let i = 0; i !== stride; ++ i ) {

			 const j = dstOffset + i;

			 buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		 }

	 }

	 _lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		 for ( let i = 0; i !== stride; ++ i ) {

			 const j = dstOffset + i;

			 buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		 }

	 }

 }

 // Characters [].:/ are reserved for track binding syntax.
 const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
 const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

 // Attempts to allow node names from any language. ES5's `\w` regexp matches
 // only latin characters, and the unicode \p{L} is not yet supported. So
 // instead, we exclude reserved characters and match everything else.
 const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
 const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

 // Parent directories, delimited by '/' or ':'. Currently unused, but must
 // be matched to parse the rest of the track name.
 const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

 // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
 const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

 // Object on target node, and accessor. May not contain reserved
 // characters. Accessor may contain any character except closing bracket.
 const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

 // Property and accessor. May not contain reserved characters. Accessor may
 // contain any non-bracket characters.
 const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

 const _trackRe = new RegExp( ''
	 + '^'
	 + _directoryRe
	 + _nodeRe
	 + _objectRe
	 + _propertyRe
	 + '$'
 );

 const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

 class Composite {

	 constructor( targetGroup, path, optionalParsedPath ) {

		 const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		 this._targetGroup = targetGroup;
		 this._bindings = targetGroup.subscribe_( path, parsedPath );

	 }

	 getValue( array, offset ) {

		 this.bind(); // bind all binding

		 const firstValidIndex = this._targetGroup.nCachedObjects_,
			 binding = this._bindings[ firstValidIndex ];

		 // and only call .getValue on the first
		 if ( binding !== undefined ) binding.getValue( array, offset );

	 }

	 setValue( array, offset ) {

		 const bindings = this._bindings;

		 for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			 bindings[ i ].setValue( array, offset );

		 }

	 }

	 bind() {

		 const bindings = this._bindings;

		 for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			 bindings[ i ].bind();

		 }

	 }

	 unbind() {

		 const bindings = this._bindings;

		 for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			 bindings[ i ].unbind();

		 }

	 }

 }

 // Note: This class uses a State pattern on a per-method basis:
 // 'bind' sets 'this.getValue' / 'setValue' and shadows the
 // prototype version of these methods with one that represents
 // the bound state. When the property is not found, the methods
 // become no-ops.
 class PropertyBinding {

	 constructor( rootNode, path, parsedPath ) {

		 this.path = path;
		 this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		 this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		 this.rootNode = rootNode;

		 // initial state of these methods that calls 'bind'
		 this.getValue = this._getValue_unbound;
		 this.setValue = this._setValue_unbound;

	 }


	 static create( root, path, parsedPath ) {

		 if ( ! ( root && root.isAnimationObjectGroup ) ) {

			 return new PropertyBinding( root, path, parsedPath );

		 } else {

			 return new PropertyBinding.Composite( root, path, parsedPath );

		 }

	 }

	 /**
		* Replaces spaces with underscores and removes unsupported characters from
		* node names, to ensure compatibility with parseTrackName().
		*
		* @param {string} name Node name to be sanitized.
		* @return {string}
		*/
	 static sanitizeNodeName( name ) {

		 return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	 }

	 static parseTrackName( trackName ) {

		 const matches = _trackRe.exec( trackName );

		 if ( ! matches ) {

			 throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		 }

		 const results = {
			 // directoryName: matches[ 1 ], // (tschw) currently unused
			 nodeName: matches[ 2 ],
			 objectName: matches[ 3 ],
			 objectIndex: matches[ 4 ],
			 propertyName: matches[ 5 ], // required
			 propertyIndex: matches[ 6 ]
		 };

		 const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		 if ( lastDot !== undefined && lastDot !== - 1 ) {

			 const objectName = results.nodeName.substring( lastDot + 1 );

			 // Object names must be checked against an allowlist. Otherwise, there
			 // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			 // 'bar' could be the objectName, or part of a nodeName (which can
			 // include '.' characters).
			 if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				 results.nodeName = results.nodeName.substring( 0, lastDot );
				 results.objectName = objectName;

			 }

		 }

		 if ( results.propertyName === null || results.propertyName.length === 0 ) {

			 throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		 }

		 return results;

	 }

	 static findNode( root, nodeName ) {

		 if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			 return root;

		 }

		 // search into skeleton bones.
		 if ( root.skeleton ) {

			 const bone = root.skeleton.getBoneByName( nodeName );

			 if ( bone !== undefined ) {

				 return bone;

			 }

		 }

		 // search into node subtree.
		 if ( root.children ) {

			 const searchNodeSubtree = function ( children ) {

				 for ( let i = 0; i < children.length; i ++ ) {

					 const childNode = children[ i ];

					 if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						 return childNode;

					 }

					 const result = searchNodeSubtree( childNode.children );

					 if ( result ) return result;

				 }

				 return null;

			 };

			 const subTreeNode = searchNodeSubtree( root.children );

			 if ( subTreeNode ) {

				 return subTreeNode;

			 }

		 }

		 return null;

	 }

	 // these are used to "bind" a nonexistent property
	 _getValue_unavailable() {}
	 _setValue_unavailable() {}

	 // Getters

	 _getValue_direct( buffer, offset ) {

		 buffer[ offset ] = this.node[ this.propertyName ];

	 }

	 _getValue_array( buffer, offset ) {

		 const source = this.resolvedProperty;

		 for ( let i = 0, n = source.length; i !== n; ++ i ) {

			 buffer[ offset ++ ] = source[ i ];

		 }

	 }

	 _getValue_arrayElement( buffer, offset ) {

		 buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	 }

	 _getValue_toArray( buffer, offset ) {

		 this.resolvedProperty.toArray( buffer, offset );

	 }

	 // Direct

	 _setValue_direct( buffer, offset ) {

		 this.targetObject[ this.propertyName ] = buffer[ offset ];

	 }

	 _setValue_direct_setNeedsUpdate( buffer, offset ) {

		 this.targetObject[ this.propertyName ] = buffer[ offset ];
		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 this.targetObject[ this.propertyName ] = buffer[ offset ];
		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 // EntireArray

	 _setValue_array( buffer, offset ) {

		 const dest = this.resolvedProperty;

		 for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			 dest[ i ] = buffer[ offset ++ ];

		 }

	 }

	 _setValue_array_setNeedsUpdate( buffer, offset ) {

		 const dest = this.resolvedProperty;

		 for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			 dest[ i ] = buffer[ offset ++ ];

		 }

		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 const dest = this.resolvedProperty;

		 for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			 dest[ i ] = buffer[ offset ++ ];

		 }

		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 // ArrayElement

	 _setValue_arrayElement( buffer, offset ) {

		 this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	 }

	 _setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 // HasToFromArray

	 _setValue_fromArray( buffer, offset ) {

		 this.resolvedProperty.fromArray( buffer, offset );

	 }

	 _setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty.fromArray( buffer, offset );
		 this.targetObject.needsUpdate = true;

	 }

	 _setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		 this.resolvedProperty.fromArray( buffer, offset );
		 this.targetObject.matrixWorldNeedsUpdate = true;

	 }

	 _getValue_unbound( targetArray, offset ) {

		 this.bind();
		 this.getValue( targetArray, offset );

	 }

	 _setValue_unbound( sourceArray, offset ) {

		 this.bind();
		 this.setValue( sourceArray, offset );

	 }

	 // create getter / setter pair for a property in the scene graph
	 bind() {

		 let targetObject = this.node;
		 const parsedPath = this.parsedPath;

		 const objectName = parsedPath.objectName;
		 const propertyName = parsedPath.propertyName;
		 let propertyIndex = parsedPath.propertyIndex;

		 if ( ! targetObject ) {

			 targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			 this.node = targetObject;

		 }

		 // set fail state so we can just 'return' on error
		 this.getValue = this._getValue_unavailable;
		 this.setValue = this._setValue_unavailable;

		 // ensure there is a value node
		 if ( ! targetObject ) {

			 console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			 return;

		 }

		 if ( objectName ) {

			 let objectIndex = parsedPath.objectIndex;

			 // special cases were we need to reach deeper into the hierarchy to get the face materials....
			 switch ( objectName ) {

				 case 'materials':

					 if ( ! targetObject.material ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						 return;

					 }

					 if ( ! targetObject.material.materials ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						 return;

					 }

					 targetObject = targetObject.material.materials;

					 break;

				 case 'bones':

					 if ( ! targetObject.skeleton ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						 return;

					 }

					 // potential future optimization: skip this if propertyIndex is already an integer
					 // and convert the integer string to a true integer.

					 targetObject = targetObject.skeleton.bones;

					 // support resolving morphTarget names into indices.
					 for ( let i = 0; i < targetObject.length; i ++ ) {

						 if ( targetObject[ i ].name === objectIndex ) {

							 objectIndex = i;
							 break;

						 }

					 }

					 break;

				 default:

					 if ( targetObject[ objectName ] === undefined ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						 return;

					 }

					 targetObject = targetObject[ objectName ];

			 }


			 if ( objectIndex !== undefined ) {

				 if ( targetObject[ objectIndex ] === undefined ) {

					 console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					 return;

				 }

				 targetObject = targetObject[ objectIndex ];

			 }

		 }

		 // resolve property
		 const nodeProperty = targetObject[ propertyName ];

		 if ( nodeProperty === undefined ) {

			 const nodeName = parsedPath.nodeName;

			 console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				 '.' + propertyName + ' but it wasn\'t found.', targetObject );
			 return;

		 }

		 // determine versioning scheme
		 let versioning = this.Versioning.None;

		 this.targetObject = targetObject;

		 if ( targetObject.needsUpdate !== undefined ) { // material

			 versioning = this.Versioning.NeedsUpdate;

		 } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			 versioning = this.Versioning.MatrixWorldNeedsUpdate;

		 }

		 // determine how the property gets bound
		 let bindingType = this.BindingType.Direct;

		 if ( propertyIndex !== undefined ) {

			 // access a sub element of the property array (only primitives are supported right now)

			 if ( propertyName === 'morphTargetInfluences' ) {

				 // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				 // support resolving morphTarget names into indices.
				 if ( ! targetObject.geometry ) {

					 console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					 return;

				 }

				 if ( targetObject.geometry.isBufferGeometry ) {

					 if ( ! targetObject.geometry.morphAttributes ) {

						 console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						 return;

					 }

					 if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						 propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					 }


				 } else {

					 console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					 return;

				 }

			 }

			 bindingType = this.BindingType.ArrayElement;

			 this.resolvedProperty = nodeProperty;
			 this.propertyIndex = propertyIndex;

		 } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			 // must use copy for Object3D.Euler/Quaternion

			 bindingType = this.BindingType.HasFromToArray;

			 this.resolvedProperty = nodeProperty;

		 } else if ( Array.isArray( nodeProperty ) ) {

			 bindingType = this.BindingType.EntireArray;

			 this.resolvedProperty = nodeProperty;

		 } else {

			 this.propertyName = propertyName;

		 }

		 // select getter / setter
		 this.getValue = this.GetterByBindingType[ bindingType ];
		 this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	 }

	 unbind() {

		 this.node = null;

		 // back to the prototype version of getValue / setValue
		 // note: avoiding to mutate the shape of 'this' via 'delete'
		 this.getValue = this._getValue_unbound;
		 this.setValue = this._setValue_unbound;

	 }

 }

 PropertyBinding.Composite = Composite;

 PropertyBinding.prototype.BindingType = {
	 Direct: 0,
	 EntireArray: 1,
	 ArrayElement: 2,
	 HasFromToArray: 3
 };

 PropertyBinding.prototype.Versioning = {
	 None: 0,
	 NeedsUpdate: 1,
	 MatrixWorldNeedsUpdate: 2
 };

 PropertyBinding.prototype.GetterByBindingType = [

	 PropertyBinding.prototype._getValue_direct,
	 PropertyBinding.prototype._getValue_array,
	 PropertyBinding.prototype._getValue_arrayElement,
	 PropertyBinding.prototype._getValue_toArray,

 ];

 PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	 [
		 // Direct
		 PropertyBinding.prototype._setValue_direct,
		 PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		 PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	 ], [

		 // EntireArray

		 PropertyBinding.prototype._setValue_array,
		 PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		 PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	 ], [

		 // ArrayElement
		 PropertyBinding.prototype._setValue_arrayElement,
		 PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		 PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	 ], [

		 // HasToFromArray
		 PropertyBinding.prototype._setValue_fromArray,
		 PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		 PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	 ]

 ];

 class AnimationAction {

	 constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		 this._mixer = mixer;
		 this._clip = clip;
		 this._localRoot = localRoot;
		 this.blendMode = blendMode;

		 const tracks = clip.tracks,
			 nTracks = tracks.length,
			 interpolants = new Array( nTracks );

		 const interpolantSettings = {
			 endingStart: ZeroCurvatureEnding,
			 endingEnd: ZeroCurvatureEnding
		 };

		 for ( let i = 0; i !== nTracks; ++ i ) {

			 const interpolant = tracks[ i ].createInterpolant( null );
			 interpolants[ i ] = interpolant;
			 interpolant.settings = interpolantSettings;

		 }

		 this._interpolantSettings = interpolantSettings;

		 this._interpolants = interpolants; // bound by the mixer

		 // inside: PropertyMixer (managed by the mixer)
		 this._propertyBindings = new Array( nTracks );

		 this._cacheIndex = null; // for the memory manager
		 this._byClipCacheIndex = null; // for the memory manager

		 this._timeScaleInterpolant = null;
		 this._weightInterpolant = null;

		 this.loop = LoopRepeat;
		 this._loopCount = - 1;

		 // global mixer time when the action is to be started
		 // it's set back to 'null' upon start of the action
		 this._startTime = null;

		 // scaled local time of the action
		 // gets clamped or wrapped to 0..clip.duration according to loop
		 this.time = 0;

		 this.timeScale = 1;
		 this._effectiveTimeScale = 1;

		 this.weight = 1;
		 this._effectiveWeight = 1;

		 this.repetitions = Infinity; // no. of repetitions when looping

		 this.paused = false; // true -> zero effective time scale
		 this.enabled = true; // false -> zero effective weight

		 this.clampWhenFinished = false;// keep feeding the last frame?

		 this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		 this.zeroSlopeAtEnd = true;// clips for start, loop and end

	 }

	 // State & Scheduling

	 play() {

		 this._mixer._activateAction( this );

		 return this;

	 }

	 stop() {

		 this._mixer._deactivateAction( this );

		 return this.reset();

	 }

	 reset() {

		 this.paused = false;
		 this.enabled = true;

		 this.time = 0; // restart clip
		 this._loopCount = - 1;// forget previous loops
		 this._startTime = null;// forget scheduling

		 return this.stopFading().stopWarping();

	 }

	 isRunning() {

		 return this.enabled && ! this.paused && this.timeScale !== 0 &&
			 this._startTime === null && this._mixer._isActiveAction( this );

	 }

	 // return true when play has been called
	 isScheduled() {

		 return this._mixer._isActiveAction( this );

	 }

	 startAt( time ) {

		 this._startTime = time;

		 return this;

	 }

	 setLoop( mode, repetitions ) {

		 this.loop = mode;
		 this.repetitions = repetitions;

		 return this;

	 }

	 // Weight

	 // set the weight stopping any scheduled fading
	 // although .enabled = false yields an effective weight of zero, this
	 // method does *not* change .enabled, because it would be confusing
	 setEffectiveWeight( weight ) {

		 this.weight = weight;

		 // note: same logic as when updated at runtime
		 this._effectiveWeight = this.enabled ? weight : 0;

		 return this.stopFading();

	 }

	 // return the weight considering fading and .enabled
	 getEffectiveWeight() {

		 return this._effectiveWeight;

	 }

	 fadeIn( duration ) {

		 return this._scheduleFading( duration, 0, 1 );

	 }

	 fadeOut( duration ) {

		 return this._scheduleFading( duration, 1, 0 );

	 }

	 crossFadeFrom( fadeOutAction, duration, warp ) {

		 fadeOutAction.fadeOut( duration );
		 this.fadeIn( duration );

		 if ( warp ) {

			 const fadeInDuration = this._clip.duration,
				 fadeOutDuration = fadeOutAction._clip.duration,

				 startEndRatio = fadeOutDuration / fadeInDuration,
				 endStartRatio = fadeInDuration / fadeOutDuration;

			 fadeOutAction.warp( 1.0, startEndRatio, duration );
			 this.warp( endStartRatio, 1.0, duration );

		 }

		 return this;

	 }

	 crossFadeTo( fadeInAction, duration, warp ) {

		 return fadeInAction.crossFadeFrom( this, duration, warp );

	 }

	 stopFading() {

		 const weightInterpolant = this._weightInterpolant;

		 if ( weightInterpolant !== null ) {

			 this._weightInterpolant = null;
			 this._mixer._takeBackControlInterpolant( weightInterpolant );

		 }

		 return this;

	 }

	 // Time Scale Control

	 // set the time scale stopping any scheduled warping
	 // although .paused = true yields an effective time scale of zero, this
	 // method does *not* change .paused, because it would be confusing
	 setEffectiveTimeScale( timeScale ) {

		 this.timeScale = timeScale;
		 this._effectiveTimeScale = this.paused ? 0 : timeScale;

		 return this.stopWarping();

	 }

	 // return the time scale considering warping and .paused
	 getEffectiveTimeScale() {

		 return this._effectiveTimeScale;

	 }

	 setDuration( duration ) {

		 this.timeScale = this._clip.duration / duration;

		 return this.stopWarping();

	 }

	 syncWith( action ) {

		 this.time = action.time;
		 this.timeScale = action.timeScale;

		 return this.stopWarping();

	 }

	 halt( duration ) {

		 return this.warp( this._effectiveTimeScale, 0, duration );

	 }

	 warp( startTimeScale, endTimeScale, duration ) {

		 const mixer = this._mixer,
			 now = mixer.time,
			 timeScale = this.timeScale;

		 let interpolant = this._timeScaleInterpolant;

		 if ( interpolant === null ) {

			 interpolant = mixer._lendControlInterpolant();
			 this._timeScaleInterpolant = interpolant;

		 }

		 const times = interpolant.parameterPositions,
			 values = interpolant.sampleValues;

		 times[ 0 ] = now;
		 times[ 1 ] = now + duration;

		 values[ 0 ] = startTimeScale / timeScale;
		 values[ 1 ] = endTimeScale / timeScale;

		 return this;

	 }

	 stopWarping() {

		 const timeScaleInterpolant = this._timeScaleInterpolant;

		 if ( timeScaleInterpolant !== null ) {

			 this._timeScaleInterpolant = null;
			 this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		 }

		 return this;

	 }

	 // Object Accessors

	 getMixer() {

		 return this._mixer;

	 }

	 getClip() {

		 return this._clip;

	 }

	 getRoot() {

		 return this._localRoot || this._mixer._root;

	 }

	 // Interna

	 _update( time, deltaTime, timeDirection, accuIndex ) {

		 // called by the mixer

		 if ( ! this.enabled ) {

			 // call ._updateWeight() to update ._effectiveWeight

			 this._updateWeight( time );
			 return;

		 }

		 const startTime = this._startTime;

		 if ( startTime !== null ) {

			 // check for scheduled start of action

			 const timeRunning = ( time - startTime ) * timeDirection;
			 if ( timeRunning < 0 || timeDirection === 0 ) {

				 return; // yet to come / don't decide when delta = 0

			 }

			 // start

			 this._startTime = null; // unschedule
			 deltaTime = timeDirection * timeRunning;

		 }

		 // apply time scale and advance time

		 deltaTime *= this._updateTimeScale( time );
		 const clipTime = this._updateTime( deltaTime );

		 // note: _updateTime may disable the action resulting in
		 // an effective weight of 0

		 const weight = this._updateWeight( time );

		 if ( weight > 0 ) {

			 const interpolants = this._interpolants;
			 const propertyMixers = this._propertyBindings;

			 switch ( this.blendMode ) {

				 case AdditiveAnimationBlendMode:

					 for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						 interpolants[ j ].evaluate( clipTime );
						 propertyMixers[ j ].accumulateAdditive( weight );

					 }

					 break;

				 case NormalAnimationBlendMode:
				 default:

					 for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						 interpolants[ j ].evaluate( clipTime );
						 propertyMixers[ j ].accumulate( accuIndex, weight );

					 }

			 }

		 }

	 }

	 _updateWeight( time ) {

		 let weight = 0;

		 if ( this.enabled ) {

			 weight = this.weight;
			 const interpolant = this._weightInterpolant;

			 if ( interpolant !== null ) {

				 const interpolantValue = interpolant.evaluate( time )[ 0 ];

				 weight *= interpolantValue;

				 if ( time > interpolant.parameterPositions[ 1 ] ) {

					 this.stopFading();

					 if ( interpolantValue === 0 ) {

						 // faded out, disable
						 this.enabled = false;

					 }

				 }

			 }

		 }

		 this._effectiveWeight = weight;
		 return weight;

	 }

	 _updateTimeScale( time ) {

		 let timeScale = 0;

		 if ( ! this.paused ) {

			 timeScale = this.timeScale;

			 const interpolant = this._timeScaleInterpolant;

			 if ( interpolant !== null ) {

				 const interpolantValue = interpolant.evaluate( time )[ 0 ];

				 timeScale *= interpolantValue;

				 if ( time > interpolant.parameterPositions[ 1 ] ) {

					 this.stopWarping();

					 if ( timeScale === 0 ) {

						 // motion has halted, pause
						 this.paused = true;

					 } else {

						 // warp done - apply final time scale
						 this.timeScale = timeScale;

					 }

				 }

			 }

		 }

		 this._effectiveTimeScale = timeScale;
		 return timeScale;

	 }

	 _updateTime( deltaTime ) {

		 const duration = this._clip.duration;
		 const loop = this.loop;

		 let time = this.time + deltaTime;
		 let loopCount = this._loopCount;

		 const pingPong = ( loop === LoopPingPong );

		 if ( deltaTime === 0 ) {

			 if ( loopCount === - 1 ) return time;

			 return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		 }

		 if ( loop === LoopOnce ) {

			 if ( loopCount === - 1 ) {

				 // just started

				 this._loopCount = 0;
				 this._setEndings( true, true, false );

			 }

			 handle_stop: {

				 if ( time >= duration ) {

					 time = duration;

				 } else if ( time < 0 ) {

					 time = 0;

				 } else {

					 this.time = time;

					 break handle_stop;

				 }

				 if ( this.clampWhenFinished ) this.paused = true;
				 else this.enabled = false;

				 this.time = time;

				 this._mixer.dispatchEvent( {
					 type: 'finished', action: this,
					 direction: deltaTime < 0 ? - 1 : 1
				 } );

			 }

		 } else { // repetitive Repeat or PingPong

			 if ( loopCount === - 1 ) {

				 // just started

				 if ( deltaTime >= 0 ) {

					 loopCount = 0;

					 this._setEndings( true, this.repetitions === 0, pingPong );

				 } else {

					 // when looping in reverse direction, the initial
					 // transition through zero counts as a repetition,
					 // so leave loopCount at -1

					 this._setEndings( this.repetitions === 0, true, pingPong );

				 }

			 }

			 if ( time >= duration || time < 0 ) {

				 // wrap around

				 const loopDelta = Math.floor( time / duration ); // signed
				 time -= duration * loopDelta;

				 loopCount += Math.abs( loopDelta );

				 const pending = this.repetitions - loopCount;

				 if ( pending <= 0 ) {

					 // have to stop (switch state, clamp time, fire event)

					 if ( this.clampWhenFinished ) this.paused = true;
					 else this.enabled = false;

					 time = deltaTime > 0 ? duration : 0;

					 this.time = time;

					 this._mixer.dispatchEvent( {
						 type: 'finished', action: this,
						 direction: deltaTime > 0 ? 1 : - 1
					 } );

				 } else {

					 // keep running

					 if ( pending === 1 ) {

						 // entering the last round

						 const atStart = deltaTime < 0;
						 this._setEndings( atStart, ! atStart, pingPong );

					 } else {

						 this._setEndings( false, false, pingPong );

					 }

					 this._loopCount = loopCount;

					 this.time = time;

					 this._mixer.dispatchEvent( {
						 type: 'loop', action: this, loopDelta: loopDelta
					 } );

				 }

			 } else {

				 this.time = time;

			 }

			 if ( pingPong && ( loopCount & 1 ) === 1 ) {

				 // invert time for the "pong round"

				 return duration - time;

			 }

		 }

		 return time;

	 }

	 _setEndings( atStart, atEnd, pingPong ) {

		 const settings = this._interpolantSettings;

		 if ( pingPong ) {

			 settings.endingStart = ZeroSlopeEnding;
			 settings.endingEnd = ZeroSlopeEnding;

		 } else {

			 // assuming for LoopOnce atStart == atEnd == true

			 if ( atStart ) {

				 settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			 } else {

				 settings.endingStart = WrapAroundEnding;

			 }

			 if ( atEnd ) {

				 settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			 } else {

				 settings.endingEnd 	 = WrapAroundEnding;

			 }

		 }

	 }

	 _scheduleFading( duration, weightNow, weightThen ) {

		 const mixer = this._mixer, now = mixer.time;
		 let interpolant = this._weightInterpolant;

		 if ( interpolant === null ) {

			 interpolant = mixer._lendControlInterpolant();
			 this._weightInterpolant = interpolant;

		 }

		 const times = interpolant.parameterPositions,
			 values = interpolant.sampleValues;

		 times[ 0 ] = now;
		 values[ 0 ] = weightNow;
		 times[ 1 ] = now + duration;
		 values[ 1 ] = weightThen;

		 return this;

	 }

 }

 class AnimationMixer extends EventDispatcher {

	 constructor( root ) {

		 super();

		 this._root = root;
		 this._initMemoryManager();
		 this._accuIndex = 0;
		 this.time = 0;
		 this.timeScale = 1.0;

	 }

	 _bindAction( action, prototypeAction ) {

		 const root = action._localRoot || this._root,
			 tracks = action._clip.tracks,
			 nTracks = tracks.length,
			 bindings = action._propertyBindings,
			 interpolants = action._interpolants,
			 rootUuid = root.uuid,
			 bindingsByRoot = this._bindingsByRootAndName;

		 let bindingsByName = bindingsByRoot[ rootUuid ];

		 if ( bindingsByName === undefined ) {

			 bindingsByName = {};
			 bindingsByRoot[ rootUuid ] = bindingsByName;

		 }

		 for ( let i = 0; i !== nTracks; ++ i ) {

			 const track = tracks[ i ],
				 trackName = track.name;

			 let binding = bindingsByName[ trackName ];

			 if ( binding !== undefined ) {

				 bindings[ i ] = binding;

			 } else {

				 binding = bindings[ i ];

				 if ( binding !== undefined ) {

					 // existing binding, make sure the cache knows

					 if ( binding._cacheIndex === null ) {

						 ++ binding.referenceCount;
						 this._addInactiveBinding( binding, rootUuid, trackName );

					 }

					 continue;

				 }

				 const path = prototypeAction && prototypeAction.
					 _propertyBindings[ i ].binding.parsedPath;

				 binding = new PropertyMixer(
					 PropertyBinding.create( root, trackName, path ),
					 track.ValueTypeName, track.getValueSize() );

				 ++ binding.referenceCount;
				 this._addInactiveBinding( binding, rootUuid, trackName );

				 bindings[ i ] = binding;

			 }

			 interpolants[ i ].resultBuffer = binding.buffer;

		 }

	 }

	 _activateAction( action ) {

		 if ( ! this._isActiveAction( action ) ) {

			 if ( action._cacheIndex === null ) {

				 // this action has been forgotten by the cache, but the user
				 // appears to be still using it -> rebind

				 const rootUuid = ( action._localRoot || this._root ).uuid,
					 clipUuid = action._clip.uuid,
					 actionsForClip = this._actionsByClip[ clipUuid ];

				 this._bindAction( action,
					 actionsForClip && actionsForClip.knownActions[ 0 ] );

				 this._addInactiveAction( action, clipUuid, rootUuid );

			 }

			 const bindings = action._propertyBindings;

			 // increment reference counts / sort out state
			 for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				 const binding = bindings[ i ];

				 if ( binding.useCount ++ === 0 ) {

					 this._lendBinding( binding );
					 binding.saveOriginalState();

				 }

			 }

			 this._lendAction( action );

		 }

	 }

	 _deactivateAction( action ) {

		 if ( this._isActiveAction( action ) ) {

			 const bindings = action._propertyBindings;

			 // decrement reference counts / sort out state
			 for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				 const binding = bindings[ i ];

				 if ( -- binding.useCount === 0 ) {

					 binding.restoreOriginalState();
					 this._takeBackBinding( binding );

				 }

			 }

			 this._takeBackAction( action );

		 }

	 }

	 // Memory manager

	 _initMemoryManager() {

		 this._actions = []; // 'nActiveActions' followed by inactive ones
		 this._nActiveActions = 0;

		 this._actionsByClip = {};
		 // inside:
		 // {
		 // 	knownActions: Array< AnimationAction > - used as prototypes
		 // 	actionByRoot: AnimationAction - lookup
		 // }


		 this._bindings = []; // 'nActiveBindings' followed by inactive ones
		 this._nActiveBindings = 0;

		 this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		 this._controlInterpolants = []; // same game as above
		 this._nActiveControlInterpolants = 0;

		 const scope = this;

		 this.stats = {

			 actions: {
				 get total() {

					 return scope._actions.length;

				 },
				 get inUse() {

					 return scope._nActiveActions;

				 }
			 },
			 bindings: {
				 get total() {

					 return scope._bindings.length;

				 },
				 get inUse() {

					 return scope._nActiveBindings;

				 }
			 },
			 controlInterpolants: {
				 get total() {

					 return scope._controlInterpolants.length;

				 },
				 get inUse() {

					 return scope._nActiveControlInterpolants;

				 }
			 }

		 };

	 }

	 // Memory management for AnimationAction objects

	 _isActiveAction( action ) {

		 const index = action._cacheIndex;
		 return index !== null && index < this._nActiveActions;

	 }

	 _addInactiveAction( action, clipUuid, rootUuid ) {

		 const actions = this._actions,
			 actionsByClip = this._actionsByClip;

		 let actionsForClip = actionsByClip[ clipUuid ];

		 if ( actionsForClip === undefined ) {

			 actionsForClip = {

				 knownActions: [ action ],
				 actionByRoot: {}

			 };

			 action._byClipCacheIndex = 0;

			 actionsByClip[ clipUuid ] = actionsForClip;

		 } else {

			 const knownActions = actionsForClip.knownActions;

			 action._byClipCacheIndex = knownActions.length;
			 knownActions.push( action );

		 }

		 action._cacheIndex = actions.length;
		 actions.push( action );

		 actionsForClip.actionByRoot[ rootUuid ] = action;

	 }

	 _removeInactiveAction( action ) {

		 const actions = this._actions,
			 lastInactiveAction = actions[ actions.length - 1 ],
			 cacheIndex = action._cacheIndex;

		 lastInactiveAction._cacheIndex = cacheIndex;
		 actions[ cacheIndex ] = lastInactiveAction;
		 actions.pop();

		 action._cacheIndex = null;


		 const clipUuid = action._clip.uuid,
			 actionsByClip = this._actionsByClip,
			 actionsForClip = actionsByClip[ clipUuid ],
			 knownActionsForClip = actionsForClip.knownActions,

			 lastKnownAction =
				 knownActionsForClip[ knownActionsForClip.length - 1 ],

			 byClipCacheIndex = action._byClipCacheIndex;

		 lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		 knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		 knownActionsForClip.pop();

		 action._byClipCacheIndex = null;


		 const actionByRoot = actionsForClip.actionByRoot,
			 rootUuid = ( action._localRoot || this._root ).uuid;

		 delete actionByRoot[ rootUuid ];

		 if ( knownActionsForClip.length === 0 ) {

			 delete actionsByClip[ clipUuid ];

		 }

		 this._removeInactiveBindingsForAction( action );

	 }

	 _removeInactiveBindingsForAction( action ) {

		 const bindings = action._propertyBindings;

		 for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			 const binding = bindings[ i ];

			 if ( -- binding.referenceCount === 0 ) {

				 this._removeInactiveBinding( binding );

			 }

		 }

	 }

	 _lendAction( action ) {

		 // [ active actions |  inactive actions  ]
		 // [  active actions >| inactive actions ]
		 //                 s        a
		 //                  <-swap->
		 //                 a        s

		 const actions = this._actions,
			 prevIndex = action._cacheIndex,

			 lastActiveIndex = this._nActiveActions ++,

			 firstInactiveAction = actions[ lastActiveIndex ];

		 action._cacheIndex = lastActiveIndex;
		 actions[ lastActiveIndex ] = action;

		 firstInactiveAction._cacheIndex = prevIndex;
		 actions[ prevIndex ] = firstInactiveAction;

	 }

	 _takeBackAction( action ) {

		 // [  active actions  | inactive actions ]
		 // [ active actions |< inactive actions  ]
		 //        a        s
		 //         <-swap->
		 //        s        a

		 const actions = this._actions,
			 prevIndex = action._cacheIndex,

			 firstInactiveIndex = -- this._nActiveActions,

			 lastActiveAction = actions[ firstInactiveIndex ];

		 action._cacheIndex = firstInactiveIndex;
		 actions[ firstInactiveIndex ] = action;

		 lastActiveAction._cacheIndex = prevIndex;
		 actions[ prevIndex ] = lastActiveAction;

	 }

	 // Memory management for PropertyMixer objects

	 _addInactiveBinding( binding, rootUuid, trackName ) {

		 const bindingsByRoot = this._bindingsByRootAndName,
			 bindings = this._bindings;

		 let bindingByName = bindingsByRoot[ rootUuid ];

		 if ( bindingByName === undefined ) {

			 bindingByName = {};
			 bindingsByRoot[ rootUuid ] = bindingByName;

		 }

		 bindingByName[ trackName ] = binding;

		 binding._cacheIndex = bindings.length;
		 bindings.push( binding );

	 }

	 _removeInactiveBinding( binding ) {

		 const bindings = this._bindings,
			 propBinding = binding.binding,
			 rootUuid = propBinding.rootNode.uuid,
			 trackName = propBinding.path,
			 bindingsByRoot = this._bindingsByRootAndName,
			 bindingByName = bindingsByRoot[ rootUuid ],

			 lastInactiveBinding = bindings[ bindings.length - 1 ],
			 cacheIndex = binding._cacheIndex;

		 lastInactiveBinding._cacheIndex = cacheIndex;
		 bindings[ cacheIndex ] = lastInactiveBinding;
		 bindings.pop();

		 delete bindingByName[ trackName ];

		 if ( Object.keys( bindingByName ).length === 0 ) {

			 delete bindingsByRoot[ rootUuid ];

		 }

	 }

	 _lendBinding( binding ) {

		 const bindings = this._bindings,
			 prevIndex = binding._cacheIndex,

			 lastActiveIndex = this._nActiveBindings ++,

			 firstInactiveBinding = bindings[ lastActiveIndex ];

		 binding._cacheIndex = lastActiveIndex;
		 bindings[ lastActiveIndex ] = binding;

		 firstInactiveBinding._cacheIndex = prevIndex;
		 bindings[ prevIndex ] = firstInactiveBinding;

	 }

	 _takeBackBinding( binding ) {

		 const bindings = this._bindings,
			 prevIndex = binding._cacheIndex,

			 firstInactiveIndex = -- this._nActiveBindings,

			 lastActiveBinding = bindings[ firstInactiveIndex ];

		 binding._cacheIndex = firstInactiveIndex;
		 bindings[ firstInactiveIndex ] = binding;

		 lastActiveBinding._cacheIndex = prevIndex;
		 bindings[ prevIndex ] = lastActiveBinding;

	 }


	 // Memory management of Interpolants for weight and time scale

	 _lendControlInterpolant() {

		 const interpolants = this._controlInterpolants,
			 lastActiveIndex = this._nActiveControlInterpolants ++;

		 let interpolant = interpolants[ lastActiveIndex ];

		 if ( interpolant === undefined ) {

			 interpolant = new LinearInterpolant(
				 new Float32Array( 2 ), new Float32Array( 2 ),
				 1, this._controlInterpolantsResultBuffer );

			 interpolant.__cacheIndex = lastActiveIndex;
			 interpolants[ lastActiveIndex ] = interpolant;

		 }

		 return interpolant;

	 }

	 _takeBackControlInterpolant( interpolant ) {

		 const interpolants = this._controlInterpolants,
			 prevIndex = interpolant.__cacheIndex,

			 firstInactiveIndex = -- this._nActiveControlInterpolants,

			 lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		 interpolant.__cacheIndex = firstInactiveIndex;
		 interpolants[ firstInactiveIndex ] = interpolant;

		 lastActiveInterpolant.__cacheIndex = prevIndex;
		 interpolants[ prevIndex ] = lastActiveInterpolant;

	 }

	 // return an action for a clip optionally using a custom root target
	 // object (this method allocates a lot of dynamic memory in case a
	 // previously unknown clip/root combination is specified)
	 clipAction( clip, optionalRoot, blendMode ) {

		 const root = optionalRoot || this._root,
			 rootUuid = root.uuid;

		 let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		 const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		 const actionsForClip = this._actionsByClip[ clipUuid ];
		 let prototypeAction = null;

		 if ( blendMode === undefined ) {

			 if ( clipObject !== null ) {

				 blendMode = clipObject.blendMode;

			 } else {

				 blendMode = NormalAnimationBlendMode;

			 }

		 }

		 if ( actionsForClip !== undefined ) {

			 const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			 if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				 return existingAction;

			 }

			 // we know the clip, so we don't have to parse all
			 // the bindings again but can just copy
			 prototypeAction = actionsForClip.knownActions[ 0 ];

			 // also, take the clip from the prototype action
			 if ( clipObject === null )
				 clipObject = prototypeAction._clip;

		 }

		 // clip must be known when specified via string
		 if ( clipObject === null ) return null;

		 // allocate all resources required to run it
		 const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		 this._bindAction( newAction, prototypeAction );

		 // and make the action known to the memory manager
		 this._addInactiveAction( newAction, clipUuid, rootUuid );

		 return newAction;

	 }

	 // get an existing action
	 existingAction( clip, optionalRoot ) {

		 const root = optionalRoot || this._root,
			 rootUuid = root.uuid,

			 clipObject = typeof clip === 'string' ?
				 AnimationClip.findByName( root, clip ) : clip,

			 clipUuid = clipObject ? clipObject.uuid : clip,

			 actionsForClip = this._actionsByClip[ clipUuid ];

		 if ( actionsForClip !== undefined ) {

			 return actionsForClip.actionByRoot[ rootUuid ] || null;

		 }

		 return null;

	 }

	 // deactivates all previously scheduled actions
	 stopAllAction() {

		 const actions = this._actions,
			 nActions = this._nActiveActions;

		 for ( let i = nActions - 1; i >= 0; -- i ) {

			 actions[ i ].stop();

		 }

		 return this;

	 }

	 // advance the time and update apply the animation
	 update( deltaTime ) {

		 deltaTime *= this.timeScale;

		 const actions = this._actions,
			 nActions = this._nActiveActions,

			 time = this.time += deltaTime,
			 timeDirection = Math.sign( deltaTime ),

			 accuIndex = this._accuIndex ^= 1;

		 // run active actions

		 for ( let i = 0; i !== nActions; ++ i ) {

			 const action = actions[ i ];

			 action._update( time, deltaTime, timeDirection, accuIndex );

		 }

		 // update scene graph

		 const bindings = this._bindings,
			 nBindings = this._nActiveBindings;

		 for ( let i = 0; i !== nBindings; ++ i ) {

			 bindings[ i ].apply( accuIndex );

		 }

		 return this;

	 }

	 // Allows you to seek to a specific time in an animation.
	 setTime( timeInSeconds ) {

		 this.time = 0; // Zero out time attribute for AnimationMixer object;
		 for ( let i = 0; i < this._actions.length; i ++ ) {

			 this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		 }

		 return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	 }

	 // return this mixer's root target object
	 getRoot() {

		 return this._root;

	 }

	 // free all resources specific to a particular clip
	 uncacheClip( clip ) {

		 const actions = this._actions,
			 clipUuid = clip.uuid,
			 actionsByClip = this._actionsByClip,
			 actionsForClip = actionsByClip[ clipUuid ];

		 if ( actionsForClip !== undefined ) {

			 // note: just calling _removeInactiveAction would mess up the
			 // iteration state and also require updating the state we can
			 // just throw away

			 const actionsToRemove = actionsForClip.knownActions;

			 for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				 const action = actionsToRemove[ i ];

				 this._deactivateAction( action );

				 const cacheIndex = action._cacheIndex,
					 lastInactiveAction = actions[ actions.length - 1 ];

				 action._cacheIndex = null;
				 action._byClipCacheIndex = null;

				 lastInactiveAction._cacheIndex = cacheIndex;
				 actions[ cacheIndex ] = lastInactiveAction;
				 actions.pop();

				 this._removeInactiveBindingsForAction( action );

			 }

			 delete actionsByClip[ clipUuid ];

		 }

	 }

	 // free all resources specific to a particular root target object
	 uncacheRoot( root ) {

		 const rootUuid = root.uuid,
			 actionsByClip = this._actionsByClip;

		 for ( const clipUuid in actionsByClip ) {

			 const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				 action = actionByRoot[ rootUuid ];

			 if ( action !== undefined ) {

				 this._deactivateAction( action );
				 this._removeInactiveAction( action );

			 }

		 }

		 const bindingsByRoot = this._bindingsByRootAndName,
			 bindingByName = bindingsByRoot[ rootUuid ];

		 if ( bindingByName !== undefined ) {

			 for ( const trackName in bindingByName ) {

				 const binding = bindingByName[ trackName ];
				 binding.restoreOriginalState();
				 this._removeInactiveBinding( binding );

			 }

		 }

	 }

	 // remove a targeted clip from the cache
	 uncacheAction( clip, optionalRoot ) {

		 const action = this.existingAction( clip, optionalRoot );

		 if ( action !== null ) {

			 this._deactivateAction( action );
			 this._removeInactiveAction( action );

		 }

	 }

 }

 AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

 class InstancedInterleavedBuffer extends InterleavedBuffer {

	 constructor( array, stride, meshPerAttribute = 1 ) {

		 super( array, stride );

		 this.meshPerAttribute = meshPerAttribute;

	 }

	 copy( source ) {

		 super.copy( source );

		 this.meshPerAttribute = source.meshPerAttribute;

		 return this;

	 }

	 clone( data ) {

		 const ib = super.clone( data );

		 ib.meshPerAttribute = this.meshPerAttribute;

		 return ib;

	 }

	 toJSON( data ) {

		 const json = super.toJSON( data );

		 json.isInstancedInterleavedBuffer = true;
		 json.meshPerAttribute = this.meshPerAttribute;

		 return json;

	 }

 }

 InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

 class ImmediateRenderObject extends Object3D {

	 constructor( material ) {

		 super();

		 this.material = material;
		 this.render = function ( /* renderCallback */ ) {};

		 this.hasPositions = false;
		 this.hasNormals = false;
		 this.hasColors = false;
		 this.hasUvs = false;

		 this.positionArray = null;
		 this.normalArray = null;
		 this.colorArray = null;
		 this.uvArray = null;

		 this.count = 0;

	 }

 }

 ImmediateRenderObject.prototype.isImmediateRenderObject = true;

 const _vector$2 = /*@__PURE__*/ new Vector3();
 const _boneMatrix = /*@__PURE__*/ new Matrix4();
 const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


 class SkeletonHelper extends LineSegments {

	 constructor( object ) {

		 const bones = getBoneList( object );

		 const geometry = new BufferGeometry();

		 const vertices = [];
		 const colors = [];

		 const color1 = new Color$1( 0, 0, 1 );
		 const color2 = new Color$1( 0, 1, 0 );

		 for ( let i = 0; i < bones.length; i ++ ) {

			 const bone = bones[ i ];

			 if ( bone.parent && bone.parent.isBone ) {

				 vertices.push( 0, 0, 0 );
				 vertices.push( 0, 0, 0 );
				 colors.push( color1.r, color1.g, color1.b );
				 colors.push( color2.r, color2.g, color2.b );

			 }

		 }

		 geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		 geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		 const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		 super( geometry, material );

		 this.type = 'SkeletonHelper';
		 this.isSkeletonHelper = true;

		 this.root = object;
		 this.bones = bones;

		 this.matrix = object.matrixWorld;
		 this.matrixAutoUpdate = false;

	 }

	 updateMatrixWorld( force ) {

		 const bones = this.bones;

		 const geometry = this.geometry;
		 const position = geometry.getAttribute( 'position' );

		 _matrixWorldInv.copy( this.root.matrixWorld ).invert();

		 for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			 const bone = bones[ i ];

			 if ( bone.parent && bone.parent.isBone ) {

				 _boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				 _vector$2.setFromMatrixPosition( _boneMatrix );
				 position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				 _boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				 _vector$2.setFromMatrixPosition( _boneMatrix );
				 position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				 j += 2;

			 }

		 }

		 geometry.getAttribute( 'position' ).needsUpdate = true;

		 super.updateMatrixWorld( force );

	 }

 }


 function getBoneList( object ) {

	 const boneList = [];

	 if ( object && object.isBone ) {

		 boneList.push( object );

	 }

	 for ( let i = 0; i < object.children.length; i ++ ) {

		 boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	 }

	 return boneList;

 }

 class GridHelper extends LineSegments {

	 constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		 color1 = new Color$1( color1 );
		 color2 = new Color$1( color2 );

		 const center = divisions / 2;
		 const step = size / divisions;
		 const halfSize = size / 2;

		 const vertices = [], colors = [];

		 for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			 vertices.push( - halfSize, 0, k, halfSize, 0, k );
			 vertices.push( k, 0, - halfSize, k, 0, halfSize );

			 const color = i === center ? color1 : color2;

			 color.toArray( colors, j ); j += 3;
			 color.toArray( colors, j ); j += 3;
			 color.toArray( colors, j ); j += 3;
			 color.toArray( colors, j ); j += 3;

		 }

		 const geometry = new BufferGeometry();
		 geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		 geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		 const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		 super( geometry, material );

		 this.type = 'GridHelper';

	 }

 }

 const _floatView = new Float32Array( 1 );
 new Int32Array( _floatView.buffer );

 const backgroundMaterial = new MeshBasicMaterial( {
	 side: BackSide,
	 depthWrite: false,
	 depthTest: false,
 } );
 new Mesh( new BoxGeometry(), backgroundMaterial );

 //

 Curve.create = function ( construct, getPoint ) {

	 console.log( 'THREE.Curve.create() has been deprecated' );

	 construct.prototype = Object.create( Curve.prototype );
	 construct.prototype.constructor = construct;
	 construct.prototype.getPoint = getPoint;

	 return construct;

 };

 //

 Path.prototype.fromPoints = function ( points ) {

	 console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
	 return this.setFromPoints( points );

 };

 GridHelper.prototype.setColors = function () {

	 console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

 };

 SkeletonHelper.prototype.update = function () {

	 console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

 };

 //

 Loader.prototype.extractUrlBase = function ( url ) {

	 console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
	 return LoaderUtils.extractUrlBase( url );

 };

 Loader.Handlers = {

	 add: function ( /* regex, loader */ ) {

		 console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	 },

	 get: function ( /* file */ ) {

		 console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	 }

 };

 //

 Box3.prototype.center = function ( optionalTarget ) {

	 console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
	 return this.getCenter( optionalTarget );

 };

 Box3.prototype.empty = function () {

	 console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
	 return this.isEmpty();

 };

 Box3.prototype.isIntersectionBox = function ( box ) {

	 console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
	 return this.intersectsBox( box );

 };

 Box3.prototype.isIntersectionSphere = function ( sphere ) {

	 console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	 return this.intersectsSphere( sphere );

 };

 Box3.prototype.size = function ( optionalTarget ) {

	 console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
	 return this.getSize( optionalTarget );

 };

 //

 Sphere.prototype.empty = function () {

	 console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
	 return this.isEmpty();

 };

 //

 Frustum.prototype.setFromMatrix = function ( m ) {

	 console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	 return this.setFromProjectionMatrix( m );

 };

 //

 Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

	 console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	 return this.toArray( array, offset );

 };

 Matrix3.prototype.multiplyVector3 = function ( vector ) {

	 console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
	 return vector.applyMatrix3( this );

 };

 Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

	 console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

 };

 Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

	 console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
	 return attribute.applyMatrix3( this );

 };

 Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	 console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

 };

 Matrix3.prototype.getInverse = function ( matrix ) {

	 console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	 return this.copy( matrix ).invert();

 };

 //

 Matrix4.prototype.extractPosition = function ( m ) {

	 console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
	 return this.copyPosition( m );

 };

 Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

	 console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	 return this.toArray( array, offset );

 };

 Matrix4.prototype.getPosition = function () {

	 console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	 return new Vector3().setFromMatrixColumn( this, 3 );

 };

 Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

	 console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	 return this.makeRotationFromQuaternion( q );

 };

 Matrix4.prototype.multiplyToArray = function () {

	 console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

 };

 Matrix4.prototype.multiplyVector3 = function ( vector ) {

	 console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	 return vector.applyMatrix4( this );

 };

 Matrix4.prototype.multiplyVector4 = function ( vector ) {

	 console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	 return vector.applyMatrix4( this );

 };

 Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

	 console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

 };

 Matrix4.prototype.rotateAxis = function ( v ) {

	 console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	 v.transformDirection( this );

 };

 Matrix4.prototype.crossVector = function ( vector ) {

	 console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	 return vector.applyMatrix4( this );

 };

 Matrix4.prototype.translate = function () {

	 console.error( 'THREE.Matrix4: .translate() has been removed.' );

 };

 Matrix4.prototype.rotateX = function () {

	 console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

 };

 Matrix4.prototype.rotateY = function () {

	 console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

 };

 Matrix4.prototype.rotateZ = function () {

	 console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

 };

 Matrix4.prototype.rotateByAxis = function () {

	 console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

 };

 Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

	 console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
	 return attribute.applyMatrix4( this );

 };

 Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	 console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

 };

 Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

	 console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
	 return this.makePerspective( left, right, top, bottom, near, far );

 };

 Matrix4.prototype.getInverse = function ( matrix ) {

	 console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	 return this.copy( matrix ).invert();

 };

 //

 Plane.prototype.isIntersectionLine = function ( line ) {

	 console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	 return this.intersectsLine( line );

 };

 //

 Quaternion.prototype.multiplyVector3 = function ( vector ) {

	 console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	 return vector.applyQuaternion( this );

 };

 Quaternion.prototype.inverse = function ( ) {

	 console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
	 return this.invert();

 };

 //

 Ray.prototype.isIntersectionBox = function ( box ) {

	 console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
	 return this.intersectsBox( box );

 };

 Ray.prototype.isIntersectionPlane = function ( plane ) {

	 console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
	 return this.intersectsPlane( plane );

 };

 Ray.prototype.isIntersectionSphere = function ( sphere ) {

	 console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	 return this.intersectsSphere( sphere );

 };

 //

 Triangle.prototype.area = function () {

	 console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
	 return this.getArea();

 };

 Triangle.prototype.barycoordFromPoint = function ( point, target ) {

	 console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	 return this.getBarycoord( point, target );

 };

 Triangle.prototype.midpoint = function ( target ) {

	 console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
	 return this.getMidpoint( target );

 };

 Triangle.prototypenormal = function ( target ) {

	 console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	 return this.getNormal( target );

 };

 Triangle.prototype.plane = function ( target ) {

	 console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
	 return this.getPlane( target );

 };

 Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

	 console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	 return Triangle.getBarycoord( point, a, b, c, target );

 };

 Triangle.normal = function ( a, b, c, target ) {

	 console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	 return Triangle.getNormal( a, b, c, target );

 };

 //

 Shape.prototype.extractAllPoints = function ( divisions ) {

	 console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
	 return this.extractPoints( divisions );

 };

 Shape.prototype.extrude = function ( options ) {

	 console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
	 return new ExtrudeGeometry( this, options );

 };

 Shape.prototype.makeGeometry = function ( options ) {

	 console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
	 return new ShapeGeometry( this, options );

 };

 //

 Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

	 console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	 return this.fromBufferAttribute( attribute, index, offset );

 };

 Vector2.prototype.distanceToManhattan = function ( v ) {

	 console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	 return this.manhattanDistanceTo( v );

 };

 Vector2.prototype.lengthManhattan = function () {

	 console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
	 return this.manhattanLength();

 };

 //

 Vector3.prototype.setEulerFromRotationMatrix = function () {

	 console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

 };

 Vector3.prototype.setEulerFromQuaternion = function () {

	 console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

 };

 Vector3.prototype.getPositionFromMatrix = function ( m ) {

	 console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	 return this.setFromMatrixPosition( m );

 };

 Vector3.prototype.getScaleFromMatrix = function ( m ) {

	 console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	 return this.setFromMatrixScale( m );

 };

 Vector3.prototype.getColumnFromMatrix = function ( index, matrix ) {

	 console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	 return this.setFromMatrixColumn( matrix, index );

 };

 Vector3.prototype.applyProjection = function ( m ) {

	 console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
	 return this.applyMatrix4( m );

 };

 Vector3.prototype.fromAttribute = function ( attribute, index, offset ) {

	 console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	 return this.fromBufferAttribute( attribute, index, offset );

 };

 Vector3.prototype.distanceToManhattan = function ( v ) {

	 console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	 return this.manhattanDistanceTo( v );

 };

 Vector3.prototype.lengthManhattan = function () {

	 console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
	 return this.manhattanLength();

 };

 //

 Vector4.prototype.fromAttribute = function ( attribute, index, offset ) {

	 console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	 return this.fromBufferAttribute( attribute, index, offset );

 };

 Vector4.prototype.lengthManhattan = function () {

	 console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
	 return this.manhattanLength();

 };

 //

 Object3D.prototype.getChildByName = function ( name ) {

	 console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
	 return this.getObjectByName( name );

 };

 Object3D.prototype.renderDepth = function () {

	 console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

 };

 Object3D.prototype.translate = function ( distance, axis ) {

	 console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
	 return this.translateOnAxis( axis, distance );

 };

 Object3D.prototype.getWorldRotation = function () {

	 console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

 };

 Object3D.prototype.applyMatrix = function ( matrix ) {

	 console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
	 return this.applyMatrix4( matrix );

 };

 Object.defineProperties( Object3D.prototype, {

	 eulerOrder: {
		 get: function () {

			 console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			 return this.rotation.order;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			 this.rotation.order = value;

		 }
	 },
	 useQuaternion: {
		 get: function () {

			 console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		 },
		 set: function () {

			 console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		 }
	 }

 } );

 Mesh.prototype.setDrawMode = function () {

	 console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

 };

 Object.defineProperties( Mesh.prototype, {

	 drawMode: {
		 get: function () {

			 console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			 return TrianglesDrawMode;

		 },
		 set: function () {

			 console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		 }
	 }

 } );

 SkinnedMesh.prototype.initBones = function () {

	 console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

 };

 //

 PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	 console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
			 'Use .setFocalLength and .filmGauge for a photographic setup.' );

	 if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	 this.setFocalLength( focalLength );

 };

 //

 Object.defineProperties( Light.prototype, {
	 onlyShadow: {
		 set: function () {

			 console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		 }
	 },
	 shadowCameraFov: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			 this.shadow.camera.fov = value;

		 }
	 },
	 shadowCameraLeft: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			 this.shadow.camera.left = value;

		 }
	 },
	 shadowCameraRight: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			 this.shadow.camera.right = value;

		 }
	 },
	 shadowCameraTop: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			 this.shadow.camera.top = value;

		 }
	 },
	 shadowCameraBottom: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			 this.shadow.camera.bottom = value;

		 }
	 },
	 shadowCameraNear: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			 this.shadow.camera.near = value;

		 }
	 },
	 shadowCameraFar: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			 this.shadow.camera.far = value;

		 }
	 },
	 shadowCameraVisible: {
		 set: function () {

			 console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		 }
	 },
	 shadowBias: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			 this.shadow.bias = value;

		 }
	 },
	 shadowDarkness: {
		 set: function () {

			 console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		 }
	 },
	 shadowMapWidth: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			 this.shadow.mapSize.width = value;

		 }
	 },
	 shadowMapHeight: {
		 set: function ( value ) {

			 console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			 this.shadow.mapSize.height = value;

		 }
	 }
 } );

 //

 Object.defineProperties( BufferAttribute.prototype, {

	 length: {
		 get: function () {

			 console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			 return this.array.length;

		 }
	 },
	 dynamic: {
		 get: function () {

			 console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			 return this.usage === DynamicDrawUsage;

		 },
		 set: function ( /* value */ ) {

			 console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			 this.setUsage( DynamicDrawUsage );

		 }
	 }

 } );

 BufferAttribute.prototype.setDynamic = function ( value ) {

	 console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	 this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	 return this;

 };

 BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

	 console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

 },

 BufferAttribute.prototype.setArray = function ( /* array */ ) {

	 console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

 };

 //

 BufferGeometry.prototype.addIndex = function ( index ) {

	 console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
	 this.setIndex( index );

 };

 BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

	 console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

	 if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

		 console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

		 return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

	 }

	 if ( name === 'index' ) {

		 console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
		 this.setIndex( attribute );

		 return this;

	 }

	 return this.setAttribute( name, attribute );

 };

 BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

	 if ( indexOffset !== undefined ) {

		 console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

	 }

	 console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
	 this.addGroup( start, count );

 };

 BufferGeometry.prototype.clearDrawCalls = function () {

	 console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
	 this.clearGroups();

 };

 BufferGeometry.prototype.computeOffsets = function () {

	 console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

 };

 BufferGeometry.prototype.removeAttribute = function ( name ) {

	 console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

	 return this.deleteAttribute( name );

 };

 BufferGeometry.prototype.applyMatrix = function ( matrix ) {

	 console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
	 return this.applyMatrix4( matrix );

 };

 Object.defineProperties( BufferGeometry.prototype, {

	 drawcalls: {
		 get: function () {

			 console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			 return this.groups;

		 }
	 },
	 offsets: {
		 get: function () {

			 console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			 return this.groups;

		 }
	 }

 } );

 InterleavedBuffer.prototype.setDynamic = function ( value ) {

	 console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	 this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	 return this;

 };

 InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

	 console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

 };

 //

 ExtrudeGeometry.prototype.getArrays = function () {

	 console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

 };

 ExtrudeGeometry.prototype.addShapeList = function () {

	 console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

 };

 ExtrudeGeometry.prototype.addShape = function () {

	 console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

 };

 //

 Scene.prototype.dispose = function () {

	 console.error( 'THREE.Scene: .dispose() has been removed.' );

 };

 //

 Object.defineProperties( Material.prototype, {

	 wrapAround: {
		 get: function () {

			 console.warn( 'THREE.Material: .wrapAround has been removed.' );

		 },
		 set: function () {

			 console.warn( 'THREE.Material: .wrapAround has been removed.' );

		 }
	 },

	 overdraw: {
		 get: function () {

			 console.warn( 'THREE.Material: .overdraw has been removed.' );

		 },
		 set: function () {

			 console.warn( 'THREE.Material: .overdraw has been removed.' );

		 }
	 },

	 wrapRGB: {
		 get: function () {

			 console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			 return new Color$1();

		 }
	 },

	 shading: {
		 get: function () {

			 console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			 this.flatShading = ( value === FlatShading );

		 }
	 },

	 stencilMask: {
		 get: function () {

			 console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			 return this.stencilFuncMask;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			 this.stencilFuncMask = value;

		 }
	 }

 } );

 Object.defineProperties( ShaderMaterial.prototype, {

	 derivatives: {
		 get: function () {

			 console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			 return this.extensions.derivatives;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			 this.extensions.derivatives = value;

		 }
	 }

 } );

 //

 WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

	 console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
	 this.setRenderTarget( renderTarget );
	 this.clear( color, depth, stencil );

 };

 WebGLRenderer.prototype.animate = function ( callback ) {

	 console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
	 this.setAnimationLoop( callback );

 };

 WebGLRenderer.prototype.getCurrentRenderTarget = function () {

	 console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
	 return this.getRenderTarget();

 };

 WebGLRenderer.prototype.getMaxAnisotropy = function () {

	 console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
	 return this.capabilities.getMaxAnisotropy();

 };

 WebGLRenderer.prototype.getPrecision = function () {

	 console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
	 return this.capabilities.precision;

 };

 WebGLRenderer.prototype.resetGLState = function () {

	 console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
	 return this.state.reset();

 };

 WebGLRenderer.prototype.supportsFloatTextures = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
	 return this.extensions.get( 'OES_texture_float' );

 };

 WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
	 return this.extensions.get( 'OES_texture_half_float' );

 };

 WebGLRenderer.prototype.supportsStandardDerivatives = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
	 return this.extensions.get( 'OES_standard_derivatives' );

 };

 WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
	 return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

 };

 WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
	 return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

 };

 WebGLRenderer.prototype.supportsBlendMinMax = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
	 return this.extensions.get( 'EXT_blend_minmax' );

 };

 WebGLRenderer.prototype.supportsVertexTextures = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
	 return this.capabilities.vertexTextures;

 };

 WebGLRenderer.prototype.supportsInstancedArrays = function () {

	 console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
	 return this.extensions.get( 'ANGLE_instanced_arrays' );

 };

 WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

	 console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
	 this.setScissorTest( boolean );

 };

 WebGLRenderer.prototype.initMaterial = function () {

	 console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

 };

 WebGLRenderer.prototype.addPrePlugin = function () {

	 console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

 };

 WebGLRenderer.prototype.addPostPlugin = function () {

	 console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

 };

 WebGLRenderer.prototype.updateShadowMap = function () {

	 console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

 };

 WebGLRenderer.prototype.setFaceCulling = function () {

	 console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

 };

 WebGLRenderer.prototype.allocTextureUnit = function () {

	 console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

 };

 WebGLRenderer.prototype.setTexture = function () {

	 console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

 };

 WebGLRenderer.prototype.setTexture2D = function () {

	 console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

 };

 WebGLRenderer.prototype.setTextureCube = function () {

	 console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

 };

 WebGLRenderer.prototype.getActiveMipMapLevel = function () {

	 console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
	 return this.getActiveMipmapLevel();

 };

 Object.defineProperties( WebGLRenderer.prototype, {

	 shadowMapEnabled: {
		 get: function () {

			 return this.shadowMap.enabled;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			 this.shadowMap.enabled = value;

		 }
	 },
	 shadowMapType: {
		 get: function () {

			 return this.shadowMap.type;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			 this.shadowMap.type = value;

		 }
	 },
	 shadowMapCullFace: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function ( /* value */ ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		 }
	 },
	 context: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			 return this.getContext();

		 }
	 },
	 vr: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			 return this.xr;

		 }
	 },
	 gammaInput: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			 return false;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		 }
	 },
	 gammaOutput: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			 return false;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			 this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		 }
	 },
	 toneMappingWhitePoint: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			 return 1.0;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		 }
	 },

 } );

 Object.defineProperties( WebGLShadowMap.prototype, {

	 cullFace: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function ( /* cullFace */ ) {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		 }
	 },
	 renderReverseSided: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		 }
	 },
	 renderSingleSided: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			 return undefined;

		 },
		 set: function () {

			 console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		 }
	 }

 } );

 //

 Object.defineProperties( WebGLRenderTarget.prototype, {

	 wrapS: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			 return this.texture.wrapS;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			 this.texture.wrapS = value;

		 }
	 },
	 wrapT: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			 return this.texture.wrapT;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			 this.texture.wrapT = value;

		 }
	 },
	 magFilter: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			 return this.texture.magFilter;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			 this.texture.magFilter = value;

		 }
	 },
	 minFilter: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			 return this.texture.minFilter;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			 this.texture.minFilter = value;

		 }
	 },
	 anisotropy: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			 return this.texture.anisotropy;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			 this.texture.anisotropy = value;

		 }
	 },
	 offset: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			 return this.texture.offset;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			 this.texture.offset = value;

		 }
	 },
	 repeat: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			 return this.texture.repeat;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			 this.texture.repeat = value;

		 }
	 },
	 format: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			 return this.texture.format;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			 this.texture.format = value;

		 }
	 },
	 type: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			 return this.texture.type;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			 this.texture.type = value;

		 }
	 },
	 generateMipmaps: {
		 get: function () {

			 console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			 return this.texture.generateMipmaps;

		 },
		 set: function ( value ) {

			 console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			 this.texture.generateMipmaps = value;

		 }
	 }

 } );

 //

 Audio.prototype.load = function ( file ) {

	 console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	 const scope = this;
	 const audioLoader = new AudioLoader();
	 audioLoader.load( file, function ( buffer ) {

		 scope.setBuffer( buffer );

	 } );
	 return this;

 };

 //

 CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	 console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	 return this.update( renderer, scene );

 };

 CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

	 console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	 return this.renderTarget.clear( renderer, color, depth, stencil );

 };

 ImageUtils.crossOrigin = undefined;

 ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	 console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	 const loader = new TextureLoader();
	 loader.setCrossOrigin( this.crossOrigin );

	 const texture = loader.load( url, onLoad, undefined, onError );

	 if ( mapping ) texture.mapping = mapping;

	 return texture;

 };

 ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	 console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	 const loader = new CubeTextureLoader();
	 loader.setCrossOrigin( this.crossOrigin );

	 const texture = loader.load( urls, onLoad, undefined, onError );

	 if ( mapping ) texture.mapping = mapping;

	 return texture;

 };

 ImageUtils.loadCompressedTexture = function () {

	 console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

 };

 ImageUtils.loadCompressedTextureCube = function () {

	 console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

 };

 if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	 /* eslint-disable no-undef */
	 __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		 revision: REVISION,
	 } } ) );
	 /* eslint-enable no-undef */

 }

 if ( typeof window !== 'undefined' ) {

	 if ( window.__THREE__ ) {

		 console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	 } else {

		 window.__THREE__ = REVISION;

	 }

 }

class SceneManagerImpl extends Emitter {
  constructor() {
    super();
    this.currentScene;
    this.clock = new Clock(false);
    this.renderer;
    this.camera;
    this.scene;
    this.composer;
    this.fxaa;
    this.renderTargets;
    this.tomi;
    this.assets = {};
    this._loader = new GLTFLoader();
    this.speech =  new TTS({voice: 0});
    this._reflect;//  = new THREE.WebGLCubeRenderTarget( 128, { format: THREE.RGBFormat, generateMipmaps: true, minFilter:THREE.LinearMipmapLinearFilter } );
    this.ioc;
  }

  addObjects(sce) {
    if (sce.name === 'Scene') {
      if (sce.children.length) {
        sce.children.forEach(child => {
          this.scene.add(child);
        });
      }
    }
  }

  speak(txt) {
    this.speech.speak(txt);
  }

  async setup(target = "#app", props = undefined) {
    const build = await setupWebGL(target, props);
    if (build) {
      this.camera = build.camera;
      this.renderer = build.renderer;
      this.scene = build.scene;
     
      setupLightings(this.scene);
      const { composer, fxaa } = postEffects(
        this.renderer,
        this.scene,
        this.camera,
        null
      );
      this.composer = composer;
      this.fxaa = fxaa;
    } else {
      console.warn("setupGLError");
    }
    this.scene = build.scene;
    this.controls = setupControls(
      this.camera,
      this.scene,
      "#app",
      this.renderer
    );
     
    return build;
  }

  _onResize(e) {
    const parent = this.renderer.domElement.parentNode;
    console.log(parent);
    const w = parent.offsetWidth || parent.clientWidth;
    
    const h = parent.offsetHeight || parent.clientHeight;
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    if (this.renderer) this.renderer.setSize(w, h);
    if (this.composer) {
      this.composer.setSize(w, h);
    }

    const pixelRatio = this.renderer.getPixelRatio();

    if (this.fxaa) {
      this.fxaa.material.uniforms["resolution"].value.x = 1 / (w * pixelRatio);
      this.fxaa.material.uniforms["resolution"].value.y = 1 / (h * pixelRatio);
    }
  }

  async loadAssets(src) {
    const sources = src;
    return await new Promise((res, rej) => {
      let counter = 0;
      let arr = [];
      src[counter];

      const loader = this._loader;
      const self = this;
      const loadModel = (s) => {
        // arr[src] =  {src: src, scene: null, id: i};
        self.emit("loadbegin", s);
        loader.load(s, loadComplete, loadProgress, loadError);
      };

      const loadComplete = (event) => {

        //arr[sources[counter]] = event;
        self.emit("loadcomplete", event);
        arr.push(event);
        if (counter < sources.length - 1) {
          counter++;
          loadModel(sources[counter]);
        } else {
          self.emit("loadfinished", arr);
        }
      };
      const loadProgress = (event) => this.emit("loadprogress", event);
      const loadError = (event) => this.emit("loaderror", event);


      loadModel(src[counter]);
    });
  }

  play() {
    //window.addEventListener('resize', this._onResize.bind(this), false);
    this.clock.start();
    this.renderer.shadowMap.needsUpdate = true;
    createjs.Ticker.timingMode = createjs.Ticker.RAF;
    createjs.Ticker.addEventListener("tick", this._onRender.bind(this));
   
  }

  stop() {
    //window.removeEventListener('resize', this._onResize.bind(this));
    this.clock.stop();
    createjs.Ticker.removeEventListener("tick", this._onRender.bind(this));
  }

  _onRender(ms) {
    const delta = this.clock.getDelta();
    const elapsed = this.clock.getElapsedTime();
    this.emit("beforeRender", delta, elapsed);
    if (this.tomi) this.tomi.update(delta, elapsed);

    if (this.controls) this.controls.update();
     
    if (this.composer) {
      this.composer.render();
    }

    this.emit('afterRender', delta, elapsed);
  }
}

const RendererProps = {
  antialias: false,
  alpha: false,
  depth: true,
  autoRender: false,
  autoClear: false,
  pixelRatio: window.devicePixelRatio,
};

const setupWebGL = async (target = "#app", props = undefined) => {
  const el = document.querySelector(target);
  const build = await setupScene(target, "tm-three", {
    resizeTo: el,
    ...RendererProps,
    ...props,
  });

  return build;
};

const setupLightings = (scene, sun = 1.8, ambient = 1.8, shadow = 1024) => {
  const light = new AmbientLight$1(0xffffff, ambient);
  createHelper(light, () => new PointLightHelper(light, 0.2, 0xffff00));

  const hemi = new HemisphereLight(0xffffff, 0xB65D27, 0.5);
  scene.add(hemi);
  light.position.set(0, 4, 2);

  const sunl = new DirectionalLight$1(0xffffff, sun);
  // const sunH = new THREE.DirectionalLightHelper(sunl, 1, 0xffff00);
  // sunl.add(sunH);

  sunl.position.set(1, 4, 1);
  sunl.lookAt(0, 0, 0);
  sunl.castShadow = true;

  scene.add(sunl);
  scene.add(light);

  if (shadow) {
    sunl.shadow.bias = -0.0001;
    sunl.shadow.mapSize.width = shadow;
    sunl.shadow.mapSize.height = shadow;
    sunl.shadow.camera.near = 0;
    sunl.shadow.camera.far = 500;
  }

  return {
    sunl,
    ambient,
  };
};

function createHelper(object, helperType = undefined) {
  let helper;
  if (helperType) {
    helper = helperType();
    helper.layers.set(7);
    object.add(helper);
  } else {
    const b = new Box3$1().setFromObject(object);
    b.getSize(new Vector3$1());
    helper.layers.set(7);
    object.add(helper);
  }

  return object;
}

const SceneManager = new SceneManagerImpl();

class GLTFExporter {

	constructor() {

		this.pluginCallbacks = [];

		this.register( function ( writer ) {

			return new GLTFLightExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsUnlitExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsPBRSpecularGlossiness( writer );

		} );

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	/**
	 * Parse scenes and generate GLTF output
	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
	 * @param  {Function} onDone  Callback on completed
	 * @param  {Object} options options
	 */
	parse( input, onDone, options ) {

		const writer = new GLTFWriter();
		const plugins = [];

		for ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {

			plugins.push( this.pluginCallbacks[ i ]( writer ) );

		}

		writer.setPlugins( plugins );
		writer.write( input, onDone, options );

	}

}

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const WEBGL_CONSTANTS = {
	POINTS: 0x0000,
	LINES: 0x0001,
	LINE_LOOP: 0x0002,
	LINE_STRIP: 0x0003,
	TRIANGLES: 0x0004,
	TRIANGLE_STRIP: 0x0005,
	TRIANGLE_FAN: 0x0006,

	UNSIGNED_BYTE: 0x1401,
	UNSIGNED_SHORT: 0x1403,
	FLOAT: 0x1406,
	UNSIGNED_INT: 0x1405,
	ARRAY_BUFFER: 0x8892,
	ELEMENT_ARRAY_BUFFER: 0x8893,

	NEAREST: 0x2600,
	LINEAR: 0x2601,
	NEAREST_MIPMAP_NEAREST: 0x2700,
	LINEAR_MIPMAP_NEAREST: 0x2701,
	NEAREST_MIPMAP_LINEAR: 0x2702,
	LINEAR_MIPMAP_LINEAR: 0x2703,

	CLAMP_TO_EDGE: 33071,
	MIRRORED_REPEAT: 33648,
	REPEAT: 10497
};

const THREE_TO_WEBGL = {};

THREE_TO_WEBGL[ NearestFilter$1 ] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[ NearestMipmapNearestFilter$1 ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[ NearestMipmapLinearFilter$1 ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[ LinearFilter$1 ] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[ LinearMipmapNearestFilter$1 ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[ LinearMipmapLinearFilter$1 ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;

THREE_TO_WEBGL[ ClampToEdgeWrapping$1 ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[ RepeatWrapping$1 ] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[ MirroredRepeatWrapping$1 ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;

const PATH_PROPERTIES = {
	scale: 'scale',
	position: 'translation',
	quaternion: 'rotation',
	morphTargetInfluences: 'weights'
};

// GLB constants
// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

const GLB_HEADER_BYTES = 12;
const GLB_HEADER_MAGIC = 0x46546C67;
const GLB_VERSION = 2;

const GLB_CHUNK_PREFIX_BYTES = 8;
const GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
const GLB_CHUNK_TYPE_BIN = 0x004E4942;

//------------------------------------------------------------------------------
// Utility functions
//------------------------------------------------------------------------------

/**
 * Compare two arrays
 * @param  {Array} array1 Array 1 to compare
 * @param  {Array} array2 Array 2 to compare
 * @return {Boolean}        Returns true if both arrays are equal
 */
function equalArray( array1, array2 ) {

	return ( array1.length === array2.length ) && array1.every( function ( element, index ) {

		return element === array2[ index ];

	} );

}

/**
 * Converts a string to an ArrayBuffer.
 * @param  {string} text
 * @return {ArrayBuffer}
 */
function stringToArrayBuffer( text ) {

	if ( window.TextEncoder !== undefined ) {

		return new TextEncoder().encode( text ).buffer;

	}

	const array = new Uint8Array( new ArrayBuffer( text.length ) );

	for ( let i = 0, il = text.length; i < il; i ++ ) {

		const value = text.charCodeAt( i );

		// Replacing multi-byte character with space(0x20).
		array[ i ] = value > 0xFF ? 0x20 : value;

	}

	return array.buffer;

}

/**
 * Is identity matrix
 *
 * @param {Matrix4} matrix
 * @returns {Boolean} Returns true, if parameter is identity matrix
 */
function isIdentityMatrix( matrix ) {

	return equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );

}

/**
 * Get the min and max vectors from the given attribute
 * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
 * @param  {Integer} start
 * @param  {Integer} count
 * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
 */
function getMinMax( attribute, start, count ) {

	const output = {

		min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
		max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )

	};

	for ( let i = start; i < start + count; i ++ ) {

		for ( let a = 0; a < attribute.itemSize; a ++ ) {

			let value;

			if ( attribute.itemSize > 4 ) {

				 // no support for interleaved data for itemSize > 4

				value = attribute.array[ i * attribute.itemSize + a ];

			} else {

				if ( a === 0 ) value = attribute.getX( i );
				else if ( a === 1 ) value = attribute.getY( i );
				else if ( a === 2 ) value = attribute.getZ( i );
				else if ( a === 3 ) value = attribute.getW( i );

			}

			output.min[ a ] = Math.min( output.min[ a ], value );
			output.max[ a ] = Math.max( output.max[ a ], value );

		}

	}

	return output;

}

/**
 * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
 * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
 *
 * @param {Integer} bufferSize The size the original buffer.
 * @returns {Integer} new buffer size with required padding.
 *
 */
function getPaddedBufferSize( bufferSize ) {

	return Math.ceil( bufferSize / 4 ) * 4;

}

/**
 * Returns a buffer aligned to 4-byte boundary.
 *
 * @param {ArrayBuffer} arrayBuffer Buffer to pad
 * @param {Integer} paddingByte (Optional)
 * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
 */
function getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {

	const paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );

	if ( paddedLength !== arrayBuffer.byteLength ) {

		const array = new Uint8Array( paddedLength );
		array.set( new Uint8Array( arrayBuffer ) );

		if ( paddingByte !== 0 ) {

			for ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {

				array[ i ] = paddingByte;

			}

		}

		return array.buffer;

	}

	return arrayBuffer;

}

let cachedCanvas = null;

/**
 * Writer
 */
class GLTFWriter {

	constructor() {

		this.plugins = [];

		this.options = {};
		this.pending = [];
		this.buffers = [];

		this.byteOffset = 0;
		this.buffers = [];
		this.nodeMap = new Map();
		this.skins = [];
		this.extensionsUsed = {};

		this.uids = new Map();
		this.uid = 0;

		this.json = {
			asset: {
				version: '2.0',
				generator: 'THREE.GLTFExporter'
			}
		};

		this.cache = {
			meshes: new Map(),
			attributes: new Map(),
			attributesNormalized: new Map(),
			materials: new Map(),
			textures: new Map(),
			images: new Map()
		};

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	/**
	 * Parse scenes and generate GLTF output
	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
	 * @param  {Function} onDone  Callback on completed
	 * @param  {Object} options options
	 */
	write( input, onDone, options ) {

		this.options = Object.assign( {}, {
			// default options
			binary: false,
			trs: false,
			onlyVisible: true,
			truncateDrawRange: true,
			embedImages: true,
			maxTextureSize: Infinity,
			animations: [],
			includeCustomExtensions: false
		}, options );

		if ( this.options.animations.length > 0 ) {

			// Only TRS properties, and not matrices, may be targeted by animation.
			this.options.trs = true;

		}

		this.processInput( input );

		const writer = this;

		Promise.all( this.pending ).then( function () {

			const buffers = writer.buffers;
			const json = writer.json;
			const options = writer.options;
			const extensionsUsed = writer.extensionsUsed;

			// Merge buffers.
			const blob = new Blob( buffers, { type: 'application/octet-stream' } );

			// Declare extensions.
			const extensionsUsedList = Object.keys( extensionsUsed );

			if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;

			// Update bytelength of the single buffer.
			if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

			if ( options.binary === true ) {

				// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

				const reader = new window.FileReader();
				reader.readAsArrayBuffer( blob );
				reader.onloadend = function () {

					// Binary chunk.
					const binaryChunk = getPaddedArrayBuffer( reader.result );
					const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
					binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );
					binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );

					// JSON chunk.
					const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );
					const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
					jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );
					jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );

					// GLB header.
					const header = new ArrayBuffer( GLB_HEADER_BYTES );
					const headerView = new DataView( header );
					headerView.setUint32( 0, GLB_HEADER_MAGIC, true );
					headerView.setUint32( 4, GLB_VERSION, true );
					const totalByteLength = GLB_HEADER_BYTES
						+ jsonChunkPrefix.byteLength + jsonChunk.byteLength
						+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;
					headerView.setUint32( 8, totalByteLength, true );

					const glbBlob = new Blob( [
						header,
						jsonChunkPrefix,
						jsonChunk,
						binaryChunkPrefix,
						binaryChunk
					], { type: 'application/octet-stream' } );

					const glbReader = new window.FileReader();
					glbReader.readAsArrayBuffer( glbBlob );
					glbReader.onloadend = function () {

						onDone( glbReader.result );

					};

				};

			} else {

				if ( json.buffers && json.buffers.length > 0 ) {

					const reader = new window.FileReader();
					reader.readAsDataURL( blob );
					reader.onloadend = function () {

						const base64data = reader.result;
						json.buffers[ 0 ].uri = base64data;
						onDone( json );

					};

				} else {

					onDone( json );

				}

			}

		} );

	}

	/**
	 * Serializes a userData.
	 *
	 * @param {THREE.Object3D|THREE.Material} object
	 * @param {Object} objectDef
	 */
	serializeUserData( object, objectDef ) {

		if ( Object.keys( object.userData ).length === 0 ) return;

		const options = this.options;
		const extensionsUsed = this.extensionsUsed;

		try {

			const json = JSON.parse( JSON.stringify( object.userData ) );

			if ( options.includeCustomExtensions && json.gltfExtensions ) {

				if ( objectDef.extensions === undefined ) objectDef.extensions = {};

				for ( const extensionName in json.gltfExtensions ) {

					objectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];
					extensionsUsed[ extensionName ] = true;

				}

				delete json.gltfExtensions;

			}

			if ( Object.keys( json ).length > 0 ) objectDef.extras = json;

		} catch ( error ) {

			console.warn( 'THREE.GLTFExporter: userData of \'' + object.name + '\' ' +
				'won\'t be serialized because of JSON.stringify error - ' + error.message );

		}

	}

	/**
	 * Assign and return a temporal unique id for an object
	 * especially which doesn't have .uuid
	 * @param  {Object} object
	 * @return {Integer}
	 */
	getUID( object ) {

		if ( ! this.uids.has( object ) ) this.uids.set( object, this.uid ++ );

		return this.uids.get( object );

	}

	/**
	 * Checks if normal attribute values are normalized.
	 *
	 * @param {BufferAttribute} normal
	 * @returns {Boolean}
	 */
	isNormalizedNormalAttribute( normal ) {

		const cache = this.cache;

		if ( cache.attributesNormalized.has( normal ) ) return false;

		const v = new Vector3$1();

		for ( let i = 0, il = normal.count; i < il; i ++ ) {

			// 0.0005 is from glTF-validator
			if ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;

		}

		return true;

	}

	/**
	 * Creates normalized normal buffer attribute.
	 *
	 * @param {BufferAttribute} normal
	 * @returns {BufferAttribute}
	 *
	 */
	createNormalizedNormalAttribute( normal ) {

		const cache = this.cache;

		if ( cache.attributesNormalized.has( normal ) )	return cache.attributesNormalized.get( normal );

		const attribute = normal.clone();
		const v = new Vector3$1();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			v.fromBufferAttribute( attribute, i );

			if ( v.x === 0 && v.y === 0 && v.z === 0 ) {

				// if values can't be normalized set (1, 0, 0)
				v.setX( 1.0 );

			} else {

				v.normalize();

			}

			attribute.setXYZ( i, v.x, v.y, v.z );

		}

		cache.attributesNormalized.set( normal, attribute );

		return attribute;

	}

	/**
	 * Applies a texture transform, if present, to the map definition. Requires
	 * the KHR_texture_transform extension.
	 *
	 * @param {Object} mapDef
	 * @param {THREE.Texture} texture
	 */
	applyTextureTransform( mapDef, texture ) {

		let didTransform = false;
		const transformDef = {};

		if ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {

			transformDef.offset = texture.offset.toArray();
			didTransform = true;

		}

		if ( texture.rotation !== 0 ) {

			transformDef.rotation = texture.rotation;
			didTransform = true;

		}

		if ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {

			transformDef.scale = texture.repeat.toArray();
			didTransform = true;

		}

		if ( didTransform ) {

			mapDef.extensions = mapDef.extensions || {};
			mapDef.extensions[ 'KHR_texture_transform' ] = transformDef;
			this.extensionsUsed[ 'KHR_texture_transform' ] = true;

		}

	}

	/**
	 * Process a buffer to append to the default one.
	 * @param  {ArrayBuffer} buffer
	 * @return {Integer}
	 */
	processBuffer( buffer ) {

		const json = this.json;
		const buffers = this.buffers;

		if ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];

		// All buffers are merged before export.
		buffers.push( buffer );

		return 0;

	}

	/**
	 * Process and generate a BufferView
	 * @param  {BufferAttribute} attribute
	 * @param  {number} componentType
	 * @param  {number} start
	 * @param  {number} count
	 * @param  {number} target (Optional) Target usage of the BufferView
	 * @return {Object}
	 */
	processBufferView( attribute, componentType, start, count, target ) {

		const json = this.json;

		if ( ! json.bufferViews ) json.bufferViews = [];

		// Create a new dataview and dump the attribute's array into it

		let componentSize;

		if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

			componentSize = 1;

		} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

			componentSize = 2;

		} else {

			componentSize = 4;

		}

		const byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );
		const dataView = new DataView( new ArrayBuffer( byteLength ) );
		let offset = 0;

		for ( let i = start; i < start + count; i ++ ) {

			for ( let a = 0; a < attribute.itemSize; a ++ ) {

				let value;

				if ( attribute.itemSize > 4 ) {

					 // no support for interleaved data for itemSize > 4

					value = attribute.array[ i * attribute.itemSize + a ];

				} else {

					if ( a === 0 ) value = attribute.getX( i );
					else if ( a === 1 ) value = attribute.getY( i );
					else if ( a === 2 ) value = attribute.getZ( i );
					else if ( a === 3 ) value = attribute.getW( i );

				}

				if ( componentType === WEBGL_CONSTANTS.FLOAT ) {

					dataView.setFloat32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {

					dataView.setUint32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

					dataView.setUint16( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

					dataView.setUint8( offset, value );

				}

				offset += componentSize;

			}

		}

		const bufferViewDef = {

			buffer: this.processBuffer( dataView.buffer ),
			byteOffset: this.byteOffset,
			byteLength: byteLength

		};

		if ( target !== undefined ) bufferViewDef.target = target;

		if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {

			// Only define byteStride for vertex attributes.
			bufferViewDef.byteStride = attribute.itemSize * componentSize;

		}

		this.byteOffset += byteLength;

		json.bufferViews.push( bufferViewDef );

		// @TODO Merge bufferViews where possible.
		const output = {

			id: json.bufferViews.length - 1,
			byteLength: 0

		};

		return output;

	}

	/**
	 * Process and generate a BufferView from an image Blob.
	 * @param {Blob} blob
	 * @return {Promise<Integer>}
	 */
	processBufferViewImage( blob ) {

		const writer = this;
		const json = writer.json;

		if ( ! json.bufferViews ) json.bufferViews = [];

		return new Promise( function ( resolve ) {

			const reader = new window.FileReader();
			reader.readAsArrayBuffer( blob );
			reader.onloadend = function () {

				const buffer = getPaddedArrayBuffer( reader.result );

				const bufferViewDef = {
					buffer: writer.processBuffer( buffer ),
					byteOffset: writer.byteOffset,
					byteLength: buffer.byteLength
				};

				writer.byteOffset += buffer.byteLength;
				resolve( json.bufferViews.push( bufferViewDef ) - 1 );

			};

		} );

	}

	/**
	 * Process attribute to generate an accessor
	 * @param  {BufferAttribute} attribute Attribute to process
	 * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
	 * @param  {Integer} start (Optional)
	 * @param  {Integer} count (Optional)
	 * @return {Integer|null} Index of the processed accessor on the "accessors" array
	 */
	processAccessor( attribute, geometry, start, count ) {

		const options = this.options;
		const json = this.json;

		const types = {

			1: 'SCALAR',
			2: 'VEC2',
			3: 'VEC3',
			4: 'VEC4',
			16: 'MAT4'

		};

		let componentType;

		// Detect the component type of the attribute array (float, uint or ushort)
		if ( attribute.array.constructor === Float32Array ) {

			componentType = WEBGL_CONSTANTS.FLOAT;

		} else if ( attribute.array.constructor === Uint32Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_INT;

		} else if ( attribute.array.constructor === Uint16Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;

		} else if ( attribute.array.constructor === Uint8Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );

		}

		if ( start === undefined ) start = 0;
		if ( count === undefined ) count = attribute.count;

		// @TODO Indexed buffer geometry with drawRange not supported yet
		if ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {

			const end = start + count;
			const end2 = geometry.drawRange.count === Infinity
				? attribute.count
				: geometry.drawRange.start + geometry.drawRange.count;

			start = Math.max( start, geometry.drawRange.start );
			count = Math.min( end, end2 ) - start;

			if ( count < 0 ) count = 0;

		}

		// Skip creating an accessor if the attribute doesn't have data to export
		if ( count === 0 ) return null;

		const minMax = getMinMax( attribute, start, count );
		let bufferViewTarget;

		// If geometry isn't provided, don't infer the target usage of the bufferView. For
		// animation samplers, target must not be set.
		if ( geometry !== undefined ) {

			bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;

		}

		const bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );

		const accessorDef = {

			bufferView: bufferView.id,
			byteOffset: bufferView.byteOffset,
			componentType: componentType,
			count: count,
			max: minMax.max,
			min: minMax.min,
			type: types[ attribute.itemSize ]

		};

		if ( attribute.normalized === true ) accessorDef.normalized = true;
		if ( ! json.accessors ) json.accessors = [];

		return json.accessors.push( accessorDef ) - 1;

	}

	/**
	 * Process image
	 * @param  {Image} image to process
	 * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)
	 * @param  {Boolean} flipY before writing out the image
	 * @return {Integer}     Index of the processed texture in the "images" array
	 */
	processImage( image, format, flipY ) {

		const writer = this;
		const cache = writer.cache;
		const json = writer.json;
		const options = writer.options;
		const pending = writer.pending;

		if ( ! cache.images.has( image ) ) cache.images.set( image, {} );

		const cachedImages = cache.images.get( image );
		const mimeType = format === RGBAFormat$1 ? 'image/png' : 'image/jpeg';
		const key = mimeType + ':flipY/' + flipY.toString();

		if ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];

		if ( ! json.images ) json.images = [];

		const imageDef = { mimeType: mimeType };

		if ( options.embedImages ) {

			const canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );

			canvas.width = Math.min( image.width, options.maxTextureSize );
			canvas.height = Math.min( image.height, options.maxTextureSize );

			const ctx = canvas.getContext( '2d' );

			if ( flipY === true ) {

				ctx.translate( 0, canvas.height );
				ctx.scale( 1, - 1 );

			}

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				ctx.drawImage( image, 0, 0, canvas.width, canvas.height );

			} else {

				if ( format !== RGBAFormat$1 && format !== RGBFormat$1 ) {

					console.error( 'GLTFExporter: Only RGB and RGBA formats are supported.' );

				}

				if ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {

					console.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );

				}

				const data = new Uint8ClampedArray( image.height * image.width * 4 );

				if ( format === RGBAFormat$1 ) {

					for ( let i = 0; i < data.length; i += 4 ) {

						data[ i + 0 ] = image.data[ i + 0 ];
						data[ i + 1 ] = image.data[ i + 1 ];
						data[ i + 2 ] = image.data[ i + 2 ];
						data[ i + 3 ] = image.data[ i + 3 ];

					}

				} else {

					for ( let i = 0, j = 0; i < data.length; i += 4, j += 3 ) {

						data[ i + 0 ] = image.data[ j + 0 ];
						data[ i + 1 ] = image.data[ j + 1 ];
						data[ i + 2 ] = image.data[ j + 2 ];
						data[ i + 3 ] = 255;

					}

				}

				ctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );

			}

			if ( options.binary === true ) {

				pending.push( new Promise( function ( resolve ) {

					canvas.toBlob( function ( blob ) {

						writer.processBufferViewImage( blob ).then( function ( bufferViewIndex ) {

							imageDef.bufferView = bufferViewIndex;
							resolve();

						} );

					}, mimeType );

				} ) );

			} else {

				imageDef.uri = canvas.toDataURL( mimeType );

			}

		} else {

			imageDef.uri = image.src;

		}

		const index = json.images.push( imageDef ) - 1;
		cachedImages[ key ] = index;
		return index;

	}

	/**
	 * Process sampler
	 * @param  {Texture} map Texture to process
	 * @return {Integer}     Index of the processed texture in the "samplers" array
	 */
	processSampler( map ) {

		const json = this.json;

		if ( ! json.samplers ) json.samplers = [];

		const samplerDef = {
			magFilter: THREE_TO_WEBGL[ map.magFilter ],
			minFilter: THREE_TO_WEBGL[ map.minFilter ],
			wrapS: THREE_TO_WEBGL[ map.wrapS ],
			wrapT: THREE_TO_WEBGL[ map.wrapT ]
		};

		return json.samplers.push( samplerDef ) - 1;

	}

	/**
	 * Process texture
	 * @param  {Texture} map Map to process
	 * @return {Integer} Index of the processed texture in the "textures" array
	 */
	processTexture( map ) {

		const cache = this.cache;
		const json = this.json;

		if ( cache.textures.has( map ) ) return cache.textures.get( map );

		if ( ! json.textures ) json.textures = [];

		const textureDef = {
			sampler: this.processSampler( map ),
			source: this.processImage( map.image, map.format, map.flipY )
		};

		if ( map.name ) textureDef.name = map.name;

		this._invokeAll( function ( ext ) {

			ext.writeTexture && ext.writeTexture( map, textureDef );

		} );

		const index = json.textures.push( textureDef ) - 1;
		cache.textures.set( map, index );
		return index;

	}

	/**
	 * Process material
	 * @param  {THREE.Material} material Material to process
	 * @return {Integer|null} Index of the processed material in the "materials" array
	 */
	processMaterial( material ) {

		const cache = this.cache;
		const json = this.json;

		if ( cache.materials.has( material ) ) return cache.materials.get( material );

		if ( material.isShaderMaterial ) {

			console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );
			return null;

		}

		if ( ! json.materials ) json.materials = [];

		// @QUESTION Should we avoid including any attribute that has the default value?
		const materialDef = {	pbrMetallicRoughness: {} };

		if ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {

			console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );

		}

		// pbrMetallicRoughness.baseColorFactor
		const color = material.color.toArray().concat( [ material.opacity ] );

		if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

			materialDef.pbrMetallicRoughness.baseColorFactor = color;

		}

		if ( material.isMeshStandardMaterial ) {

			materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
			materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;

		} else {

			materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
			materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;

		}

		// pbrMetallicRoughness.metallicRoughnessTexture
		if ( material.metalnessMap || material.roughnessMap ) {

			if ( material.metalnessMap === material.roughnessMap ) {

				const metalRoughMapDef = { index: this.processTexture( material.metalnessMap ) };
				this.applyTextureTransform( metalRoughMapDef, material.metalnessMap );
				materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;

			} else {

				console.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );

			}

		}

		// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture
		if ( material.map ) {

			const baseColorMapDef = { index: this.processTexture( material.map ) };
			this.applyTextureTransform( baseColorMapDef, material.map );
			materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;

		}

		if ( material.emissive ) {

			// note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.
			const emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity );
			const maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );

			if ( maxEmissiveComponent > 1 ) {

				emissive.multiplyScalar( 1 / maxEmissiveComponent );

				console.warn( 'THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited' );

			}

			if ( maxEmissiveComponent > 0 ) {

				materialDef.emissiveFactor = emissive.toArray();

			}

			// emissiveTexture
			if ( material.emissiveMap ) {

				const emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };
				this.applyTextureTransform( emissiveMapDef, material.emissiveMap );
				materialDef.emissiveTexture = emissiveMapDef;

			}

		}

		// normalTexture
		if ( material.normalMap ) {

			const normalMapDef = { index: this.processTexture( material.normalMap ) };

			if ( material.normalScale && material.normalScale.x !== - 1 ) {

				if ( material.normalScale.x !== material.normalScale.y ) {

					console.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );

				}

				normalMapDef.scale = material.normalScale.x;

			}

			this.applyTextureTransform( normalMapDef, material.normalMap );
			materialDef.normalTexture = normalMapDef;

		}

		// occlusionTexture
		if ( material.aoMap ) {

			const occlusionMapDef = {
				index: this.processTexture( material.aoMap ),
				texCoord: 1
			};

			if ( material.aoMapIntensity !== 1.0 ) {

				occlusionMapDef.strength = material.aoMapIntensity;

			}

			this.applyTextureTransform( occlusionMapDef, material.aoMap );
			materialDef.occlusionTexture = occlusionMapDef;

		}

		// alphaMode
		if ( material.transparent ) {

			materialDef.alphaMode = 'BLEND';

		} else {

			if ( material.alphaTest > 0.0 ) {

				materialDef.alphaMode = 'MASK';
				materialDef.alphaCutoff = material.alphaTest;

			}

		}

		// doubleSided
		if ( material.side === DoubleSide$1 ) materialDef.doubleSided = true;
		if ( material.name !== '' ) materialDef.name = material.name;

		this.serializeUserData( material, materialDef );

		this._invokeAll( function ( ext ) {

			ext.writeMaterial && ext.writeMaterial( material, materialDef );

		} );

		const index = json.materials.push( materialDef ) - 1;
		cache.materials.set( material, index );
		return index;

	}

	/**
	 * Process mesh
	 * @param  {THREE.Mesh} mesh Mesh to process
	 * @return {Integer|null} Index of the processed mesh in the "meshes" array
	 */
	processMesh( mesh ) {

		const cache = this.cache;
		const json = this.json;

		const meshCacheKeyParts = [ mesh.geometry.uuid ];

		if ( Array.isArray( mesh.material ) ) {

			for ( let i = 0, l = mesh.material.length; i < l; i ++ ) {

				meshCacheKeyParts.push( mesh.material[ i ].uuid	);

			}

		} else {

			meshCacheKeyParts.push( mesh.material.uuid );

		}

		const meshCacheKey = meshCacheKeyParts.join( ':' );

		if ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );

		const geometry = mesh.geometry;
		let mode;

		// Use the correct mode
		if ( mesh.isLineSegments ) {

			mode = WEBGL_CONSTANTS.LINES;

		} else if ( mesh.isLineLoop ) {

			mode = WEBGL_CONSTANTS.LINE_LOOP;

		} else if ( mesh.isLine ) {

			mode = WEBGL_CONSTANTS.LINE_STRIP;

		} else if ( mesh.isPoints ) {

			mode = WEBGL_CONSTANTS.POINTS;

		} else {

			mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;

		}

		if ( geometry.isBufferGeometry !== true ) {

			throw new Error( 'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.' );

		}

		const meshDef = {};
		const attributes = {};
		const primitives = [];
		const targets = [];

		// Conversion between attributes names in threejs and gltf spec
		const nameConversion = {
			uv: 'TEXCOORD_0',
			uv2: 'TEXCOORD_1',
			color: 'COLOR_0',
			skinWeight: 'WEIGHTS_0',
			skinIndex: 'JOINTS_0'
		};

		const originalNormal = geometry.getAttribute( 'normal' );

		if ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {

			console.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );

			geometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );

		}

		// @QUESTION Detect if .vertexColors = true?
		// For every attribute create an accessor
		let modifiedAttribute = null;

		for ( let attributeName in geometry.attributes ) {

			// Ignore morph target attributes, which are exported later.
			if ( attributeName.substr( 0, 5 ) === 'morph' ) continue;

			const attribute = geometry.attributes[ attributeName ];
			attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();

			// Prefix all geometry attributes except the ones specifically
			// listed in the spec; non-spec attributes are considered custom.
			const validVertexAttributes =
					/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;

			if ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;

			if ( cache.attributes.has( this.getUID( attribute ) ) ) {

				attributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );
				continue;

			}

			// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
			modifiedAttribute = null;
			const array = attribute.array;

			if ( attributeName === 'JOINTS_0' &&
				! ( array instanceof Uint16Array ) &&
				! ( array instanceof Uint8Array ) ) {

				console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );
				modifiedAttribute = new BufferAttribute$1( new Uint16Array( array ), attribute.itemSize, attribute.normalized );

			}

			const accessor = this.processAccessor( modifiedAttribute || attribute, geometry );

			if ( accessor !== null ) {

				attributes[ attributeName ] = accessor;
				cache.attributes.set( this.getUID( attribute ), accessor );

			}

		}

		if ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );

		// Skip if no exportable attributes found
		if ( Object.keys( attributes ).length === 0 ) return null;

		// Morph targets
		if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {

			const weights = [];
			const targetNames = [];
			const reverseDictionary = {};

			if ( mesh.morphTargetDictionary !== undefined ) {

				for ( const key in mesh.morphTargetDictionary ) {

					reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;

				}

			}

			for ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {

				const target = {};
				let warned = false;

				for ( const attributeName in geometry.morphAttributes ) {

					// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
					// Three.js doesn't support TANGENT yet.

					if ( attributeName !== 'position' && attributeName !== 'normal' ) {

						if ( ! warned ) {

							console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );
							warned = true;

						}

						continue;

					}

					const attribute = geometry.morphAttributes[ attributeName ][ i ];
					const gltfAttributeName = attributeName.toUpperCase();

					// Three.js morph attribute has absolute values while the one of glTF has relative values.
					//
					// glTF 2.0 Specification:
					// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

					const baseAttribute = geometry.attributes[ attributeName ];

					if ( cache.attributes.has( this.getUID( attribute ) ) ) {

						target[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute ) );
						continue;

					}

					// Clones attribute not to override
					const relativeAttribute = attribute.clone();

					if ( ! geometry.morphTargetsRelative ) {

						for ( let j = 0, jl = attribute.count; j < jl; j ++ ) {

							relativeAttribute.setXYZ(
								j,
								attribute.getX( j ) - baseAttribute.getX( j ),
								attribute.getY( j ) - baseAttribute.getY( j ),
								attribute.getZ( j ) - baseAttribute.getZ( j )
							);

						}

					}

					target[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );
					cache.attributes.set( this.getUID( baseAttribute ), target[ gltfAttributeName ] );

				}

				targets.push( target );

				weights.push( mesh.morphTargetInfluences[ i ] );

				if ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );

			}

			meshDef.weights = weights;

			if ( targetNames.length > 0 ) {

				meshDef.extras = {};
				meshDef.extras.targetNames = targetNames;

			}

		}

		const isMultiMaterial = Array.isArray( mesh.material );

		if ( isMultiMaterial && geometry.groups.length === 0 ) return null;

		const materials = isMultiMaterial ? mesh.material : [ mesh.material ];
		const groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];

		for ( let i = 0, il = groups.length; i < il; i ++ ) {

			const primitive = {
				mode: mode,
				attributes: attributes,
			};

			this.serializeUserData( geometry, primitive );

			if ( targets.length > 0 ) primitive.targets = targets;

			if ( geometry.index !== null ) {

				let cacheKey = this.getUID( geometry.index );

				if ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {

					cacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;

				}

				if ( cache.attributes.has( cacheKey ) ) {

					primitive.indices = cache.attributes.get( cacheKey );

				} else {

					primitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );
					cache.attributes.set( cacheKey, primitive.indices );

				}

				if ( primitive.indices === null ) delete primitive.indices;

			}

			const material = this.processMaterial( materials[ groups[ i ].materialIndex ] );

			if ( material !== null ) primitive.material = material;

			primitives.push( primitive );

		}

		meshDef.primitives = primitives;

		if ( ! json.meshes ) json.meshes = [];

		this._invokeAll( function ( ext ) {

			ext.writeMesh && ext.writeMesh( mesh, meshDef );

		} );

		const index = json.meshes.push( meshDef ) - 1;
		cache.meshes.set( meshCacheKey, index );
		return index;

	}

	/**
	 * Process camera
	 * @param  {THREE.Camera} camera Camera to process
	 * @return {Integer}      Index of the processed mesh in the "camera" array
	 */
	processCamera( camera ) {

		const json = this.json;

		if ( ! json.cameras ) json.cameras = [];

		const isOrtho = camera.isOrthographicCamera;

		const cameraDef = {
			type: isOrtho ? 'orthographic' : 'perspective'
		};

		if ( isOrtho ) {

			cameraDef.orthographic = {
				xmag: camera.right * 2,
				ymag: camera.top * 2,
				zfar: camera.far <= 0 ? 0.001 : camera.far,
				znear: camera.near < 0 ? 0 : camera.near
			};

		} else {

			cameraDef.perspective = {
				aspectRatio: camera.aspect,
				yfov: MathUtils.degToRad( camera.fov ),
				zfar: camera.far <= 0 ? 0.001 : camera.far,
				znear: camera.near < 0 ? 0 : camera.near
			};

		}

		// Question: Is saving "type" as name intentional?
		if ( camera.name !== '' ) cameraDef.name = camera.type;

		return json.cameras.push( cameraDef ) - 1;

	}

	/**
	 * Creates glTF animation entry from AnimationClip object.
	 *
	 * Status:
	 * - Only properties listed in PATH_PROPERTIES may be animated.
	 *
	 * @param {THREE.AnimationClip} clip
	 * @param {THREE.Object3D} root
	 * @return {number|null}
	 */
	processAnimation( clip, root ) {

		const json = this.json;
		const nodeMap = this.nodeMap;

		if ( ! json.animations ) json.animations = [];

		clip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );

		const tracks = clip.tracks;
		const channels = [];
		const samplers = [];

		for ( let i = 0; i < tracks.length; ++ i ) {

			const track = tracks[ i ];
			const trackBinding = PropertyBinding$1.parseTrackName( track.name );
			let trackNode = PropertyBinding$1.findNode( root, trackBinding.nodeName );
			const trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];

			if ( trackBinding.objectName === 'bones' ) {

				if ( trackNode.isSkinnedMesh === true ) {

					trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );

				} else {

					trackNode = undefined;

				}

			}

			if ( ! trackNode || ! trackProperty ) {

				console.warn( 'THREE.GLTFExporter: Could not export animation track "%s".', track.name );
				return null;

			}

			const inputItemSize = 1;
			let outputItemSize = track.values.length / track.times.length;

			if ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {

				outputItemSize /= trackNode.morphTargetInfluences.length;

			}

			let interpolation;

			// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE

			// Detecting glTF cubic spline interpolant by checking factory method's special property
			// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
			// valid value from .getInterpolation().
			if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {

				interpolation = 'CUBICSPLINE';

				// itemSize of CUBICSPLINE keyframe is 9
				// (VEC3 * 3: inTangent, splineVertex, and outTangent)
				// but needs to be stored as VEC3 so dividing by 3 here.
				outputItemSize /= 3;

			} else if ( track.getInterpolation() === InterpolateDiscrete$1 ) {

				interpolation = 'STEP';

			} else {

				interpolation = 'LINEAR';

			}

			samplers.push( {
				input: this.processAccessor( new BufferAttribute$1( track.times, inputItemSize ) ),
				output: this.processAccessor( new BufferAttribute$1( track.values, outputItemSize ) ),
				interpolation: interpolation
			} );

			channels.push( {
				sampler: samplers.length - 1,
				target: {
					node: nodeMap.get( trackNode ),
					path: trackProperty
				}
			} );

		}

		json.animations.push( {
			name: clip.name || 'clip_' + json.animations.length,
			samplers: samplers,
			channels: channels
		} );

		return json.animations.length - 1;

	}

	/**
	 * @param {THREE.Object3D} object
	 * @return {number|null}
	 */
	 processSkin( object ) {

		const json = this.json;
		const nodeMap = this.nodeMap;

		const node = json.nodes[ nodeMap.get( object ) ];

		const skeleton = object.skeleton;

		if ( skeleton === undefined ) return null;

		const rootJoint = object.skeleton.bones[ 0 ];

		if ( rootJoint === undefined ) return null;

		const joints = [];
		const inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );
		const temporaryBoneInverse = new Matrix4$1();

		for ( let i = 0; i < skeleton.bones.length; ++ i ) {

			joints.push( nodeMap.get( skeleton.bones[ i ] ) );
			temporaryBoneInverse.copy( skeleton.boneInverses[ i ] );
			temporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );

		}

		if ( json.skins === undefined ) json.skins = [];

		json.skins.push( {
			inverseBindMatrices: this.processAccessor( new BufferAttribute$1( inverseBindMatrices, 16 ) ),
			joints: joints,
			skeleton: nodeMap.get( rootJoint )
		} );

		const skinIndex = node.skin = json.skins.length - 1;

		return skinIndex;

	}

	/**
	 * Process Object3D node
	 * @param  {THREE.Object3D} node Object3D to processNode
	 * @return {Integer} Index of the node in the nodes list
	 */
	processNode( object ) {

		const json = this.json;
		const options = this.options;
		const nodeMap = this.nodeMap;

		if ( ! json.nodes ) json.nodes = [];

		const nodeDef = {};

		if ( options.trs ) {

			const rotation = object.quaternion.toArray();
			const position = object.position.toArray();
			const scale = object.scale.toArray();

			if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

				nodeDef.rotation = rotation;

			}

			if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

				nodeDef.translation = position;

			}

			if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

				nodeDef.scale = scale;

			}

		} else {

			if ( object.matrixAutoUpdate ) {

				object.updateMatrix();

			}

			if ( isIdentityMatrix( object.matrix ) === false ) {

				nodeDef.matrix = object.matrix.elements;

			}

		}

		// We don't export empty strings name because it represents no-name in Three.js.
		if ( object.name !== '' ) nodeDef.name = String( object.name );

		this.serializeUserData( object, nodeDef );

		if ( object.isMesh || object.isLine || object.isPoints ) {

			const meshIndex = this.processMesh( object );

			if ( meshIndex !== null ) nodeDef.mesh = meshIndex;

		} else if ( object.isCamera ) {

			nodeDef.camera = this.processCamera( object );

		}

		if ( object.isSkinnedMesh ) this.skins.push( object );

		if ( object.children.length > 0 ) {

			const children = [];

			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

				const child = object.children[ i ];

				if ( child.visible || options.onlyVisible === false ) {

					const nodeIndex = this.processNode( child );

					if ( nodeIndex !== null ) children.push( nodeIndex );

				}

			}

			if ( children.length > 0 ) nodeDef.children = children;

		}

		this._invokeAll( function ( ext ) {

			ext.writeNode && ext.writeNode( object, nodeDef );

		} );

		const nodeIndex = json.nodes.push( nodeDef ) - 1;
		nodeMap.set( object, nodeIndex );
		return nodeIndex;

	}

	/**
	 * Process Scene
	 * @param  {Scene} node Scene to process
	 */
	processScene( scene ) {

		const json = this.json;
		const options = this.options;

		if ( ! json.scenes ) {

			json.scenes = [];
			json.scene = 0;

		}

		const sceneDef = {};

		if ( scene.name !== '' ) sceneDef.name = scene.name;

		json.scenes.push( sceneDef );

		const nodes = [];

		for ( let i = 0, l = scene.children.length; i < l; i ++ ) {

			const child = scene.children[ i ];

			if ( child.visible || options.onlyVisible === false ) {

				const nodeIndex = this.processNode( child );

				if ( nodeIndex !== null ) nodes.push( nodeIndex );

			}

		}

		if ( nodes.length > 0 ) sceneDef.nodes = nodes;

		this.serializeUserData( scene, sceneDef );

	}

	/**
	 * Creates a Scene to hold a list of objects and parse it
	 * @param  {Array} objects List of objects to process
	 */
	processObjects( objects ) {

		const scene = new Scene$1();
		scene.name = 'AuxScene';

		for ( let i = 0; i < objects.length; i ++ ) {

			// We push directly to children instead of calling `add` to prevent
			// modify the .parent and break its original scene and hierarchy
			scene.children.push( objects[ i ] );

		}

		this.processScene( scene );

	}

	/**
	 * @param {THREE.Object3D|Array<THREE.Object3D>} input
	 */
	processInput( input ) {

		const options = this.options;

		input = input instanceof Array ? input : [ input ];

		this._invokeAll( function ( ext ) {

			ext.beforeParse && ext.beforeParse( input );

		} );

		const objectsWithoutScene = [];

		for ( let i = 0; i < input.length; i ++ ) {

			if ( input[ i ] instanceof Scene$1 ) {

				this.processScene( input[ i ] );

			} else {

				objectsWithoutScene.push( input[ i ] );

			}

		}

		if ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );

		for ( let i = 0; i < this.skins.length; ++ i ) {

			this.processSkin( this.skins[ i ] );

		}

		for ( let i = 0; i < options.animations.length; ++ i ) {

			this.processAnimation( options.animations[ i ], input[ 0 ] );

		}

		this._invokeAll( function ( ext ) {

			ext.afterParse && ext.afterParse( input );

		} );

	}

	_invokeAll( func ) {

		for ( let i = 0, il = this.plugins.length; i < il; i ++ ) {

			func( this.plugins[ i ] );

		}

	}

}

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_lights_punctual';

	}

	writeNode( light, nodeDef ) {

		if ( ! light.isLight ) return;

		if ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {

			console.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );
			return;

		}

		const writer = this.writer;
		const json = writer.json;
		const extensionsUsed = writer.extensionsUsed;

		const lightDef = {};

		if ( light.name ) lightDef.name = light.name;

		lightDef.color = light.color.toArray();

		lightDef.intensity = light.intensity;

		if ( light.isDirectionalLight ) {

			lightDef.type = 'directional';

		} else if ( light.isPointLight ) {

			lightDef.type = 'point';

			if ( light.distance > 0 ) lightDef.range = light.distance;

		} else if ( light.isSpotLight ) {

			lightDef.type = 'spot';

			if ( light.distance > 0 ) lightDef.range = light.distance;

			lightDef.spot = {};
			lightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;
			lightDef.spot.outerConeAngle = light.angle;

		}

		if ( light.decay !== undefined && light.decay !== 2 ) {

			console.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '
				+ 'and expects light.decay=2.' );

		}

		if ( light.target
				&& ( light.target.parent !== light
				|| light.target.position.x !== 0
				|| light.target.position.y !== 0
				|| light.target.position.z !== - 1 ) ) {

			console.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '
				+ 'make light.target a child of the light with position 0,0,-1.' );

		}

		if ( ! extensionsUsed[ this.name ] ) {

			json.extensions = json.extensions || {};
			json.extensions[ this.name ] = { lights: [] };
			extensionsUsed[ this.name ] = true;

		}

		const lights = json.extensions[ this.name ].lights;
		lights.push( lightDef );

		nodeDef.extensions = nodeDef.extensions || {};
		nodeDef.extensions[ this.name ] = { light: lights.length - 1 };

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_unlit';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshBasicMaterial ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = {};

		extensionsUsed[ this.name ] = true;

		materialDef.pbrMetallicRoughness.metallicFactor = 0.0;
		materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */
class GLTFMaterialsPBRSpecularGlossiness {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_pbrSpecularGlossiness';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isGLTFSpecularGlossinessMaterial ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		if ( materialDef.pbrMetallicRoughness.baseColorFactor ) {

			extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;

		}

		const specularFactor = [ 1, 1, 1 ];
		material.specular.toArray( specularFactor, 0 );
		extensionDef.specularFactor = specularFactor;
		extensionDef.glossinessFactor = material.glossiness;

		if ( materialDef.pbrMetallicRoughness.baseColorTexture ) {

			extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;

		}

		if ( material.specularMap ) {

			const specularMapDef = { index: writer.processTexture( material.specularMap ) };
			writer.applyTextureTransform( specularMapDef, material.specularMap );
			extensionDef.specularGlossinessTexture = specularMapDef;

		}

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;
		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Static utility functions
 */
GLTFExporter.Utils = {

	insertKeyframe: function ( track, time ) {

		const tolerance = 0.001; // 1ms
		const valueSize = track.getValueSize();

		const times = new track.TimeBufferType( track.times.length + 1 );
		const values = new track.ValueBufferType( track.values.length + valueSize );
		const interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );

		let index;

		if ( track.times.length === 0 ) {

			times[ 0 ] = time;

			for ( let i = 0; i < valueSize; i ++ ) {

				values[ i ] = 0;

			}

			index = 0;

		} else if ( time < track.times[ 0 ] ) {

			if ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;

			times[ 0 ] = time;
			times.set( track.times, 1 );

			values.set( interpolant.evaluate( time ), 0 );
			values.set( track.values, valueSize );

			index = 0;

		} else if ( time > track.times[ track.times.length - 1 ] ) {

			if ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {

				return track.times.length - 1;

			}

			times[ times.length - 1 ] = time;
			times.set( track.times, 0 );

			values.set( track.values, 0 );
			values.set( interpolant.evaluate( time ), track.values.length );

			index = times.length - 1;

		} else {

			for ( let i = 0; i < track.times.length; i ++ ) {

				if ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;

				if ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {

					times.set( track.times.slice( 0, i + 1 ), 0 );
					times[ i + 1 ] = time;
					times.set( track.times.slice( i + 1 ), i + 2 );

					values.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );
					values.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );
					values.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );

					index = i + 1;

					break;

				}

			}

		}

		track.times = times;
		track.values = values;

		return index;

	},

	mergeMorphTargetTracks: function ( clip, root ) {

		const tracks = [];
		const mergedTracks = {};
		const sourceTracks = clip.tracks;

		for ( let i = 0; i < sourceTracks.length; ++ i ) {

			let sourceTrack = sourceTracks[ i ];
			const sourceTrackBinding = PropertyBinding$1.parseTrackName( sourceTrack.name );
			const sourceTrackNode = PropertyBinding$1.findNode( root, sourceTrackBinding.nodeName );

			if ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {

				// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
				tracks.push( sourceTrack );
				continue;

			}

			if ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete
				&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {

				if ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					// This should never happen, because glTF morph target animations
					// affect all targets already.
					throw new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );

				}

				console.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );

				sourceTrack = sourceTrack.clone();
				sourceTrack.setInterpolation( InterpolateLinear$1 );

			}

			const targetCount = sourceTrackNode.morphTargetInfluences.length;
			const targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];

			if ( targetIndex === undefined ) {

				throw new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );

			}

			let mergedTrack;

			// If this is the first time we've seen this object, create a new
			// track to store merged keyframe data for each morph target.
			if ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {

				mergedTrack = sourceTrack.clone();

				const values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );

				for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

					values[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];

				}

				// We need to take into consideration the intended target node
				// of our original un-merged morphTarget animation.
				mergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';
				mergedTrack.values = values;

				mergedTracks[ sourceTrackNode.uuid ] = mergedTrack;
				tracks.push( mergedTrack );

				continue;

			}

			const sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );

			mergedTrack = mergedTracks[ sourceTrackNode.uuid ];

			// For every existing keyframe of the merged track, write a (possibly
			// interpolated) value from the source track.
			for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

				mergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );

			}

			// For every existing keyframe of the source track, write a (possibly
			// new) keyframe to the merged track. Values from the previous loop may
			// be written again, but keyframes are de-duplicated.
			for ( let j = 0; j < sourceTrack.times.length; j ++ ) {

				const keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );
				mergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];

			}

		}

		clip.tracks = tracks;

		return clip;

	}

};

/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 */

class CSS3DObject extends Object3D$1 {

	constructor( element ) {

		super();

		this.element = element || document.createElement( 'div' );
		this.element.style.position = 'absolute';
		this.element.style.pointerEvents = 'auto';

		this.addEventListener( 'removed', function () {

			this.traverse( function ( object ) {

				if ( object.element instanceof Element && object.element.parentNode !== null ) {

					object.element.parentNode.removeChild( object.element );

				}

			} );

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.element = source.element.cloneNode( true );

		return this;

	}

}

CSS3DObject.prototype.isCSS3DObject = true;

class CSS3DSprite extends CSS3DObject {

	constructor( element ) {

		super( element );

		this.rotation2D = 0;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.rotation2D = source.rotation2D;

		return this;

	}

}

CSS3DSprite.prototype.isCSS3DSprite = true;

//

new Matrix4$1();
new Matrix4$1();

const ExportToGLTF = async (name, ...obj) => {
  return await new Promise((res, rej) => {
    const exporter = new GLTFExporter();
    exporter.parse(obj, (gltf) => {
      console.log("exported", name, gltf);
      SaveString(gltf, name);
      res(gltf);
    });
  });
};

export const setupReflection = (tomi, simple = false) => {
    if (simple) return;
    const cubeRenderTarget = new WebGLCubeRenderTarget$1(512, {
        format: RGBFormat$1,
        generateMipmaps: true,
        minFilter: LinearMipmapLinearFilter$1,
        encoding: sRGBEncoding$1
    });
    const cubeCamera = new CubeCamera$1(0.1, 1000, cubeRenderTarget);
    //tomi._body.combine = THREE.MultiplyOperation;
   
    tomi.cubeCamera = cubeCamera;
    tomi._cubeRenderTarget = cubeRenderTarget;
    
    tomi.updateReflect = () => {
        tomi.cubeCamera.update(tomi.sceneManager.renderer, tomi.sceneManager.scene);
        
         if (tomi._mainMaterials) {
            tomi._mainMaterials.envMap =  cubeRenderTarget.texture;
        }
        //tomi._body.material.envMap =  tomi._cubeRenderTarget.texture;
        //tomi._hat.material.envMap =  tomi._cubeRenderTarget.texture;
       //tomi.sceneManager.scene.environment = tomi._cubeRenderTarget.texture;
    };
    
    return {
        cubeRenderTarget,
        cubeCamera
    }
};

class ActionSet {
  constructor(clip = undefined, loop = undefined, repeat = undefined, expression = undefined, ended = undefined) {
    this.clip = clip;
    this.loop = loop;
    this.repeat = repeat;
    this.ended = ended;
    this.expression = expression;
    this._action = null;
    this.paused = false;
    return this;
  }

  setAction(action) {
    this._action = action;
    return this;
  }

  clone() {
    return new ActionSet(this.clip, this.loop, this.repeat, this.expression, this.ended);
  }

  reverse() {
    this._reverse = true;
    return this;
  }
}

const ActionClip = {
  greeting: 0,
  idle: 1,
  idle_afk: 2,
  talk: 3
};

const NLA = {
  intro: [ActionClip.idle, ActionClip.greeting, ActionClip.talk, ActionClip.idle_afk]
};


const TomiFace = Facial();
TomiFace.Face.reset();

export class TOMIController extends Object3D$1 {
  constructor(mesh = undefined, scale = 1, sceneManager = undefined) {
    super();
    this.sceneManager = sceneManager;
    this._autoAnimate = false;
    this._mixer = null;
    this._sounds = [];
    this._clips = [];
    this._currentSequence = NLA.intro;
    this._actionSet = {};
    this._sound;
    this.mesh = mesh.scene || mesh;
    this.states = {};
    this._state = "idle";
    this._face = null;
    this._body = null;
    this.bones = {};
    this.rigs = {};

    this._currentClip = null;
    this._currentAction = null;
    this._currentIndex = 0;

    this._talking = false;
    this._lastElapse = 0;

    this._defaultClip = 1;
    this._actionCallbacks = {};

    this._root;
    this.dataArray;
    this.analyser;
    this._animating = false;
    this._currentActions = [];
    this._mainMaterials = null;
    this._autoAnimTM = null;

    this._lookTarget = new Vector3$1();
    this._plugins = {};
    // this.actions = ActionProps(this, this.face);
    //this._waypoints = JSON.parse(waypoints);
    if (mesh) {
		console.log(mesh);
      this.bind(mesh, scale);
      if (mesh.animations) {
        this.__loadAnimations(mesh);
      }
    }
  }

  use(...setupFn) {
    setupFn.forEach(fn => {
      fn(this);
    });
  }

  usePlugin(name, setupFn) {
    if (!this._plugins[name]) {
      this._plugins[name] = setupFn(this);
      console.log(`plugin :${name} installed`, this._plugins[name]);
    } else {
      console.log(`plugin ${name} is already installed`);
    }
  }

  removePlugin(name) {
    if (this._plugins[name]) {
      delete this._plugins[name];
    }
  }

  getPlugin(name) {
    return this._plugins[name] || null;
  }

  // set selfAware(state) {
  //   const self = this;
  //   if (!state) {
  //     if (self._autoAnimTM) {
  //       clearInterval(self._autoAnimTM);
  //       self._autoAnimTM = null;
  //     }
  //   } else {

  //     self._autoAnimTM = setInterval(_ => {
  //       const list = ["talkAction", "talkAction2", "talkAction3", "talkAction4", "eureka", "thinking", "sigh"]
  //       const id = Math.min(Math.round(Math.random() * list.length), list.length - 1);
  //       self.actions(list[id]);
  //     }, 1500);

  //   }
  // }

  // get selfAware() {
  //   return (this._autoAnimTM !== null);
  // }

  defineActions(actions = {}) {
    this._actions = actions;
  }

  actions(actionName) {
    return this._actions[actionName] || null;
  }


  get root() {
    return this._root;
  }

  async save(model = true, animations = true) {
    if (model) {
      await ExportToGLTF('tomi.gltf', this);
    }

    if (animations) {
      const data = JSON.stringify(this._clips);
      SaveString(data, 'tomi-animations.json');
    }
  }

  moveTo(newPos, tween = true, lookAt = undefined, lookDur = 'update', update = undefined, complete = undefined) {
    if (tween) {
     // const lookPos = (lookAt instanceof THREE.Object3D)? lookAt.position.clone() : {...lookAt};
      const tpos = { ...newPos };
      tpos.y += .25;
      const self = this;
      gsap.to(this.position, {
        ...tpos, duration: 2, onComplete: () => {
          gsap.to(this.position, {
            ...newPos, duration: 2, ease: 'sine.out',
            onUpdate: () => {
              if (lookAt && lookDur === 'update') {
                self.lookAt(lookAt, true);
              }
              if (update)update(this.position.clone());
            }
          , onComplete:()=>{
            if(complete)complete();
          }});
        }, onUpdate: () => {
          if (lookAt && lookDur === 'mid') {
            self.lookAt(lookAt, true);
          }
          if (update)update(this.position.clone());
        }
      });
    }
    return this;
  }

  moveToRef(index = 0) {
    const ref = this._waypoints[index];
    console.log(ref);

    let rpos = new Vector3$1(ref.x, ref.y + .6, ref.z);
    const cam = SceneManager.camera.position.clone();
    cam.y = rpos.y;
    SceneManager.tomi.moveTo(rpos, true, cam);
  }

  hoverTo(object) {
    if (object instanceof Object3D$1) {
      const bb = new Box3$1().setFromObject(object);
      const sz = bb.getSize(object.position);
      const newp = object.position.clone();
      newp.y -= sz.y * 0.5;
      this.moveTo(newp);
    }
  }

  async setupBodyTextures(config = { env: '/models/tomi/city_02.jpg', body: {} }) {
    // const loader = new THREE.TextureLoader();
    // const envTexture = (typeof config.env === 'string') ? await loader.load(config.env, t => t)
    // : config.env;
    // envTexture.mapping = THREE.EquirectangularReflectionMapping;

    // const bodyTexture = await loader.load(`/models/tomi/tomi_col.jpg`, t=>t);
    // bodyTexture.flipY = false;

    // const bodyNormal = await new THREE.TextureLoader().load('/models/tomi/tomi_nrm.jpg', t => t);
    // bodyNormal.flipY = false;

    // const brough = await new THREE.TextureLoader().load('/models/tomi/tomi_rough.jpg', t => t);
    // brough.flipY = false;

    // const bmetal = await new THREE.TextureLoader().load('/models/tomi/tomi_metal.png', t => t);
    // bmetal.flipY = false;

    // const bodyMat = new MeshPhysicalMaterial({
    //   color: 0xffffff,
    //   encoding: THREE.sRGBEncoding,
    //   reflectivity: 0.8,
    //   map: bodyTexture,
    //   envMap: envTexture,
    //   normalMap: bodyNormal,
    //   roughnessMap: brough,
    //   metalnessMap: bmetal,
    //   roughness: 0.9,
    //   metalness: 1,
    //   ...config.body,
    // });

    // const blue = new THREE.MeshLambertMaterial({
    //   transparent: true,
    //   opacity: 0.5,
    //   emissive: 0x59F4F6,
    //   side: THREE.DoubleSide
    // });

    // const faceMat = new THREE.MeshBasicMaterial({
    //   map: self.face.texture,
    //   envMap: city,
    //   reflectivity: 0.1
    // })

    // this._materials = {
    //   body: bodyMat,
    //   blue: blue,
    //   face: faceMat
    // }
    // return this._materials;
  }

  async bind(mesh, scale = 1, reflect = false) {
	this.mesh = mesh.scene || mesh;
	this.add(this.mesh);
    const self = this;
    const city = new TextureLoader$1().load('/models/tomi/city_02.jpg');
    city.flipY = false;
    city.encoding = sRGBEncoding$1;
    city.mapping = EquirectangularReflectionMapping$1;

    
    
    this.mesh.position.set(0, 0, 0);
    self.sceneManager.scene.background = city;
    
    // this.add(this._reflect)
    // SceneManager._reflect.position.set(0, 0, 0)

    const body = new TextureLoader$1().load('/models/tomi/tomi_col.jpg');

    body.flipY = false;
    body.encoding = sRGBEncoding$1;
    const bodyNormal = new TextureLoader$1().load('/models/tomi/tomi_nrm.jpg');
    bodyNormal.flipY = false;
    //body.encoding = THREE.sRGBEncoding;
    const brough = new TextureLoader$1().load('/models/tomi/tomi_rough.jpg');
    brough.flipY = false;
    const bmetal = new TextureLoader$1().load('/models/tomi/tomi_metal.png');
    bmetal.flipY = false;

    // const group = new Object3D$1();
    // group.add(mesh);

    // this.add(group);
    // mesh.scale.set(scale, scale, scale);
   
    const {cubeRenderTarget, cubeCamera} = setupReflection(self);
    //self.updateReflect();
   // if (cubeRenderTarget) self.sceneManager.scene.environment = cubeRenderTarget.texture;
    const shield = new MeshPhysicalMaterial$1({
      // side: THREE.DoubleSide,
      reflectivity: 1,
      map: body,
      envMap:  cubeRenderTarget.texture,
      
      normalMap: bodyNormal,
      roughnessMap: brough,
      metalnessMap: bmetal,
      roughness: 0.8,
      metalness: 1,
      color: 0xffffff,
    });
    this._mainMaterials = shield;
    //SceneManager._reflect.texture.needsUpdate = true;

    const blue = new MeshLambertMaterial$1({
      transparent: true,
      opacity: 0.5,
      emissive: 0x59F4F6,
      side: DoubleSide$1
    });

    this.mesh.traverse((n) => {
      if (n.name.startsWith('Root')) {
        this._root = n;
      }
      if (n.type.endsWith("esh")) {
        if (n.material) {
          n.material.side = DoubleSide$1;
          n.material.transparent = true;
        }
        n.castShadow = n.receiveShadow = true;
        if (n.name === "hat" && n.material.name === 'hat_mat') {
          self._hat = n;
          n.material = shield;
        } else {

          //sconsole.log('mat', n.material.name, n.material.map);
          if (n.material.name.startsWith('Material #63') || n.material.name === "body_mat") {
            self._body = n;
            n.material = shield;
          } else if (n.material.name.startsWith("Material #10")) {
            blue.map = n.material.map;
            blue.alphaMap = n.material.alphaMap;
            blue.transparent = true;
            n.material = blue;
          } else if (n.material.name === 'face_mat') {
            this._face = n;
            //n.material = faceMat;
            // if (self.face) {
            //   self.face.update()
            // }
            //self.facial.UpdatePath('left', 'happy')
          } else {
            const etc = shield.clone();
            etc.map = n.material.map;
            etc.color = n.material.color;
            n.material = etc;
            
          }
        }
      } else if (n.type == 'Bones') {
        if (n.name.startsWith('Hand')) {
          const pl = new PointLight$1(0x00cbfe, 0.4, 0.1);
          n.add(pl);
        }
      }
    });
    //SceneManager._reflect.texture.needsUpdate = true;
    //mesh.position.set(0, 1, 0);
    this.__init(this);
  }

  setEnvironment(src) {
    if (typeof src === 'string') {
      const texture = new TextureLoader$1().load(src, t => t);
      texture.mapping = EquirectangularReflectionMapping$1;
      this._mainMaterials.envMap = texture;
    } else {
      if (src instanceof Texture$1) {
        this._mainMaterials.envMap = src;
      }
    }
  }

  async load(
    src = "./models/tomi/tom-new.gltf",
    progress = undefined,
    compressed = false,
  ) {
    return new Promise(
      (res, rej) => {
        const loader = new GLTFLoader$1();
        loader.load(
          src,
          (asset) => {
            const model = asset.scene || asset;
            if (model) {
              this.bind(model);
              if (asset.animations) {
                this.__loadAnimations(asset);

              }
              res(this);
            } else {
              rej(`invalid mesh`);
            }
          },
          (prog) => {
            if (progress) progress(prog);
          }
        );
      },
      (err) => {
        rej(err);
      }
    );
  }

  __init(m) {
    m.layers.set(6);
  }

  lookAt(target, eyeLevel = true) {
    if (target instanceof Object3D$1) {
      target = target.position.clone();
    }
    if (eyeLevel) target.y = this.position.y;
    this.children[0].lookAt(target);

  }

  sortAnimationClips() {
    // this._clips = _.sortBy(this.clips, (o) => o.name.toLowerCase());
  }

  getClipsContaining(keywords, random = false) {
    const arr = this._clips.filter(c => c.name.startsWith(keywords));
    return (random) ? arr[_.random(false) * arr.length - 1] : arr;
  }

  async __loadAnimations(scene, onlyClips = false, overwrite = false) {
    //console.log(scene.animations);
    if (onlyClips) {
      if (overwrite) this._clips = [];
      scene.animations.forEach(clip => {
        const index = this._clips.length;
        clip.name = `${clip.name} - #${index}`;
        this._clips.push(clip);
      });
      return
    }
    // scene.animations.forEach(clip => {
    //   const index = this._clips.length;
    //   clip.name = `${clip.name} - #${index}`;
    //   this._clips.push(clip);
    // });
	//this._clips = [scene.animations];
    this._clips.push(...scene.animations);
    const mixer = new AnimationMixer$1(this.mesh);

    mixer.timeScale = 1;
    //this._clips = scene.animations;
    const self = this;
    mixer.addEventListener("finished", (e) => {
      self.nextAction();
    });
    mixer.addEventListener("loop", (e) => {
      this._currentIndex = 0;
      // self.dispatchEvent({ type: "animationend" });
      if (this._currentActions.length > 0)
        self.nextAction();
      else {
        self.dispatchEvent({ type: "animationend" });
      }
    });
    this._mixer = mixer;
  }

  nextAction() {
    if (this._currentActions.length > 1) {
      if (this._actionCallbacks[this._currentAction]) {
        this._actionCallbacks[this._currentAction]();
        this._actionCallbacks[this._currentAction] = null;
      }
      const action = this._currentActions.shift();
      this.play(action.clip, action.loop, action.repeat, action.ended, action.paused);
    } else {
      this.play(this._defaultClip, LoopRepeat$1);
      this.dispatchEvent({ type: "animationend" });
    }
  }

  randomClip(seq = ["talkAction", "talkAction2", "talkAction3", "talkAction4", "eureka", "thinking", "sigh"]) {

    const animationId = seq[Math.random() * seq.length - 1];
    this.actions(animationId);
  }

  reset() {
    this._actionCallbacks = {};
    this.face.reset();
    this._defaultClip = 1;
  }

  playAction(sets, autoDefault = true) {
    if (!this._currentActions) this._currentActions = [...sets];
    else this._currentActions.push(sets);

    if (autoDefault) this._currentActions.push(new ActionSet(1, LoopRepeat$1));
    this._playFromSet = true;
    this.nextAction();
  }

  play(clipNameOrIndex, loop = LoopRepeat$1, repeat = 0, ended = undefined, paused = false) {
    this._animating = true;
    let clip;
    this._currentIndex = 0;
    this._currentSequence = [];
    if (typeof clipNameOrIndex === 'number') {
      clip = this._clips[clipNameOrIndex];
    } else {
      clip = AnimationClip$1.findByName(this._clips, clipNameOrIndex);
    }


    //this._mixer.timeScale = 1;
    if (clip) {
      const action = this._mixer.clipAction(clip, this.mesh, NormalAnimationBlendMode$1);
		console.log(clip, action);
      if (ended) {
        this._actionCallbacks[action] = ended;
      }
      if (
        this._currentAction &&
        this._currentAction.getClip().name !== clip.name
      ) {
        const ca = this._currentAction;
        action.loop = loop;
        action.repeat = repeat;
        action.clampWhenFinished = true;
        //action.timeScale = (reverse) ? -1 : 1;

        if (ca) {
          ca.paused = true;
          if (action.paused) action.paused = false;
          action.crossFadeFrom(ca, .5, true).play();
          ca.fadeOut(.5);

          if (!paused) setTimeout(_ => ca.stop(), 800);
        } else {
          action.play();
        }

      } else {
        action.loop = loop;
        action.repeat = repeat;
        action.play();
      }

      this._currentClip = clip;
      this._currentAction = action;
    }
  }

  action(actionName, startIndex = 0) {
    this._currentSequence = NLA[actionName];
    this._currentIndex = startIndex;
    this.play(this._currentSequence[this._currentIndex]);
  }

  appear(clip = 0) {
    if (!this.visible) {
      this.visible = true;
      this.play(clip);
    }
  }

  disappear(clip = 0) {
    if (this.visible) {
      this.stopSound();
      this.visible = false;
    }
  }

  update(delta, elapse = 0) {
    if (this.mesh) ;

    const act = ((Math.random() * 10) == 0);
    if (act) {
      this.face.action(8, -1, -1, 100);
    }
    // if (this.overlayGroup && this.overlayGroup.visible) {
    //   this.overlayGroup.rotateY(0.12 * delta);
    // }
    this.face.update(elapse);
    this._mixer.update(delta);

  }

  async loadTracks(scene, name = undefined) {
    scene.name = name;
    return this.__loadAnimations(scene, true);
  }
}

const waypoints = `[{"x":2.692347288131714,"y":1.3512234687805176,"z":-1.9569206237792969},
{"x":1.9725112915039062,"y":1.164458990097046,"z":-2.0890021324157715},
{"x":2.636974573135376,"y":1.3711497783660889,"z":-1.4529128074645996},
{"x":4.232120990753174,"y":1.3711497783660889,"z":-1.4529128074645996},
{"x":0.5577804446220398,"y":4.463057518005371,"z":10.336880683898926},
{"x":2.692347288131714,"y":1.3512234687805176,"z":-1.9569206237792969},
{"x":1.9725112915039062,"y":1.164458990097046,"z":-2.0890021324157715},
{"x":2.636974573135376,"y":1.3711497783660889,"z":-1.4529128074645996},
{"x":4.232120990753174,"y":1.3711497783660889,"z":-1.4529128074645996},
{"x":0.5577804446220398,"y":4.463057518005371,"z":10.336880683898926}]`;

export const setupAudio = (tomi, mod = 128, mx = 5) => {
    const self = tomi;
    if (!self.autoAnimate) self.autoAnimate = true;
    const setupAnalyzer = (source = undefined) => {
        let analyser, audioCtx;
        if (source instanceof HTMLVideoElement) {
            const ctx = new webkitAudioContext();
            const n = ctx.createMediaElementSource(source);
            analyser = ctx.createAnalyser();
            n.connect(analyser);
            analyser.connect(ctx.destination);
            audioCtx = ctx.destination.context;
        } else {
            analyser = Howler.ctx.createAnalyser();
            Howler.masterGain.connect(analyser);
            analyser.connect(Howler.ctx.destination);
            audioCtx = Howler.ctx.destination.context;
        }


        // Creating output array (according to documentation https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API)
        analyser.fftSize = 2048;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        // Get the Data array
        analyser.getByteTimeDomainData(dataArray);

        self.analyser = analyser;
        self.dataArray = dataArray;
        self.audioCtx = audioCtx;
    };
    let silenceCount = 0;
    const startAnalyze = () => {
        if (self.autoAnimate) {
            self.selfAware(true);
        }
        const tm = setInterval(_ => {
            
            self.analyser.getByteTimeDomainData(self.dataArray);
            const id = self.dataArray[512] % mod;
            const mouthIndex = Math.round(id / mod * mx);
            self.face.setLip(mouthIndex);
            if (id < 1) {
                silenceCount++;
            } else {
                silenceCount = 0;
            }
            if (silenceCount > 50) {
                stopAnalyze();
            }
            //console.log(self.audioCtx.context.state,self.audioCtx.context);
        }, 100);
        self.__tm = tm;
        return { tm };
    };

    const stopAnalyze = () => {
        if (self.autoAnimate) {
            self.selfAware(false);
        }
        if (self.__tm) {
            
            clearInterval(self.__tm);
            self.__tm = null;
        }
    };

    const addSound = (...src) => {
        undefined._sounds.push(...src);
        undefined._sound = new Howl({
            src: undefined._sounds,
            html5: true,
            autoUnlock: true
        });
        const self = undefined;

        undefined._sound.on('play', (e) => {
            if (self._syncClip > -1) {
                self.play(self._syncClip);
            }
        });
    };

    const playSound = async (src, autoSpeak = true) => {
        return await new Promise((res, rej) => {
          if (self._sounds[src]) {
            self._sound = self._sounds[src];
            if (self._sound.playing) {
                self._sound.stop();
            }
            res(self._sound);
            return
          }

          self.face.useAudio = autoSpeak;
          self._sound = new Howl({
            src: src,
            autoplay: false,
            userWebAudio: true,
            onplay: () => {
              self.face.talking = (self.face.useAudio);
              if (!self.analyser) self.setupAnalyzer();
              if (self.face.useAudio) self.startAnalyze();

            },
            onstop: () => {
              if (self.__tm) {
                clearInterval(self.__tm);
                self.__tm = null;
              }
              self.face.talking = false;
              //self.dispatchEvent({ type: 'audiostop' });
            },
            onended: () => {
              if (self.__tm) {
                clearInterval(self.__tm);
                self.__tm = null;
                self.face.talking = false;
              }
            }
          });
    
          self._sound.once('load', () => {
            res(self._sound);
          });
          self._sounds[src] = self._sound;
    
        });
      };
    
      const soundPosition = (tm = 0) => {
        if (self._sound) {
            self._sound.pause();
            self._sound.pos = tm;
            self._sound.play();
        }
      };
    
      const disableAutoSpeak = ()=> {
        if (self.__tm) {
          clearInterval(undefined.__tm);
          self.__tm = null;
        }
      };
    
      const soundDuration = () => {
        if (self._sound && self._sound.playing) {
          const seek = self._sound.seek() || 0;
          const timeDisplay = formatTime(Math.round(seek));
          const duration = self._sound.duration();
          return { timeDisplay, seek, duration }
        }
        return null;
      };
    
      const stopSound = () => {
        if (self._sound && self._sound.playing) {
            self._sound.stop();
        }
      };

    if (self) {
        self.setupAnalyzer = setupAnalyzer;
        self.startAnalyze = startAnalyze;
        self.stopAnalyze = stopAnalyze;
        self.addSound = addSound;
        self.playSound = playSound;
        self.soundPosition = soundPosition;
        self.disableAutoSpeak = disableAutoSpeak;
        self.soundDuration = soundDuration;
        self.stopSound = stopSound;
    }
};

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle( css ) {

	if ( ! css ) {

		return;

	}
	if ( typeof window === 'undefined' ) {

		return;

	}

	var style = document.createElement( 'style' );

	style.setAttribute( 'type', 'text/css' );
	style.innerHTML = css;
	document.head.appendChild( style );

	return css;

}

function colorToString( color, forceCSSHex ) {

	var colorFormat = color.__state.conversionName.toString();
	var r = Math.round( color.r );
	var g = Math.round( color.g );
	var b = Math.round( color.b );
	var a = color.a;
	var h = Math.round( color.h );
	var s = color.s.toFixed( 1 );
	var v = color.v.toFixed( 1 );
	if ( forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX' ) {

		var str = color.hex.toString( 16 );
		while ( str.length < 6 ) {

			str = '0' + str;

		}
		return '#' + str;

	} else if ( colorFormat === 'CSS_RGB' ) {

		return 'rgb(' + r + ',' + g + ',' + b + ')';

	} else if ( colorFormat === 'CSS_RGBA' ) {

		return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

	} else if ( colorFormat === 'HEX' ) {

		return '0x' + color.hex.toString( 16 );

	} else if ( colorFormat === 'RGB_ARRAY' ) {

		return '[' + r + ',' + g + ',' + b + ']';

	} else if ( colorFormat === 'RGBA_ARRAY' ) {

		return '[' + r + ',' + g + ',' + b + ',' + a + ']';

	} else if ( colorFormat === 'RGB_OBJ' ) {

		return '{r:' + r + ',g:' + g + ',b:' + b + '}';

	} else if ( colorFormat === 'RGBA_OBJ' ) {

		return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';

	} else if ( colorFormat === 'HSV_OBJ' ) {

		return '{h:' + h + ',s:' + s + ',v:' + v + '}';

	} else if ( colorFormat === 'HSVA_OBJ' ) {

		return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';

	}
	return 'unknown format';

}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
	BREAK: {},
	extend: function extend( target ) {

		this.each( ARR_SLICE.call( arguments, 1 ), function ( obj ) {

			var keys = this.isObject( obj ) ? Object.keys( obj ) : [];
			keys.forEach( function ( key ) {

				if ( ! this.isUndefined( obj[ key ] ) ) {

					target[ key ] = obj[ key ];

				}

			}.bind( this ) );

		}, this );
		return target;

	},
	defaults: function defaults( target ) {

		this.each( ARR_SLICE.call( arguments, 1 ), function ( obj ) {

			var keys = this.isObject( obj ) ? Object.keys( obj ) : [];
			keys.forEach( function ( key ) {

				if ( this.isUndefined( target[ key ] ) ) {

					target[ key ] = obj[ key ];

				}

			}.bind( this ) );

		}, this );
		return target;

	},
	compose: function compose() {

		var toCall = ARR_SLICE.call( arguments );
		return function () {

			var args = ARR_SLICE.call( arguments );
			for ( var i = toCall.length - 1; i >= 0; i -- ) {

				args = [ toCall[ i ].apply( this, args ) ];

			}
			return args[ 0 ];

		};

	},
	each: function each( obj, itr, scope ) {

		if ( ! obj ) {

			return;

		}
		if ( ARR_EACH && obj.forEach && obj.forEach === ARR_EACH ) {

			obj.forEach( itr, scope );

		} else if ( obj.length === obj.length + 0 ) {

			var key = void 0;
			var l = void 0;
			for ( key = 0, l = obj.length; key < l; key ++ ) {

				if ( key in obj && itr.call( scope, obj[ key ], key ) === this.BREAK ) {

					return;

				}

			}

		} else {

			for ( var _key in obj ) {

				if ( itr.call( scope, obj[ _key ], _key ) === this.BREAK ) {

					return;

				}

			}

		}

	},
	defer: function defer( fnc ) {

		setTimeout( fnc, 0 );

	},
	debounce: function debounce( func, threshold, callImmediately ) {

		var timeout = void 0;
		return function () {

			var obj = this;
			var args = arguments;
			function delayed() {

				timeout = null;
				if ( ! callImmediately ) func.apply( obj, args );

			}
			var callNow = callImmediately || ! timeout;
			clearTimeout( timeout );
			timeout = setTimeout( delayed, threshold );
			if ( callNow ) {

				func.apply( obj, args );

			}

		};

	},
	toArray: function toArray( obj ) {

		if ( obj.toArray ) return obj.toArray();
		return ARR_SLICE.call( obj );

	},
	isUndefined: function isUndefined( obj ) {

		return obj === undefined;

	},
	isNull: function isNull( obj ) {

		return obj === null;

	},
	isNaN: function ( _isNaN ) {

		function isNaN() {

			return _isNaN.apply( this, arguments );

		}
		isNaN.toString = function () {

			return _isNaN.toString();

		};
		return isNaN;

	}( function ( obj ) {

		return isNaN( obj );

	} ),
	isArray: Array.isArray || function ( obj ) {

		return obj.constructor === Array;

	},
	isObject: function isObject( obj ) {

		return obj === Object( obj );

	},
	isNumber: function isNumber( obj ) {

		return obj === obj + 0;

	},
	isString: function isString( obj ) {

		return obj === obj + '';

	},
	isBoolean: function isBoolean( obj ) {

		return obj === false || obj === true;

	},
	isFunction: function isFunction( obj ) {

		return obj instanceof Function;

	}
};

var INTERPRETATIONS = [
	{
		litmus: Common.isString,
		conversions: {
			THREE_CHAR_HEX: {
				read: function read( original ) {

					var test = original.match( /^#([A-F0-9])([A-F0-9])([A-F0-9])$/i );
					if ( test === null ) {

						return false;

					}
					return {
						space: 'HEX',
						hex: parseInt( '0x' + test[ 1 ].toString() + test[ 1 ].toString() + test[ 2 ].toString() + test[ 2 ].toString() + test[ 3 ].toString() + test[ 3 ].toString(), 0 )
					};

				},
				write: colorToString
			},
			SIX_CHAR_HEX: {
				read: function read( original ) {

					var test = original.match( /^#([A-F0-9]{6})$/i );
					if ( test === null ) {

						return false;

					}
					return {
						space: 'HEX',
						hex: parseInt( '0x' + test[ 1 ].toString(), 0 )
					};

				},
				write: colorToString
			},
			CSS_RGB: {
				read: function read( original ) {

					var test = original.match( /^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/ );
					if ( test === null ) {

						return false;

					}
					return {
						space: 'RGB',
						r: parseFloat( test[ 1 ] ),
						g: parseFloat( test[ 2 ] ),
						b: parseFloat( test[ 3 ] )
					};

				},
				write: colorToString
			},
			CSS_RGBA: {
				read: function read( original ) {

					var test = original.match( /^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/ );
					if ( test === null ) {

						return false;

					}
					return {
						space: 'RGB',
						r: parseFloat( test[ 1 ] ),
						g: parseFloat( test[ 2 ] ),
						b: parseFloat( test[ 3 ] ),
						a: parseFloat( test[ 4 ] )
					};

				},
				write: colorToString
			}
		}
	},
	{
		litmus: Common.isNumber,
		conversions: {
			HEX: {
				read: function read( original ) {

					return {
						space: 'HEX',
						hex: original,
						conversionName: 'HEX'
					};

				},
				write: function write( color ) {

					return color.hex;

				}
			}
		}
	},
	{
		litmus: Common.isArray,
		conversions: {
			RGB_ARRAY: {
				read: function read( original ) {

					if ( original.length !== 3 ) {

						return false;

					}
					return {
						space: 'RGB',
						r: original[ 0 ],
						g: original[ 1 ],
						b: original[ 2 ]
					};

				},
				write: function write( color ) {

					return [ color.r, color.g, color.b ];

				}
			},
			RGBA_ARRAY: {
				read: function read( original ) {

					if ( original.length !== 4 ) return false;
					return {
						space: 'RGB',
						r: original[ 0 ],
						g: original[ 1 ],
						b: original[ 2 ],
						a: original[ 3 ]
					};

				},
				write: function write( color ) {

					return [ color.r, color.g, color.b, color.a ];

				}
			}
		}
	},
	{
		litmus: Common.isObject,
		conversions: {
			RGBA_OBJ: {
				read: function read( original ) {

					if ( Common.isNumber( original.r ) && Common.isNumber( original.g ) && Common.isNumber( original.b ) && Common.isNumber( original.a ) ) {

						return {
							space: 'RGB',
							r: original.r,
							g: original.g,
							b: original.b,
							a: original.a
						};

					}
					return false;

				},
				write: function write( color ) {

					return {
						r: color.r,
						g: color.g,
						b: color.b,
						a: color.a
					};

				}
			},
			RGB_OBJ: {
				read: function read( original ) {

					if ( Common.isNumber( original.r ) && Common.isNumber( original.g ) && Common.isNumber( original.b ) ) {

						return {
							space: 'RGB',
							r: original.r,
							g: original.g,
							b: original.b
						};

					}
					return false;

				},
				write: function write( color ) {

					return {
						r: color.r,
						g: color.g,
						b: color.b
					};

				}
			},
			HSVA_OBJ: {
				read: function read( original ) {

					if ( Common.isNumber( original.h ) && Common.isNumber( original.s ) && Common.isNumber( original.v ) && Common.isNumber( original.a ) ) {

						return {
							space: 'HSV',
							h: original.h,
							s: original.s,
							v: original.v,
							a: original.a
						};

					}
					return false;

				},
				write: function write( color ) {

					return {
						h: color.h,
						s: color.s,
						v: color.v,
						a: color.a
					};

				}
			},
			HSV_OBJ: {
				read: function read( original ) {

					if ( Common.isNumber( original.h ) && Common.isNumber( original.s ) && Common.isNumber( original.v ) ) {

						return {
							space: 'HSV',
							h: original.h,
							s: original.s,
							v: original.v
						};

					}
					return false;

				},
				write: function write( color ) {

					return {
						h: color.h,
						s: color.s,
						v: color.v
					};

				}
			}
		}
	} ];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {

	toReturn = false;
	var original = arguments.length > 1 ? Common.toArray( arguments ) : arguments[ 0 ];
	Common.each( INTERPRETATIONS, function ( family ) {

		if ( family.litmus( original ) ) {

			Common.each( family.conversions, function ( conversion, conversionName ) {

				result = conversion.read( original );
				if ( toReturn === false && result !== false ) {

					toReturn = result;
					result.conversionName = conversionName;
					result.conversion = conversion;
					return Common.BREAK;

				}

			} );
			return Common.BREAK;

		}

	} );
	return toReturn;

};

var tmpComponent = void 0;
var ColorMath = {
	hsv_to_rgb: function hsv_to_rgb( h, s, v ) {

		var hi = Math.floor( h / 60 ) % 6;
		var f = h / 60 - Math.floor( h / 60 );
		var p = v * ( 1.0 - s );
		var q = v * ( 1.0 - f * s );
		var t = v * ( 1.0 - ( 1.0 - f ) * s );
		var c = [[ v, t, p ], [ q, v, p ], [ p, v, t ], [ p, q, v ], [ t, p, v ], [ v, p, q ]][ hi ];
		return {
			r: c[ 0 ] * 255,
			g: c[ 1 ] * 255,
			b: c[ 2 ] * 255
		};

	},
	rgb_to_hsv: function rgb_to_hsv( r, g, b ) {

		var min = Math.min( r, g, b );
		var max = Math.max( r, g, b );
		var delta = max - min;
		var h = void 0;
		var s = void 0;
		if ( max !== 0 ) {

			s = delta / max;

		} else {

			return {
				h: NaN,
				s: 0,
				v: 0
			};

		}
		if ( r === max ) {

			h = ( g - b ) / delta;

		} else if ( g === max ) {

			h = 2 + ( b - r ) / delta;

		} else {

			h = 4 + ( r - g ) / delta;

		}
		h /= 6;
		if ( h < 0 ) {

			h += 1;

		}
		return {
			h: h * 360,
			s: s,
			v: max / 255
		};

	},
	rgb_to_hex: function rgb_to_hex( r, g, b ) {

		var hex = this.hex_with_component( 0, 2, r );
		hex = this.hex_with_component( hex, 1, g );
		hex = this.hex_with_component( hex, 0, b );
		return hex;

	},
	component_from_hex: function component_from_hex( hex, componentIndex ) {

		return hex >> componentIndex * 8 & 0xFF;

	},
	hex_with_component: function hex_with_component( hex, componentIndex, value ) {

		return value << ( tmpComponent = componentIndex * 8 ) | hex & ~ ( 0xFF << tmpComponent );

	}
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function ( obj ) {

	return typeof obj;

} : function ( obj ) {

	return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;

};











var classCallCheck = function ( instance, Constructor ) {

	if ( ! ( instance instanceof Constructor ) ) {

		throw new TypeError( "Cannot call a class as a function" );

	}

};

var createClass = function () {

	function defineProperties( target, props ) {

		for ( var i = 0; i < props.length; i ++ ) {

			var descriptor = props[ i ];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ( "value" in descriptor ) descriptor.writable = true;
			Object.defineProperty( target, descriptor.key, descriptor );

		}

	}

	return function ( Constructor, protoProps, staticProps ) {

		if ( protoProps ) defineProperties( Constructor.prototype, protoProps );
		if ( staticProps ) defineProperties( Constructor, staticProps );
		return Constructor;

	};

}();







var get = function get( object, property, receiver ) {

	if ( object === null ) object = Function.prototype;
	var desc = Object.getOwnPropertyDescriptor( object, property );

	if ( desc === undefined ) {

		var parent = Object.getPrototypeOf( object );

		if ( parent === null ) {

			return undefined;

		} else {

			return get( parent, property, receiver );

		}

	} else if ( "value" in desc ) {

		return desc.value;

	} else {

		var getter = desc.get;

		if ( getter === undefined ) {

			return undefined;

		}

		return getter.call( receiver );

	}

};

var inherits = function ( subClass, superClass ) {

	if ( typeof superClass !== "function" && superClass !== null ) {

		throw new TypeError( "Super expression must either be null or a function, not " + typeof superClass );

	}

	subClass.prototype = Object.create( superClass && superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	} );
	if ( superClass ) Object.setPrototypeOf ? Object.setPrototypeOf( subClass, superClass ) : subClass.__proto__ = superClass;

};











var possibleConstructorReturn = function ( self, call ) {

	if ( ! self ) {

		throw new ReferenceError( "this hasn't been initialised - super() hasn't been called" );

	}

	return call && ( typeof call === "object" || typeof call === "function" ) ? call : self;

};

var Color = function () {

	function Color() {

		classCallCheck( this, Color );
		this.__state = interpret.apply( this, arguments );
		if ( this.__state === false ) {

			throw new Error( 'Failed to interpret color arguments' );

		}
		this.__state.a = this.__state.a || 1;

	}
	createClass( Color, [ {
		key: 'toString',
		value: function toString() {

			return colorToString( this );

		}
	}, {
		key: 'toHexString',
		value: function toHexString() {

			return colorToString( this, true );

		}
	}, {
		key: 'toOriginal',
		value: function toOriginal() {

			return this.__state.conversion.write( this );

		}
	} ] );
	return Color;

}();
function defineRGBComponent( target, component, componentHexIndex ) {

	Object.defineProperty( target, component, {
		get: function get$$1() {

			if ( this.__state.space === 'RGB' ) {

				return this.__state[ component ];

			}
			Color.recalculateRGB( this, component, componentHexIndex );
			return this.__state[ component ];

		},
		set: function set$$1( v ) {

			if ( this.__state.space !== 'RGB' ) {

				Color.recalculateRGB( this, component, componentHexIndex );
				this.__state.space = 'RGB';

			}
			this.__state[ component ] = v;

		}
	} );

}
function defineHSVComponent( target, component ) {

	Object.defineProperty( target, component, {
		get: function get$$1() {

			if ( this.__state.space === 'HSV' ) {

				return this.__state[ component ];

			}
			Color.recalculateHSV( this );
			return this.__state[ component ];

		},
		set: function set$$1( v ) {

			if ( this.__state.space !== 'HSV' ) {

				Color.recalculateHSV( this );
				this.__state.space = 'HSV';

			}
			this.__state[ component ] = v;

		}
	} );

}
Color.recalculateRGB = function ( color, component, componentHexIndex ) {

	if ( color.__state.space === 'HEX' ) {

		color.__state[ component ] = ColorMath.component_from_hex( color.__state.hex, componentHexIndex );

	} else if ( color.__state.space === 'HSV' ) {

		Common.extend( color.__state, ColorMath.hsv_to_rgb( color.__state.h, color.__state.s, color.__state.v ) );

	} else {

		throw new Error( 'Corrupted color state' );

	}

};
Color.recalculateHSV = function ( color ) {

	var result = ColorMath.rgb_to_hsv( color.r, color.g, color.b );
	Common.extend( color.__state, {
		s: result.s,
		v: result.v
	} );
	if ( ! Common.isNaN( result.h ) ) {

		color.__state.h = result.h;

	} else if ( Common.isUndefined( color.__state.h ) ) {

		color.__state.h = 0;

	}

};
Color.COMPONENTS = [ 'r', 'g', 'b', 'h', 's', 'v', 'hex', 'a' ];
defineRGBComponent( Color.prototype, 'r', 2 );
defineRGBComponent( Color.prototype, 'g', 1 );
defineRGBComponent( Color.prototype, 'b', 0 );
defineHSVComponent( Color.prototype, 'h' );
defineHSVComponent( Color.prototype, 's' );
defineHSVComponent( Color.prototype, 'v' );
Object.defineProperty( Color.prototype, 'a', {
	get: function get$$1() {

		return this.__state.a;

	},
	set: function set$$1( v ) {

		this.__state.a = v;

	}
} );
Object.defineProperty( Color.prototype, 'hex', {
	get: function get$$1() {

		if ( this.__state.space !== 'HEX' ) {

			this.__state.hex = ColorMath.rgb_to_hex( this.r, this.g, this.b );
			this.__state.space = 'HEX';

		}
		return this.__state.hex;

	},
	set: function set$$1( v ) {

		this.__state.space = 'HEX';
		this.__state.hex = v;

	}
} );

var Controller = function () {

	function Controller( object, property ) {

		classCallCheck( this, Controller );
		this.initialValue = object[ property ];
		this.domElement = document.createElement( 'div' );
		this.object = object;
		this.property = property;
		this.__onChange = undefined;
		this.__onFinishChange = undefined;

	}
	createClass( Controller, [ {
		key: 'onChange',
		value: function onChange( fnc ) {

			this.__onChange = fnc;
			return this;

		}
	}, {
		key: 'onFinishChange',
		value: function onFinishChange( fnc ) {

			this.__onFinishChange = fnc;
			return this;

		}
	}, {
		key: 'setValue',
		value: function setValue( newValue ) {

			this.object[ this.property ] = newValue;
			if ( this.__onChange ) {

				this.__onChange.call( this, newValue );

			}
			this.updateDisplay();
			return this;

		}
	}, {
		key: 'getValue',
		value: function getValue() {

			return this.object[ this.property ];

		}
	}, {
		key: 'updateDisplay',
		value: function updateDisplay() {

			return this;

		}
	}, {
		key: 'isModified',
		value: function isModified() {

			return this.initialValue !== this.getValue();

		}
	} ] );
	return Controller;

}();

var EVENT_MAP = {
	HTMLEvents: [ 'change' ],
	MouseEvents: [ 'click', 'mousemove', 'mousedown', 'mouseup', 'mouseover' ],
	KeyboardEvents: [ 'keydown' ]
};
var EVENT_MAP_INV = {};
Common.each( EVENT_MAP, function ( v, k ) {

	Common.each( v, function ( e ) {

		EVENT_MAP_INV[ e ] = k;

	} );

} );
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels( val ) {

	if ( val === '0' || Common.isUndefined( val ) ) {

		return 0;

	}
	var match = val.match( CSS_VALUE_PIXELS );
	if ( ! Common.isNull( match ) ) {

		return parseFloat( match[ 1 ] );

	}
	return 0;

}
var dom = {
	makeSelectable: function makeSelectable( elem, selectable ) {

		if ( elem === undefined || elem.style === undefined ) return;
		elem.onselectstart = selectable ? function () {

			return false;

		} : function () {};
		elem.style.MozUserSelect = selectable ? 'auto' : 'none';
		elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
		elem.unselectable = selectable ? 'on' : 'off';

	},
	makeFullscreen: function makeFullscreen( elem, hor, vert ) {

		var vertical = vert;
		var horizontal = hor;
		if ( Common.isUndefined( horizontal ) ) {

			horizontal = true;

		}
		if ( Common.isUndefined( vertical ) ) {

			vertical = true;

		}
		elem.style.position = 'absolute';
		if ( horizontal ) {

			elem.style.left = 0;
			elem.style.right = 0;

		}
		if ( vertical ) {

			elem.style.top = 0;
			elem.style.bottom = 0;

		}

	},
	fakeEvent: function fakeEvent( elem, eventType, pars, aux ) {

		var params = pars || {};
		var className = EVENT_MAP_INV[ eventType ];
		if ( ! className ) {

			throw new Error( 'Event type ' + eventType + ' not supported.' );

		}
		var evt = document.createEvent( className );
		switch ( className ) {

			case 'MouseEvents':
			{

				var clientX = params.x || params.clientX || 0;
				var clientY = params.y || params.clientY || 0;
				evt.initMouseEvent( eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
					0,
					clientX,
					clientY,
					false, false, false, false, 0, null );
				break;

			}
			case 'KeyboardEvents':
			{

				var init = evt.initKeyboardEvent || evt.initKeyEvent;
				Common.defaults( params, {
					cancelable: true,
					ctrlKey: false,
					altKey: false,
					shiftKey: false,
					metaKey: false,
					keyCode: undefined,
					charCode: undefined
				} );
				init( eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode );
				break;

			}
			default:
			{

				evt.initEvent( eventType, params.bubbles || false, params.cancelable || true );
				break;

			}

		}
		Common.defaults( evt, aux );
		elem.dispatchEvent( evt );

	},
	bind: function bind( elem, event, func, newBool ) {

		var bool = newBool || false;
		if ( elem.addEventListener ) {

			elem.addEventListener( event, func, bool );

		} else if ( elem.attachEvent ) {

			elem.attachEvent( 'on' + event, func );

		}
		return dom;

	},
	unbind: function unbind( elem, event, func, newBool ) {

		var bool = newBool || false;
		if ( elem.removeEventListener ) {

			elem.removeEventListener( event, func, bool );

		} else if ( elem.detachEvent ) {

			elem.detachEvent( 'on' + event, func );

		}
		return dom;

	},
	addClass: function addClass( elem, className ) {

		if ( elem.className === undefined ) {

			elem.className = className;

		} else if ( elem.className !== className ) {

			var classes = elem.className.split( / +/ );
			if ( classes.indexOf( className ) === - 1 ) {

				classes.push( className );
				elem.className = classes.join( ' ' ).replace( /^\s+/, '' ).replace( /\s+$/, '' );

			}

		}
		return dom;

	},
	removeClass: function removeClass( elem, className ) {

		if ( className ) {

			if ( elem.className === className ) {

				elem.removeAttribute( 'class' );

			} else {

				var classes = elem.className.split( / +/ );
				var index = classes.indexOf( className );
				if ( index !== - 1 ) {

					classes.splice( index, 1 );
					elem.className = classes.join( ' ' );

				}

			}

		} else {

			elem.className = undefined;

		}
		return dom;

	},
	hasClass: function hasClass( elem, className ) {

		return new RegExp( '(?:^|\\s+)' + className + '(?:\\s+|$)' ).test( elem.className ) || false;

	},
	getWidth: function getWidth( elem ) {

		var style = getComputedStyle( elem );
		return cssValueToPixels( style[ 'border-left-width' ] ) + cssValueToPixels( style[ 'border-right-width' ] ) + cssValueToPixels( style[ 'padding-left' ] ) + cssValueToPixels( style[ 'padding-right' ] ) + cssValueToPixels( style.width );

	},
	getHeight: function getHeight( elem ) {

		var style = getComputedStyle( elem );
		return cssValueToPixels( style[ 'border-top-width' ] ) + cssValueToPixels( style[ 'border-bottom-width' ] ) + cssValueToPixels( style[ 'padding-top' ] ) + cssValueToPixels( style[ 'padding-bottom' ] ) + cssValueToPixels( style.height );

	},
	getOffset: function getOffset( el ) {

		var elem = el;
		var offset = { left: 0, top: 0 };
		if ( elem.offsetParent ) {

			do {

				offset.left += elem.offsetLeft;
				offset.top += elem.offsetTop;
				elem = elem.offsetParent;

			} while ( elem );

		}
		return offset;

	},
	isActive: function isActive( elem ) {

		return elem === document.activeElement && ( elem.type || elem.href );

	}
};

var BooleanController = function ( _Controller ) {

	inherits( BooleanController, _Controller );
	function BooleanController( object, property ) {

		classCallCheck( this, BooleanController );
		var _this2 = possibleConstructorReturn( this, ( BooleanController.__proto__ || Object.getPrototypeOf( BooleanController ) ).call( this, object, property ) );
		var _this = _this2;
		_this2.__prev = _this2.getValue();
		_this2.__checkbox = document.createElement( 'input' );
		_this2.__checkbox.setAttribute( 'type', 'checkbox' );
		function onChange() {

			_this.setValue( ! _this.__prev );

		}
		dom.bind( _this2.__checkbox, 'change', onChange, false );
		_this2.domElement.appendChild( _this2.__checkbox );
		_this2.updateDisplay();
		return _this2;

	}
	createClass( BooleanController, [ {
		key: 'setValue',
		value: function setValue( v ) {

			var toReturn = get( BooleanController.prototype.__proto__ || Object.getPrototypeOf( BooleanController.prototype ), 'setValue', this ).call( this, v );
			if ( this.__onFinishChange ) {

				this.__onFinishChange.call( this, this.getValue() );

			}
			this.__prev = this.getValue();
			return toReturn;

		}
	}, {
		key: 'updateDisplay',
		value: function updateDisplay() {

			if ( this.getValue() === true ) {

				this.__checkbox.setAttribute( 'checked', 'checked' );
				this.__checkbox.checked = true;
				this.__prev = true;

			} else {

				this.__checkbox.checked = false;
				this.__prev = false;

			}
			return get( BooleanController.prototype.__proto__ || Object.getPrototypeOf( BooleanController.prototype ), 'updateDisplay', this ).call( this );

		}
	} ] );
	return BooleanController;

}( Controller );

var OptionController = function ( _Controller ) {

	inherits( OptionController, _Controller );
	function OptionController( object, property, opts ) {

		classCallCheck( this, OptionController );
		var _this2 = possibleConstructorReturn( this, ( OptionController.__proto__ || Object.getPrototypeOf( OptionController ) ).call( this, object, property ) );
		var options = opts;
		var _this = _this2;
		_this2.__select = document.createElement( 'select' );
		if ( Common.isArray( options ) ) {

			var map = {};
			Common.each( options, function ( element ) {

				map[ element ] = element;

			} );
			options = map;

		}
		Common.each( options, function ( value, key ) {

			var opt = document.createElement( 'option' );
			opt.innerHTML = key;
			opt.setAttribute( 'value', value );
			_this.__select.appendChild( opt );

		} );
		_this2.updateDisplay();
		dom.bind( _this2.__select, 'change', function () {

			var desiredValue = this.options[ this.selectedIndex ].value;
			_this.setValue( desiredValue );

		} );
		_this2.domElement.appendChild( _this2.__select );
		return _this2;

	}
	createClass( OptionController, [ {
		key: 'setValue',
		value: function setValue( v ) {

			var toReturn = get( OptionController.prototype.__proto__ || Object.getPrototypeOf( OptionController.prototype ), 'setValue', this ).call( this, v );
			if ( this.__onFinishChange ) {

				this.__onFinishChange.call( this, this.getValue() );

			}
			return toReturn;

		}
	}, {
		key: 'updateDisplay',
		value: function updateDisplay() {

			if ( dom.isActive( this.__select ) ) return this;
			this.__select.value = this.getValue();
			return get( OptionController.prototype.__proto__ || Object.getPrototypeOf( OptionController.prototype ), 'updateDisplay', this ).call( this );

		}
	} ] );
	return OptionController;

}( Controller );

var StringController = function ( _Controller ) {

	inherits( StringController, _Controller );
	function StringController( object, property ) {

		classCallCheck( this, StringController );
		var _this2 = possibleConstructorReturn( this, ( StringController.__proto__ || Object.getPrototypeOf( StringController ) ).call( this, object, property ) );
		var _this = _this2;
		function onChange() {

			_this.setValue( _this.__input.value );

		}
		function onBlur() {

			if ( _this.__onFinishChange ) {

				_this.__onFinishChange.call( _this, _this.getValue() );

			}

		}
		_this2.__input = document.createElement( 'input' );
		_this2.__input.setAttribute( 'type', 'text' );
		dom.bind( _this2.__input, 'keyup', onChange );
		dom.bind( _this2.__input, 'change', onChange );
		dom.bind( _this2.__input, 'blur', onBlur );
		dom.bind( _this2.__input, 'keydown', function ( e ) {

			if ( e.keyCode === 13 ) {

				this.blur();

			}

		} );
		_this2.updateDisplay();
		_this2.domElement.appendChild( _this2.__input );
		return _this2;

	}
	createClass( StringController, [ {
		key: 'updateDisplay',
		value: function updateDisplay() {

			if ( ! dom.isActive( this.__input ) ) {

				this.__input.value = this.getValue();

			}
			return get( StringController.prototype.__proto__ || Object.getPrototypeOf( StringController.prototype ), 'updateDisplay', this ).call( this );

		}
	} ] );
	return StringController;

}( Controller );

function numDecimals( x ) {

	var _x = x.toString();
	if ( _x.indexOf( '.' ) > - 1 ) {

		return _x.length - _x.indexOf( '.' ) - 1;

	}
	return 0;

}
var NumberController = function ( _Controller ) {

	inherits( NumberController, _Controller );
	function NumberController( object, property, params ) {

		classCallCheck( this, NumberController );
		var _this = possibleConstructorReturn( this, ( NumberController.__proto__ || Object.getPrototypeOf( NumberController ) ).call( this, object, property ) );
		var _params = params || {};
		_this.__min = _params.min;
		_this.__max = _params.max;
		_this.__step = _params.step;
		if ( Common.isUndefined( _this.__step ) ) {

			if ( _this.initialValue === 0 ) {

				_this.__impliedStep = 1;

			} else {

				_this.__impliedStep = Math.pow( 10, Math.floor( Math.log( Math.abs( _this.initialValue ) ) / Math.LN10 ) ) / 10;

			}

		} else {

			_this.__impliedStep = _this.__step;

		}
		_this.__precision = numDecimals( _this.__impliedStep );
		return _this;

	}
	createClass( NumberController, [ {
		key: 'setValue',
		value: function setValue( v ) {

			var _v = v;
			if ( this.__min !== undefined && _v < this.__min ) {

				_v = this.__min;

			} else if ( this.__max !== undefined && _v > this.__max ) {

				_v = this.__max;

			}
			if ( this.__step !== undefined && _v % this.__step !== 0 ) {

				_v = Math.round( _v / this.__step ) * this.__step;

			}
			return get( NumberController.prototype.__proto__ || Object.getPrototypeOf( NumberController.prototype ), 'setValue', this ).call( this, _v );

		}
	}, {
		key: 'min',
		value: function min( minValue ) {

			this.__min = minValue;
			return this;

		}
	}, {
		key: 'max',
		value: function max( maxValue ) {

			this.__max = maxValue;
			return this;

		}
	}, {
		key: 'step',
		value: function step( stepValue ) {

			this.__step = stepValue;
			this.__impliedStep = stepValue;
			this.__precision = numDecimals( stepValue );
			return this;

		}
	} ] );
	return NumberController;

}( Controller );

function roundToDecimal( value, decimals ) {

	var tenTo = Math.pow( 10, decimals );
	return Math.round( value * tenTo ) / tenTo;

}
var NumberControllerBox = function ( _NumberController ) {

	inherits( NumberControllerBox, _NumberController );
	function NumberControllerBox( object, property, params ) {

		classCallCheck( this, NumberControllerBox );
		var _this2 = possibleConstructorReturn( this, ( NumberControllerBox.__proto__ || Object.getPrototypeOf( NumberControllerBox ) ).call( this, object, property, params ) );
		_this2.__truncationSuspended = false;
		var _this = _this2;
		var prevY = void 0;
		function onChange() {

			var attempted = parseFloat( _this.__input.value );
			if ( ! Common.isNaN( attempted ) ) {

				_this.setValue( attempted );

			}

		}
		function onFinish() {

			if ( _this.__onFinishChange ) {

				_this.__onFinishChange.call( _this, _this.getValue() );

			}

		}
		function onBlur() {

			onFinish();

		}
		function onMouseDrag( e ) {

			var diff = prevY - e.clientY;
			_this.setValue( _this.getValue() + diff * _this.__impliedStep );
			prevY = e.clientY;

		}
		function onMouseUp() {

			dom.unbind( window, 'mousemove', onMouseDrag );
			dom.unbind( window, 'mouseup', onMouseUp );
			onFinish();

		}
		function onMouseDown( e ) {

			dom.bind( window, 'mousemove', onMouseDrag );
			dom.bind( window, 'mouseup', onMouseUp );
			prevY = e.clientY;

		}
		_this2.__input = document.createElement( 'input' );
		_this2.__input.setAttribute( 'type', 'text' );
		dom.bind( _this2.__input, 'change', onChange );
		dom.bind( _this2.__input, 'blur', onBlur );
		dom.bind( _this2.__input, 'mousedown', onMouseDown );
		dom.bind( _this2.__input, 'keydown', function ( e ) {

			if ( e.keyCode === 13 ) {

				_this.__truncationSuspended = true;
				this.blur();
				_this.__truncationSuspended = false;
				onFinish();

			}

		} );
		_this2.updateDisplay();
		_this2.domElement.appendChild( _this2.__input );
		return _this2;

	}
	createClass( NumberControllerBox, [ {
		key: 'updateDisplay',
		value: function updateDisplay() {

			this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal( this.getValue(), this.__precision );
			return get( NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf( NumberControllerBox.prototype ), 'updateDisplay', this ).call( this );

		}
	} ] );
	return NumberControllerBox;

}( NumberController );

function map( v, i1, i2, o1, o2 ) {

	return o1 + ( o2 - o1 ) * ( ( v - i1 ) / ( i2 - i1 ) );

}
var NumberControllerSlider = function ( _NumberController ) {

	inherits( NumberControllerSlider, _NumberController );
	function NumberControllerSlider( object, property, min, max, step ) {

		classCallCheck( this, NumberControllerSlider );
		var _this2 = possibleConstructorReturn( this, ( NumberControllerSlider.__proto__ || Object.getPrototypeOf( NumberControllerSlider ) ).call( this, object, property, { min: min, max: max, step: step } ) );
		var _this = _this2;
		_this2.__background = document.createElement( 'div' );
		_this2.__foreground = document.createElement( 'div' );
		dom.bind( _this2.__background, 'mousedown', onMouseDown );
		dom.bind( _this2.__background, 'touchstart', onTouchStart );
		dom.addClass( _this2.__background, 'slider' );
		dom.addClass( _this2.__foreground, 'slider-fg' );
		function onMouseDown( e ) {

			document.activeElement.blur();
			dom.bind( window, 'mousemove', onMouseDrag );
			dom.bind( window, 'mouseup', onMouseUp );
			onMouseDrag( e );

		}
		function onMouseDrag( e ) {

			e.preventDefault();
			var bgRect = _this.__background.getBoundingClientRect();
			_this.setValue( map( e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max ) );
			return false;

		}
		function onMouseUp() {

			dom.unbind( window, 'mousemove', onMouseDrag );
			dom.unbind( window, 'mouseup', onMouseUp );
			if ( _this.__onFinishChange ) {

				_this.__onFinishChange.call( _this, _this.getValue() );

			}

		}
		function onTouchStart( e ) {

			if ( e.touches.length !== 1 ) {

				return;

			}
			dom.bind( window, 'touchmove', onTouchMove );
			dom.bind( window, 'touchend', onTouchEnd );
			onTouchMove( e );

		}
		function onTouchMove( e ) {

			var clientX = e.touches[ 0 ].clientX;
			var bgRect = _this.__background.getBoundingClientRect();
			_this.setValue( map( clientX, bgRect.left, bgRect.right, _this.__min, _this.__max ) );

		}
		function onTouchEnd() {

			dom.unbind( window, 'touchmove', onTouchMove );
			dom.unbind( window, 'touchend', onTouchEnd );
			if ( _this.__onFinishChange ) {

				_this.__onFinishChange.call( _this, _this.getValue() );

			}

		}
		_this2.updateDisplay();
		_this2.__background.appendChild( _this2.__foreground );
		_this2.domElement.appendChild( _this2.__background );
		return _this2;

	}
	createClass( NumberControllerSlider, [ {
		key: 'updateDisplay',
		value: function updateDisplay() {

			var pct = ( this.getValue() - this.__min ) / ( this.__max - this.__min );
			this.__foreground.style.width = pct * 100 + '%';
			return get( NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf( NumberControllerSlider.prototype ), 'updateDisplay', this ).call( this );

		}
	} ] );
	return NumberControllerSlider;

}( NumberController );

var FunctionController = function ( _Controller ) {

	inherits( FunctionController, _Controller );
	function FunctionController( object, property, text ) {

		classCallCheck( this, FunctionController );
		var _this2 = possibleConstructorReturn( this, ( FunctionController.__proto__ || Object.getPrototypeOf( FunctionController ) ).call( this, object, property ) );
		var _this = _this2;
		_this2.__button = document.createElement( 'div' );
		_this2.__button.innerHTML = text === undefined ? 'Fire' : text;
		dom.bind( _this2.__button, 'click', function ( e ) {

			e.preventDefault();
			_this.fire();
			return false;

		} );
		dom.addClass( _this2.__button, 'button' );
		_this2.domElement.appendChild( _this2.__button );
		return _this2;

	}
	createClass( FunctionController, [ {
		key: 'fire',
		value: function fire() {

			if ( this.__onChange ) {

				this.__onChange.call( this );

			}
			this.getValue().call( this.object );
			if ( this.__onFinishChange ) {

				this.__onFinishChange.call( this, this.getValue() );

			}

		}
	} ] );
	return FunctionController;

}( Controller );

var ColorController = function ( _Controller ) {

	inherits( ColorController, _Controller );
	function ColorController( object, property ) {

		classCallCheck( this, ColorController );
		var _this2 = possibleConstructorReturn( this, ( ColorController.__proto__ || Object.getPrototypeOf( ColorController ) ).call( this, object, property ) );
		_this2.__color = new Color( _this2.getValue() );
		_this2.__temp = new Color( 0 );
		var _this = _this2;
		_this2.domElement = document.createElement( 'div' );
		dom.makeSelectable( _this2.domElement, false );
		_this2.__selector = document.createElement( 'div' );
		_this2.__selector.className = 'selector';
		_this2.__saturation_field = document.createElement( 'div' );
		_this2.__saturation_field.className = 'saturation-field';
		_this2.__field_knob = document.createElement( 'div' );
		_this2.__field_knob.className = 'field-knob';
		_this2.__field_knob_border = '2px solid ';
		_this2.__hue_knob = document.createElement( 'div' );
		_this2.__hue_knob.className = 'hue-knob';
		_this2.__hue_field = document.createElement( 'div' );
		_this2.__hue_field.className = 'hue-field';
		_this2.__input = document.createElement( 'input' );
		_this2.__input.type = 'text';
		_this2.__input_textShadow = '0 1px 1px ';
		dom.bind( _this2.__input, 'keydown', function ( e ) {

			if ( e.keyCode === 13 ) {

				onBlur.call( this );

			}

		} );
		dom.bind( _this2.__input, 'blur', onBlur );
		dom.bind( _this2.__selector, 'mousedown', function () {

			dom.addClass( this, 'drag' ).bind( window, 'mouseup', function () {

				dom.removeClass( _this.__selector, 'drag' );

			} );

		} );
		dom.bind( _this2.__selector, 'touchstart', function () {

			dom.addClass( this, 'drag' ).bind( window, 'touchend', function () {

				dom.removeClass( _this.__selector, 'drag' );

			} );

		} );
		var valueField = document.createElement( 'div' );
		Common.extend( _this2.__selector.style, {
			width: '122px',
			height: '102px',
			padding: '3px',
			backgroundColor: '#222',
			boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
		} );
		Common.extend( _this2.__field_knob.style, {
			position: 'absolute',
			width: '12px',
			height: '12px',
			border: _this2.__field_knob_border + ( _this2.__color.v < 0.5 ? '#fff' : '#000' ),
			boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
			borderRadius: '12px',
			zIndex: 1
		} );
		Common.extend( _this2.__hue_knob.style, {
			position: 'absolute',
			width: '15px',
			height: '2px',
			borderRight: '4px solid #fff',
			zIndex: 1
		} );
		Common.extend( _this2.__saturation_field.style, {
			width: '100px',
			height: '100px',
			border: '1px solid #555',
			marginRight: '3px',
			display: 'inline-block',
			cursor: 'pointer'
		} );
		Common.extend( valueField.style, {
			width: '100%',
			height: '100%',
			background: 'none'
		} );
		linearGradient( valueField, 'top', 'rgba(0,0,0,0)', '#000' );
		Common.extend( _this2.__hue_field.style, {
			width: '15px',
			height: '100px',
			border: '1px solid #555',
			cursor: 'ns-resize',
			position: 'absolute',
			top: '3px',
			right: '3px'
		} );
		hueGradient( _this2.__hue_field );
		Common.extend( _this2.__input.style, {
			outline: 'none',
			textAlign: 'center',
			color: '#fff',
			border: 0,
			fontWeight: 'bold',
			textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
		} );
		dom.bind( _this2.__saturation_field, 'mousedown', fieldDown );
		dom.bind( _this2.__saturation_field, 'touchstart', fieldDown );
		dom.bind( _this2.__field_knob, 'mousedown', fieldDown );
		dom.bind( _this2.__field_knob, 'touchstart', fieldDown );
		dom.bind( _this2.__hue_field, 'mousedown', fieldDownH );
		dom.bind( _this2.__hue_field, 'touchstart', fieldDownH );
		function fieldDown( e ) {

			setSV( e );
			dom.bind( window, 'mousemove', setSV );
			dom.bind( window, 'touchmove', setSV );
			dom.bind( window, 'mouseup', fieldUpSV );
			dom.bind( window, 'touchend', fieldUpSV );

		}
		function fieldDownH( e ) {

			setH( e );
			dom.bind( window, 'mousemove', setH );
			dom.bind( window, 'touchmove', setH );
			dom.bind( window, 'mouseup', fieldUpH );
			dom.bind( window, 'touchend', fieldUpH );

		}
		function fieldUpSV() {

			dom.unbind( window, 'mousemove', setSV );
			dom.unbind( window, 'touchmove', setSV );
			dom.unbind( window, 'mouseup', fieldUpSV );
			dom.unbind( window, 'touchend', fieldUpSV );
			onFinish();

		}
		function fieldUpH() {

			dom.unbind( window, 'mousemove', setH );
			dom.unbind( window, 'touchmove', setH );
			dom.unbind( window, 'mouseup', fieldUpH );
			dom.unbind( window, 'touchend', fieldUpH );
			onFinish();

		}
		function onBlur() {

			var i = interpret( this.value );
			if ( i !== false ) {

				_this.__color.__state = i;
				_this.setValue( _this.__color.toOriginal() );

			} else {

				this.value = _this.__color.toString();

			}

		}
		function onFinish() {

			if ( _this.__onFinishChange ) {

				_this.__onFinishChange.call( _this, _this.__color.toOriginal() );

			}

		}
		_this2.__saturation_field.appendChild( valueField );
		_this2.__selector.appendChild( _this2.__field_knob );
		_this2.__selector.appendChild( _this2.__saturation_field );
		_this2.__selector.appendChild( _this2.__hue_field );
		_this2.__hue_field.appendChild( _this2.__hue_knob );
		_this2.domElement.appendChild( _this2.__input );
		_this2.domElement.appendChild( _this2.__selector );
		_this2.updateDisplay();
		function setSV( e ) {

			if ( e.type.indexOf( 'touch' ) === - 1 ) {

				e.preventDefault();

			}
			var fieldRect = _this.__saturation_field.getBoundingClientRect();
			var _ref = e.touches && e.touches[ 0 ] || e,
				clientX = _ref.clientX,
				clientY = _ref.clientY;
			var s = ( clientX - fieldRect.left ) / ( fieldRect.right - fieldRect.left );
			var v = 1 - ( clientY - fieldRect.top ) / ( fieldRect.bottom - fieldRect.top );
			if ( v > 1 ) {

				v = 1;

			} else if ( v < 0 ) {

				v = 0;

			}
			if ( s > 1 ) {

				s = 1;

			} else if ( s < 0 ) {

				s = 0;

			}
			_this.__color.v = v;
			_this.__color.s = s;
			_this.setValue( _this.__color.toOriginal() );
			return false;

		}
		function setH( e ) {

			if ( e.type.indexOf( 'touch' ) === - 1 ) {

				e.preventDefault();

			}
			var fieldRect = _this.__hue_field.getBoundingClientRect();
			var _ref2 = e.touches && e.touches[ 0 ] || e,
				clientY = _ref2.clientY;
			var h = 1 - ( clientY - fieldRect.top ) / ( fieldRect.bottom - fieldRect.top );
			if ( h > 1 ) {

				h = 1;

			} else if ( h < 0 ) {

				h = 0;

			}
			_this.__color.h = h * 360;
			_this.setValue( _this.__color.toOriginal() );
			return false;

		}
		return _this2;

	}
	createClass( ColorController, [ {
		key: 'updateDisplay',
		value: function updateDisplay() {

			var i = interpret( this.getValue() );
			if ( i !== false ) {

				var mismatch = false;
				Common.each( Color.COMPONENTS, function ( component ) {

					if ( ! Common.isUndefined( i[ component ] ) && ! Common.isUndefined( this.__color.__state[ component ] ) && i[ component ] !== this.__color.__state[ component ] ) {

						mismatch = true;
						return {};

					}

				}, this );
				if ( mismatch ) {

					Common.extend( this.__color.__state, i );

				}

			}
			Common.extend( this.__temp.__state, this.__color.__state );
			this.__temp.a = 1;
			var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
			var _flip = 255 - flip;
			Common.extend( this.__field_knob.style, {
				marginLeft: 100 * this.__color.s - 7 + 'px',
				marginTop: 100 * ( 1 - this.__color.v ) - 7 + 'px',
				backgroundColor: this.__temp.toHexString(),
				border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
			} );
			this.__hue_knob.style.marginTop = ( 1 - this.__color.h / 360 ) * 100 + 'px';
			this.__temp.s = 1;
			this.__temp.v = 1;
			linearGradient( this.__saturation_field, 'left', '#fff', this.__temp.toHexString() );
			this.__input.value = this.__color.toString();
			Common.extend( this.__input.style, {
				backgroundColor: this.__color.toHexString(),
				color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
				textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
			} );

		}
	} ] );
	return ColorController;

}( Controller );
var vendors = [ '-moz-', '-o-', '-webkit-', '-ms-', '' ];
function linearGradient( elem, x, a, b ) {

	elem.style.background = '';
	Common.each( vendors, function ( vendor ) {

		elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';

	} );

}
function hueGradient( elem ) {

	elem.style.background = '';
	elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
	elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
	elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
	elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
	elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';

}

var css = {
	load: function load( url, indoc ) {

		var doc = indoc || document;
		var link = doc.createElement( 'link' );
		link.type = 'text/css';
		link.rel = 'stylesheet';
		link.href = url;
		doc.getElementsByTagName( 'head' )[ 0 ].appendChild( link );

	},
	inject: function inject( cssContent, indoc ) {

		var doc = indoc || document;
		var injected = document.createElement( 'style' );
		injected.type = 'text/css';
		injected.innerHTML = cssContent;
		var head = doc.getElementsByTagName( 'head' )[ 0 ];
		try {

			head.appendChild( injected );

		} catch ( e ) {
		}

	}
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory( object, property ) {

	var initialValue = object[ property ];
	if ( Common.isArray( arguments[ 2 ] ) || Common.isObject( arguments[ 2 ] ) ) {

		return new OptionController( object, property, arguments[ 2 ] );

	}
	if ( Common.isNumber( initialValue ) ) {

		if ( Common.isNumber( arguments[ 2 ] ) && Common.isNumber( arguments[ 3 ] ) ) {

			if ( Common.isNumber( arguments[ 4 ] ) ) {

				return new NumberControllerSlider( object, property, arguments[ 2 ], arguments[ 3 ], arguments[ 4 ] );

			}
			return new NumberControllerSlider( object, property, arguments[ 2 ], arguments[ 3 ] );

		}
		if ( Common.isNumber( arguments[ 4 ] ) ) {

			return new NumberControllerBox( object, property, { min: arguments[ 2 ], max: arguments[ 3 ], step: arguments[ 4 ] } );

		}
		return new NumberControllerBox( object, property, { min: arguments[ 2 ], max: arguments[ 3 ] } );

	}
	if ( Common.isString( initialValue ) ) {

		return new StringController( object, property );

	}
	if ( Common.isFunction( initialValue ) ) {

		return new FunctionController( object, property, '' );

	}
	if ( Common.isBoolean( initialValue ) ) {

		return new BooleanController( object, property );

	}
	return null;

};

function requestAnimationFrame( callback ) {

	setTimeout( callback, 1000 / 60 );

}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {

	function CenteredDiv() {

		classCallCheck( this, CenteredDiv );
		this.backgroundElement = document.createElement( 'div' );
		Common.extend( this.backgroundElement.style, {
			backgroundColor: 'rgba(0,0,0,0.8)',
			top: 0,
			left: 0,
			display: 'none',
			zIndex: '1000',
			opacity: 0,
			WebkitTransition: 'opacity 0.2s linear',
			transition: 'opacity 0.2s linear'
		} );
		dom.makeFullscreen( this.backgroundElement );
		this.backgroundElement.style.position = 'fixed';
		this.domElement = document.createElement( 'div' );
		Common.extend( this.domElement.style, {
			position: 'fixed',
			display: 'none',
			zIndex: '1001',
			opacity: 0,
			WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
			transition: 'transform 0.2s ease-out, opacity 0.2s linear'
		} );
		document.body.appendChild( this.backgroundElement );
		document.body.appendChild( this.domElement );
		var _this = this;
		dom.bind( this.backgroundElement, 'click', function () {

			_this.hide();

		} );

	}
	createClass( CenteredDiv, [ {
		key: 'show',
		value: function show() {

			var _this = this;
			this.backgroundElement.style.display = 'block';
			this.domElement.style.display = 'block';
			this.domElement.style.opacity = 0;
			this.domElement.style.webkitTransform = 'scale(1.1)';
			this.layout();
			Common.defer( function () {

				_this.backgroundElement.style.opacity = 1;
				_this.domElement.style.opacity = 1;
				_this.domElement.style.webkitTransform = 'scale(1)';

			} );

		}
	}, {
		key: 'hide',
		value: function hide() {

			var _this = this;
			var hide = function hide() {

				_this.domElement.style.display = 'none';
				_this.backgroundElement.style.display = 'none';
				dom.unbind( _this.domElement, 'webkitTransitionEnd', hide );
				dom.unbind( _this.domElement, 'transitionend', hide );
				dom.unbind( _this.domElement, 'oTransitionEnd', hide );

			};
			dom.bind( this.domElement, 'webkitTransitionEnd', hide );
			dom.bind( this.domElement, 'transitionend', hide );
			dom.bind( this.domElement, 'oTransitionEnd', hide );
			this.backgroundElement.style.opacity = 0;
			this.domElement.style.opacity = 0;
			this.domElement.style.webkitTransform = 'scale(1.1)';

		}
	}, {
		key: 'layout',
		value: function layout() {

			this.domElement.style.left = window.innerWidth / 2 - dom.getWidth( this.domElement ) / 2 + 'px';
			this.domElement.style.top = window.innerHeight / 2 - dom.getHeight( this.domElement ) / 2 + 'px';

		}
	} ] );
	return CenteredDiv;

}();

var styleSheet = ___$insertStyle( ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n" );

css.inject( styleSheet );
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {

	try {

		return !! window.localStorage;

	} catch ( e ) {

		return false;

	}

}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI( pars ) {

	var _this = this;
	var params = pars || {};
	this.domElement = document.createElement( 'div' );
	this.__ul = document.createElement( 'ul' );
	this.domElement.appendChild( this.__ul );
	dom.addClass( this.domElement, CSS_NAMESPACE );
	this.__folders = {};
	this.__controllers = [];
	this.__rememberedObjects = [];
	this.__rememberedObjectIndecesToControllers = [];
	this.__listening = [];
	params = Common.defaults( params, {
		closeOnTop: false,
		autoPlace: true,
		width: GUI.DEFAULT_WIDTH
	} );
	params = Common.defaults( params, {
		resizable: params.autoPlace,
		hideable: params.autoPlace
	} );
	if ( ! Common.isUndefined( params.load ) ) {

		if ( params.preset ) {

			params.load.preset = params.preset;

		}

	} else {

		params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

	}
	if ( Common.isUndefined( params.parent ) && params.hideable ) {

		hideableGuis.push( this );

	}
	params.resizable = Common.isUndefined( params.parent ) && params.resizable;
	if ( params.autoPlace && Common.isUndefined( params.scrollable ) ) {

		params.scrollable = true;

	}
	var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem( getLocalStorageHash( this, 'isLocal' ) ) === 'true';
	var saveToLocalStorage = void 0;
	var titleRow = void 0;
	Object.defineProperties( this,
		{
			parent: {
				get: function get$$1() {

					return params.parent;

				}
			},
			scrollable: {
				get: function get$$1() {

					return params.scrollable;

				}
			},
			autoPlace: {
				get: function get$$1() {

					return params.autoPlace;

				}
			},
			closeOnTop: {
				get: function get$$1() {

					return params.closeOnTop;

				}
			},
			preset: {
				get: function get$$1() {

					if ( _this.parent ) {

						return _this.getRoot().preset;

					}
					return params.load.preset;

				},
				set: function set$$1( v ) {

					if ( _this.parent ) {

						_this.getRoot().preset = v;

					} else {

						params.load.preset = v;

					}
					setPresetSelectIndex( this );
					_this.revert();

				}
			},
			width: {
				get: function get$$1() {

					return params.width;

				},
				set: function set$$1( v ) {

					params.width = v;
					setWidth( _this, v );

				}
			},
			name: {
				get: function get$$1() {

					return params.name;

				},
				set: function set$$1( v ) {

					params.name = v;
					if ( titleRow ) {

						titleRow.innerHTML = params.name;

					}

				}
			},
			closed: {
				get: function get$$1() {

					return params.closed;

				},
				set: function set$$1( v ) {

					params.closed = v;
					if ( params.closed ) {

						dom.addClass( _this.__ul, GUI.CLASS_CLOSED );

					} else {

						dom.removeClass( _this.__ul, GUI.CLASS_CLOSED );

					}
					this.onResize();
					if ( _this.__closeButton ) {

						_this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;

					}

				}
			},
			load: {
				get: function get$$1() {

					return params.load;

				}
			},
			useLocalStorage: {
				get: function get$$1() {

					return useLocalStorage;

				},
				set: function set$$1( bool ) {

					if ( SUPPORTS_LOCAL_STORAGE ) {

						useLocalStorage = bool;
						if ( bool ) {

							dom.bind( window, 'unload', saveToLocalStorage );

						} else {

							dom.unbind( window, 'unload', saveToLocalStorage );

						}
						localStorage.setItem( getLocalStorageHash( _this, 'isLocal' ), bool );

					}

				}
			}
		} );
	if ( Common.isUndefined( params.parent ) ) {

		this.closed = params.closed || false;
		dom.addClass( this.domElement, GUI.CLASS_MAIN );
		dom.makeSelectable( this.domElement, false );
		if ( SUPPORTS_LOCAL_STORAGE ) {

			if ( useLocalStorage ) {

				_this.useLocalStorage = true;
				var savedGui = localStorage.getItem( getLocalStorageHash( this, 'gui' ) );
				if ( savedGui ) {

					params.load = JSON.parse( savedGui );

				}

			}

		}
		this.__closeButton = document.createElement( 'div' );
		this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
		dom.addClass( this.__closeButton, GUI.CLASS_CLOSE_BUTTON );
		if ( params.closeOnTop ) {

			dom.addClass( this.__closeButton, GUI.CLASS_CLOSE_TOP );
			this.domElement.insertBefore( this.__closeButton, this.domElement.childNodes[ 0 ] );

		} else {

			dom.addClass( this.__closeButton, GUI.CLASS_CLOSE_BOTTOM );
			this.domElement.appendChild( this.__closeButton );

		}
		dom.bind( this.__closeButton, 'click', function () {

			_this.closed = ! _this.closed;

		} );

	} else {

		if ( params.closed === undefined ) {

			params.closed = true;

		}
		var titleRowName = document.createTextNode( params.name );
		dom.addClass( titleRowName, 'controller-name' );
		titleRow = addRow( _this, titleRowName );
		var onClickTitle = function onClickTitle( e ) {

			e.preventDefault();
			_this.closed = ! _this.closed;
			return false;

		};
		dom.addClass( this.__ul, GUI.CLASS_CLOSED );
		dom.addClass( titleRow, 'title' );
		dom.bind( titleRow, 'click', onClickTitle );
		if ( ! params.closed ) {

			this.closed = false;

		}

	}
	if ( params.autoPlace ) {

		if ( Common.isUndefined( params.parent ) ) {

			if ( autoPlaceVirgin ) {

				autoPlaceContainer = document.createElement( 'div' );
				dom.addClass( autoPlaceContainer, CSS_NAMESPACE );
				dom.addClass( autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER );
				document.body.appendChild( autoPlaceContainer );
				autoPlaceVirgin = false;

			}
			autoPlaceContainer.appendChild( this.domElement );
			dom.addClass( this.domElement, GUI.CLASS_AUTO_PLACE );

		}
		if ( ! this.parent ) {

			setWidth( _this, params.width );

		}

	}
	this.__resizeHandler = function () {

		_this.onResizeDebounced();

	};
	dom.bind( window, 'resize', this.__resizeHandler );
	dom.bind( this.__ul, 'webkitTransitionEnd', this.__resizeHandler );
	dom.bind( this.__ul, 'transitionend', this.__resizeHandler );
	dom.bind( this.__ul, 'oTransitionEnd', this.__resizeHandler );
	this.onResize();
	if ( params.resizable ) {

		addResizeHandle( this );

	}
	saveToLocalStorage = function saveToLocalStorage() {

		if ( SUPPORTS_LOCAL_STORAGE && localStorage.getItem( getLocalStorageHash( _this, 'isLocal' ) ) === 'true' ) {

			localStorage.setItem( getLocalStorageHash( _this, 'gui' ), JSON.stringify( _this.getSaveObject() ) );

		}

	};
	this.saveToLocalStorageIfPossible = saveToLocalStorage;
	function resetWidth() {

		var root = _this.getRoot();
		root.width += 1;
		Common.defer( function () {

			root.width -= 1;

		} );

	}
	if ( ! params.parent ) {

		resetWidth();

	}

};
GUI.toggleHide = function () {

	hide = ! hide;
	Common.each( hideableGuis, function ( gui ) {

		gui.domElement.style.display = hide ? 'none' : '';

	} );

};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function ( e ) {

	if ( document.activeElement.type !== 'text' && ( e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE ) ) {

		GUI.toggleHide();

	}

};
dom.bind( window, 'keydown', GUI._keydownHandler, false );
Common.extend( GUI.prototype,
	{
		add: function add( object, property ) {

			return _add( this, object, property, {
				factoryArgs: Array.prototype.slice.call( arguments, 2 )
			} );

		},
		addColor: function addColor( object, property ) {

			return _add( this, object, property, {
				color: true
			} );

		},
		remove: function remove( controller ) {

			this.__ul.removeChild( controller.__li );
			this.__controllers.splice( this.__controllers.indexOf( controller ), 1 );
			var _this = this;
			Common.defer( function () {

				_this.onResize();

			} );

		},
		destroy: function destroy() {

			if ( this.parent ) {

				throw new Error( 'Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.' );

			}
			if ( this.autoPlace ) {

				autoPlaceContainer.removeChild( this.domElement );

			}
			var _this = this;
			Common.each( this.__folders, function ( subfolder ) {

				_this.removeFolder( subfolder );

			} );
			dom.unbind( window, 'keydown', GUI._keydownHandler, false );
			removeListeners( this );

		},
		addFolder: function addFolder( name ) {

			if ( this.__folders[ name ] !== undefined ) {

				throw new Error( 'You already have a folder in this GUI by the' + ' name "' + name + '"' );

			}
			var newGuiParams = { name: name, parent: this };
			newGuiParams.autoPlace = this.autoPlace;
			if ( this.load &&
    this.load.folders &&
    this.load.folders[ name ] ) {

				newGuiParams.closed = this.load.folders[ name ].closed;
				newGuiParams.load = this.load.folders[ name ];

			}
			var gui = new GUI( newGuiParams );
			this.__folders[ name ] = gui;
			var li = addRow( this, gui.domElement );
			dom.addClass( li, 'folder' );
			return gui;

		},
		removeFolder: function removeFolder( folder ) {

			this.__ul.removeChild( folder.domElement.parentElement );
			delete this.__folders[ folder.name ];
			if ( this.load &&
    this.load.folders &&
    this.load.folders[ folder.name ] ) {

				delete this.load.folders[ folder.name ];

			}
			removeListeners( folder );
			var _this = this;
			Common.each( folder.__folders, function ( subfolder ) {

				folder.removeFolder( subfolder );

			} );
			Common.defer( function () {

				_this.onResize();

			} );

		},
		open: function open() {

			this.closed = false;

		},
		close: function close() {

			this.closed = true;

		},
		hide: function hide() {

			this.domElement.style.display = 'none';

		},
		show: function show() {

			this.domElement.style.display = '';

		},
		onResize: function onResize() {

			var root = this.getRoot();
			if ( root.scrollable ) {

				var top = dom.getOffset( root.__ul ).top;
				var h = 0;
				Common.each( root.__ul.childNodes, function ( node ) {

					if ( ! ( root.autoPlace && node === root.__save_row ) ) {

						h += dom.getHeight( node );

					}

				} );
				if ( window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h ) {

					dom.addClass( root.domElement, GUI.CLASS_TOO_TALL );
					root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';

				} else {

					dom.removeClass( root.domElement, GUI.CLASS_TOO_TALL );
					root.__ul.style.height = 'auto';

				}

			}
			if ( root.__resize_handle ) {

				Common.defer( function () {

					root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';

				} );

			}
			if ( root.__closeButton ) {

				root.__closeButton.style.width = root.width + 'px';

			}

		},
		onResizeDebounced: Common.debounce( function () {

			this.onResize();

		}, 50 ),
		remember: function remember() {

			if ( Common.isUndefined( SAVE_DIALOGUE ) ) {

				SAVE_DIALOGUE = new CenteredDiv();
				SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;

			}
			if ( this.parent ) {

				throw new Error( 'You can only call remember on a top level GUI.' );

			}
			var _this = this;
			Common.each( Array.prototype.slice.call( arguments ), function ( object ) {

				if ( _this.__rememberedObjects.length === 0 ) {

					addSaveMenu( _this );

				}
				if ( _this.__rememberedObjects.indexOf( object ) === - 1 ) {

					_this.__rememberedObjects.push( object );

				}

			} );
			if ( this.autoPlace ) {

				setWidth( this, this.width );

			}

		},
		getRoot: function getRoot() {

			var gui = this;
			while ( gui.parent ) {

				gui = gui.parent;

			}
			return gui;

		},
		getSaveObject: function getSaveObject() {

			var toReturn = this.load;
			toReturn.closed = this.closed;
			if ( this.__rememberedObjects.length > 0 ) {

				toReturn.preset = this.preset;
				if ( ! toReturn.remembered ) {

					toReturn.remembered = {};

				}
				toReturn.remembered[ this.preset ] = getCurrentPreset( this );

			}
			toReturn.folders = {};
			Common.each( this.__folders, function ( element, key ) {

				toReturn.folders[ key ] = element.getSaveObject();

			} );
			return toReturn;

		},
		save: function save() {

			if ( ! this.load.remembered ) {

				this.load.remembered = {};

			}
			this.load.remembered[ this.preset ] = getCurrentPreset( this );
			markPresetModified( this, false );
			this.saveToLocalStorageIfPossible();

		},
		saveAs: function saveAs( presetName ) {

			if ( ! this.load.remembered ) {

				this.load.remembered = {};
				this.load.remembered[ DEFAULT_DEFAULT_PRESET_NAME ] = getCurrentPreset( this, true );

			}
			this.load.remembered[ presetName ] = getCurrentPreset( this );
			this.preset = presetName;
			addPresetOption( this, presetName, true );
			this.saveToLocalStorageIfPossible();

		},
		revert: function revert( gui ) {

			Common.each( this.__controllers, function ( controller ) {

				if ( ! this.getRoot().load.remembered ) {

					controller.setValue( controller.initialValue );

				} else {

					recallSavedValue( gui || this.getRoot(), controller );

				}
				if ( controller.__onFinishChange ) {

					controller.__onFinishChange.call( controller, controller.getValue() );

				}

			}, this );
			Common.each( this.__folders, function ( folder ) {

				folder.revert( folder );

			} );
			if ( ! gui ) {

				markPresetModified( this.getRoot(), false );

			}

		},
		listen: function listen( controller ) {

			var init = this.__listening.length === 0;
			this.__listening.push( controller );
			if ( init ) {

				updateDisplays( this.__listening );

			}

		},
		updateDisplay: function updateDisplay() {

			Common.each( this.__controllers, function ( controller ) {

				controller.updateDisplay();

			} );
			Common.each( this.__folders, function ( folder ) {

				folder.updateDisplay();

			} );

		}
	} );
function addRow( gui, newDom, liBefore ) {

	var li = document.createElement( 'li' );
	if ( newDom ) {

		li.appendChild( newDom );

	}
	if ( liBefore ) {

		gui.__ul.insertBefore( li, liBefore );

	} else {

		gui.__ul.appendChild( li );

	}
	gui.onResize();
	return li;

}
function removeListeners( gui ) {

	dom.unbind( window, 'resize', gui.__resizeHandler );
	if ( gui.saveToLocalStorageIfPossible ) {

		dom.unbind( window, 'unload', gui.saveToLocalStorageIfPossible );

	}

}
function markPresetModified( gui, modified ) {

	var opt = gui.__preset_select[ gui.__preset_select.selectedIndex ];
	if ( modified ) {

		opt.innerHTML = opt.value + '*';

	} else {

		opt.innerHTML = opt.value;

	}

}
function augmentController( gui, li, controller ) {

	controller.__li = li;
	controller.__gui = gui;
	Common.extend( controller, {
		options: function options( _options ) {

			if ( arguments.length > 1 ) {

				var nextSibling = controller.__li.nextElementSibling;
				controller.remove();
				return _add( gui, controller.object, controller.property, {
					before: nextSibling,
					factoryArgs: [ Common.toArray( arguments ) ]
				} );

			}
			if ( Common.isArray( _options ) || Common.isObject( _options ) ) {

				var _nextSibling = controller.__li.nextElementSibling;
				controller.remove();
				return _add( gui, controller.object, controller.property, {
					before: _nextSibling,
					factoryArgs: [ _options ]
				} );

			}

		},
		name: function name( _name ) {

			controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
			return controller;

		},
		listen: function listen() {

			controller.__gui.listen( controller );
			return controller;

		},
		remove: function remove() {

			controller.__gui.remove( controller );
			return controller;

		}
	} );
	if ( controller instanceof NumberControllerSlider ) {

		var box = new NumberControllerBox( controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step } );
		Common.each( [ 'updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max' ], function ( method ) {

			var pc = controller[ method ];
			var pb = box[ method ];
			controller[ method ] = box[ method ] = function () {

				var args = Array.prototype.slice.call( arguments );
				pb.apply( box, args );
				return pc.apply( controller, args );

			};

		} );
		dom.addClass( li, 'has-slider' );
		controller.domElement.insertBefore( box.domElement, controller.domElement.firstElementChild );

	} else if ( controller instanceof NumberControllerBox ) {

		var r = function r( returned ) {

			if ( Common.isNumber( controller.__min ) && Common.isNumber( controller.__max ) ) {

				var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
				var wasListening = controller.__gui.__listening.indexOf( controller ) > - 1;
				controller.remove();
				var newController = _add( gui, controller.object, controller.property, {
					before: controller.__li.nextElementSibling,
					factoryArgs: [ controller.__min, controller.__max, controller.__step ]
				} );
				newController.name( oldName );
				if ( wasListening ) newController.listen();
				return newController;

			}
			return returned;

		};
		controller.min = Common.compose( r, controller.min );
		controller.max = Common.compose( r, controller.max );

	} else if ( controller instanceof BooleanController ) {

		dom.bind( li, 'click', function () {

			dom.fakeEvent( controller.__checkbox, 'click' );

		} );
		dom.bind( controller.__checkbox, 'click', function ( e ) {

			e.stopPropagation();

		} );

	} else if ( controller instanceof FunctionController ) {

		dom.bind( li, 'click', function () {

			dom.fakeEvent( controller.__button, 'click' );

		} );
		dom.bind( li, 'mouseover', function () {

			dom.addClass( controller.__button, 'hover' );

		} );
		dom.bind( li, 'mouseout', function () {

			dom.removeClass( controller.__button, 'hover' );

		} );

	} else if ( controller instanceof ColorController ) {

		dom.addClass( li, 'color' );
		controller.updateDisplay = Common.compose( function ( val ) {

			li.style.borderLeftColor = controller.__color.toString();
			return val;

		}, controller.updateDisplay );
		controller.updateDisplay();

	}
	controller.setValue = Common.compose( function ( val ) {

		if ( gui.getRoot().__preset_select && controller.isModified() ) {

			markPresetModified( gui.getRoot(), true );

		}
		return val;

	}, controller.setValue );

}
function recallSavedValue( gui, controller ) {

	var root = gui.getRoot();
	var matchedIndex = root.__rememberedObjects.indexOf( controller.object );
	if ( matchedIndex !== - 1 ) {

		var controllerMap = root.__rememberedObjectIndecesToControllers[ matchedIndex ];
		if ( controllerMap === undefined ) {

			controllerMap = {};
			root.__rememberedObjectIndecesToControllers[ matchedIndex ] = controllerMap;

		}
		controllerMap[ controller.property ] = controller;
		if ( root.load && root.load.remembered ) {

			var presetMap = root.load.remembered;
			var preset = void 0;
			if ( presetMap[ gui.preset ] ) {

				preset = presetMap[ gui.preset ];

			} else if ( presetMap[ DEFAULT_DEFAULT_PRESET_NAME ] ) {

				preset = presetMap[ DEFAULT_DEFAULT_PRESET_NAME ];

			} else {

				return;

			}
			if ( preset[ matchedIndex ] && preset[ matchedIndex ][ controller.property ] !== undefined ) {

				var value = preset[ matchedIndex ][ controller.property ];
				controller.initialValue = value;
				controller.setValue( value );

			}

		}

	}

}
function _add( gui, object, property, params ) {

	if ( object[ property ] === undefined ) {

		throw new Error( 'Object "' + object + '" has no property "' + property + '"' );

	}
	var controller = void 0;
	if ( params.color ) {

		controller = new ColorController( object, property );

	} else {

		var factoryArgs = [ object, property ].concat( params.factoryArgs );
		controller = ControllerFactory.apply( gui, factoryArgs );

	}
	if ( params.before instanceof Controller ) {

		params.before = params.before.__li;

	}
	recallSavedValue( gui, controller );
	dom.addClass( controller.domElement, 'c' );
	var name = document.createElement( 'span' );
	dom.addClass( name, 'property-name' );
	name.innerHTML = controller.property;
	var container = document.createElement( 'div' );
	container.appendChild( name );
	container.appendChild( controller.domElement );
	var li = addRow( gui, container, params.before );
	dom.addClass( li, GUI.CLASS_CONTROLLER_ROW );
	if ( controller instanceof ColorController ) {

		dom.addClass( li, 'color' );

	} else {

		dom.addClass( li, _typeof( controller.getValue() ) );

	}
	augmentController( gui, li, controller );
	gui.__controllers.push( controller );
	return controller;

}
function getLocalStorageHash( gui, key ) {

	return document.location.href + '.' + key;

}
function addPresetOption( gui, name, setSelected ) {

	var opt = document.createElement( 'option' );
	opt.innerHTML = name;
	opt.value = name;
	gui.__preset_select.appendChild( opt );
	if ( setSelected ) {

		gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;

	}

}
function showHideExplain( gui, explain ) {

	explain.style.display = gui.useLocalStorage ? 'block' : 'none';

}
function addSaveMenu( gui ) {

	var div = gui.__save_row = document.createElement( 'li' );
	dom.addClass( gui.domElement, 'has-save' );
	gui.__ul.insertBefore( div, gui.__ul.firstChild );
	dom.addClass( div, 'save-row' );
	var gears = document.createElement( 'span' );
	gears.innerHTML = '&nbsp;';
	dom.addClass( gears, 'button gears' );
	var button = document.createElement( 'span' );
	button.innerHTML = 'Save';
	dom.addClass( button, 'button' );
	dom.addClass( button, 'save' );
	var button2 = document.createElement( 'span' );
	button2.innerHTML = 'New';
	dom.addClass( button2, 'button' );
	dom.addClass( button2, 'save-as' );
	var button3 = document.createElement( 'span' );
	button3.innerHTML = 'Revert';
	dom.addClass( button3, 'button' );
	dom.addClass( button3, 'revert' );
	var select = gui.__preset_select = document.createElement( 'select' );
	if ( gui.load && gui.load.remembered ) {

		Common.each( gui.load.remembered, function ( value, key ) {

			addPresetOption( gui, key, key === gui.preset );

		} );

	} else {

		addPresetOption( gui, DEFAULT_DEFAULT_PRESET_NAME, false );

	}
	dom.bind( select, 'change', function () {

		for ( var index = 0; index < gui.__preset_select.length; index ++ ) {

			gui.__preset_select[ index ].innerHTML = gui.__preset_select[ index ].value;

		}
		gui.preset = this.value;

	} );
	div.appendChild( select );
	div.appendChild( gears );
	div.appendChild( button );
	div.appendChild( button2 );
	div.appendChild( button3 );
	if ( SUPPORTS_LOCAL_STORAGE ) {

		var explain = document.getElementById( 'dg-local-explain' );
		var localStorageCheckBox = document.getElementById( 'dg-local-storage' );
		var saveLocally = document.getElementById( 'dg-save-locally' );
		saveLocally.style.display = 'block';
		if ( localStorage.getItem( getLocalStorageHash( gui, 'isLocal' ) ) === 'true' ) {

			localStorageCheckBox.setAttribute( 'checked', 'checked' );

		}
		showHideExplain( gui, explain );
		dom.bind( localStorageCheckBox, 'change', function () {

			gui.useLocalStorage = ! gui.useLocalStorage;
			showHideExplain( gui, explain );

		} );

	}
	var newConstructorTextArea = document.getElementById( 'dg-new-constructor' );
	dom.bind( newConstructorTextArea, 'keydown', function ( e ) {

		if ( e.metaKey && ( e.which === 67 || e.keyCode === 67 ) ) {

			SAVE_DIALOGUE.hide();

		}

	} );
	dom.bind( gears, 'click', function () {

		newConstructorTextArea.innerHTML = JSON.stringify( gui.getSaveObject(), undefined, 2 );
		SAVE_DIALOGUE.show();
		newConstructorTextArea.focus();
		newConstructorTextArea.select();

	} );
	dom.bind( button, 'click', function () {

		gui.save();

	} );
	dom.bind( button2, 'click', function () {

		var presetName = prompt( 'Enter a new preset name.' );
		if ( presetName ) {

			gui.saveAs( presetName );

		}

	} );
	dom.bind( button3, 'click', function () {

		gui.revert();

	} );

}
function addResizeHandle( gui ) {

	var pmouseX = void 0;
	gui.__resize_handle = document.createElement( 'div' );
	Common.extend( gui.__resize_handle.style, {
		width: '6px',
		marginLeft: '-3px',
		height: '200px',
		cursor: 'ew-resize',
		position: 'absolute'
	} );
	function drag( e ) {

		e.preventDefault();
		gui.width += pmouseX - e.clientX;
		gui.onResize();
		pmouseX = e.clientX;
		return false;

	}
	function dragStop() {

		dom.removeClass( gui.__closeButton, GUI.CLASS_DRAG );
		dom.unbind( window, 'mousemove', drag );
		dom.unbind( window, 'mouseup', dragStop );

	}
	function dragStart( e ) {

		e.preventDefault();
		pmouseX = e.clientX;
		dom.addClass( gui.__closeButton, GUI.CLASS_DRAG );
		dom.bind( window, 'mousemove', drag );
		dom.bind( window, 'mouseup', dragStop );
		return false;

	}
	dom.bind( gui.__resize_handle, 'mousedown', dragStart );
	dom.bind( gui.__closeButton, 'mousedown', dragStart );
	gui.domElement.insertBefore( gui.__resize_handle, gui.domElement.firstElementChild );

}
function setWidth( gui, w ) {

	gui.domElement.style.width = w + 'px';
	if ( gui.__save_row && gui.autoPlace ) {

		gui.__save_row.style.width = w + 'px';

	}
	if ( gui.__closeButton ) {

		gui.__closeButton.style.width = w + 'px';

	}

}
function getCurrentPreset( gui, useInitialValues ) {

	var toReturn = {};
	Common.each( gui.__rememberedObjects, function ( val, index ) {

		var savedValues = {};
		var controllerMap = gui.__rememberedObjectIndecesToControllers[ index ];
		Common.each( controllerMap, function ( controller, property ) {

			savedValues[ property ] = useInitialValues ? controller.initialValue : controller.getValue();

		} );
		toReturn[ index ] = savedValues;

	} );
	return toReturn;

}
function setPresetSelectIndex( gui ) {

	for ( var index = 0; index < gui.__preset_select.length; index ++ ) {

		if ( gui.__preset_select[ index ].value === gui.preset ) {

			gui.__preset_select.selectedIndex = index;

		}

	}

}
function updateDisplays( controllerArray ) {

	if ( controllerArray.length !== 0 ) {

		requestAnimationFrame$1.call( window, function () {

			updateDisplays( controllerArray );

		} );

	}
	Common.each( controllerArray, function ( c ) {

		c.updateDisplay();

	} );

}

({
    StartingPos: new Vector3$1(0, 0, 0),
    face: {
        eyesIndex: 0,
        defaultLipIndex: 0,
        talking: true,
    },
    Animation: {
        clip: '',
        loop: LoopOnce$1,
        loopCount: 0,
        blendTime: 0.8,
    }
});

const defaultActionList = ["talkAction", "talkAction2", "talkAction3", "talkAction4", "eureka", "thinking", "sigh"];
export const setupTOMIAnimator = (tomi) => {
    const self = tomi;
    let awareId = null;
    self.autoAnimate = true;
    const selfAware = (state) => {

        if (!state) {
            if (awareId) {
                clearInterval(awareId);
                awareId = null;
            }
        } else {
            if (awareId) {
                clearInterval(awareId);
                awareId = null;
            }
            awareId = setInterval(_ => {
                const list = defaultActionList;
                const id = Math.min(Math.round(Math.random() * list.length), list.length - 1);
                self.actions(list[id])();
            }, 1500);

        }
    };
    self.selfAware = selfAware;
};

export default { TOMIController, setupFacial, setupAudio, setupReflection, setupTOMIAnimator};
